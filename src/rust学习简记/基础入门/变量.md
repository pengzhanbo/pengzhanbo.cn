---
title: 变量
createTime: 2022/06/03 05:40:30
permalink: /learn-rust/variable/
---

## 声明变量

在 Rust 中， 通过 `let` 关键字声明变量。

## 变量命名

在命名方面，与其他语言没有区别，但是需要遵循 [Rust 命名规范](https://www.notion.so/d6508ec305c44193b2d36fd0ce5e84bb)

## 变量绑定

在其他语言， `var a = 'hello'` 表示将 字符串 `hello` 赋值给了变量 `a` 。

在 Rust中， `let a = 'hello'` ，这个过程被称为 变量绑定。

使用 **绑定** 而不是 **赋值** ,是因为涉及了 Rust 的核心原则 —— **所有权** 。

::: tip 所有权
简单来说，任何内存对象都是有主人的，而且一般情况下完全属于它的主人，绑定就是把这个对象绑定给一个变量，让这个变量成为它的主人。
:::

## 变量可变性

Rust 的变量默认是 **不可变** 的。 这是 Rust 的特性之一，让我们编写的代码更安全、性能也更好。

如果变量 `a` 是不可变的，那么它一旦被绑定值，那么就不能再被修改

但也可以通过 关键字 `mut` 使变量变为 **可变的** 。

**示例1**：不可变变量

```rust
let a = 5;
println!("a: {}", a);
a = 6;
println!("a: {}", a);
```

使用 `cargo run` 运行，将会抛出一个 **cannot assign twice to immutable variable `a` `** 的错误提示。

**示例2**：可变变量

```rust
let mut a = 5;
println!("a: {}", a);
a = 6;
println!("a: {}", a);
```

运行程序将得到以下结果：

```sh
a: 5
a: 6
```

## 使用下划线开头忽略未使用变量

如果创建了一个变量，但是却没有使用它，Rust会给出一个警告，因为这可能是一个Bug。

但有时候创建未使用的变量可能是有用的，这时你希望Rust不要警告未使用的变量，那么可以 **使用下划线作为变量名开头** ：

```rust
fn main() {
  let x = 1;
  let _y = 2;
}
```

这时，Rust 只会警告 变量 `x` 未被使用，而不会警告变量 `_y` 未被使用。

## 变量结构

`let` 表达式不仅可以用于 变量绑定，还可以用于复杂的变量解构。

**变量结构** 是指，从一个相对复杂的变量中，匹配出变量的一部分内容。

```rust
let (a, mut b): (bool, bool) = (true, false);
// a 不可变， b 可变
println!("a: {:?}, b: {:?}", a, b);
```

### 解构式赋值

赋值语句左边可以使用 **元组**， **切片** ， **结构体模式** 。

```rust
let (a, b, c, d, e);
(a, b) = (1, 2); // 元组
[c, .., d, _] = (1, 2, 3, 4, 5); // 切片

struct Struct {
 e: i32
}
Struct { e, .. } = Struct { e: 5 }; // 结构体模式

println!("{:?} {:?} {:?} {:?} {:?}", a, b, c, d, e)
// 1 2 1 4 5
```

## 常量

在 Rust 中，通过 `const` 声明常量。

并且常量的必须标注值的类型。

## 变量遮蔽

Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的变量：

```rust
fn main() {
  let x = 1;
  // 在 之前的 x 进行变量遮蔽
  let x = x + 2; // 遮蔽前可以使用 之前的变量 x 的值
  // x 值为 3
  {
    let x = x + 2; // 在块级作用域内对 之前的 x 进行遮蔽
    // x 值为 5
  }
}
```

变量遮蔽不同于使用 `mut` 声明的可变变量，第二个 `let` 声明生成的是完全不同的变量，只是拥有相同的变量名，是一次内存对象的再分配，而 `mut` 声明的变量，修改的是同一个内存地址上的值，并不会发生内存对象的再分配。

变量遮蔽的用处在于，如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。
