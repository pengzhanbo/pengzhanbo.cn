---
url: /index.md
---
# 鹏展博

---

---
url: /ai-agent-skills/index.md
---
# Agent Skills
## 概述

Agent Skills  是 一种简单、开放的格式，用于为智能体提供新能力和专业知识。

Agent Skills 是包含指令、脚本和资源的文件夹，智能体可以发现并使用它们来更准确、更高效地完成任务。

::: tip 本文档 **翻译自** [Agent Skills](https://agentskills.io/)。仅供个人学习使用。

翻译版本仓库提交节点为 [75287b2](https://github.com/agentskills/agentskills/commit/75287b28fb7a8106d7798de99e13189f7bea5ca0)
:::

## 仓库地址

## Skills 搜索

## CLI 工具

## 相关文章

[使用 **Agent Skills** 为真实世界装备代理 —— Anthropic 官方博客](https://www.anthropic.com/engineering/equipping-agents-for-the-real-world-with-agent-skills){.readmore}

[**Agent Skills** ——Claude Docs](https://platform.claude.com/docs/zh-CN/agents-and-tools/agent-skills/overview){.readmore}

---

---
url: >-
  /ai-agent-skills/equipping-agents-for-the-real-world-with-agent-skills/index.md
---
# 使用 Agent Skills 为真实世界装备代理
Claude 功能强大，但实际工作需要流程知识与组织情境。
现推出智能体技能——一种通过文件与文件夹构建专业智能体的全新方式。

*更新：我们已发布 [Agent Skills](https://agentskills.io/) 作为跨平台可移植性的开放标准。（2025年12月18日）*

随着模型能力的提升，我们现在可以构建能够与成熟计算环境交互的通用智能体。
例如，[Claude Code](https://claude.com/product/claude-code) 就能通过本地代码执行和文件系统完成跨领域的复杂任务。
但随着这些智能体日益强大，我们需要更可组合、可扩展且可移植的方式来为它们配备领域专业知识。

这促使我们创建了 [**Agent Skills**](https://www.anthropic.com/news/skills)：
即组织有序的指令、脚本和资源文件夹，智能体能够动态发现并加载这些内容，从而在特定任务中表现更佳。
Skills 通过将您的专业知识打包成可供 Claude 使用的可组合资源，扩展了 Claude 的能力，将通用智能体转化为符合您需求的专用智能体。

为智能体构建一项 Skills，就如同为新员工编写入职指南。
如今，任何人都无需为每个用例零散地定制专属智能体，而是可以通过捕捉和分享流程性知识，用可组合的能力来专业化自己的智能体。
在本文中，我们将解释什么是 Skills ，展示其运作方式，并分享构建自有技能的最佳实践。

::: center
![image](../assets/ea-1.png)

Skills 是一个包含 `SKILL.md` 文件的目录，该文件内含结构化的指令、脚本和资源文件夹，用于为智能体提供额外能力。
:::

## Skills 结构剖析

为直观展示 Skills 运作机制，让我们通过真实案例逐步解析：这是实现 [Claude 近期上线的文档编辑功能](https://www.anthropic.com/news/create-files) 的核心技能之一。
Claude 本身已具备丰富的PDF解析能力，但在直接操作PDF方面存在局限（例如填写表格）。
这项 [PDF Skill](https://github.com/anthropics/skills/tree/main/document-skills/pdf) 使我们能够赋予 Claude 此类新能力。

最基础的 Skills 形式是一个包含 `SKILL.md` file 的目录。
该文件必须以包含必要元数据的 YAML frontmatter：`name` 与 `description`。
Agent 程序在启动时，会预先将所有已安装 Skills 的 `name` 与 `description` 加载至系统提示中。

此元数据属于 **渐进式披露** 的第一层级：仅提供足够信息让 Claude 知晓何时应调用各项 Skills，而无需将所有内容载入上下文。
该文件的实际主体内容构成**第二层级**的详细信息。
若 Claude 判定某项 Skills 与当前任务相关，将通过读取完整的 `SKILL.md` 文件将其载入上下文。

::: center
![image](../assets/ea-2.png)

`SKILL.md` 文件必须以包含文件名和描述的YAML Frontmatter开头，这些信息会在启动时加载到其系统提示中。
:::

随着 Skills 复杂度的增加，其内容可能过多而无法容纳在单个 `SKILL.md` 中，或者某些内容仅在特定场景下相关。
在这种情况下，Skills 可以在 Skills 目录中捆绑附加文件，并通过名称在 `SKILL.md` 中引用它们。
这些附加的链接文件是**第三层**（及更深入）的细节，Claude 可以根据需要选择性地浏览和发现。

在下方展示的PDF技能中，`SKILL.md` 引用了 Skills 作者选择与核心 `SKILL.md` 捆绑的
两个附加文件（`reference.md` 和 `forms.md`）。
通过将填写表单的说明移至单独的文件（`forms.md`），Skills 作者能够保持 Skills 核心的简洁性，
并相信 Claude 仅在填写表单时才会读取 `forms.md` 。

::: center
![image](../assets/ea-3.png)

您可以在 Skills 中融入更多上下文（通过附加文件），Claude 随后可根据系统提示触发这些内容。
:::

**渐进式披露** 是使 Agent Skills 灵活且可扩展的核心设计原则。
它如同一本编排精良的手册，从目录开始，到具体章节，再到详细附录，技能让Claude能够按需加载信息：

![image](../assets/ea-4.png)

拥有文件系统和代码执行工具的智能体在处理特定任务时，无需将整个技能内容读入其上下文窗口。
这意味着可以捆绑到 Skills 中的上下文量实际上是无限的。

## Skills 与上下文窗口

下图展示了当 Skills 被用户消息触发时，上下文窗口的变化情况。

::: center
![image](../assets/ea-5.png)

Skills 通过系统提示在上下文窗口中被触发。
:::

所示的操作序列：

::: steps

* 开始时，上下文窗口包含核心系统提示、每个已安装 Skills 的元数据以及用户的初始消息；
* Claude 通过调用 Bash 工具读取 `pdf/SKILL.md` 的内容来触发 PDF Skill；
* Claude 选择读取与该 SKill 捆绑的 `forms.md` 文件；
* 最终，Claude 在从 PDF Skill 加载了相关指令后，继续处理用户的任务。

:::

## Skills 与代码执行

Skills 也可以包含代码，供 Claude 自行决定作为工具执行。

大语言模型擅长处理多种任务，但某些操作更适合通过传统代码执行。
例如，通过令牌生成对列表进行排序，远比直接运行排序算法成本高昂。
除了效率考量外，许多应用需要只有代码才能提供的确定性可靠保障。

在我们的示例中，PDF Skill 包含一个预先编写的 Python 脚本，用于读取 PDF 并提取所有表单字段。
Claude 可以运行此脚本，而无需将脚本或 PDF 加载到上下文中。
由于代码具有确定性，这一工作流程是稳定且可重复的。

::: center
![image](../assets/ea-6.png)

Skills 还可以包含代码，供Claude根据任务性质自行决定是否作为工具执行。
:::

## 开发与评估 Skills

以下是一些关于如何开始创作和测试 Skills 的实用指南：

* **从评估入手**：

  通过在代表性任务中运行智能体并观察其薄弱环节或需要补充上下文的场景，来识别能力缺口。
  随后通过渐进式构建 Skills 来弥补这些不足。

* **构建可扩展结构**：

  当 `SKILL.md` 文件变得臃肿时，将其内容拆分至独立文件并建立引用关系。
  若某些上下文互斥或很少同时使用，保持独立路径可减少令牌消耗。
  最后，代码既可充当可执行工具，也可作为文档。
  应明确区分 Claude 应直接运行脚本还是将其作为参考上下文读取。

* **从 Claude 视角思考**：

  在实际场景中观察 Claude 如何使用您的 Skills ，并根据观察结果进行迭代：
  留意意外操作轨迹或对特定上下文的过度依赖。
  请特别关注 Skills 的 `name` 和 `description` ，Claude 将根据这些信息决定是否针对当前任务触发该 Skill。

* **与Claude协同迭代**：

  在使用 Claude 处理任务时，可要求 Claude 将其成功方法和常见错误总结为可复用的上下文及代码并整合到技能中。
  若 Claude 使用 Skills 执行任务时出现偏差，可要求其自我反思问题所在。
  此过程有助于发现 Claude 实际需要的上下文，而非预先猜测。

## 使用 Skills 时的安全考量

Skills 通过指令和代码为 Claude 赋予新能力。
虽然这使得 Skills 功能强大，但也意味着恶意技能可能在使用环境中引入安全漏洞，或诱导 Claude 泄露数据并执行非预期操作。

建议仅从可信来源安装 Skills 。
若从可信度较低的来源安装 Skills ，请在使用前彻底审核其内容。
首先阅读技能包内文件，了解其功能，特别注意代码依赖项及捆绑资源（如图像或脚本）。
同时，需留意 Skills 中指示 Claude 连接可能不可信外部网络资源的指令或代码。

## Skills 的未来展望

Agent Skills 目前已 [全面支持](https://www.anthropic.com/news/skills)，
覆盖 [Claude.ai](http://claude.ai/redirect/website.v1.cb6e2017-f868-4af8-a0e9-2e618a4fc002) 、Claude Code 、Claude 智能体 SDK 以及 Claude 开发者平台。

在接下来的几周里，我们将持续新增功能，以支持技能从创建、编辑、发现、分享到使用的完整生命周期。
我们尤其期待 Skills 能帮助组织和个人与 Claude 共享其背景信息和工作流程。
我们还将探索 Skills 如何通过教导智能体掌握涉及外部工具和软件的更复杂工作流，来补充 [模型上下文协议](https://modelcontextprotocol.io/)（MCP）服务器。

展望未来，我们希望能让智能体自主创建、编辑和评估 Skills ，使它们能够将自身的行为模式固化为可复用的能力。

Skills 是一个简单的概念，对应着同样简洁的格式。
这种简洁性让组织、开发者和终端用户能更轻松地构建定制化智能体，并赋予其新的能力。

我们期待看到大家运用 Skills 创造出怎样的成果。立即查看我们的 Skills
[文档](https://docs.claude.com/en/docs/agents-and-tools/agent-skills/overview) 和 [示例库](https://github.com/anthropics/claude-cookbooks/tree/main/skills)，开启您的探索之旅。

## 致谢

本文由 Barry Zhang、Keith Lazuka 和 Mahesh Murag 共同撰写，他们都对文件夹情有独钟。
特别感谢 Anthropic 公司内外众多支持、倡导并参与构建 Skills 体系的同仁。

---

---
url: /ai-agent-skills/integrate/index.md
---
# 集成 Skills
**将 Skills 集成到你的 智能体 中**。

如何为您的智能体或工具添加 Agent Skills 支持。

本指南说明如何为 AI智能体或开发工具添加 Skills 支持。

## 集成方法 {#integration-approaches}

集成技能的两种主要方法：

**基于文件系统的智能体** 在计算机环境（bash/unix）中运行，代表 Skills 最全面的选项。
当模型发出如 `cat /path/to/my-skill/SKILL.md` 的 Shell 命令时，Skills 即被激活。
捆绑资源通过 Shell 命令访问。

**基于工具的智能体** 无需专用计算机环境即可运行。
它们通过实现工具来允许模型触发 Skills 并访问捆绑资源。具体工具的实现由开发者决定。

## 概述 {#overview}

支持 Skills 的智能体需要：

* **发现** 配置目录中的 Skills
* **加载元数据**（名称和描述）于启动时
* **匹配** 用户任务至相关 Skills
* **激活** Skills：通过加载完整指令
* **执行** 脚本并按需访问资源

## Skills 发现 {#skill-discovery}

技能是包含 `SKILL.md` 文件的文件夹。您的智能体应扫描配置目录以发现有效 Skills 。

## 加载元数据 {#loading-metadata}

启动时仅解析每个 `SKILL.md` 文件的 frontmatter

### 解析 frontmatter {#parsing-frontmatter}

```
function parseMetadata(skillPath):
    content = readFile(skillPath + "/SKILL.md")
    frontmatter = extractYAMLFrontmatter(content)

    return {
        name: frontmatter.name,
        description: frontmatter.description,
        path: skillPath
    }
```

### 注入上下文 {#injecting-context}

在系统提示中包含 Skill 元数据，以便模型了解可用的 Skills 。

遵循您所在平台关于系统提示更新的指导。例如，对于 Claude 模型，推荐使用 XML 格式：

```xml
<available_skills>
  <skill>
    <name>pdf-processing</name>
    <description>Extracts text and tables from PDF files, fills forms, merges documents.</description>
    <location>/path/to/skills/pdf-processing/SKILL.md</location>
  </skill>
  <skill>
    <name>data-analysis</name>
    <description>Analyzes datasets, generates charts, and creates summary reports.</description>
    <location>/path/to/skills/data-analysis/SKILL.md</location>
  </skill>
</available_skills>
```

对于基于文件系统的智能体，需包含 location 字段并指定 `SKILL.md` 文件的绝对路径。
基于工具的智能体则可省略此位置信息。

保持元数据简洁。每个技能添加到上下文中的内容应控制在约50-100个 tokens

## 安全注意事项 {security-considerations}

脚本执行会引入安全风险。需考虑：

* **沙箱隔离**：在隔离环境中运行脚本

* **白名单机制**: 仅运行来自可信技能的脚本

* **确认**: 在执行可能危险的操作前询问用户

* **日志记录**: 记录所有脚本执行情况以供审计

## 参考实现 {#reference-implementation}

[skills-ref](https://github.com/agentskills/agentskills/tree/main/skills-ref) 库提供了用于处理 Skills 的 Python 实用工具和命令行界面。

例如：

**验证 Skills 目录**：

```sh
skills-ref validate <path>
```

**为智能体提示生成 `<available_skills>` XML**：

```sh
skills-ref to-prompt <path>...
```

以库源代码作为参考实现。

---

---
url: /ai-agent-skills/overview/index.md
---
# 概述
一种简单、开放的格式，用于为智能体提供新能力和专业知识。

Agent Skills 是包含指令、脚本和资源的文件夹，智能体可以发现并使用它们来更准确、更高效地完成任务。

## 为什么选择 Agent Skills ? {#why-agent-skills}

智能体能力日益增强，但常常缺乏可靠执行实际工作所需的上下文信息。
Skills 机制通过为智能体提供程序性知识及公司、团队和用户特定上下文（可按需加载），有效解决了这一问题。
配备 Skills 集的智能体能够根据当前处理的任务动态扩展其能力。

**面向技能开发者**：一次构建能力，即可部署到多个智能体产品中。

**面向兼容智能体**：支持技能让终端用户能够为智能体开箱即用地添加新能力。

**面向团队和企业**：将组织知识封装成可移植、版本控制的包。

## Agent Skills 能实现什么 ？{#what-can-agent-skills-enable}

* **领域专业知识**：将专业知识打包成可复用的指令，从法律审查流程到数据分析流水线。

* **新能力**：为智能体赋予新能力（例如创建演示文稿、构建 MCP 服务器、分析数据集）。

* **可重复的工作流程**：将多步骤任务转化为一致且可审计的工作流程。

* **互操作性**：在不同的技能兼容智能体产品中复用同一技能。

## 采用情况 {#adoption}

Agent Skills 受到领先的 AI 开发工具支持。

## 开放开发 {#open-development}

Agent Skills 格式最初由 [Anthropic](https://www.anthropic.com/) 开发，作为开放标准发布，
并已被越来越多的智能体产品采用。该标准欢迎更广泛的生态系统参与者贡献内容。

[在 **github** 上查看](https://github.com/agentskills/agentskills){.readmore}

## 开始使用 {#get-started}

:::card-grid

`Skill.md` 文件的完整格式规范。

:::

:::card-grid

验证 Skills 并生成 Prompt XML。

:::

---

---
url: /ai-agent-skills/specification/index.md
---
# 规范说明
Agent Skills 的完整格式规范。

本文档定义了 Agent Skills 的格式。

## 目录结构 {#directory-structure}

Skill 是一个至少包含 `SKILL.md` 文件的目录：

:::file-tree

* skill-name
  * SKILL.md  # 必须

:::

::: tip 您可以选择性地包含 [额外目录](#optional-directories)，例如 `scripts/`、`references/` 和 `assets/`，以支持您的 Skill 。
:::

## SKILL.md 格式 {#skill-md-format}

`SKILL.md` 文件必须包含 YAML frontmatter，后跟 Markdown 内容。

### frontmatter (必须) {#frontmatter-required}

```md title="SKILL.md"
---
name: skill-name
description: 此 Skill 的功能描述及适用场景说明。
---
```

可选字段包括：

```md title="SKILL.md"
---
name: pdf-processing
description: 从PDF文件中提取文本和表格，填写表单，合并文档。
license: Apache-2.0
metadata:
  author: example-org
  version: "1.0"
---
```

|      字段       | 必填  | 描述                                                                 |
| :-------------: | :---: | :------------------------------------------------------------------- |
|     `name`      |  是   | 最多64个字符。仅允许小写字母、数字和连字符。不能以连字符开头或结尾。 |
|  `description`  |  是   | 最多1024个字符。非空。描述该 Skill 的功能及适用场景。                |
|    `license`    |  否   | 许可证名称或引用的捆绑许可证文件。                                   |
| `compatibility` |  否   | 最多500个字符。说明环境要求（目标产品、系统包、网络访问权限等）。    |
|   `metadata`    |  否   | 用于附加元数据的任意键值映射。                                       |
| `allowed-tools` |  否   | Skill 可使用的预批准工具列表（空格分隔）。（实验性功能）             |

#### `name` 字段 {#name-field}

必需的 `name` 字段：

* 长度必须为 **1-64** 个字符
* 只能包含 Unicode 小写字母数字字符和连字符（`a-z` 和 `-`）
* 不能以 `-` 开头或结尾
* 不能包含连续连字符（`--`）
* 必须与父目录名称匹配

有效示例：

```yaml
name: pdf-processing
```

```yaml
name: data-analysis
```

```yaml
name: code-review
```

无效示例：

```yaml
name: PDF-Processing # 不允许使用大写字母 [!code error]
```

```yaml
name: -pdf # 不能以连字符开头 [!code error]
```

```yaml
name: pdf--processing # 不允许使用连续连字符 [!code error]
```

#### `description` 字段 {#description-field}

必需的 `description` 字段：

* 长度须为 **1-1024** 个字符
* 应同时描述 Skill 的功能及适用场景
* 应包含帮助智能体识别相关任务的关键词

优秀示例：

```yaml
description: 从PDF文件中提取文本和表格，填写PDF表单，并合并多个PDF文件。适用于处理PDF文档或当用户提及PDF、表单或文档提取时。
```

```yaml
description: Extracts text and tables from PDF files, fills PDF forms, and merges multiple PDFs. Use when working with PDF documents or when the user mentions PDFs, forms, or document extraction.
```

反面示例

```yaml
description: Helps with PDFs.
```

#### `license` 字段 {#license-field}

可选的 `license` 字段：

* 指定应用于 Skill 的许可证
* 建议保持简短（可以是许可证名称或捆绑许可证文件的名称）

示例:

```yaml
license: Proprietary. LICENSE.txt has complete terms
```

#### `compatibility` 字段 {#compatibility-field}

可选的 `compatibility` 字段：

* 若提供，长度须为 **1-500** 个字符
* 仅当 Skill 有特定环境要求时才应包含此字段
* 可注明目标产品、所需系统包、网络访问需求等

示例:

```yaml
compatibility: Designed for Claude Code (or similar products)
```

```yaml
compatibility: Requires git, docker, jq, and access to the internet
```

::: info 大多数 Skills 无需 `compatibility` 字段
:::

#### `metadata` 字段 {#metadata-field}

可选的 `metadata` 字段：

* 从字符串键到字符串值的映射
* 客户端可用此字段存储 Agent Skills 规范未定义的其他属性
* 建议使用相对唯一的键名以避免意外冲突

示例:

```yaml
metadata:
  author: example-org
  version: '1.0'
```

#### `allowed-tools` 字段 {#allowed-tools-field}

可选的 `allowed-tools` 字段:

* 以空格分隔的预批准运行工具列表
* 实验性功能。不同 Agent 实现对该字段的支持可能有所差异

示例:

```yaml
allowed-tools: Bash(git:*) Bash(jq:*) Read
```

### 正文内容 {#body-content}

frontmatter 之后的 Markdown 正文包含 Skill 说明。格式无限制。
撰写任何有助于智能体有效执行任务的内容即可。

推荐章节：

* 分步操作指南
* 输入与输出示例
* 常见边界情况

请注意，一旦决定激活某个 Skill，Agent 将完整加载此文件。
建议将较长的 `SKILL.md` 内容拆分为引用文件。

## 可选目录 {#optional-directories}

### scripts/

包含 Agents 可执行的代码。脚本应满足：

* 保持内容自包含或明确记录依赖关系
* 提供有用的错误提示信息
* 优雅处理边界情况

支持的语言取决于 Agent 的具体实现。常见选项包括 Python、Bash 和 JavaScript。

### references/

包含 Agent 在需要时可以阅读的额外文档：

* **REFERENCE.md** - 详细技术参考
* **FORMS.md** - 表单模板或结构化数据格式
* 领域特定文件（**finance.md**、**legal.md** 等）

保持单个[参考文件](#file-references) 内容聚焦。Agent 按需加载这些文件，较小的文件意味着更少占用上下文。

### assets/

包含静态资源：

* 模板（文档模板、配置模板）
* 图像（图表、示例）
* 数据文件（查找表、模式）

## 渐进式披露 {#progressive-disclosure}

Skills 应结构化以便高效利用上下文：

* **元数据 Metadata**（约100个tokens）：`name` 和 `description` 字段在启动时为所有技能加载
* **使用说明 Instructions**（建议少于5000 tokens）：完整的 `SKILL.md` 内容在技能激活时加载
* **资源**（按需）：文件（例如位于 `scripts/`、`references/` 或 `assets/` 中的文件）仅在需要时加载

主 `SKILL.md` 文件应保持在500行以内。将详细参考资料移至单独文件。

## 文件引用 {#file-references}

在 Skills 中引用其他文件时，请使用相对于技能根目录的相对路径：

```md title="SKILL.md"
See [the reference guide](references/REFERENCE.md) for details.

Run the extraction script:
scripts/extract.py
```

文件引用应保持在 `SKILL.md` 下一级深度。避免深层嵌套的引用链。

## 验证 {#validation}

使用 [skills-ref](https://github.com/agentskills/agentskills/tree/main/skills-ref) 验证您的 Skills：

```sh
skills-ref validate ./my-skill
```

此操作会检查您的 `SKILL.md` frontmatter 是否有效并遵循所有命名约定。

---

---
url: /ai-agent-skills/what-are-skills/index.md
---
Agent Skills 是一种轻量级、开放的格式，用于通过专业知识和工作流扩展AI智能体的能力。

Skills 的核心是一个包含 `SKILL.md` 文件的文件夹。
该文件包含元数据（至少包含 `name` 和 `description`）以及指导智能体执行特定任务的指令。
Skills 还可以捆绑脚本、模板和参考资料。

:::file-tree

* my-skill
  * SKILL.md     # 必需：说明 + 元数据
  * scripts/     # 可选：可执行代码
  * references/  # 可选：文档
  * assets/      # 可选：模板、资源

:::

## Skills 如何运作 {#how-skills-work}

技能采用 **渐进式披露** 来高效管理上下文：

1. **发现**：启动时，智能体仅加载每个可用技能的名称和描述，仅够判断何时可能相关。
2. **激活**：当任务与技能描述匹配时，智能体会将完整的SKILL.md指令读入上下文。
3. **执行**：智能体遵循指令，根据需要选择性加载引用文件或执行捆绑代码。

这种方法既保持了智能体的快速响应，又使其能按需获取更多上下文。

## SKILL.md 文件 {#skill-md-file}

每个 Skills 都始于一个包含 YAML frontmatter 和 Markdown 内容的 `SKILL.md` 文件：

```md title="SKILL.md"
---
name: pdf-processing
description: 从PDF文件中提取文本和表格，填写表单，合并文档。
---

# PDF处理

## 何时使用此 skill
当用户需要处理PDF文件时使用此 skill...

## 如何提取文本
1. 使用 pdfplumber 进行文本提取...

## 如何填写表格
...
```

在 `SKILL.md` 文件顶部必须包含以下 frontmatter：

* `name`：简短标识符
* `description`：使用此 Skill 的时机

Markdown 正文包含实际说明内容，对结构和内容没有特定限制。

这种简单格式具有若干关键优势：

* **自文档化**：Skill 作者或用户通过阅读 `SKILL.md` 即可理解其功能，便于 Skills 审计与改进。

* **可扩展性**：Skill 复杂度可涵盖从纯文本说明到可执行代码、资源文件和模板。

* **便携性**：Skills 仅由文件构成，便于编辑、版本管理和共享。

## 后续步骤 {#next-steps}

:::card-grid

`Skill.md` 文件的完整格式规范。

:::

:::card-grid

验证 Skills 并生成 Prompt XML。

:::

---

---
url: /ai/index.md
---
# AI 导航
## 大模型在线应用

AI 模型网页版对话应用，通常免费使用

## 模型服务商

通过 AI 服务商提供的 **访问接口** 和 **API KEY**，获得模型的访问权限

### API 直供

由模型开发商直接提供的 API 接口

### API 聚合平台

聚合多个不同的模型，提供统一的 API 接口

## AI 搜索

## AI 开发平台

## 音频模型

### 语音

### 音乐

## 视觉模型

### 图像

### 视频

### 3D

### 数字人

### 设计

## 工业级模型

## 数据集

## 实用集成

### 应用程序

### MCP 市场

### RAG 框架

### Office 插件

### 代码编辑器

### CLI AI 工具

## 优质开源项目

## 相关优质文章

* [**《LLM Powered Autonomous Agents》 by Lilian Weng (OpenAI)** - 深入理解 LLM 驱动的自主 Agent 设计框架](https://lilianweng.github.io/posts/2023-06-23-agent/)
* [**Prompt Engineering Guide** - 学习如何更好地设计提示词以提升 LLM 表现](https://www.promptingguide.ai/zh)
* [Best 100+ Stable Diffusion Prompts - 100+ 最美的 Stable Diffusion 提示词](https://mpost.io/best-100-stable-diffusion-prompts-the-most-beautiful-ai-text-to-image-prompts)
* [awesome-chatgpt-prompts - 优质的 ChatGPT 提示词](https://github.com/f/awesome-chatgpt-prompts)

---

---
url: /algorithm/index.md
---
# 数据结构与算法

---

---
url: /algorithm/backtracking/index.md
---
# 回溯算法
## 概述

\==回溯算法== 是一种通过尝试所有可能的候选解来解决问题的通用算法。

当发现当前候选解不可能满足条件时，会回退（回溯）到上一步，尝试其他选择。
它本质上是 **深度优先搜索（DFS）** 的一种优化形式，通过剪枝减少不必要的搜索。

## 核心思想

* **试错**：逐步构建候选解
* **剪枝**：发现无效解时立即回溯
* **状态管理**：记录当前路径，回溯时撤销选择

```ts
function backtrack(路径: 解的部分, 选择列表: 可用选项): void {
  if (满足结束条件) {
    结果集.push(路径副本) // 保存有效解
    return
  }

  for (选择 of 选择列表) {
    if (无效选择)
      continue // 剪枝

    做选择
    backtrack(新路径, 新选择列表)
    撤销选择 // 关键：状态重置
  }
}
```

## 实现

### 子集问题（无重复元素）

```ts
function subsets(nums: number[]): number[][] {
  const res: number[][] = []

  const backtrack = (start: number, path: number[]) => {
    res.push([...path]) // 保存当前子集

    for (let i = start; i < nums.length; i++) {
      path.push(nums[i]) // 做选择
      backtrack(i + 1, path) // 递归
      path.pop() // 撤销选择
    }
  }

  backtrack(0, [])
  return res
}

// 示例：subsets([1,2,3])
// 输出：[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]
```

### 全排列（无重复元素）

```ts
function permute(nums: number[]): number[][] {
  const res: number[][] = []
  const used: boolean[] = Array.from({ length: nums.length }).fill(false)

  const backtrack = (path: number[]) => {
    if (path.length === nums.length) {
      res.push([...path])
      return
    }

    for (let i = 0; i < nums.length; i++) {
      if (used[i])
        continue // 剪枝：已使用

      used[i] = true
      path.push(nums[i])
      backtrack(path)
      path.pop()
      used[i] = false // 关键：撤销状态
    }
  }

  backtrack([])
  return res
}

// 示例：permute([1,2,3])
// 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

## 优化技巧

* **剪枝策略**：

  * 提前终止无效路径（如组合总和中的 `sum > target`）
  * 跳过重复解（排序后判断 `if (i > start && nums[i] === nums[i-1])` ）

* **状态存储**：

  * 使用索引（`start`）避免重复组合
  * 使用布尔数组（`used[]`）标记已选元素

* **迭代代替递归**：

  * 对于深度大的问题，可用栈模拟递归

* **记忆化搜索**：

  * 缓存中间结果（适用于重叠子问题）

## 相关问题

[**LeetCode** - 回溯算法](https://leetcode.cn/problem-list/backtracking/){.read-more}

### 组合与求和问题

* **39. 组合总和**（[LeetCode](https://leetcode.cn/problems/combination-sum/)）
* **40. 组合总和 II**（[LeetCode](https://leetcode.cn/problems/combination-sum-ii/)）
* **216. 组合总和 III**（[LeetCode](https://leetcode.cn/problems/combination-sum-iii/)）

### 子集与排列问题

* **78. 子集**（[LeetCode](https://leetcode.cn/problems/subsets/)）
* **90. 子集 II**（[LeetCode](https://leetcode.cn/problems/subsets-ii/)）
* **46. 全排列**（[LeetCode](https://leetcode.cn/problems/permutations/)）
* **47. 全排列 II**（[LeetCode](https://leetcode.cn/problems/permutations-ii/)）

### 字符串与构造问题

* **22. 括号生成**（[LeetCode](https://leetcode.cn/problems/generate-parentheses/)）
* **51. N 皇后**（[LeetCode](https://leetcode.cn/problems/n-queens/)）

---

---
url: /algorithm/binary-search/index.md
---
# 二分查找
## 概述

\==二分查找（Binary Search）==，也称 **折半搜索（half-interval search）**、**对数搜索（logarithmic search）** 。
是一种高效的搜索算法，适用于已排序的数据集（如数组）。
它通过不断将搜索范围减半来定位目标值，时间复杂度为 $O(log n)$ ，远优于线性查找的 $O(n)$ 。

## 核心思想

* **分而治之**：每次比较目标值与数组中间元素。
* **缩小范围**：根据比较结果，将搜索范围缩小一半。
* **终止条件**：找到目标值或范围为空（未找到）。

## 过程

以在一个升序数组中查找一个数为例。

1. 它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；
2. 如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；
3. 如果中间元素大于所查找的值同理，只需到左侧查找。

## 实现

* **循环条件**：`left <= right`

  确保当 `left === right` 时（只剩一个元素）仍会检查。

* **中间索引计算**：

  * `mid = Math.floor((left + right) / 2)` 防止小数索引

    建议写作 `mid = (left + right) >> 1` 。

  * 大数安全写法：`mid = left + Math.floor((right - left) / 2)`（避免溢出）

    建议写作 `mid = left + ((right - left) >> 1)`。

* **边界更新**：

  * 目标在右侧：`left = mid + 1`（跳过已检查的 mid）。
  * 目标在左侧：`right = mid - 1`（同上）。

* **终止条件**：

  * 找到：`arr[mid] === target`。
  * 未找到：`left > right`（范围无效）。

### 迭代实现

```ts
function binarySearch(arr: number[], target: number): number {
  let left = 0
  let right = arr.length - 1

  while (left <= right) {
    const mid = left + ((right - left) >> 1) // 中间索引
    if (arr[mid] === target) {
      return mid // 找到目标
    }
    else if (arr[mid] < target) {
      left = mid + 1 // 目标在右半部分
    }
    else {
      right = mid - 1 // 目标在左半部分
    }
  }
  return -1 // 未找到
}
```

### 递归实现

```ts
function binarySearchRecursive(
  arr: number[],
  target: number,
  left: number = 0,
  right: number = arr.length - 1
): number {
  if (left > right)
    return -1 // 终止条件

  const mid = left + ((right - left) >> 1)
  if (arr[mid] === target) {
    return mid
  }
  else if (arr[mid] < target) {
    return binarySearchRecursive(arr, target, mid + 1, right) // 搜索右半
  }
  else {
    return binarySearchRecursive(arr, target, left, mid - 1) // 搜索左半
  }
}
```

## 最大值最小化

注意，这里的有序是广义的有序，如果一个数组中的左侧或者右侧都满足某一种条件，
而另一侧都不满足这种条件，也可以看作是一种有序（如果把满足条件看做 1，不满足看做 0，
至少对于这个条件的这一维度是有序的）。换言之，二分搜索法可以用来查找满足某种条件的最大（最小）的值。

要求满足某种条件的最大值的最小可能情况（最大值最小化），首先的想法是从小到大枚举这个作为答案的「最大值」，
然后去判断是否合法。若答案单调，就可以使用二分搜索法来更快地找到答案。
因此，要想使用二分搜索法来解这种「最大值最小化」的题目，需要满足以下三个条件：

* 答案在一个固定区间内；
* 可能查找一个符合条件的值不是很容易，但是要求能比较容易地判断某个值是否是符合条件的；
* 可行解对于区间满足一定的单调性。换言之，如果 x 是符合条件的，那么有 x + 1 或者 x - 1 也符合条件。（这样下来就满足了上面提到的单调性）

当然，最小值最大化是同理的。

## 适用场景

* 有序数据（数组、列表等）。
* 需要高效搜索（如数据库索引、大型数据集）。
* 变体问题：找边界、插入位置）。

## 相关问题

[**LeetCode** - 二分查找](https://leetcode.cn/problem-list/binary-search/){.read-more}

### 基础分治应用

* **169. 多数元素**（[LeetCode](https://leetcode.cn/problems/majority-element/)）
* **50. Pow(x, n)**（[LeetCode](https://leetcode.cn/problems/powx-n/)）

### 最大子数组问题

* **53. 最大子序和**（[LeetCode](https://leetcode.cn/problems/maximum-subarray/)）

### 进阶问题

* **4. 寻找两个有序数组的中位数**（[LeetCode](https://leetcode.cn/problems/median-of-two-sorted-arrays/)）
* **23. 合并 K 个升序链表**（[LeetCode](https://leetcode.cn/problems/merge-k-sorted-lists/)）

### 经典变体（分治思想延伸）

* **215. 数组中的第K个最大元素**（[LeetCode](https://leetcode.cn/problems/kth-largest-element-in-an-array/)）
* **240. 搜索二维矩阵 II**（[LeetCode](https://leetcode.cn/problems/search-a-2d-matrix-ii/)）

---

---
url: /algorithm/breadth-first-search/index.md
---
# 广度优先搜索
## 概述

\==广度优先搜索（Breadth-First Search）（BFS）== 是一种用于遍历或搜索树/图数据结构的算法。

是图上最基础、最重要的搜索算法之一。

所谓广度优先。就是每次都尝试访问同一层的节点。 如果同一层都访问完了，再访问下一层。

这样做的结果是，BFS 算法找到的路径是从起点开始的 最短 合法路径。换言之，这条路径所包含的边数最小。

在 BFS 结束时，每个节点都是通过从起点到该点的最短路径访问的。

## 核心思想

核心思想是 **逐层遍历**：

* 从起点开始，先访问所有直接邻居
* 再访问邻居的邻居
* 使用队列（FIFO）管理待访问节点
* 避免重复访问（通过记录已访问节点）

## 实现

### 图结构定义

```ts
type Graph = Record<string, string[]> // 邻接表表示法

// 示例图结构
const graph: Graph = {
  A: ['B', 'C'],
  B: ['A', 'D', 'E'],
  C: ['A', 'F'],
  D: ['B'],
  E: ['B', 'F'],
  F: ['C', 'E']
}
// A → B → C
// B → D → E
// C → F ← E
```

### BFS基础实现

```ts
function bfs(graph: Graph, start: string): string[] {
  const visited = new Set<string>() // 记录已访问节点
  const queue: string[] = [start] // 初始化队列
  const result: string[] = [] // 存储遍历结果

  visited.add(start)

  while (queue.length > 0) {
    const current = queue.shift()! // 从队列头部取出节点
    result.push(current)

    // 遍历当前节点的所有邻居
    for (const neighbor of graph[current]) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor)
        queue.push(neighbor) // 新节点加入队列尾部
      }
    }
  }

  return result
}

// 测试执行
console.log(bfs(graph, 'A'))
// 输出: ['A', 'B', 'C', 'D', 'E', 'F']
```

### 最短路径实现（无权图）

```ts
function shortestPath(
  graph: Graph,
  start: string,
  target: string
): string[] | null {
  const visited = new Set<string>([start])
  const queue: string[] = [start]
  const predecessor: Record<string, string> = {} // 记录前驱节点
  const distance: Record<string, number> = { [start]: 0 } // 记录距离

  while (queue.length > 0) {
    const current = queue.shift()!

    if (current === target) {
      // 回溯构建路径
      const path = [target]
      let node = target
      while (node !== start) {
        node = predecessor[node]
        path.unshift(node)
      }
      return path
    }

    for (const neighbor of graph[current]) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor)
        predecessor[neighbor] = current
        distance[neighbor] = distance[current] + 1
        queue.push(neighbor)
      }
    }
  }

  return null // 未找到路径
}

// 测试最短路径
console.log(shortestPath(graph, 'A', 'F'))
// 输出: ['A', 'C', 'F']（最短路径）
```

### 执行过程示例（从A开始）

| 步骤  | 队列状态   | 当前节点 | 新访问节点 | 访问顺序            |
| :---: | :--------- | :------: | :--------: | :------------------ |
|   1   | \[A]       |    A     |    B, C    | \[A]                |
|   2   | \[B, C]    |    B     |    D, E    | \[A, B]             |
|   3   | \[C, D, E] |    C     |     F      | \[A, B, C]          |
|   4   | \[D, E, F] |    D     | (无新节点) | \[A, B, C, D]       |
|   5   | \[E, F]    |    E     | (F已访问)  | \[A, B, C, D, E]    |
|   6   | \[F]       |    F     |     -      | \[A, B, C, D, E, F] |

## 关键解析

* **队列（Queue）**：

  * 使用数组模拟队列（push()入队，shift()出队）
  * 确保先进先出（FIFO）的访问顺序

* **访问记录（Visited Set）**：

  * 防止重复访问和循环
  * 空间换时间（O(1)时间复杂度检查）

* **前驱记录（Predecessor Map）**：

  * 存储节点的来源节点
  * 用于回溯构建完整路径

## 性能优化

* **双向BFS**：从起点和终点同时搜索（适合已知终点的场景）
* **层级记录**：使用level变量替代距离字典减少内存
* **队列选择**：使用链表实现真正O(1)出队的队列
* **剪枝策略**：提前终止不符合条件的路径

## 适用场景

* **社交网络**：查找N度好友关系
* **路径规划**：迷宫最短路径（无权图）
* **网络爬虫**：分层抓取网页
* **连通性检测**：判断岛屿数量（网格BFS）
* **状态转换**：解决华容道/八数码问题

## 相关问题

[**LeetCode** - 广度优先搜索 - Breadth-First Search](https://leetcode.cn/problem-list/breadth-first-search/){.read-more}

### 基础图遍历

* **LCP 07. 传递信息** （[LeetCode](https://leetcode.cn/problems/chuan-di-xin-xi/)）
* **547. 朋友圈**（[LeetCode](https://leetcode.cn/problems/friend-circles/)）

### 网格类问题（矩阵BFS）

* **542. 01 矩阵**（[LeetCode](https://leetcode.cn/problems/01-matrix/)）
* **994. 腐烂的橘子**（[LeetCode](https://leetcode.cn/problems/rotting-oranges/)）
* **1162. 地图分析（最短路径）**（[LeetCode](https://leetcode.cn/problems/maximum-distance-in-arrays/)）

### 二叉树层序遍历

* **199. 二叉树的右视图**（[LeetCode](https://leetcode.cn/problems/binary-tree-right-side-view/)）
* **1609. 奇偶树**（[LeetCode](https://leetcode.cn/problems/even-odd-tree/)）

### 进阶挑战题

* **127. 单词接龙**（[LeetCode](https://leetcode.cn/problems/word-ladder/)）
* **417. 太平洋大西洋水流问题**（[LeetCode](https://leetcode.cn/problems/pacific-atlantic-water-flow/)）

---

---
url: /algorithm/bubble-sort/index.md
---
# 冒泡排序
## 概述

\==冒泡排序（Bubble sort）== 一种基础的比较排序算法。

### 核心思想

**重复遍历数组，依次比较相邻元素，将较大值向后交换**，如同气泡上浮的过程。

## 算法步骤

1. **外层循环**：控制遍历轮数（n-1 轮）
2. **内层循环**：比较相邻元素，将较大值后移
3. **优化点**：每轮结束后，末尾元素已有序，可减少比较范围
4. **提前终止**：当某轮无交换时，说明数组已有序，提前结束

## 时间复杂度

* 在序列完全有序时，冒泡排序只需遍历一遍数组，不用执行任何交换操作，时间复杂度为 $O(n)$。
* 在最坏情况下，冒泡排序要执行 $\frac{(n-1)n}{2}$ 次交换操作，时间复杂度为 $O(n^2)$。
* 冒泡排序的平均时间复杂度为 $O(n^2)$。

## 空间复杂度

$O(1)$（原地排序）

## 稳定性

**稳定**（相同元素顺序不变）

## 伪代码

$$
\begin{array}{ll}
1 & \textbf{Input. } \text{An array } A \text{ consisting of }n\text{ elements.} \\
2 & \textbf{Output. } A\text{ will be sorted in nondecreasing order stably.} \\
3 & \textbf{Method. }  \\
4 & flag\gets True\\
5 & \textbf{while }flag\\
6 & \qquad flag\gets False\\
7 & \qquad\textbf{for }i\gets1\textbf{ to }n-1\\
8 & \qquad\qquad\textbf{if }A\[i]>A\[i + 1]\\
9 & \qquad\qquad\qquad flag\gets True\\
10 & \qquad\qquad\qquad \text{Swap } A\[i]\text{ and }A\[i + 1]
\end{array}
$$

## 实现

```ts
function bubbleSort(arr: number[]): number[] {
  const n = arr.length
  // 复制数组以避免修改原数组（可选）
  const sortedArr = [...arr]

  // 外层循环：控制遍历轮数（n-1轮）
  for (let i = 0; i < n - 1; i++) {
    let swapped = false // 优化标记

    // 内层循环：比较相邻元素（每轮减少i个已排序元素）
    for (let j = 0; j < n - 1 - i; j++) {
      // 如果前一个元素大于后一个元素
      if (sortedArr[j] > sortedArr[j + 1]) {
        // 交换元素（ES6解构赋值）
        [sortedArr[j], sortedArr[j + 1]] = [sortedArr[j + 1], sortedArr[j]]
        swapped = true // 标记发生交换
      }
    }

    // 如果本轮无交换，说明数组已有序，提前终止
    if (!swapped)
      break
  }

  return sortedArr
}

// 测试示例
const unsortedArray = [64, 34, 25, 12, 22, 11, 90]
const sortedArray = bubbleSort(unsortedArray)
console.log('排序前:', unsortedArray) // [64, 34, 25, 12, 22, 11, 90]
console.log('排序后:', sortedArray) // [11, 12, 22, 25, 34, 64, 90]
```

### 执行过程示例 （`[5, 3, 8, 4]`）

* 第一轮：

  * 比较 $5 > 3$ → 交换 → `[3, 5, 8, 4]`
  * 比较 $5 < 8$ → 不交换
  * 比较 $8 > 4$ → 交换 → `[3, 5, 4, 8]`

* 第二轮：

  * 比较 $3 < 5$ → 不交换
  * 比较 $5 > 4$ → 交换 → `[3, 4, 5, 8]`
  * 检查发现无交换 → 提前终止

## 优化

* **优化内层循环范围**

  ```ts
  for (let j = 0; j < n - 1 - i; j++) {
    // ...
  }
  ```

  每轮结束后，末尾 i 个元素已有序，无需再比较。

* **提前终止**

  ```ts
  if (!swapped)
    break
  ```

  当数组在中间轮次已有序时，避免无效遍历。

---

---
url: /algorithm/bucket-sort/index.md
---
# 桶排序
## 概述

\==桶排序（Bucket Sort）== 是一种分布式排序算法，适用于数据分布均匀的场景。

### 核心思想

将数据分散到多个有序的桶中，对每个桶单独排序，最后合并所有桶。

## 基本原理

* **分桶**：根据元素范围创建固定数量的桶，将元素分配到对应的桶中。
* **桶内排序**：对每个非空桶单独排序（通常用插入排序等简单算法）。
* **合并结果**：按桶顺序合并所有元素。

## 过程

桶排序按下列步骤进行：

1. 设置一个定量的数组当作空桶；
2. 遍历序列，并将元素一个个放到对应的桶中；
3. 对每个不是空的桶进行排序；
4. 从不是空的桶里把元素再放回原来的序列中。

## 时间复杂度

桶排序的平均时间复杂度为 $O(n + n^2/k + k)$（将值域平均分成 $n$ 块 + 排序 + 重新合并元素），当 $k\approx n$ 时为 $O(n)$。

桶排序的最坏时间复杂度为 $O(n^2)$。

## 空间复杂度

桶排序的空间复杂度为 $O(n + k)$。 （需额外存储桶）

## 稳定性

如果使用稳定的内层排序，并且将元素插入桶中时不改变元素间的相对顺序，那么桶排序就是一种稳定的排序算法。

由于每块元素不多，一般使用插入排序。此时桶排序是一种稳定的排序算法。

## 实现

```ts
function bucketSort(arr: number[], bucketSize: number = 5): number[] {
  if (arr.length === 0)
    return arr

  // 1. 计算数组最小/最大值
  let min = arr[0]
  let max = arr[0]
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < min)
      min = arr[i]
    else if (arr[i] > max)
      max = arr[i]
  }

  // 2. 初始化桶
  const bucketCount = Math.floor((max - min) / bucketSize) + 1
  const buckets: number[][] = Array.from({ length: bucketCount })
  for (let i = 0; i < bucketCount; i++) {
    buckets[i] = []
  }

  // 3. 元素分配到桶中
  for (let num of arr) {
    const bucketIndex = Math.floor((num - min) / bucketSize)
    buckets[bucketIndex].push(num)
  }

  // 4. 对每个桶排序并合并
  const sortedArr: number[] = []
  for (let bucket of buckets) {
    if (bucket.length > 0) {
      // 使用插入排序（可替换为其他排序）
      insertionSort(bucket)
      sortedArr.push(...bucket)
    }
  }
  return sortedArr
}

// 插入排序辅助函数
function insertionSort(arr: number[]): void {
  for (let i = 1; i < arr.length; i++) {
    const key = arr[i]
    let j = i - 1
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j]
      j--
    }
    arr[j + 1] = key
  }
}

// 测试用例
const arr = [0.42, 0.32, 0.75, 0.12, 0.98, 0.63]
console.log(bucketSort(arr))
// 输出: [0.12, 0.32, 0.42, 0.63, 0.75, 0.98]
```

## 优化

* **动态桶大小**：根据数据分布动态调整 `bucketSize` 。
* **桶内排序算法**：对大数据桶使用 ==快速排序（QuickSort）== 提升效率。
* **空桶处理**：跳过空桶减少不必要的遍历。

---

---
url: /algorithm/data-structure/array/index.md
---
# 数组
## 概述

\==数组（Array）== 是一种有序的线性数据结构，它的每个元素都是一个独立的数据项，可以通过下标快速访问。

## 核心特性

* **有序性**:数组中的元素按照一定的顺序排列，可以通过下标访问特定位置的元素。
* **线性性**:数组中的元素是连续存储的，可以通过下标访问特定位置的元素。
* **可变性**:数组可以动态增加或删除元素，可以根据需要调整数组的大小。

## 相关问题

[**LeetCode** - 数组](https://leetcode.cn/problem-list/array/){.read-more}

### 基础操作与双指针

* **1. 两数之和**（[LeetCode](https://leetcode.cn/problems/two-sum/)）
* **283. 移动零**（[LeetCode](https://leetcode.cn/problems/move-zeroes/)）
* **11. 盛最多水的容器**（[LeetCode](https://leetcode.cn/problems/container-with-most-water/)）
* **15. 三数之和**（[LeetCode](https://leetcode.cn/problems/3sum/)）

### 二分查找与滑动窗口

* **704. 二分查找**（[LeetCode](https://leetcode.cn/problems/binary-search/)）
* **35. 搜索插入位置**（[LeetCode](https://leetcode.cn/problems/search-insert-position/)）
* **209. 长度最小的子数组**（[LeetCode](https://leetcode.cn/problems/minimum-size-subarray-sum/)）
* **2653. 滑动子数组的美丽值**（[LeetCode](https://leetcode.cn/problems/sliding-subarray-beauty/)）

### 经典多维数组

* **59. 螺旋矩阵 II**（[LeetCode](https://leetcode.cn/problems/spiral-matrix-ii/)）
* **724. 寻找数组的中心索引**（[LeetCode](https://leetcode.cn/problems/find-pivot-index/)）
* **18. 四数之和**（[LeetCode](https://leetcode.cn/problems/4sum/)）
* **26. 删除有序数组中的重复项**（[LeetCode](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)）

---

---
url: /algorithm/data-structure/binary-tree/index.md
---
# 二叉树
## 概述

\==二叉树（Binary Tree）== 是一种非线性数据结构，每个节点最多有两个子节点（左子节点和右子节点）。

## 核心特性

* **度**：节点拥有的子树数（二叉树节点度 ≤ 2）
* **层次**：根节点为第 1 层，逐级递增
* **深度**：从根到节点的路径长度
* **高度**：从节点到最深叶子的路径长度

## 二叉树基础节点实现

```ts
class TreeNode<T> {
  val: T
  left: TreeNode<T> | null
  right: TreeNode<T> | null

  constructor(
    val: T,
    left: TreeNode<T> | null = null,
    right: TreeNode<T> | null = null
  ) {
    this.val = val
    this.left = left
    this.right = right
  }
}
```

## 特殊二叉树

* **完全二叉树**：除最后一层外全满，最后一层左对齐
* **满二叉树**：所有非叶子节点都有两个子节点
* **二叉搜索树 (BST)**：左子树所有值 < 根 < 右子树所有值

## 二叉搜索树的实现

```ts
// 满二叉树：所有非叶子节点都有两个子节点
class FullBinaryTree<T> { /* 实现 */ }

// 完全二叉树：除最后一层外全满，最后一层左对齐
class CompleteBinaryTree<T> { /* 实现 */ }

// 二叉搜索树 (BST)：左子树所有值 < 根 < 右子树所有值
class BinarySearchTree<T> {
  root: TreeNode<T> | null = null

  insert(val: T): void {
    const newNode = new TreeNode(val)
    if (!this.root) {
      this.root = newNode
      return
    }

    let current = this.root
    while (true) {
      if (val < current.val) {
        if (!current.left) {
          current.left = newNode
          break
        }
        current = current.left
      }
      else {
        if (!current.right) {
          current.right = newNode
          break
        }
        current = current.right
      }
    }
  }
}
```

## 二叉树的遍历

访问树的所有节点有三种遍历方式：中序，先序和后序。

* **中序遍历**：以从最小到最大的顺序访问所有节点
* **先序遍历**：以优先于后代节点的顺序访问每个节点
* **后序遍历**：先访问节点的后代节点再访问节点本身

属于何种遍历方式，通常可以根据 根节点 所在的位置：

* **先序遍历**：**根** --> 左子树 --> 右子树
* **中序遍历**：左子树 --> **根** --> \*\*右子树
* **后序遍历**：左子树 --> 右子树 -- > **根**

### 先序遍历（Preorder Traversal）

**访问顺序**：根节点 → 左子树 → 右子树

**应用场景**：创建树副本、序列化树结构、前缀表达式生成

```ts
// 递归实现
function preorder<T>(root: TreeNode<T> | null): T[] {
  if (!root)
    return []
  return [
    root.val,
    ...preorder(root.left),
    ...preorder(root.right)
  ]
}

// 迭代实现（使用栈）
function preorderIterative<T>(root: TreeNode<T> | null): T[] {
  if (!root)
    return []
  const stack: TreeNode<T>[] = [root]
  const result: T[] = []

  while (stack.length) {
    const node = stack.pop()!
    result.push(node.val)
    if (node.right)
      stack.push(node.right) // 右子先入栈
    if (node.left)
      stack.push(node.left) // 左子后入栈（后进先出）
  }
  return result
}
```

### 中序遍历 (Inorder Traversal)

**访问顺序**：左子树 → 根节点 → 右子树

**应用场景**：二叉搜索树排序输出、表达式树中缀表示

```ts
// 递归实现
function inorder<T>(root: TreeNode<T> | null): T[] {
  if (!root)
    return []
  return [
    ...inorder(root.left),
    root.val,
    ...inorder(root.right)
  ]
}

// 迭代实现（使用指针+栈）
function inorderIterative<T>(root: TreeNode<T> | null): T[] {
  const stack: TreeNode<T>[] = []
  const result: T[] = []
  let curr = root

  while (curr || stack.length) {
    // 深入左子树
    while (curr) {
      stack.push(curr)
      curr = curr.left
    }
    // 回溯访问节点
    curr = stack.pop()!
    result.push(curr.val)
    // 转向右子树
    curr = curr.right
  }
  return result
}
```

### 后序遍历（Postorder Traversal）

**访问顺序**：左子树 → 右子树 → 根节点

**应用场景**：释放树内存、计算目录大小、后缀表达式求值

```ts
// 递归实现
function postorder<T>(root: TreeNode<T> | null): T[] {
  if (!root)
    return []
  return [
    ...postorder(root.left),
    ...postorder(root.right),
    root.val
  ]
}

// 迭代实现（反转法）
function postorderIterative<T>(root: TreeNode<T> | null): T[] {
  if (!root)
    return []
  const stack: TreeNode<T>[] = [root]
  const result: T[] = []

  while (stack.length) {
    const node = stack.pop()!
    result.push(node.val)
    if (node.left)
      stack.push(node.left)
    if (node.right)
      stack.push(node.right)
  }
  return result.reverse() // 反转先序变体结果
}

// 迭代实现（双栈法）
function postorderTwoStacks<T>(root: TreeNode<T> | null): T[] {
  if (!root)
    return []
  const stack1: TreeNode<T>[] = [root]
  const stack2: TreeNode<T>[] = []
  const result: T[] = []

  while (stack1.length) {
    const node = stack1.pop()!
    stack2.push(node)
    if (node.left)
      stack1.push(node.left)
    if (node.right)
      stack1.push(node.right)
  }

  while (stack2.length) {
    result.push(stack2.pop()!.val)
  }
  return result
}
```

### 遍历过程

```mermaid
---
title: 示例树
---
graph TD
  A --> B
  A --> C
  B --> D
  B --> E
  C --> F
  C --> G
```

| 遍历方式 | 访问顺序       | 输出结果        |
| -------- | -------------- | --------------- |
| 先序遍历 | A→B→D→E→C→F->G | `[A,B,D,E,C,F]` |
| 中序遍历 | D→B→E→A→C→F->G | `[D,B,E,A,C,F]` |
| 后序遍历 | D→E→B→F→G->C→A | `[D,E,B,F,C,A]` |

## 二叉树的搜索

在二叉树中搜索值是树操作中最基础和重要的操作之一。

### 普通二叉树搜索

::: code-tabs

@tab 递归实现

```ts
function searchBinaryTree<T>(
  root: TreeNode<T> | null,
  target: T
): TreeNode<T> | null {
  if (!root)
    return null

  // 检查当前节点
  if (root.val === target)
    return root

  // 递归搜索左子树
  const leftResult = searchBinaryTree(root.left, target)
  if (leftResult)
    return leftResult

  // 递归搜索右子树
  return searchBinaryTree(root.right, target)
}
```

@tab 迭代实现（使用栈）

```ts
function searchBinaryTreeIterative<T>(
  root: TreeNode<T> | null,
  target: T
): TreeNode<T> | null {
  if (!root)
    return null

  const stack: TreeNode<T>[] = [root]

  while (stack.length) {
    const node = stack.pop()!

    // 检查当前节点
    if (node.val === target)
      return node

    // 将子节点压入栈
    if (node.right)
      stack.push(node.right)
    if (node.left)
      stack.push(node.left)
  }

  return null
}
```

:::

### 二叉搜索树（BST）搜索

二叉搜索树具有有序特性，可以高效搜索：

::: code-tabs

@tab 递归实现

```ts
function searchBST<T>(
  root: TreeNode<T> | null,
  target: T,
  comparator: (a: T, b: T) => number = (a, b) => a === b ? 0 : a > b ? 1 : -1
): TreeNode<T> | null {
  if (!root)
    return null

  const comp = comparator(target, root.val)

  if (comp === 0)
    return root // 找到目标
  if (comp < 0)
    return searchBST(root.left, target, comparator) // 目标小于当前值，搜索左子树
  return searchBST(root.right, target, comparator) // 目标大于当前值，搜索右子树
}
```

@tab 迭代实现

```ts
function searchBSTIterative<T>(
  root: TreeNode<T> | null,
  target: T,
  comparator: (a: T, b: T) => number = (a, b) => a === b ? 0 : a > b ? 1 : -1
): TreeNode<T> | null {
  let current = root

  while (current) {
    const comp = comparator(target, current.val)

    if (comp === 0)
      return current // 找到目标
    if (comp < 0)
      current = current.left // 目标小于当前值，转向左子树
    else current = current.right // 目标大于当前值，转向右子树
  }

  return null // 未找到
}
```

:::

### 搜索路径记录

有时我们需要记录搜索路径而不仅仅是找到节点：

```ts
function searchWithPath<T>(
  root: TreeNode<T> | null,
  target: T
): TreeNode<T>[] | null {
  if (!root)
    return null

  const path: TreeNode<T>[] = []
  let found = false

  function dfs(node: TreeNode<T> | null): boolean {
    if (!node || found)
      return false

    path.push(node)

    if (node.val === target) {
      found = true
      return true
    }

    if (dfs(node.left))
      return true
    if (dfs(node.right))
      return true

    path.pop()
    return false
  }

  dfs(root)
  return found ? path : null
}
```

## 时间复杂度

| 操作      | 平均       | 最差   |
| --------- | ---------- | ------ |
| 访问/搜索 | $O(log n)$ | $O(n)$ |
| 插入/删除 | $O(log n)$ | $O(n)$ |
| 空间      | $O(n)$     | $O(n)$ |

## 适用场景

* **数据库索引**：B/B+ 树（二叉树变种）
* **文件系统**：目录树结构
* **编译器**：语法分析树
* **游戏 AI**：决策树
* **数据压缩**：哈夫曼编码树

## 相关问题

[**LeetCode** - 二叉树](https://leetcode.cn/problem-list/tree/){.read-more}

### 基础操作

* **101. 对称二叉树**（[LeetCode](https://leetcode.cn/problems/symmetric-tree/)）
* **104. 二叉树的最大深度**（[LeetCode](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)）
* **226. 翻转二叉树**（[LeetCode](https://leetcode.cn/problems/invert-binary-tree/)）
* **102. 二叉树的层序遍历**（[LeetCode](https://leetcode.cn/problems/binary-tree-level-order-traversal/)）
* **199. 二叉树的右视图**（[LeetCode](https://leetcode.cn/problems/binary-tree-right-side-view/)）

### 路径、深度与综合应用

* **112. 路径总和**（[LeetCode](https://leetcode.cn/problems/path-sum/)）
* **543. 二叉树的直径**（[LeetCode](https://leetcode.cn/problems/diameter-of-binary-tree/)）
* **110. 平衡二叉树**（[LeetCode](https://leetcode.cn/problems/balanced-binary-tree/)）
* **114. 二叉树展开为链表**（[LeetCode](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)）

### 二叉搜索树（BST）专项

* **98. 验证二叉搜索树**（[LeetCode](https://leetcode.cn/problems/validate-binary-search-tree/)）
* **230. 二叉搜索树中第K小的元素**（[LeetCode](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)）
* **538. 把二叉搜索树转换为累加树**（[LeetCode](https://leetcode.cn/problems/convert-bst-to-greater-tree/)）
* **701. 二叉搜索树中的插入操作**（[LeetCode](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)）

---

---
url: /algorithm/data-structure/graph/index.md
---
# 图
[**维基百科** - 图论](https://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA){.read-more}

::: warning 受限于篇幅和作者个人水平，本篇仅粗略的介绍 **图** 的一些基本概念，有兴趣的读者可以自行了解更多的知识。
:::

## 概述

\==图（Graph）== 是一种表示多对多关系的非线性数据结构，由 **顶点（Vertex）** 和 **边（Edge）** 组成。

## 图的核心概念

* **顶点（Vertex）**：图中的基本元素（节点）

* **边（Edge）**：连接两个顶点的关系（可带权重）

* **类型**：

  * **无向图**：边无方向（A-B 表示双向关系）

  * **有向图**：边有方向（A→B 表示单向关系）

* **术语**：

  * **度（Degree）**：顶点连接的边数

  * **路径（Path）**：顶点序列通过边连接

  * **环（Cycle）**：起点=终点的路径

  * **连通图**：任意两顶点间存在路径

## 图的表示方法

### 邻接矩阵（Adjacency Matrix）

```ts
class GraphMatrix {
  private matrix: number[][]
  private vertices: string[]

  constructor(vertices: string[]) {
    this.vertices = vertices
    this.matrix = Array.from({ length: vertices.length })
      .fill(0)
      .map(() => Array.from({ length: vertices.length }).fill(0))
  }

  // 添加边（无向图）
  addEdge(v1: string, v2: string, weight: number = 1) {
    const i = this.vertices.indexOf(v1)
    const j = this.vertices.indexOf(v2)
    this.matrix[i][j] = weight
    this.matrix[j][i] = weight // 有向图时删除此行
  }

  // 打印矩阵
  print() {
    console.log(`  ${this.vertices.join(' ')}`)
    this.matrix.forEach((row, i) => {
      console.log(`${this.vertices[i]} ${row.join(' ')}`)
    })
  }
}

// 使用示例
const graph = new GraphMatrix(['A', 'B', 'C'])
graph.addEdge('A', 'B', 3)
graph.addEdge('B', 'C', 2)
graph.print()
/* 输出：
   A B C
A 0 3 0
B 3 0 2
C 0 2 0
*/
```

### 邻接表（Adjacency List）

```ts
interface Edge { vertex: string, weight: number }
class GraphList {
  private adjacencyList: Map<string, Edge[]> = new Map()

  addVertex(vertex: string): void {
    if (!this.adjacencyList.has(vertex)) {
      this.adjacencyList.set(vertex, [])
    }
  }

  addEdge(v1: string, v2: string, weight: number = 1): void {
    this.adjacencyList.get(v1)?.push({ vertex: v2, weight })
    // 无向图需添加反向边（有向图时删除）
    this.adjacencyList.get(v2)?.push({ vertex: v1, weight })
  }

  getNeighbors(vertex: string): Edge[] {
    return this.adjacencyList.get(vertex) || []
  }

  print() {
    this.adjacencyList.forEach((edges, vertex) => {
      const edgeStr = edges.map(e => `${e.vertex}(${e.weight})`).join(', ')
      console.log(`${vertex} -> ${edgeStr}`)
    })
  }
}

// 使用示例
const graph = new GraphList()
graph.addVertex('A')
graph.addVertex('B')
graph.addVertex('C')
graph.addEdge('A', 'B', 3)
graph.addEdge('B', 'C', 2)
graph.print()
/* 输出：
A -> B(3)
B -> A(3), C(2)
C -> B(2)
*/
```

## 图的应用场景

* **社交网络**：好友关系（顶点=用户，边=关注）
* **路径规划**：地图导航（顶点=地点，边=道路权重）
* **依赖分析**：编译顺序（有向无环图拓扑排序）
* **推荐系统**：用户-商品二部图

## 相关问题

[**LeetCode** - 图](https://leetcode.cn/problem-list/graph/){.read-more}

### 基础遍历与连通性问题

* **200. 岛屿数量**（[LeetCode](https://leetcode.cn/problems/number-of-islands/)）
* **133. 克隆图**（[LeetCode](https://leetcode.cn/problems/clone-graph/)）

### 环检测与树结构判断

* **261. 以图判树**（[LeetCode](https://leetcode.cn/problems/graph-valid-tree/)）
* **207. 课程表**（[LeetCode](https://leetcode.cn/problems/course-schedule/)）

### 最短路径与多源遍历

* **743. 网络延迟时间**（[LeetCode](https://leetcode.cn/problems/network-delay-time/)）
* **994. 腐烂的橘子**（[LeetCode](https://leetcode.cn/problems/oranges-rotting/)）

### 拓扑排序与应用

* **210.课程表 II**（[LeetCode](https://leetcode.cn/problems/course-schedule-ii/)）
* **310. 最小高度树**（[LeetCode](https://leetcode.cn/problems/minimum-height-trees/)）

### 矩阵与隐式图转换

* **417. 太平洋大西洋水流问题**（[LeetCode](https://leetcode.cn/problems/pacific-atlantic-water-flow/)）
* **127. 单词接龙**（[LeetCode](https://leetcode.cn/problems/word-ladder/)）

---

---
url: /algorithm/data-structure/hash-table/index.md
---
# 哈希表
## 概述

\==哈希表（Hash Table）== 是一种基于键值对（key-value）存储的高效数据结构，通过哈希函数将键映射到存储位置，
实现平均时间复杂度 $O(1)$ 的插入、删除和查找操作。

::: center
![hash-table](/images/algorithm/hashtable.svg)
:::

以 `key-value` 形式存储数据，是指任意的键值 key 都唯一对应到内存中的某个位置。
只需要输入查找的键值，就可以快速地找到其对应的 value。
可以把哈希表理解为一种高级的数组，这种数组的下标可以是很大的整数，浮点数，字符串甚至结构体。

## 核心特性

### 哈希函数 (Hash Function)

**将任意大小的数据（键）映射到固定大小的值（哈希值）。**

要让键值对应到内存中的位置，就要为键值计算索引，也就是计算这个数据应该放到哪里。
这个根据键值计算索引的函数就叫做哈希函数，也称散列函数。

举个例子，如果键值是一个人的身份证号码，哈希函数就可以是号码的后四位，当然也可以是号码的前四位。
生活中常用的「手机尾号」也是一种哈希函数。
在实际的应用中，键值可能是更复杂的东西，比如浮点数、字符串、结构体等，这时候就要根据具体情况设计合适的哈希函数。
哈希函数应当易于计算，并且尽量使计算出来的索引均匀分布。

**对于 哈希函数，应该满足以下要求**：

* **一致性**：相同的键总是产生相同的哈希值。
* **高效性**：计算速度快。
* **均匀性**：尽可能均匀地分布哈希值，以减少冲突。

### 冲突解决 (Collision Resolution)

如果对于任意的键值，哈希函数计算出来的索引都不相同，那只用根据索引把 $(key, value)$ 放到对应的位置就行了。
但实际上，常常会出现两个不同的键值，他们用哈希函数计算出来的索引是相同的。这时候就需要一些方法来处理冲突。

**常见的冲突解决方法包括**:

* **开散列法（Open hashing）**：也称 **拉链法**，在每个存放数据的地方开一个链表，如果有多个键值索引到同一个地方，
  只用把他们都放到那个位置的链表里就行了。
  查询的时候需要把对应位置的链表整个扫一遍，对其中的每个数据比较其键值与查询的键值是否一致。

  如果索引的范围是 $1\ldots M$，哈希表的大小为 $N$，那么一次 插入/查询 需要进行期望 $O(\frac{N}{M})$ 次比较。

* **闭散列法（Closed hashing）**：把所有记录直接存储在散列表中，如果发生冲突则根据某种方式继续进行探查。

  比如线性探查法：如果在 `d` 处发生冲突，就依次检查 `d + 1`，`d + 2` ……

### 动态扩容 (Rehashing)

当负载因子（元素数/桶数）超过阈值（如 0.75）时，扩容并重新哈希所有元素。

## 哈希表的实现

```ts
type Bucket<K, V> = Array<[K, V]> // 桶结构：存储键值对元组的数组

class HashTable<K, V> {
  private buckets: Array<Bucket<K, V>>
  private capacity: number
  private size: number
  private loadFactor: number = 0.75

  constructor(initialCapacity: number = 16) {
    this.capacity = initialCapacity
    this.size = 0
    this.buckets = Array.from({ length: initialCapacity }, () => [])
  }

  // 哈希函数（简化版，实际需更健壮）
  private hash(key: K): number {
    const keyString = String(key)
    let hash = 0
    for (let i = 0; i < keyString.length; i++) {
      hash = (hash << 5) + keyString.charCodeAt(i)
      hash = hash & hash // 转为32位整数
      hash = Math.abs(hash)
    }
    return hash % this.capacity
  }

  // 插入/更新键值对
  put(key: K, value: V): void {
    const index = this.hash(key)
    const bucket = this.buckets[index]

    // 检查是否已存在相同key
    for (const pair of bucket) {
      if (pair[0] === key) {
        pair[1] = value // 更新值
        return
      }
    }

    // 新增键值对
    bucket.push([key, value])
    this.size++

    // 检查扩容
    if (this.size / this.capacity > this.loadFactor) {
      this.resize()
    }
  }

  // 获取值
  get(key: K): V | undefined {
    const index = this.hash(key)
    const bucket = this.buckets[index]
    for (const [k, v] of bucket) {
      if (k === key)
        return v
    }
    return undefined
  }

  // 删除键值对
  remove(key: K): boolean {
    const index = this.hash(key)
    const bucket = this.buckets[index]
    for (let i = 0; i < bucket.length; i++) {
      if (bucket[i][0] === key) {
        bucket.splice(i, 1)
        this.size--
        return true
      }
    }
    return false
  }

  // 动态扩容
  private resize(): void {
    const oldBuckets = this.buckets
    this.capacity *= 2
    this.buckets = Array.from({ length: this.capacity }, () => [])
    this.size = 0

    // 重新哈希所有元素
    for (const bucket of oldBuckets) {
      for (const [key, value] of bucket) {
        this.put(key, value) // 插入到新桶
      }
    }
  }

  // 当前元素数量
  getSize(): number {
    return this.size
  }
}
```

## 时间复杂度

| 操作     | 时间复杂度                | 说明                    |
| -------- | ------------------------- | ----------------------- |
| put()    | 平均 $O(1)$ ，最坏 $O(n)$ | 哈希计算 + 桶内线性扫描 |
| get()    | 平均 $O(1)$ ，最坏 $O(n)$ | 桶内线性查找            |
| remove() | 平均 $O(1)$ ，最坏 $O(n)$ | 桶内查找后删除          |
| resize() | $O(n)$                    | 所有元素重新哈希        |

## 适用场景

* 高频插入/删除且需快速查找
* 缓存实现（如 LRU Cache）
* 数据库索引
* 字典类应用（词频统计）

## 相关问题

[**LeetCode** - 哈希表](https://leetcode.cn/problem-list/hash-table/){.read-more}
[**LeetCode** - 哈希函数](https://leetcode.cn/problem-list/hash-function/){.read-more}

### 基础操作（数组/集合/映射）

* **1. 两数之和**（[LeetCode](https://leetcode.cn/problems/two-sum/)）
* **242. 有效的字母异位词**（[LeetCode](https://leetcode.cn/problems/valid-anagram/)）
* **349. 两个数组的交集**（[LeetCode](https://leetcode.cn/problems/intersection-of-two-arrays/)）
* **202. 快乐数**（[LeetCode](https://leetcode.cn/problems/happy-number/)）

### 复杂数据结构与策略

* **146. LRU 缓存**（[LeetCode](https://leetcode.cn/problems/lru-cache/)）
* **49. 字母异位词分组**（[LeetCode](https://leetcode.cn/problems/group-anagrams/)）
* **974. 和可被 K 整除的子数组**（[LeetCode](https://leetcode.cn/problems/subarray-sums-divisible-by-k/)）

### 多步骤哈希优化

* **454. 四数相加 II**（[LeetCode](https://leetcode.cn/problems/4sum-ii/)）
* **347. 前 K 个高频元素**（[LeetCode](https://leetcode.cn/problems/top-k-frequent-elements/)）
* **128. 最长连续序列**（[LeetCode](https://leetcode.cn/problems/longest-consecutive-sequence/)）

---

---
url: /algorithm/data-structure/heap/index.md
---
# 堆
::: info 本篇仅讨论 **二叉堆**
:::

## 概述

\==堆（heap）== 是一种完全二叉树结构，满足以下性质：

* **堆序性**：每个节点的值必须满足特定顺序关系

  * **最大堆**：父节点值 ≥ 子节点值（根节点最大）
  * **最小堆**：父节点值 ≤ 子节点值（根节点最小）

* **结构完整性**：除最后一层外，其他层节点必须全满，且最后一层节点靠左排列

## 堆的实现

### 插入操作

**插入操作** 是指向二叉堆中插入一个元素，要保证插入后也是一棵完全二叉树。

最简单的方法就是，最下一层最右边的叶子之后插入。如果最下一层已满，就新增一层。
插入之后如果不满足堆性质，则采用 **向上调整** ：

如果这个节点的权值大于它父节点的权值，就交换，重复此过程直到不满足或者到根。
可以证明，插入之后向上调整后，没有其他接点会不满足堆性质。

**向上调整** 的时间复杂度是 $O(\log n)$ 。

:::center
![插入操作](/images/algorithm/binary-heap-insert.svg)
:::

### 删除操作

**删除操作** 指删除堆中最大的元素，即删除根结点。

但是如果直接删除，则变成了两个堆，难以处理。
所以不妨考虑 **插入操作的逆过程**，设法将根节点移到最后一个结点，然后直接删掉。
然而实际上不好做，我们通常采用的方法是，把根节点和最后一个节点直接交换。
于是直接删掉（在最后一个节点处的）根结点，但是新的根节点可能不满足堆性质。
这时候可以采用 **向下调整** :

在该节点的子节点中，找一个最大的，与该节点交换，重复此过程直到底层。
可以证明，删除并向下调整后，没有其他节点不满足堆性质。

时间复杂度 $O(\log n)$ 。

### 核心特性

* **数组表示**：堆通常使用数组存储（利用完全二叉树特性）

  索引计算（设当前索引为 i）：

  ```ts
  parentIndex = Math.floor((i - 1) / 2)
  leftChildIndex = 2 * i + 1
  rightChildIndex = 2 * i + 2
  ```

### 最大堆实现

```ts :collapsed-lines
class MaxHeap {
  private heap: number[]

  constructor() {
    this.heap = []
  }

  // 获取父节点索引
  private getParentIndex(index: number): number {
    return Math.floor((index - 1) / 2)
  }

  // 获取左子节点索引
  private getLeftChildIndex(index: number): number {
    return 2 * index + 1
  }

  // 获取右子节点索引
  private getRightChildIndex(index: number): number {
    return 2 * index + 2
  }

  // 交换元素
  private swap(i: number, j: number): void {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]]
  }

  // 上浮操作（插入后维护堆）
  private siftUp(): void {
    let currentIndex = this.heap.length - 1
    while (currentIndex > 0) {
      const parentIndex = this.getParentIndex(currentIndex)
      if (this.heap[currentIndex] > this.heap[parentIndex]) {
        this.swap(currentIndex, parentIndex)
        currentIndex = parentIndex
      }
      else {
        break
      }
    }
  }

  // 下沉操作（删除后维护堆）
  private siftDown(): void {
    let currentIndex = 0
    const size = this.heap.length

    while (this.getLeftChildIndex(currentIndex) < size) {
      const leftChildIndex = this.getLeftChildIndex(currentIndex)
      const rightChildIndex = this.getRightChildIndex(currentIndex)
      let largerChildIndex = leftChildIndex

      // 选择较大的子节点
      if (rightChildIndex < size
        && this.heap[rightChildIndex] > this.heap[leftChildIndex]) {
        largerChildIndex = rightChildIndex
      }

      // 与当前节点比较
      if (this.heap[currentIndex] < this.heap[largerChildIndex]) {
        this.swap(currentIndex, largerChildIndex)
        currentIndex = largerChildIndex
      }
      else {
        break
      }
    }
  }

  // 插入元素
  insert(value: number): void {
    this.heap.push(value)
    this.siftUp()
  }

  // 删除并返回堆顶元素
  extractMax(): number | null {
    if (this.heap.length === 0)
      return null

    const max = this.heap[0]
    const last = this.heap.pop()!

    if (this.heap.length > 0) {
      this.heap[0] = last
      this.siftDown()
    }

    return max
  }

  // 获取堆顶元素（不删除）
  peek(): number | null {
    return this.heap[0] ?? null
  }

  // 获取堆大小
  size(): number {
    return this.heap.length
  }

  // 堆排序（原地排序）
  static heapSort(arr: number[]): number[] {
    const heap = new MaxHeap()

    // 构建堆
    for (const num of arr) heap.insert(num)

    // 依次提取最大值
    const sorted: number[] = []
    while (heap.size() > 0) {
      sorted.unshift(heap.extractMax()!)
    }

    return sorted
  }
}
```

### 最小堆实现

最小堆实现进需要在 最大堆 的基础上进行修改，调整比较逻辑：

```ts
class MinHeap {
  private heap: number[] = []

  // ...（索引计算和swap方法同MaxHeap）

  private siftUp() {
    let index = this.heap.length - 1
    while (index > 0) {
      const parentIndex = this.getParentIndex(index)
      if (this.heap[index] < this.heap[parentIndex]) {
        this.swap(index, parentIndex)
        index = parentIndex
      }
      else {
        break
      }
    }
  }

  private siftDown() {
    let index = 0
    const length = this.heap.length

    while (true) {
      const leftChildIndex = this.getLeftChildIndex(index)
      const rightChildIndex = this.getRightChildIndex(index)
      let smallest = index

      if (leftChildIndex < length
        && this.heap[leftChildIndex] < this.heap[smallest]) {
        smallest = leftChildIndex
      }

      if (rightChildIndex < length
        && this.heap[rightChildIndex] < this.heap[smallest]) {
        smallest = rightChildIndex
      }

      if (smallest !== index) {
        this.swap(index, smallest)
        index = smallest
      }
      else {
        break
      }
    }
  }

  // 其他方法与MaxHeap类似
}
```

## 时间复杂度

| 操作           | 时间复杂度   | 说明                          |
| -------------- | ------------ | ----------------------------- |
| `insert()`     | $O(log n)$   | 最坏情况下上浮整棵树高度      |
| `extractMax()` | $O(log n)$   | 最坏情况下下沉整棵树高度      |
| `peek()`       | $O(1) $      | 直接访问数组首元素            |
| `buildHeap()`  | $O(n)$       | Floyd 算法自底向上堆化        |
| `heapSort()`   | $O(n log n)$ | 每次 extractMax 为 $O(log n)$ |

:::warning 注意
虽然单个插入操作是 $O(log n)$ ，但将 n 个元素插入空堆的总体时间复杂度是 $O(n log n)$ ，而 Floyd 建堆算法只需 $O(n)$ 。
:::

## 适用场景

* **优先队列**：

  ```ts
  class PriorityQueue {
    private heap = new MaxHeap()

    enqueue(val: number) { this.heap.insert(val) }
    dequeue() { return this.heap.extractMax() }
  }
  ```

* **堆排序**：

  * 时间复杂度：O(n log n)
  * 空间复杂度：O(1)（原地排序）

  ```ts
  const arr = [4, 10, 3, 5, 1]
  const sorted = MaxHeap.heapSort(arr) // [1, 3, 4, 5, 10]
  ```

* **Top K 问题**：

  ```ts
  function findTopK(nums: number[], k: number): number[] {
    const minHeap = new MinHeap() // 最小堆实现类似
    for (const num of nums) {
      minHeap.insert(num)
      if (minHeap.size() > k)
        minHeap.extractMin()
    }
    return minHeap.toArray()
  }
  ```

* **Dijkstra 算法**：优先队列优化最短路径搜索

## 相关问题

[**LeetCode** - 堆（优先队列）](https://leetcode.cn/problem-list/heap-priority-queue/){.read-more}

### 堆排序与选择问题

* **703. 数据流中的第 K 大元素**（[LeetCode](https://leetcode.cn/problems/kth-largest-element-in-a-stream/)）
* **215. 数组中的第K个最大元素**（[LeetCode](https://leetcode.cn/problems/kth-largest-element-in-an-array/)）
* **347. 前 K 个高频元素**（[LeetCode](https://leetcode.cn/problems/top-k-frequent-elements/)）

### 多堆结构与复杂规则处理

* **23. 合并 K 个升序链表**（[LeetCode](https://leetcode.cn/problems/merge-k-sorted-lists/)）
* **295. 数据流的中位数**（[LeetCode](https://leetcode.cn/problems/find-median-from-data-stream/)）
* **239. 滑动窗口最大值**（[LeetCode](https://leetcode.cn/problems/sliding-window-maximum/)）

### 综合场景

* **313. 超级丑数**（[LeetCode](https://leetcode.cn/problems/super-ugly-number/)）
* **786. 第 K 个最小的素数分数**（[LeetCode](https://leetcode.cn/problems/k-th-smallest-prime-fraction/)）
* **871. 最低加油次数**（[LeetCode](https://leetcode.cn/problems/minimum-number-of-refueling-stops/)）

---

---
url: /algorithm/data-structure/linked-list/index.md
---
# 链表
## 概述

链表是一种用于存储数据的数据结构，通过如链条一般的指针来连接元素。
它的特点是插入与删除数据十分方便，但寻找与读取数据的表现欠佳。

## 核心特性

* **节点（Node）**：

  * 存储数据（value）
  * 指向下一个节点的指针（next）
  * 双向链表额外包含指向前一个节点的指针（prev）

* **头指针（Head）**：

  * 指向链表的第一个节点
  * 链表入口点

* **尾节点（Tail）**：

  * 最后一个节点，其 next 指向 null

## 单向链表

单向链表中包含数据域和指针域，其中数据域用于存放数据，指针域用来连接当前结点和下一节点。

:::center
![linked list](/images/algorithm/linked-list.svg)
:::

### 插入数据

单向链表插入数据的流程大致如下：

::: steps

1. 初始化待插入的数据 node

   ![insert node](/images/algorithm/linked-list-insert-1.svg)

2. 将 node 的 next 指针指向 p 的下一个结点

   ![insert node](/images/algorithm/linked-list-insert-2.svg)

3. 将 p 的 next 指针指向 node

   ![insert node](/images/algorithm/linked-list-insert-3.svg)

:::

对于 **单向循环链表** ，由于链表首尾相连，在插入数据时需要判断原链表是否为空：为空则自身循环，不为空则正常插入数据。

大致流程如下：

1. 初始化待插入的数据 node；
2. 判断给定链表 p 是否为空；
3. 若为空，则将 node 的 next 指针和 p 都指向自己；
4. 否则，将 node 的 next 指针指向 p 的下一个结点；
5. 将 p 的 next 指针指向 node。

::: steps

* ![insert node](/images/algorithm/linked-list-insert-cyclic-1.svg)
* ![insert node](/images/algorithm/linked-list-insert-cyclic-2.svg)
* ![insert node](/images/algorithm/linked-list-insert-cyclic-3.svg)

:::

### 删除数据

设待删除结点为 p，从链表中删除它时，将 p 的下一个结点 p->next 的值覆盖给 p 即可，与此同时更新 p 的下下个结点。

流程大致如下：

1. 将 p 下一个结点的值赋给 p，以抹掉 p->value；
2. 新建一个临时结点 t 存放 p->next 的地址；
3. 将 p 的 next 指针指向 p 的下下个结点，以抹掉 p->next；
4. 删除 t。此时虽然原结点 p 的地址还在使用，删除的是原结点 p->next 的地址，但 p 的数据被 p->next 覆盖，p 名存实亡。

**参考**：

::: steps

* ![delete node](/images/algorithm/linked-list-delete-1.svg)
* ![delete node](/images/algorithm/linked-list-delete-2.svg)
* ![delete node](/images/algorithm/linked-list-delete-3.svg)

:::

### 单向链表实现

1. 定义节点类

```ts
class ListNode<T> {
  value: T
  next: ListNode<T> | null

  constructor(value: T) {
    this.value = value
    this.next = null
  }
}
```

2. 定义链表类

```ts :collapsed-lines
class SinglyLinkedList<T> {
  private head: ListNode<T> | null
  private size: number

  constructor() {
    this.head = null
    this.size = 0
  }

  // 插入到尾部 (O(n))
  append(value: T): void {
    const newNode = new ListNode(value)
    if (!this.head) {
      this.head = newNode
    }
    else {
      let current = this.head
      while (current.next) {
        current = current.next
      }
      current.next = newNode
    }
    this.size++
  }

  // 插入到头部 (O(1))
  prepend(value: T): void {
    const newNode = new ListNode(value)
    newNode.next = this.head
    this.head = newNode
    this.size++
  }

  // 删除节点 (O(n))
  delete(value: T): void {
    if (!this.head)
      return

    if (this.head.value === value) {
      this.head = this.head.next
      this.size--
      return
    }

    let current = this.head
    while (current.next) {
      if (current.next.value === value) {
        current.next = current.next.next
        this.size--
        return
      }
      current = current.next
    }
  }

  // 查找节点 (O(n))
  find(value: T): ListNode<T> | null {
    let current = this.head
    while (current) {
      if (current.value === value)
        return current
      current = current.next
    }
    return null
  }

  // 获取长度 (O(1))
  getLength(): number {
    return this.size
  }

  // 转换为数组 (O(n))
  toArray(): T[] {
    const result: T[] = []
    let current = this.head
    while (current) {
      result.push(current.value)
      current = current.next
    }
    return result
  }
}
```

## 双向链表

双向链表中同样有数据域和指针域。不同之处在于，指针域有左右（或上一个、下一个）之分，用来连接上一个结点、当前结点、下一个结点。

:::center
![double linked list](/images/algorithm/double-linked-list.svg)
:::

### 插入数据

在向双向（循环）链表插入数据时，除了要判断给定链表是否为空外，还要同时修改左、右两个指针。

大致流程如下：

1. 初始化待插入的数据 node；
2. 判断给定链表 p 是否为空；
3. 若为空，则将 node 的 left 和 right 指针，以及 p 都指向自己；
4. 否则，将 node 的 left 指针指向 p;
5. 将 node 的 right 指针指向 p 的右结点；
6. 将 p 右结点的 left 指针指向 node；
7. 将 p 的 right 指针指向 node。

### 删除数据

流程大致如下：

1. 将 p 左结点的右指针指向 p 的右节点；
2. 将 p 右结点的左指针指向 p 的左节点；
3. 新建一个临时结点 t 存放 p 的地址；
4. 将 p 的右节点地址赋给 p，以避免 p 变成悬垂指针；
5. 删除 t。

### 双向链表实现

1. 定义节点类

```ts
class DoublyListNode<T> {
  value: T
  next: DoublyListNode<T> | null
  prev: DoublyListNode<T> | null

  constructor(value: T) {
    this.value = value
    this.next = null
    this.prev = null
  }
}
```

2. 定义双向链表类

```ts :collapsed-lines
class DoublyLinkedList<T> {
  private head: DoublyListNode<T> | null
  private tail: DoublyListNode<T> | null
  private size: number

  constructor() {
    this.head = null
    this.tail = null
    this.size = 0
  }

  // 尾部插入 (O(1))
  append(value: T): void {
    const newNode = new DoublyListNode(value)
    if (!this.tail) {
      this.head = newNode
      this.tail = newNode
    }
    else {
      this.tail.next = newNode
      newNode.prev = this.tail
      this.tail = newNode
    }
    this.size++
  }

  // 头部插入 (O(1))
  prepend(value: T): void {
    const newNode = new DoublyListNode(value)
    if (!this.head) {
      this.head = newNode
      this.tail = newNode
    }
    else {
      newNode.next = this.head
      this.head.prev = newNode
      this.head = newNode
    }
    this.size++
  }

  // 删除节点 (O(n))
  delete(value: T): void {
    if (!this.head)
      return

    let current: DoublyListNode<T> | null = this.head
    while (current) {
      if (current.value === value) {
        if (current === this.head) {
          this.head = current.next
          if (this.head)
            this.head.prev = null
        }
        else if (current === this.tail) {
          this.tail = current.prev
          if (this.tail)
            this.tail.next = null
        }
        else {
          current.prev!.next = current.next
          current.next!.prev = current.prev
        }
        this.size--
        return
      }
      current = current.next
    }
  }
}
```

## 时间复杂度

| 操作     | 单向链表 | 双向链表 |
| -------- | -------- | -------- |
| 插入头部 | $O(1)$   | $O(1)$   |
| 插入尾部 | $O(n)$   | $O(1)$   |
| 删除头部 | $O(1)$   | $O(1)$   |
| 删除尾部 | $O(n)$   | $O(1)$   |
| 随机访问 | $O(n)$   | $O(n)$   |
| 查找元素 | $O(n)$   | $O(n)$   |

## 与数组的区别

链表和数组都可用于存储数据。与链表不同，数组将所有元素按次序依次存储。不同的存储结构令它们有了不同的优势：

* 链表因其链状的结构，能方便地删除、插入数据，操作次数是 $O(1)$ 。
  但也因为这样，寻找、读取数据的效率不如数组高，在随机访问数据中的操作次数是 $O(n)$ 。

* 数组可以方便地寻找并读取数据，在随机访问中操作次数是 $O(1)$ 。但删除、插入的操作次数是 $O(n)$ 次。

| 特性          | 链表               | 数组              |
| ------------- | ------------------ | ----------------- |
| 内存分配      | 动态分配（非连续） | 静态/连续内存     |
| 插入/删除效率 | $O(1)$ 在已知位置  | $O(n)$ 需移动元素 |
| 随机访问      | $O(n)$ 需要遍历    | $O(1)$ 通过索引   |
| 内存开销      | 额外存储指针       | 无额外开销        |
| 缓存友好度    | 差（内存不连续）   | 好（局部性原理）  |

## 应用场景

* **实现栈/队列**：

  ```ts
  // 基于链表的队列
  class Queue<T> {
    private list = new SinglyLinkedList<T>()

    enqueue(value: T) { this.list.append(value) }
    dequeue(): T | undefined { /* ... */ }
  }
  ```

* **LRU缓存淘汰算法**：

  使用双向链表 + HashMap 实现 O(1) 的插入/删除

* **大文件处理**：

  避免数组连续内存限制，分段处理数据

* **撤销操作历史记录**：

  双向链表实现前进/后退功能

## 链表使用技巧

* **虚拟头节点**：

  ```ts
  // 简化边界处理
  const dummyHead = new ListNode(0)
  dummyHead.next = head
  // ...操作后返回 dummyHead.next
  ```

* **快慢指针**：

  ```ts
  // 检测环/找中点
  let slow = head
  let fast = head
  while (fast && fast.next) {
    slow = slow.next!
    fast = fast.next.next!
  }
  ```

* **反转链表**：

  ```ts
  function reverseList<T>(head: ListNode<T> | null): ListNode<T> | null {
    let prev = null
    let current = head
    while (current) {
      const next = current.next
      current.next = prev
      prev = current
      current = next
    }
    return prev
  }
  ```

## 相关问题

[**LeetCode** - 链表](https://leetcode.cn/problem-list/linked-list/){.read-more}

### 基础操作

* **206. 反转链表**（[LeetCode](https://leetcode.cn/problems/reverse-linked-list/)）
* **21. 合并两个有序链表**（[LeetCode](https://leetcode.cn/problems/merge-two-sorted-lists/)）
* **83. 删除排序链表中的重复元素**（[LeetCode](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)）
* **203. 移除链表元素**（[LeetCode](https://leetcode.cn/problems/remove-linked-list-elements/)）

### 双指针技巧

* **141. 环形链表**（[LeetCode](https://leetcode.cn/problems/linked-list-cycle/)）
* **19. 删除链表的倒数第 N 个结点**（[LeetCode](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)）
* **876. 链表的中间结点**（[LeetCode](https://leetcode.cn/problems/middle-of-the-linked-list/)）

### 递归与归并

* **24. 两两交换链表中的节点**（[LeetCode](https://leetcode.cn/problems/swap-nodes-in-pairs/)）
* **23. 合并 K 个升序链表**（[LeetCode](https://leetcode.cn/problems/merge-k-sorted-lists/)）
* **148. 排序链表**（[LeetCode](https://leetcode.cn/problems/sort-list/)）

### 其它

* **138. 复制带随机指针的链表**（[LeetCode](https://leetcode.cn/problems/copy-list-with-random-pointer/)）
* **234. 回文链表**（[LeetCode](https://leetcode.cn/problems/palindrome-linked-list/)）
* **143. 重排链表**（[LeetCode](https://leetcode.cn/problems/reorder-list/)）

---

---
url: /algorithm/data-structure/overview/index.md
---
# 介绍
数据结构是在计算机中存储、组织数据的方式。小到变量、数组，大到线段树、平衡树，都是数据结构。

程序运行离不开数据结构，不同的数据结构又各有优劣，能够处理的问题各不相同，而根据具体问题选取合适的数据结构，
可以大大提升程序的效率。

一般你可以从两个维度来理解它，逻辑结构和存储结构。

## 逻辑结构

逻辑结构指数据之间的关系，逻辑结构大概统一的可以分成两种：线性结构、非线性结构。

* **线性结构**

  一个有序数据元素的集合。
  其中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。

  常用的线性结构有: 栈，队列，链表，线性表。

  ```mermaid
  block-beta
  A B C D E F G H
  ```

* **非线性结构**

  各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生联系。

  常见的非线性结构有 二维数组，树等。

  ```mermaid
  flowchart TD
    A --> B
    A --> C
    B --> D
    B --> E
    C --> F
    C --> G
  ```

## 存储结构

逻辑结构指的是数据间的关系，而存储结构是逻辑结构用计算机语言的实现。

常见的存储结构有顺序存储、链式存储、索引存储以及散列存储。

例如：

* 数组在内存中的位置是连续的，它就属于顺序存储；
* 链表是主动建立数据间的关联关系的，在内存中却不一定是连续的，它属于链式存储；
* 还有顺序和逻辑上都不存在顺序关系，但是你可以通过一定的方式去放问它的哈希表，数据散列存储。

---

---
url: /algorithm/data-structure/queue/index.md
---
# 队列
## 概述

\==队列（Queue）== 是一种 先进先出（FIFO: First-In-First-Out） 的线性数据结构，类似于现实生活中的排队场景。

在队列中，元素从一端（队尾）添加，从另一端（队首）移除。

:::center
![stack](/images/algorithm/queue.svg)
:::

::: tip 提示
当我们在排队买票时，排在队首的人先买票，然后离开队伍。
新来的人需要排到队伍尾部，等待前面的人买完票再轮到他。
:::

## 核心特性

* **操作受限**：只允许在两端操作
* **先进先出**：最早入队的元素最先出队
* **动态大小**：长度随操作变化（非固定容量）

## 时间复杂度

| 操作        | 描述                   | TypeScript 实现示例         |
|-------------|------------------------|----------------------------|
| `enqueue()` | 元素入队（添加到队尾） | `queue.push(item)`         |
| `dequeue()` | 元素出队（移除队首元素）| `queue.shift()`            |
| `peek()`    | 查看队首元素（不移除） | `queue[0]`                 |
| `isEmpty()` | 检查队列是否为空       | `queue.length === 0`       |
| `size()`    | 获取队列长度           | `queue.length`             |

## 队列的实现

### 数组实现

**注意**：`shift()` 操作需要移动所有元素（时间复杂度 O(n)）

```ts
class ArrayQueue<T> {
  private items: T[] = []

  enqueue(item: T): void {
    this.items.push(item)
  }

  dequeue(): T | undefined {
    return this.items.shift()
  }

  peek(): T | undefined {
    return this.items[0]
  }

  get size(): number {
    return this.items.length
  }

  isEmpty(): boolean {
    return this.items.length === 0
  }

  clear(): void {
    this.items = []
  }
}
```

### 链表实现

所有操作时间复杂度均为 O(1)

```ts
class QueueNode<T> {
  constructor(
    public value: T,
    public next: QueueNode<T> | null = null
  ) {}
}

class LinkedListQueue<T> {
  private front: QueueNode<T> | null = null
  private rear: QueueNode<T> | null = null
  private _size = 0

  enqueue(item: T): void {
    const newNode = new QueueNode(item)
    if (this.isEmpty()) {
      this.front = newNode
    }
    else {
      this.rear!.next = newNode
    }
    this.rear = newNode
    this._size++
  }

  dequeue(): T | undefined {
    if (this.isEmpty())
      return undefined

    const removed = this.front!
    this.front = this.front!.next
    this._size--

    if (this.isEmpty())
      this.rear = null
    return removed.value
  }

  peek(): T | undefined {
    return this.front?.value
  }

  get size(): number {
    return this._size
  }

  isEmpty(): boolean {
    return this._size === 0
  }

  clear(): void {
    this.front = null
    this.rear = null
    this._size = 0
  }
}
```

### 循环队列实现

解决数组实现的性能问题，使用环形缓冲区，适用于 **固定容量优化** 的场景

```ts
class CircularQueue<T> {
  private items: (T | undefined)[]
  private front = 0
  private rear = -1
  private count = 0

  constructor(private capacity: number) {
    this.items = Array.from({ length: capacity })
  }

  enqueue(item: T): boolean {
    if (this.isFull())
      return false

    this.rear = (this.rear + 1) % this.capacity
    this.items[this.rear] = item
    this.count++
    return true
  }

  dequeue(): T | undefined {
    if (this.isEmpty())
      return undefined

    const item = this.items[this.front]
    this.front = (this.front + 1) % this.capacity
    this.count--
    return item
  }

  peek(): T | undefined {
    return this.isEmpty() ? undefined : this.items[this.front]
  }

  isFull(): boolean {
    return this.count === this.capacity
  }

  isEmpty(): boolean {
    return this.count === 0
  }

  get size(): number {
    return this.count
  }
}
```

## 应用场景

* **任务调度**：CPU 进程调度、打印机任务队列
* **广度优先搜索**：树/图的层级遍历
* **消息传递**：消息队列（RabbitMQ/Kafka）
* **缓冲区管理**：网络数据包处理
* **撤销操作栈**：编辑器中的撤销历史记录

## 复杂度对比

| 操作        | 数组实现 | 链表实现 | 循环队列 |
|-------------|----------|----------|----------|
| **enqueue** | O(1)\*   | O(1)     | O(1)     |
| **dequeue** | O(n)     | O(1)     | O(1)     |
| **peek**    | O(1)     | O(1)     | O(1)     |
| **空间**    | O(n)     | O(n)     | O(n)     |

::: warning 注：数组的 push() 平均 O(1)，但动态扩容时可能 O(n)
:::

## 相关问题

[**LeetCode** - 队列](https://leetcode.cn/problem-list/queue/){.read-more}

### 基础操作

* **232. 用栈实现队列**（[LeetCode](https://leetcode.cn/problems/implement-queue-using-stacks/)）
* **622. 设计循环队列**（[LeetCode](https://leetcode.cn/problems/design-circular-queue/)）

### 广度优先搜索 (BFS)

* **102. 二叉树的层序遍历**（[LeetCode](https://leetcode.cn/problems/binary-tree-level-order-traversal/)）
* **752. 打开转盘锁**（[LeetCode](https://leetcode.cn/problems/open-the-lock/)）
* **994. 腐烂的橘子**（[LeetCode](https://leetcode.cn/problems/rotting-oranges/)）

### 单调队列

* **239. 滑动窗口最大值**（[LeetCode](https://leetcode.cn/problems/sliding-window-maximum/)）
* **862. 和至少为 K 的最短子数组**（[LeetCode](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)）

---

---
url: /algorithm/data-structure/stack/index.md
---
# 栈
## 概述

\==栈== 是一种遵循 **后进先出（LIFO） 原则** 的线性数据结构，类似于现实中的一摞盘子或书籍。

::: center
![stack](/images/algorithm/stack.svg)
:::

::: tip 提示
想象一下，我们把盘子从上到下依次摆放在桌子上，当我们要用到盘子时，就从最上面取走一个盘子，
放回盘子时，则是把盘子放在最上面。
:::

## 核心特性

* **后进先出（LIFO）**：最后添加的元素最先被移除
* **单端操作**：所有操作（插入/删除/访问）仅在栈顶（Top）进行

## 时间复杂度

* **压栈（Push）**: O(1)
* **弹栈（Pop）**: O(1)
* **查看栈顶（Peek）**: O(1)

## 栈的实现

### 使用数组模拟栈

```ts
class ArrayStack<T> {
  private items: T[]

  constructor() {
    this.items = []
  }

  // 压栈
  push(element: T): void {
    this.items.push(element)
  }

  // 弹栈
  pop(): T | undefined {
    return this.items.pop()
  }

  // 查看栈顶元素
  peek(): T | undefined {
    return this.items[this.items.length - 1]
  }

  // 判断空栈
  isEmpty(): boolean {
    return this.items.length === 0
  }

  // 获取栈大小
  size(): number {
    return this.items.length
  }

  // 清空栈
  clear(): void {
    this.items = []
  }

  // 打印栈内容
  print(): string {
    return this.items.toString()
  }
}
```

### 使用链表模拟栈

```ts
class LinkedNode<T> {
  constructor(
    public value: T,
    public next: LinkedNode<T> | null = null
  ) {}
}

class LinkedListStack<T> {
  private top: LinkedNode<T> | null = null
  private count: number = 0

  push(element: T): void {
    const newNode = new LinkedNode(element)
    newNode.next = this.top
    this.top = newNode
    this.count++
  }

  pop(): T | undefined {
    if (!this.top)
      return undefined
    const value = this.top.value
    this.top = this.top.next
    this.count--
    return value
  }

  peek(): T | undefined {
    return this.top?.value
  }

  isEmpty(): boolean {
    return this.count === 0
  }

  size(): number {
    return this.count
  }

  clear(): void {
    this.top = null
    this.count = 0
  }
}
```

## 应用场景

* **函数调用栈**（程序执行上下文管理）
* **括号匹配校验**（编译器语法检查）
* **撤销操作（Undo）**（编辑器历史记录）
* **深度优先搜索（DFS）**（图遍历算法）
* **表达式求值**（中缀转后缀表达式）
* **浏览器历史记录**（前进/后退功能）

::: important
掌握 **栈** 的关键在于理解其 **LIFO 特性** 和 **受限的操作方式**，
这种特性使其在需要"撤销"或"回溯"的场景中具有天然优势。
:::

## 相关题目

[**LeetCode** - 栈](https://leetcode.cn/problem-list/stack/){.read-more}

### 基础操作

* **20. 有效的括号**（[LeetCode](https://leetcode.cn/problems/valid-parentheses/)）
* **225. 用队列实现栈**（[LeetCode](https://leetcode.cn/problems/implement-stack-using-queues/)）
* **155. 最小栈**（[LeetCode](https://leetcode.cn/problems/min-stack/)）

### 表达式求值

* **150. 逆波兰表达式求值**（[LeetCode](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)）
* **227. 基本计算器 II**（[LeetCode](https://leetcode.cn/problems/basic-calculator-ii/)）

### 单调栈

* **496. 下一个更大元素 I**（[LeetCode](https://leetcode.cn/problems/next-greater-element-i/)）
* **503. 下一个更大元素 II**（[LeetCode](https://leetcode.cn/problems/next-greater-element-ii/)）
* **739. 每日温度**（[LeetCode](https://leetcode.cn/problems/daily-temperatures/)）
* **42. 接雨水**（[LeetCode](https://leetcode.cn/problems/trapping-rain-water/)）

### 深度优先搜索（DFS）

* **94. 二叉树的中序遍历**（[LeetCode](https://leetcode.cn/problems/binary-tree-inorder-traversal/)）
* **144. 二叉树的前序遍历**（[LeetCode](https://leetcode.cn/problems/binary-tree-preorder-traversal/)）
* **341. 扁平化嵌套列表迭代器**（[LeetCode](https://leetcode.cn/problems/flatten-nested-list-iterator/)）

### 特殊栈应用

* **316. 去除重复字母**（[LeetCode](https://leetcode.cn/problems/remove-duplicate-letters/)）
* **394. 字符串解码**（[LeetCode](https://leetcode.cn/problems/decode-string/)）
* **456. 132 模式**（[LeetCode](https://leetcode.cn/problems/132-pattern/)）

---

---
url: /algorithm/depth-first-search/index.md
---
# 深度优先搜索
## 概述

\==深度优先搜索（Depth-First Search）（DFS）== 是一种用于遍历或搜索树或图的算法。

其核心思想是尽可能深地探索分支，直到达到末端，然后回溯并探索其他分支。

::: note 该算法常常与 BFS 并列，但两者除了都能遍历图的连通块以外，用途完全不同，很少有能混用两种算法的情况。
:::

## 过程

DFS 最显著的特征在于其 **递归调用自身**。
同时与 BFS 类似，DFS 会对其访问过的点打上访问标记，在遍历图时跳过已打过标记的点，以确保 **每个点仅访问一次** 。
符合以上两条规则的函数，便是广义上的 DFS。

具体地说，DFS 大致结构如下：

```txt title="伪代码"
DFS(v) // v 可以是图中的一个顶点，也可以是抽象的概念，如 dp 状态等。
  在 v 上打访问标记
  for u in v 的相邻节点
    if u 没有打过访问标记 then
      DFS(u)
    end
  end
end
```

## 核心原理

* **深度优先**：从起始节点开始，沿一条路径不断深入直到末端，再回溯探索其他路径。
* **递归/栈结构**：天然适合递归实现（隐式栈），也可用显式栈迭代实现。
* **回溯机制**：当节点无未访问邻居时，回退到上一个节点。
* **避免重复访问**：需记录已访问节点（通常用 Set 或数组）。

## 复杂度分析

该算法通常的时间复杂度为 $O(n+m)$，空间复杂度为 $O(n)$，其中 $n$ 表示点数，$m$ 表示边数。

注意空间复杂度包含了栈空间，栈空间的空间复杂度是 $O(n)$ 的。
在平均 $O(1)$ 遍历一条边的条件下才能达到此时间复杂度，例如用前向星或邻接表存储图；
如果用邻接矩阵则不一定能达到此复杂度。

## 实现方式

### 递归实现

```ts
type Graph = Record<string, string[]>

function dfsRecursive(
  graph: Graph,
  node: string,
  visited: Set<string> = new Set()
): void {
  // 1. 访问当前节点
  console.log(node)
  visited.add(node)

  // 2. 递归访问所有未访问的邻居
  for (const neighbor of graph[node] || []) {
    if (!visited.has(neighbor)) {
      dfsRecursive(graph, neighbor, visited)
    }
  }
}
```

### 迭代实现（显式栈）

```ts
function dfsIterative(graph: Graph, start: string): void {
  const stack: string[] = [start]
  const visited = new Set<string>()

  while (stack.length > 0) {
    const node = stack.pop()! // 从栈顶弹出节点
    if (visited.has(node))
      continue

    // 访问节点
    console.log(node)
    visited.add(node)

    // 将邻居逆序入栈（保持与递归相同顺序）
    const neighbors = graph[node] || []
    for (let i = neighbors.length - 1; i >= 0; i--) {
      if (!visited.has(neighbors[i])) {
        stack.push(neighbors[i])
      }
    }
  }
}
```

## 注意事项

* **栈溢出**：深度过大时递归可能导致栈溢出，可改用迭代法。
* **环检测**：在递归中若遇到已访问节点且非父节点，说明存在环。
* **非连通图**：需遍历所有未访问节点作为新起点。

## 相关题目

[**LeetCode** - 深度优先搜索 Depth-First Search](https://leetcode.cn/problem-list/depth-first-search/){.read-more}

### 矩阵遍历类（二维网格DFS）

* **200. 岛屿数量**（[LeetCode](https://leetcode.cn/problems/number-of-islands/)）
* **417. 太平洋大西洋水流问题**（[LeetCode](https://leetcode.cn/problems/pacific-atlantic-water-flow/)）
* **LCR 129. 字符迷宫** （[LeetCode](https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/)）

### 树与图遍历类（递归/隐式栈）

* **1038. 从二叉搜索树到更大树**（[LeetCode](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/)）
* **100. 相同的树**（[LeetCode](https://leetcode.cn/problems/same-tree/)）
* **105. 从前序与中序遍历序列构造二叉树**（[LeetCode](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)）


### 回溯与组合类（路径/状态管理）

* **39. 组合总和**（[LeetCode](https://leetcode.cn/problems/combination-sum/)）
* **40. 组合总和 II**（[LeetCode](https://leetcode.cn/problems/combination-sum-ii/)）
* **LCP 07. 传递信息** （[LeetCode](https://leetcode.cn/problems/chuan-di-xin-xi/)）

### 进阶挑战题

* **79. 单词搜索**（[LeetCode](https://leetcode.cn/problems/word-search/)）
* **301. 删除无效的括号**（[LeetCode](https://leetcode.cn/problems/remove-invalid-parentheses/)）
* **694. 不同的岛屿数量**（[LeetCode](https://leetcode.cn/problems/number-of-distinct-islands/)）

---

---
url: /algorithm/divide-and-conquer/index.md
---
# 分治算法
## 概述

\==分治算法（Divide and Conquer）== , 字面上的解释是「分而治之」。
把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。

**核心流程包含三步**：

* **分解（Divide）**：将原问题拆分为独立子问题
* **解决（Conquer）**：递归求解子问题
* **合并（Combine）**：将子问题的解合并为原问题的解

## 算法特征

* 该问题的规模缩小到一定的程度就可以容易地解决。
* 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质，利用该问题分解出的子问题的解可以合并为该问题的解。
* 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。

::: warning
如果各子问题是不独立的，则分治法要重复地解公共的子问题，也就做了许多不必要的工作。
此时虽然也可用分治法，但一般用 ==动态规划== 较好。
:::

## 过程

以归并排序为例。

假设实现归并排序的函数名为 `mergeSort`。明确该函数的职责，即 **对传入的一个数组排序**。
这个问题显然可以分解。给一个数组排序等于给该数组的左右两半分别排序，然后合并成一个数组。

```ts
function mergeSort(一个数组) {
  if (可以很容易处理)
    return
  mergeSort(左半个数组)
  mergeSort(右半个数组)
  merge(左半个数组, 右半个数组)
}
```

传给它半个数组，那么处理完后这半个数组就已经被排好了。
注意到，`mergeSort` 与二叉树的后序遍历模板极其相似。
因为分治算法的套路是 **分解 -> 解决（触底）-> 合并（回溯）**，先左右分解，再处理合并，回溯就是在退栈，即相当于后序遍历。

`merge` 函数的实现方式与两个有序链表的合并一致。

## 分治示例

### 归并排序（经典分治）

* **时间复杂度**：$O(n log n)$
* **空间复杂度**：$O(n)$

```ts
function mergeSort(arr: number[]): number[] {
  if (arr.length <= 1)
    return arr // 终止条件

  // 分解阶段
  const mid = Math.floor(arr.length / 2)
  const left = mergeSort(arr.slice(0, mid))
  const right = mergeSort(arr.slice(mid))

  // 合并阶段
  return merge(left, right)
}

function merge(left: number[], right: number[]): number[] {
  let result: number[] = []
  let i = 0
  let j = 0

  // 合并两个有序数组
  while (i < left.length && j < right.length) {
    if (left[i] < right[j]) {
      result.push(left[i++])
    }
    else {
      result.push(right[j++])
    }
  }

  // 处理剩余元素
  return result.concat(left.slice(i)).concat(right.slice(j))
}

// 测试
const arr = [38, 27, 43, 3, 9, 82, 10]
console.log(mergeSort(arr)) // [3, 9, 10, 27, 38, 43, 82]
```

## 分治算法优化技巧

* **避免重复计算**：使用记忆化存储中间结果
* **尾递归优化**：减少递归栈深度
* **迭代替代递归**：降低空间复杂度
* **并行计算**：子问题独立时可并行处理

## 适用场景

* 问题可分解为独立子问题（归并排序、快速排序）
* 子问题结构相似（二叉树遍历）
* 合并操作复杂度低于暴力求解（矩阵乘法）
* 问题具有递归特性（汉诺塔、斐波那契数列）

## 相关问题

[**LeetCode** - 分治](https://leetcode.cn/tag/divide-and-conquer/){.read-more}

### 基础分治应用

* **169. 多数元素**（[LeetCode](https://leetcode.cn/problems/majority-element/)）
* **50. Pow(x, n)**（[LeetCode](https://leetcode.cn/problems/powx-n/)）

### 子问题合并技巧

* **53. 最大子序和**（[LeetCode](https://leetcode.cn/problems/maximum-subarray/)）
* **493. 翻转对**（[LeetCode](https://leetcode.cn/problems/reverse-pairs/)）

### 分治优化：三路划分

* **215. 数组中的第K个最大元素**（[LeetCode](https://leetcode.cn/problems/kth-largest-element-in-an-array/)）
* **75. 颜色分类**（[LeetCode](https://leetcode.cn/problems/sort-colors/)）

### 进阶问题

* **4. 寻找两个有序数组的中位数**（[LeetCode](https://leetcode.cn/problems/median-of-two-sorted-arrays/)）

---

---
url: /algorithm/dynamic-programming/index.md
---
# 动态规划
::: important **动态规划** 学习需要长时间的练习和强化，此篇目前仅处于 ==草稿=={.warning} 状态，在未来会引入更多的 DP 问题进行更为深入的学习。
:::

## 概述

\==动态规划（Dynamic Programming== 一种 **通过将复杂问题分解为重叠子问题，并存储子问题解以避免重复计算的优化技术**。

它适用于具有 **最优子结构** 和 **重叠子问题** 特性的问题。

## 动态规划原理

能用动态规划解决的问题，需要满足三个条件：**最优子结构** ，**无后效性** 和 **子问题重叠** 。

### 最优子结构

具有最优子结构也可能是适合用贪心的方法求解。

注意要确保我们考察了最优解中用到的所有子问题。

1. 证明问题最优解的第一个组成部分是做出一个选择；
2. 对于一个给定问题，在其可能的第一步选择中，假定你已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择；
3. 给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；
4. 证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。

要保持子问题空间尽量简单，只在必要时扩展。

最优子结构的不同体现在两个方面：

1. 原问题的最优解中涉及多少个子问题；
2. 确定最优解使用哪些子问题时，需要考察多少种选择。

子问题图中每个定点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边。

### 无后效性

已经求解的子问题，不会再受到后续决策的影响。

### 子问题重叠

如果有大量的重叠子问题，我们可以用空间将这些子问题的解存储下来，避免重复求解相同的子问题，从而提升效率。

### 基本思路

对于一个能用动态规划解决的问题，一般采用如下思路解决：

1. 将原问题划分为若干 **阶段**，每个阶段对应若干个子问题，提取这些子问题的特征（称之为 **状态**）；
2. 寻找每一个状态的可能 **决策**，或者说是各状态间的相互转移方式（用数学的语言描述就是 **状态转移方程**）。
3. 按顺序求解每一个阶段的问题。

## 示例

### 斐波那契数列（基础入门）

```ts
// 自底向上（迭代）
function fib(n: number): number {
  if (n < 2)
    return n
  const dp: number[] = [0, 1]
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n]
}

// 空间优化（滚动数组）
function fibOpt(n: number): number {
  if (n < 2)
    return n
  let prev = 0
  let curr = 1
  for (let i = 2; i <= n; i++) {
    [prev, curr] = [curr, prev + curr]
  }
  return curr
}
```

### 背包问题（0-1 Knapsack）

:::info 有 $n$ 个物品和一个容量为 $W$ 的背包，每个物品有重量 $w\_{i}$ 和价值 $v\_{i}$ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。
:::

```ts
function knapSack(
  capacity: number, // 背包的最大容量
  weights: number[], // 每个物品的重量
  values: number[], // 每个物品的价值
  n: number // 物品个数
): number {
  // dp[i][w] 表示前i个物品在容量w时的最大价值
  const dp: number[][] = Array.from({ length: n + 1 })
    .fill(0)
    .map(() => Array.from({ length: capacity + 1 }).fill(0))

  for (let i = 1; i <= n; i++) {
    for (let w = 1; w <= capacity; w++) {
      if (weights[i - 1] <= w) {
        dp[i][w] = Math.max(
          values[i - 1] + dp[i - 1][w - weights[i - 1]],
          dp[i - 1][w]
        )
      }
      else {
        dp[i][w] = dp[i - 1][w]
      }
    }
  }
  return dp[n][capacity]
}

// 使用示例
const values = [60, 100, 120]
const weights = [10, 20, 30]
const capacity = 50
console.log(knapSack(capacity, weights, values, values.length)) // 220
```

### 最长公共子序列（LCS）

:::info 给定一个长度为 $n$ 的序列 $A$ 和一个 长度为 $m$ 的序列 $B \text{（}n,m \leq 5000\text{）}$，求出一个最长的序列，使得该序列既是 $A$ 的子序列，也是 $B$ 的子序列。
:::

```ts
function lcs(text1: string, text2: string): number {
  const m = text1.length
  const n = text2.length
  // dp[i][j] 表示 text1[0..i-1] 和 text2[0..j-1] 的 LCS 长度
  const dp: number[][] = Array.from({ length: m + 1 })
    .fill(0)
    .map(() => Array.from({ length: n + 1 }).fill(0))

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (text1[i - 1] === text2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1
      }
      else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
      }
    }
  }
  return dp[m][n]
}
```

## 记忆化搜索

\==记忆化搜索== 是一种通过记录已经遍历过的状态的信息，从而避免对同一状态重复遍历的搜索实现方式。

因为记忆化搜索确保了每个状态只访问一次，它也是一种常见的动态规划实现方式。

```ts
const memo: number[] = []
function fib(n: number): number {
  if (n < 2)
    return n
  if (memo[n] !== undefined)
    return memo[n]
  memo[n] = fib(n - 1) + fib(n - 2)
  return memo[n]
}
```

## 相关问题

[**LeetCode** - 动态规划](https://leetcode.cn/problem-list/dynamic-programming/){.read-more}

### 基础

* **70. 爬楼梯**（[LeetCode](https://leetcode.cn/problems/climbing-stairs/)）
* **509. 斐波那契数列**（[LeetCode](https://leetcode.cn/problems/fibonacci-number/)）
* **LCR 127. 跳跃训练**（[LeetCode](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof)）
* **118. 杨辉三角**（[LeetCode](https://leetcode.cn/problems/pascals-triangle/)）
* **198. 打家劫舍**（[LeetCode](https://leetcode.cn/problems/house-robber/)）
* **53. 最大子序和**（[LeetCode](https://leetcode.cn/problems/maximum-subarray/)）

### 二维DP (路径、序列)

* **62. 不同路径**（[LeetCode](https://leetcode.cn/problems/unique-paths/)）
* **63. 不同路径 II**（[LeetCode](https://leetcode.cn/problems/unique-paths-ii/)）
* **64. 最小路径和**（[LeetCode](https://leetcode.cn/problems/minimum-path-sum/)）
* **1143. 最长公共子序列**（[LeetCode](https://leetcode.cn/problems/longest-common-subsequence/)）
* **72. 编辑距离**（[LeetCode](https://leetcode.cn/problems/edit-distance/)）
* **5. 最长回文子串**（[LeetCode](https://leetcode.cn/problems/longest-palindromic-substring/)）
* **300. 最长递增子序列**（[LeetCode](https://leetcode.cn/problems/longest-increasing-subsequence/)）

### 背包问题 (组合优化)

* **416. 分割等和子集**（[LeetCode](https://leetcode.cn/problems/partition-equal-subset-sum/)）
* **322. 零钱兑换**（[LeetCode](https://leetcode.cn/problems/coin-change/)）
* **518. 零钱兑换 II**（[LeetCode](https://leetcode.cn/problems/coin-change-2/)）
* **139. 单词拆分**（[LeetCode](https://leetcode.cn/problems/word-break/)）

### 状态机DP (复杂状态转移)

* **121. 买卖股票的最佳时机**（[LeetCode](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)）
* **122. 买卖股票的最佳时机 II**（[LeetCode](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)）
* **123. 买卖股票的最佳时机 III**（[LeetCode](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)）
* **188. 买卖股票的最佳时机 IV**（[LeetCode](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)）
* **309. 最佳买卖股票时机含冷冻期**（[LeetCode](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)）
* **714. 最佳买卖股票时机含手续费**（[LeetCode](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)）

### 其他经典问题

* **322. 零钱兑换**（[LeetCode](https://leetcode.cn/problems/coin-change/)）
* **96. 不同的二叉搜索树**（[LeetCode](https://leetcode.cn/problems/unique-binary-search-trees/)）
* **211. 添加与搜索单词**（[LeetCode](https://leetcode.cn/problems/add-and-search-word-data-structure-design/)）
* **337. 打家劫舍 III**（[LeetCode](https://leetcode.cn/problems/house-robber-iii/)）

---

---
url: /algorithm/greedy/index.md
---
# 贪心算法
## 概述

\==贪心算法（Greedy Algorithm）== 是用计算机来模拟一个 **贪心** 的人做出决策的过程。
这个人十分贪婪，每一步行动总是按某种指标选取最优的操作。而且他目光短浅，总是只看眼前，并不考虑以后可能造成的影响。

可想而知，并不是所有的时候贪心法都能获得最优解，所以一般使用贪心法的时候，都要确保自己能证明其正确性。

### 适用范围

贪心算法在 **有最优子结构的问题** 中尤为有效。

最优子结构的意思是 **问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解** 。

### 证明

贪心算法有两种证明方法：反证法和归纳法。一般情况下，一道题只会用到其中的一种方法来证明。

* **反证法**：如果交换方案中任意两个元素/相邻的两个元素后，答案不会变得更好，那么可以推定目前的解已经是最优解了。
* **归纳法**：先算得出边界情况（例如 $n = 1$ ）的最优解 $F\_{1}$，
  然后再证明：对于每个 $n$，$F\_{n+1}$ 都可以由 $F\_{n}$ 推导出结果。

## 核心特点

* **局部最优 → 全局最优**：通过局部最优决策的累积达到全局最优
* **不可回溯**：一旦做出选择不再改变
* **高效性**：通常时间复杂度较低
* **不保证全局最优**：仅适用于特定问题类型

## 设计步骤

* **建立数学模型**：明确优化目标
* **分解子问题**：将问题分解为多个决策阶段
* **制定贪心策略**：确定局部最优的选择标准
* **证明正确性**：验证问题具有贪心选择性质
* **实现算法**：编写高效代码实现

## 示例

### 找零问题

用最少硬币数凑出指定金额（假设硬币无限供应）

```ts
function minCoins(coins: number[], amount: number): number {
  coins.sort((a, b) => b - a) // 降序排列
  let count = 0
  let remaining = amount

  for (const coin of coins) {
    while (remaining >= coin) {
      remaining -= coin
      count++
    }
    if (remaining === 0)
      break
  }

  return remaining === 0 ? count : -1
}

// 测试
const coins = [1, 2, 5, 10, 20]
console.log(minCoins(coins, 36)) // 输出：3 (20+10+5+1)
```

### 活动选择问题

在竞争活动中选择最大兼容活动子集

```ts
interface Activity {
  start: number
  end: number
}

function selectActivities(activities: Activity[]): Activity[] {
  activities.sort((a, b) => a.end - b.end) // 按结束时间排序

  const selected: Activity[] = [activities[0]]
  let lastEnd = activities[0].end

  for (let i = 1; i < activities.length; i++) {
    if (activities[i].start >= lastEnd) {
      selected.push(activities[i])
      lastEnd = activities[i].end
    }
  }

  return selected
}

// 测试
const activities: Activity[] = [
  { start: 1, end: 4 },
  { start: 3, end: 5 },
  { start: 0, end: 6 },
  { start: 5, end: 7 },
  { start: 8, end: 9 }
]

console.log(selectActivities(activities))
// 输出：[ {start:1, end:4}, {start:5, end:7}, {start:8, end:9} ]
```

## 局限性

* **非全局最优**：如0-1背包问题无法使用贪心
* **证明困难**：需要严格数学证明正确性
* **策略敏感**：排序方式直接影响结果

## 区别

### 与动态规划的区别

贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。

动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

## 相关问题

[**LeetCode** - 贪心算法](https://leetcode.cn/problem-list/greedy/){.read-more}

### 基础（掌握贪心选择策略）

* **455. 分发饼干**（[LeetCode](https://leetcode.cn/problems/assign-cookies/)）
* **860. 柠檬水找零**（[LeetCode](https://leetcode.cn/problems/lemonade-change/)）
* **122. 买卖股票的最佳时机 II**（[LeetCode](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)）

### 进阶（区间处理与路径选择）

* **435. 无重叠区间**（[LeetCode](https://leetcode.cn/problems/non-overlapping-intervals/)）
* **452. 用最少数量的箭引爆气球**（[LeetCode](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)）
* **55. 跳跃游戏**（[LeetCode](https://leetcode.cn/problems/jump-game/)）
* **45. 跳跃游戏 II**（[LeetCode](https://leetcode.cn/problems/jump-game-ii/)）

### 挑战 （多维度贪心策略）

* **135. 分发糖果**（[LeetCode](https://leetcode.cn/problems/candy/)）
* **406. 根据身高重建队列**（[LeetCode](https://leetcode.cn/problems/queue-reconstruction-by-height/)）
* **765. 情侣牵手**（[LeetCode](https://leetcode.cn/problems/couples-holding-hands/)）

---

---
url: /algorithm/heap-sort/index.md
---
# 堆排序
## 概述

\==堆排序（Heap Sort）== 是一种基于 **二叉堆** 数据结构的高效排序算法。

## 核心思想

* **构建最大堆（Max-Heap）**：将无序数组转换为满足堆性质的结构（父节点 ≥ 子节点）。
* **反复提取最大值**：将堆顶（最大值）与末尾元素交换，缩小堆范围，重新调整堆。
* **重复调整**：直到堆大小为1，数组即有序。

## 时间复杂度

堆排序的最优时间复杂度、平均时间复杂度、最坏时间复杂度均为 $O(n\log n)$。

## 空间复杂度

由于可以在输入数组上建立堆，所以这是一个原地算法。

## 稳定性

同选择排序一样，由于其中交换位置的操作，所以是不稳定的排序算法。

## 实现

```ts
function heapSort(arr: number[]): number[] {
  const n = arr.length

  // 构建最大堆（从最后一个非叶子节点开始）
  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
    heapify(arr, n, i)
  }

  // 逐个提取最大值并调整堆
  for (let i = n - 1; i > 0; i--) {
    // 交换堆顶（最大值）与当前末尾元素
    [arr[0], arr[i]] = [arr[i], arr[0]]
    // 调整剩余元素为最大堆
    heapify(arr, i, 0)
  }
  return arr
}

// 堆调整函数（确保以i为根的子树满足最大堆性质）
function heapify(arr: number[], heapSize: number, i: number): void {
  let largest = i // 初始化最大元素为根节点
  const left = 2 * i + 1 // 左子节点索引
  const right = 2 * i + 2 // 右子节点索引

  // 若左子节点大于根，更新最大值索引
  if (left < heapSize && arr[left] > arr[largest]) {
    largest = left
  }

  // 若右子节点大于当前最大值，更新最大值索引
  if (right < heapSize && arr[right] > arr[largest]) {
    largest = right
  }

  // 如果最大值不是根节点，则交换并递归调整
  if (largest !== i) {
    [arr[i], arr[largest]] = [arr[largest], arr[i]]
    heapify(arr, heapSize, largest) // 递归调整受影响子树
  }
}

// 测试示例
const array = [12, 11, 13, 5, 6, 7]
console.log('排序前:', array)
console.log('排序后:', heapSort(array))
```

### 执行示例（`[12, 11, 13, 5, 6, 7]`）

* `构建堆`：

  ```txt
  [13, 11, 12, 5, 6, 7]  // 初始堆
  ```

* **首轮交换**：13（堆顶）与 7（末尾）交换 → `[7, 11, 12, 5, 6, 13]`

  调整堆：`[12, 11, 7, 5, 6]` → 新堆顶 12

* **次轮交换**：12 与 6 交换 → `[6, 11, 7, 5, 12, 13]`

  调整堆：`[11, 6, 7, 5]` → 新堆顶 11

* **持续交换与调整**：直到堆大小为 1，得到有序数组。

---

---
url: /algorithm/insertion-sort/index.md
---
# 插入排序
## 概述

\==插入排序（Insertion sort）== 是一种简单直观的排序算法。

### 核心思想

将数组分为 **已排序区间** 和 **未排序区间** ，每次从未排序区间取出一个元素，
在已排序区间中找到合适的位置插入（类似整理扑克牌）。

## 时间复杂度

插入排序的最优时间复杂度为 $O(n)$，在数列几乎有序时效率很高。

插入排序的最坏时间复杂度和平均时间复杂度都为 $O(n^2)$。

## 空间复杂度

原地排序, $O(1)$ ，不需要额外空间。

## 稳定性

插入排序是一种稳定的排序算法

## 伪代码

$$
\begin{array}{ll}
1 & \textbf{Input. } \text{An array } A \text{ consisting of }n\text{ elements.} \\
2 & \textbf{Output. } A\text{ will be sorted in nondecreasing order stably.} \\
3 & \textbf{Method. }  \\
4 & \textbf{for } i\gets 2\textbf{ to }n\\
5 & \qquad key\gets A\[i]\\
6 & \qquad j\gets i-1\\
7 & \qquad\textbf{while }j>0\textbf{ and }A\[j]>key\\
8 & \qquad\qquad A\[j + 1]\gets A\[j]\\
9 & \qquad\qquad j\gets j - 1\\
10 & \qquad A\[j + 1]\gets key
\end{array}
$$

## 实现

```ts
function insertionSort(arr: number[]): number[] {
  // 遍历未排序区间（从第二个元素开始）
  for (let i = 1; i < arr.length; i++) {
    const current = arr[i] // 当前待插入元素
    let j = i - 1 // 从已排序区末尾开始比较

    // 在已排序区间中寻找插入位置
    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j] // 元素后移
      j--
    }

    arr[j + 1] = current // 插入到正确位置
  }
  return arr
}

// 测试示例
const testArr = [5, 2, 4, 6, 1, 3]
console.log(insertionSort([...testArr])) // 输出: [1, 2, 3, 4, 5, 6]
```

### 执行过程示例 (`[5, 2, 4, 6, 1, 3]`)

* 初始状态

  ```txt
  已排序区 [5] | 未排序区 [2, 4, 6, 1, 3]
  ```

* 第一轮（插入 $2$ ）：

  * 比较 $5 > 2$ → $5$ 后移
  * 插入 $2$ 到首位 → `[2, 5] | [4, 6, 1, 3]`

* 第二轮（插入 $4$ ）：

  * $5 > 4$ → $5$ 后移
  * $2 < 4$ → 插入到 $5$ 前 → `[2, 4, 5] | [6, 1, 3]`

* 第三轮（插入 $6$ ）：

  * $5 < 6$ → 直接插入末尾 → `[2, 4, 5, 6] | [1, 3]`

* 第四轮（插入 $1$ ）：

  * 依次与 $6/5/4/2$ 比较 → 全部后移
  * 插入到首位 → `[1, 2, 4, 5, 6] | [3]`

* 第五轮（插入 $3$ ）：

  * $6/5/4 > 3$ → 后移，$2 < 3$ → 插入 $4$ 前
  * 最终结果：`[1, 2, 3, 4, 5, 6]`

## 优化

二分查找优化

```ts
// 二分查找优化（查找插入位置）
function insertionSortOptimized(arr: number[]) {
  for (let i = 1; i < arr.length; i++) {
    const current = arr[i]
    const pos = binarySearch(arr, 0, i - 1, current)

    // 整体后移元素
    for (let j = i - 1; j >= pos; j--) {
      arr[j + 1] = arr[j]
    }
    arr[pos] = current
  }
  return arr
}
```

二分插入排序：将比较操作优化至 $O(log n)$，但移动操作仍为 $O(n²)$

---

---
url: /algorithm/intro/index.md
---
# 概述
::: info 这篇笔记将介绍数据结构与算法的基础知识,包括数据结构的概念、算法的概念,以及常见的数据结构和算法的实现。
:::

## 数据结构

数据结构是在计算机中存储、组织数据的方式。小到变量、数组，大到线段树、平衡树，都是数据结构。

程序运行离不开数据结构，不同的数据结构又各有优劣，能够处理的问题各不相同，而根据具体问题选取合适的数据结构，
可以大大提升程序的效率。

## 算法

算法，顾名思义，即计算的方法。

算法通常用于解决特定的计算任务，但与可以直接在计算机上运行的程序不同，
算法使用数学化的描述，更加侧重于思想，可以被看作抽象的程序。

## 为什么学习数据结构和算法？

数据结构和算法是计算机科学中的基础，学习这些知识可以帮助我们理解计算机科学的基本原理，更好地解决实际问题。

> 设计出数据结构， 在施加以算法就行了。

---

---
url: /algorithm/merge-sort/index.md
---
# 归并排序
## 概述

\==归并排序（merge sort）== 是高效的基于比较的稳定排序算法

### 核心思想

**将数组递归拆分为最小单元，再逐步合并有序子序列。**

## 基本原理

### 分解（Divide）

将长度为 n 的数组递归地拆分为两个长度为 n/2 的子数组，直到子数组长度为 1（天然有序）。

### 合并（Merge）

归并排序最核心的部分是合并（merge）过程：将两个有序的数组 `a[i]` 和 `b[j]` 合并为一个有序数组 `c[k]`。

从左往右枚举 `a[i]` 和 `b[j]`，找出最小的值并放入数组 `c[k]`；重复上述过程直到 `a[i]` 和 `b[j]` 有一个为空时，将另一个数组剩下的元素放入 `c[k]`。

为保证排序的稳定性，前段首元素小于或等于后段首元素时（`a[i] <= b[j]`）而非小于时（`a[i] < b[j]`）就要作为最小值放入 `c[k]`。

## 时间复杂度

归并排序基于分治思想将数组分段排序后合并，时间复杂度在最优、最坏与平均情况下均为 $O(n \log n)$，空间复杂度为 $O(n)$。

## 空间复杂度

归并排序可以只使用 $O(1)$ 的辅助空间，但为便捷通常使用与原数组等长的辅助数组 $O(n)$。

## 稳定性

归并排序是 稳定的。（合并时左子数组元素优先保证相等元素的原始顺序）

## 实现

```ts
/**
 * 合并两个有序数组
 * @param left 左有序数组
 * @param right 右有序数组
 * @returns 合并后的有序数组
 */
function merge(left: number[], right: number[]): number[] {
  const result: number[] = []
  let leftIndex = 0
  let rightIndex = 0

  // 双指针遍历比较元素
  while (leftIndex < left.length && rightIndex < right.length) {
    if (left[leftIndex] < right[rightIndex]) {
      result.push(left[leftIndex])
      leftIndex++
    }
    else {
      result.push(right[rightIndex])
      rightIndex++
    }
  }

  // 处理剩余元素（左或右数组有剩余）
  return result.concat(left.slice(leftIndex), right.slice(rightIndex))
}

/**
 * 归并排序主函数
 * @param arr 待排序数组
 * @returns 排序后的数组
 */
function mergeSort(arr: number[]): number[] {
  // 递归终止条件：数组长度为1时天然有序
  if (arr.length <= 1)
    return arr

  // 分解数组
  const mid = Math.floor(arr.length / 2)
  const left = arr.slice(0, mid) // 左子数组
  const right = arr.slice(mid) // 右子数组

  // 递归分解 + 合并有序子数组
  return merge(mergeSort(left), mergeSort(right))
}

// 测试示例
const array = [38, 27, 43, 3, 9, 82, 10]
console.log('排序前:', array)
console.log('排序后:', mergeSort(array))
// 输出: [3, 9, 10, 27, 38, 43, 82]
```

### 执行过程示例（`[38, 27, 43, 3]`）

```txt
分解过程：
  [38, 27, 43, 3]
    → [38, 27] 和 [43, 3]
      → [38] [27] | [43] [3]

合并过程：
  merge([38], [27]) → [27, 38]
  merge([43], [3])  → [3, 43]
  merge([27, 38], [3, 43]) → [3, 27, 38, 43]
```

## 优化

### 小数组切换插入排序

当子数组长度较小时（如 `< 15`），插入排序的常数因子更优：

```ts
if (arr.length <= 15)
  return insertionSort(arr)
```

### 避免重复分配内存

预分配一个全局临时数组，减少递归中多次创建数组的开销。

### 有序性检测优化

若 `left` 的最大值 `<= right` 的最小值，可直接拼接数组：

```ts
if (left[left.length - 1] <= right[0]) {
  return left.concat(right)
}
```

---

---
url: /algorithm/overview/index.md
---
# 介绍
## 概述

\==算法== ，顾名思义，即计算的方法。

算法通常用于解决特定的计算任务，但与可以直接在计算机上运行的程序不同，算法使用数学化的描述，更加侧重于思想，可以被看作抽象的程序。
同一个算法可以有许多种不同的实现方式，两个不同的程序里也可能使用了同一种算法。

## 复杂度

\==时间复杂度== 和 ==空间复杂度== 是衡量一个算法效率的重要标准。

### 基本操作数

同一个算法在不同的计算机上运行的速度会有一定的差别，并且实际运行速度难以在理论上进行计算，
实际去测量又比较麻烦，所以我们通常考虑的不是算法运行的实际用时，而是算法运行所需要进行的基本操作的数量。

::: note 在普通的计算机上，加减乘除、访问变量（基本数据类型的变量，下同）、给变量赋值等都可以看作基本操作。
:::

对基本操作的计数或是估测可以作为评判算法用时的指标。

### 时间复杂度

衡量一个算法的快慢，一定要考虑数据规模的大小。
所谓数据规模，一般指输入的数字个数、输入中给出的图的点数与边数等等。一般来说，数据规模越大，算法的用时就越长。

我们衡量一个算法的效率时，最重要的不是看它在某个数据规模下的用时，
而是 ==看它的用时随数据规模而增长的趋势==，即 **时间复杂度**。

当然，算法的运行用时并非完全由输入规模决定，而是也与输入的内容相关。所以，时间复杂度又分为几种，例如：

* **最坏时间复杂度**，即每个输入规模下用时最长的输入对应的时间复杂度。在算法竞赛中，由于输入可以在给定的数据范围内任意给定，我们为保证算法能够通过某个数据范围内的任何数据，一般考虑最坏时间复杂度。
* **平均（期望）时间复杂度**，即每个输入规模下所有可能输入对应用时的平均值的复杂度（随机输入下期望用时的复杂度）。

### 空间复杂度

类似地，算法 ==所使用的空间随输入规模变化的趋势== 可以用 **空间复杂度** 来衡量。

---

---
url: /algorithm/quick-sort/index.md
---
# 快速排序
## 概述

\==快速排序（Quick sort）==，又称为 分区交换排序（partition-exchange sort），简称 **快排**，是一种被广泛运用的排序算法。

### 核心思想是

**选择一个基准值，将数组分成两个子数组（小于基准值和大于基准值），然后递归排序子数组。**

## 基本原理

快速排序的工作原理是通过 ==分治== 的方式来将一个数组排序。

快速排序分为三个过程：

* **选择基准值（Pivot）**：从数组中任选一个元素作为基准

* **分区（Partition）**：

  * 将小于基准的元素移到基准左侧
  * 将大于基准的元素移到基准右侧
  * 基准值此时位于最终排序位置

* **递归**：对左右子数组重复上述过程

和 **归并排序**不同，第一步并不是直接分成前后两个序列，而是在分的过程中要保证相对大小关系。
具体来说，第一步要是要把数列分成两个部分，然后保证前一个子数列中的数都小于后一个子数列中的数。
为了保证平均时间复杂度，一般是随机选择一个数 $m$ 来当做两个子数列的分界。

之后，维护一前一后两个指针 $p$ 和 $q$，依次考虑当前的数是否放在了应该放的位置（前还是后）。
如果当前的数没放对，比如说如果后面的指针 $q$ 遇到了一个比 $m$ 小的数，那么可以交换 $p$ 和 $q$ 位置上的数，
再把 $p$ 向后移一位。当前的数的位置全放对后，再移动指针继续处理，直到两个指针相遇。

快速排序没有指定应如何具体实现第一步，不论是选择 $m$ 的过程还是划分的过程，都有不止一种实现方法。

第三步中的序列已经分别有序且第一个序列中的数都小于第二个数，所以直接拼接起来就好了。

## 时间复杂度

快速排序的最优时间复杂度和平均时间复杂度为 $O(n\log n)$，最坏时间复杂度为 $O(n^2)$。

对于最优情况，每一次选择的分界值都是序列的中位数，此时算法时间复杂度满足的递推式为 $T(n) = 2T(\dfrac{n}{2}) + \Theta(n)$，由主定理，$T(n) = \Theta(n\log n)$。

对于最坏情况，每一次选择的分界值都是序列的最值，此时算法时间复杂度满足的递推式为 $T(n) = T(n - 1) + \Theta(n)$，累加可得 $T(n) = \Theta(n^2)$。

对于平均情况，每一次选择的分界值可以看作是等概率随机的。

## 空间复杂度

$O(log n)$（递归栈空间）

## 稳定性

快速排序是一种不稳定的排序算法。

## 实现

```ts
function quickSort(arr: number[]): number[] {
  if (arr.length <= 1)
    return arr // 基线条件：数组为空或只有一个元素时直接返回

  // 选择基准值（此处取中间元素避免最坏情况）
  const pivotIndex = Math.floor(arr.length / 2)
  const pivot = arr[pivotIndex]

  // 创建左右分区
  const left: number[] = []
  const right: number[] = []

  // 分区操作（跳过基准元素）
  for (let i = 0; i < arr.length; i++) {
    if (i === pivotIndex)
      continue // 跳过基准值本身
    arr[i] < pivot ? left.push(arr[i]) : right.push(arr[i])
  }

  // 递归排序并合并结果
  return [...quickSort(left), pivot, ...quickSort(right)]
}

// 测试用例
const testArr = [3, 7, 2, 5, 1, 4, 9, 6]
console.log(quickSort(testArr)) // 输出: [1, 2, 3, 4, 5, 6, 7, 9]
```

## 优化

### 避免最坏情况

* 三数取中法（选首、尾、中的中位数）

  通过 **三数取中（即选取第一个、最后一个以及中间的元素中的中位数）** 的方法来选择两个子序列的分界元素（即比较基准）。这样可以避免极端数据（如升序序列或降序序列）带来的退化；

  ```ts
  // 三数取中法选择基准
  const mid = Math.floor((low + high) / 2)
  if (arr[low] > arr[high])
    [arr[low], arr[high]] = [arr[high], arr[low]]
  if (arr[mid] > arr[high])
    [arr[mid], arr[high]] = [arr[high], arr[mid]]
  if (arr[low] < arr[mid])
    [arr[low], arr[mid]] = [arr[mid], arr[low]]
  return arr[low] // 此时arr[low]是三者的中位数
  ```

---

---
url: /algorithm/recursion/index.md
---
# 递归
## 概述

\==递归== ，在数学和计算机科学中是指在函数的定义中使用函数自身的方法，
在计算机科学中还额外指一种 **通过重复将问题分解为同类的子问题而解决问题的方法**。

递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。
求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。

## 如何理解递归？

请看下面的例子：

* 点击：递归

* 在 google 中 搜索 **递归** 时，会得到如下结果：

  ![递归](/images/algorithm/recursion-1.png)

* 给一堆数字排序？分成两半，先排左半边再排右半边，最后进行合并。而怎么排左边和右边，重新阅读这句话。

## 递归的要素

* **基线条件（Base Case）**

  递归终止的条件，防止无限递归（栈溢出）。

* **递归条件（Recursive Case）**

  将问题分解为更小的子问题，并调用自身。

* **递归方向（Progress）**

  每次递归必须向基线条件靠近。

## 递归示例

### 阶乘计算

```ts
function factorial(n: number): number {
  // 基线条件：0! = 1, 1! = 1
  if (n <= 1)
    return 1

  // 递归条件：n! = n * (n-1)!
  return n * factorial(n - 1)
}

console.log(factorial(5)) // 120
```

### 斐波那契数列

```ts
function fibonacci(n: number): number {
  // 基线条件
  if (n === 0)
    return 0
  if (n === 1)
    return 1

  // 递归条件：F(n) = F(n-1) + F(n-2)
  return fibonacci(n - 1) + fibonacci(n - 2)
}

console.log(fibonacci(6)) // 8
```

## 递归的优化策略

### 记忆化（Memoization）

缓存计算结果，避免重复递归（适合有重叠子问题的情况）。

```ts
const memo = new Map<number, number>()

function fibonacciMemo(n: number): number {
  if (n <= 1)
    return n

  // 检查缓存
  if (memo.has(n))
    return memo.get(n)!

  // 计算并缓存结果
  const result = fibonacciMemo(n - 1) + fibonacciMemo(n - 2)
  memo.set(n, result)
  return result
}
```

### 尾递归优化（Tail Recursion）

将递归操作置于函数末尾，编译器可优化为迭代（TypeScript 需手动转换）。

```ts
// 阶乘的尾递归实现
function factorialTail(n: number, acc: number = 1): number {
  return n <= 1 ? acc : factorialTail(n - 1, n * acc)
}
```

## 递归的典型应用场景

* **分治算法**

  如归并排序、快速排序。

* **树/图遍历**

  如深度优先搜索（DFS）。

* **回溯算法**

  如八皇后问题、迷宫求解。

* **动态规划**

  通常基于递归定义状态转移方程。

## 递归的优缺点

| 优点                       | 缺点                     |
| -------------------------- | ------------------------ |
| 代码简洁直观，贴近数学定义 | 栈溢出风险（深度过大）   |
| 简化复杂问题的实现         | 重复计算（需记忆化优化） |
| 天然适合处理嵌套结构       | 函数调用开销比循环大     |

## 写递归的要点

* **明确基线条件**：确保递归最终会终止。
* **信任递归**：假设子问题已解决，聚焦当前逻辑。
* **缩小问题规模**：每次递归必须更接近基线条件。
* **避免重复计算**：对重叠子问题使用记忆化。

:::important 明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节，否则就会陷入无穷的细节无法自拔。
:::

## 递归与分治的区别

递归是一种编程技巧，一种解决问题的思维方式；分治算法很大程度上是基于递归的，解决更具体问题的算法思想。

## 相关问题

[**LeetCode - 递归**](https://leetcode.cn/tag/recursion/){.read-more}

### 基础递归问题

* **509. 斐波那契数**（[LeetCode](https://leetcode.cn/problems/fibonacci-number/)）
* **70. 爬楼梯**（[LeetCode](https://leetcode.cn/problems/climbing-stairs/)）
* **50. Pow(x, n)**（[LeetCode](https://leetcode.cn/problems/powx-n/)）

### 链表与树结构递归

* **206. 反转链表**（[LeetCode](https://leetcode.cn/problems/reverse-linked-list/)）
* **112. 路径总和**（[LeetCode](https://leetcode.cn/problems/path-sum/)）
* **236. 二叉树的最近公共祖先**（[LeetCode](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)）
* **230. 二叉搜索树中第K小的元素**（[LeetCode](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)）

### 分治与回溯问题

* **169. 多数元素**（[LeetCode](https://leetcode.cn/problems/majority-element/)）
* **22. 括号生成**（[LeetCode](https://leetcode.cn/problems/generate-parentheses/)）
* **46. 全排列**（[LeetCode](https://leetcode.cn/problems/permutations/)）

---

---
url: /algorithm/selection-sort/index.md
---
# 选择排序
## 概述

\==选择排序（Selection sort）== 是一种简单直观的排序算法。

### 核心思想

**每次从未排序部分中选择最小（或最大）元素，将其与未排序部分的起始位置交换。** 重复此过程直到所有元素有序。

## 算法步骤

1. 将数组分为 已排序区（左侧）和 未排序区（右侧）
2. 初始状态：已排序区为空，未排序区为整个数组
3. 遍历未排序区，找到最小元素的索引
4. 将最小元素与未排序区的第一个元素交换
5. 将已排序区向右扩展一位
6. 重复步骤 3-5 直到未排序区为空

## 时间复杂度

选择排序的最优时间复杂度、平均时间复杂度和最坏时间复杂度均为 $O(n^2)$。

## 空间复杂度

$O(1)$（原地排序，不需要额外空间）

## 稳定性

**不稳定排序**（交换操作可能改变相等元素的原始顺序）

## 伪代码

$$
\begin{array}{ll}
1 & \textbf{Input. } \text{An array } A \text{ consisting of }n\text{ elements.} \\
2 & \textbf{Output. } A\text{ will be sorted in nondecreasing order.} \\
3 & \textbf{Method. }  \\
4 & \textbf{for } i\gets 1\textbf{ to }n-1\\
5 & \qquad ith\gets i\\
6 & \qquad \textbf{for }j\gets i+1\textbf{ to }n\\
7 & \qquad\qquad\textbf{if }A\[j]\<A\[ith]\\
8 & \qquad\qquad\qquad ith\gets j\\
9 & \qquad \text{swap }A\[i]\text{ and }A\[ith]\\
\end{array}
$$

## 实现

```ts
function selectionSort(arr: number[]): number[] {
  const len = arr.length

  for (let i = 0; i < len - 1; i++) {
    // 1. 在未排序区寻找最小值索引
    let minIndex = i
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j // 更新最小元素索引
      }
    }

    // 2. 将最小值交换到未排序区起始位置
    if (minIndex !== i) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]] // ES6解构赋值交换
    }
    // 此时 arr[0...i] 成为新的已排序区
  }
  return arr
}

// 测试示例
const testArray = [64, 25, 12, 22, 11]
console.log('排序前:', testArray)
console.log('排序后:', selectionSort(testArray))
```

### 执行过程示例（数组 \[64, 25, 12, 22, 11]）

| 轮次 | 已排序区          | 未排序区          | 最小值 | 交换后数组        |
| ---- | ----------------- | ----------------- | ------ | ----------------- |
| 初始 | \[]                | \[64,25,12,22,11] | -      | \[64,25,12,22,11] |
| 1    | \[11]             | \[25,12,22,64]    | 11     | \[11,25,12,22,64] |
| 2    | \[11,12]          | \[25,22,64]       | 12     | \[11,12,25,22,64] |
| 3    | \[11,12,22]       | \[25,64]          | 22     | \[11,12,22,25,64] |
| 4    | \[11,12,22,25]    | \[64]             | 25     | \[11,12,22,25,64] |
| 结果 | \[11,12,22,25,64] | \[]                | -      | 排序完成          |

## 优点

* **简单易实现**：逻辑清晰，代码量少
* **数据移动最少**：每轮只交换一次元素（ $O(n)$ 次交换）
* **适用场景**：小规模数据或内存受限环境
* **不足**：时间复杂度较高，不适合大规模数据

## 优化

### 双向选择排序

同时寻找最小值和最大值，减少迭代轮次

```ts
function bidirectionalSelectionSort(arr: number[]): number[] {
  let left = 0
  let right = arr.length - 1
  while (left < right) {
    let min = left
    let max = right
    for (let i = left; i <= right; i++) {
      if (arr[i] < arr[min])
        min = i
      if (arr[i] > arr[max])
        max = i
    }
    [arr[left], arr[min]] = [arr[min], arr[left]]
    // 修正最大值被交换的情况
    if (max === left)
      max = min;
    [arr[right], arr[max]] = [arr[max], arr[right]]
    left++
    right--
  }
  return arr
}
```

### 加入有序检查

提前终止已排序数组的遍历

---

---
url: /algorithm/shell-sort/index.md
---
# 希尔排序
## 概述

\==希尔排序（Shell sort）==，也称为缩小增量排序法，是 [插入排序](./3.插入排序.md) 的一种改进版本。
希尔排序以它的发明者 希尔（Donald Shell）命名。

### 核心思想

**让距离较远的元素先部分有序，减少后续插入排序的工作量。**

### 核心概念

* **增量序列 (Gap Sequence)**

  决定如何划分子序列。初始间隔较大，逐步缩小至 1（最后一次为标准的插入排序）。

  **常用序列**：希尔原始序列（N/2, N/4, ..., 1）、Hibbard 序列等。

* **子序列排序**

  对每个增量间隔形成的子序列独立进行插入排序。

* **逐步细化**

  随着增量减小，序列越来越有序，插入排序的效率显著提高。

## 过程

排序对不相邻的记录进行比较和移动：

1. 将待排序序列分为若干子序列（每个子序列的元素在原始数组中间距相同）；
2. 对这些子序列进行插入排序；
3. 减小每个子序列中元素之间的间距，重复上述过程直至间距减少为 $1$。

## 时间复杂度

取决于增量序列：

* 平均：$O(n log n)$ ~ $O(n²)$
* 最佳：$O(n log n)$

## 空间复杂度

希尔排序的空间复杂度为 $O(1)$。

## 稳定性

希尔排序是一种不稳定的排序算法。

## 实现

### 基础实现（使用希尔原始序列）

```ts
function shellSort(arr: number[]): number[] {
  const n = arr.length
  // 初始增量 gap = n/2，逐步减半直至 1
  for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {
    // 从 gap 开始，对每个子序列执行插入排序
    for (let i = gap; i < n; i++) {
      const temp = arr[i] // 当前待插入元素
      let j = i
      // 在子序列中向前比较并移位
      while (j >= gap && arr[j - gap] > temp) {
        arr[j] = arr[j - gap] // 较大元素后移
        j -= gap
      }
      arr[j] = temp // 插入到正确位置
    }
  }
  return arr
}

// 测试
const arr = [64, 34, 25, 12, 22, 11, 90]
console.log('排序前:', arr)
console.log('排序后:', shellSort(arr))
```

### 优化实现（使用 Knuth 增量序列）

```ts
function shellSortOptimized(arr: number[]): number[] {
  const n = arr.length
  // 生成 Knuth 增量序列：1, 4, 13, 40, 121, ...
  let gap = 1
  while (gap < Math.floor(n / 3)) {
    gap = gap * 3 + 1 // 计算最大有效增量
  }

  while (gap > 0) {
    for (let i = gap; i < n; i++) {
      const temp = arr[i]
      let j = i
      while (j >= gap && arr[j - gap] > temp) {
        arr[j] = arr[j - gap]
        j -= gap
      }
      arr[j] = temp
    }
    gap = Math.floor((gap - 1) / 3) // 缩小增量
  }
  return arr
}
```

### 执行示例（`[8, 3, 5, 1, 4, 2]`）

* **初始 Gap = 3**

  * 子序列 1：`[8, 1]` → 排序后 `[1, 8]`
  * 子序列 2：`[3, 4]` → 排序后 `[3, 4]`
  * 子序列 3：`[5, 2]` → 排序后 `[2, 5]`
  * 新数组：`[1, 3, 2, 8, 4, 5]`

* **Gap = 1**（标准插入排序）

  * 逐步插入排序后得到 \[1, 2, 3, 4, 5, 8]

## 优点

比简单插入排序更快（减少元素移动次数），代码简洁，空间效率高。

## 缺点

时间复杂度依赖增量序列，不稳定。

---

---
url: /article/0aqe7kd8/index.md
---
# TypeScript5.4 值得关注的新特性
2024年2月22日，[TypeScript 发布了 5.4 版本的候选版本](https://devblogs.microsoft.com/typescript/announcing-typescript-5-4-rc/)。其中，有两个新特性，非常值得我们关注，它们有效的提高了开发体验。

## 保留上次赋值后的类型收缩

在我们编写 typescript 代码时，通常需要检查变量，找出更具体的类型:

```ts
function foo(x: string | number) {
  if (typeof x === 'string') {
    // typescript 可以推断出当前 `x` 的类型为 `string`
    return x.toUpperCase()
  }
}
```

但是，在这里通常会遇到的一个痛点是，`x` 缩窄后的类型并不总是保留函数的闭包中：

```ts
function getUrls(url: string | URL, names: string[]) {
  if (typeof url === 'string') {
    url = new URL(url)
  }
  return names.map((name) => {
    url.searchParams.set('name', name)
    //      ^^^^^^^^^^^^
    // error:
    //   Property 'searchParams' does not exist on type 'string | URL'.
    //   Property 'searchParams' does not exist on type 'string'.
    return url.toString()
  })
}
```

我们读这段代码时，可以明确知道 `url` 在进入 `names.map()` 回调函数中时是 `URL` 类型。
但是，在 `typescript@5.4` 之前，typescript 会假设 `url` 在进入 回调函数中后，其类型 `URL` 是不安全的，认为它可能
会在其他的地方发生变化。

而在这个例子中，回调函数始终在 `url` 完成赋值后创建，并且它也是最后一次赋值，所以 `url` 的类型总是 `URL`。
`typescript@5.4` 利用这一点，使类型收缩变得更加智能。
在 **非提升函数（non-hoisted functions）** 中使用 **参数** 和 **通过 `let` 声明的变量** 时，`typescript` 检查器会
查找最后一个赋值点，如果能够找到，`typescript` 就可以安全的对该变量做类型收缩。

因此，在 `typescript@5.4` 中，上面的例子将不再报错。

但是请注意，如果变量在嵌套函数中的任何位置赋值，则不会进行缩窄分析。这是因为没有办法确定以后是否会调用该函数。

```ts
function printValueLater(value: string | undefined) {
  if (value === undefined) {
    value = 'missing!'
  }

  setTimeout(() => {
    // 修改 `value`，即使是以不影响其类型的方式，也会使闭包中的类型收缩无效。
    value = 'changed!'
  }, 500)

  setTimeout(() => {
    console.log(value.toUpperCase())
    //                ^^^^^
    // error: 'value' is possibly 'undefined'.
  }, 1000)
}
```

## Utility Type: `NoInfer`

在 进行 泛型函数 调用时，typescript 可以根据传入的内容推断 参数类型：

```ts
function foo<T>(x: T) {}

// 我们可以告诉typescript `x` 的类型是 `number`
foo<number>(1)

// typescript 也可以推断 `x` 的类型是 `string`
foo('bar')
```

然而，typescript 并不总是很清楚要推断的 “最佳” 类型是什么。这可能导致 `typescript` 拒绝有效的调用、
接受有问题的调用，或者只是在捕获错误时报告更糟糕的错误消息。

例如，我们实现一个 `createStreetLight` 函数，它传入 颜色名称列表以及可选的默认颜色。

```ts
function createStreetLight<C extends string>(colors: C[], defaultColor?: C) {
  // ...
}

createStreetLight(['red', 'yellow', 'green'], 'red')
```

当我们传入的 `defaultColor` 不在 `colors` 列表中时，会发生什么？

```ts twoslash
function createStreetLight<C extends string>(colors: C[], defaultColor?: C) {
  // ...
}
// 这不符合预期，但还是通过了检查
createStreetLight(['red', 'yellow', 'green'], 'blue')
// ^?
//
//
//
```

在这个调用中，类型推断会认为 `"blue"` 与 `"red"`、`"yellow"` 和 `"green"` 都是 有效的，
因此，不会拒绝调用，而是推断类型 `C` 为 `"red" | "yellow" | "green" | "blue"`。
但这显然不符合我们的预期！

目前我们通常是添加一个新的类型参数，该参数由现有的类型参数进行约束。

```ts
function createStreetLight<C extends string, D extends C>(colors: C[], defaultColor?: D) {}

createStreetLight(['red', 'yellow', 'green'], 'blue')
//                                            ^^^^^^
// error:
//   Argument of type '"blue"' is not assignable to parameter of
//   type '"red" | "yellow" | "green" | undefined'.
```

这是可行的，但是有点尴尬。因为 签名 `createStreetLight` 可能不会在其他地方使用泛型参数 `D`。
虽然看起来还不错，但是在签名中只使用一次类型参数通常是一种 代码气味。

这就是 在 `TypeScript@5.4` 中引入 `NoInfer<T>` 的原因。
将类型用 `NoInfer<...>` 包围起来，会向 `typescript` 发送信号，
使其不要深入挖掘并匹配内部类型以寻找类型推断的候选对象。

```ts
function createStreetLight<C extends string>(colors: C[], defaultColor?: NoInfer<C>) {
  // ...
}

createStreetLight(['red', 'yellow', 'green'], 'blue')
//                                            ~~~~~~
// error:
//   Argument of type '"blue"' is not assignable to parameter
//   of type '"red" | "yellow" | "green" | undefined'.
```

排除 `defaultColor` 类型进行推理意味着 `"blue"` 永远不会作为推理候选，并且类型检查器可以拒绝它。

---

---
url: /article/0ed6asz0/index.md
---
`Docker` 是一个开源的应用容器引擎，它可以将应用打包到一个可移植的镜像中，
使得应用可以更轻便的部署在任意 Linux 或 Windows 的操作系统的机器上。
同时还提供了环境隔离，很大程度上避免了不同环境不一致带来的各种问题。
`Docker`可轻便移植的特性，也极大的促进了 `CI/CD` 的发展。

**`Docker`架构图**

![architecture](https://docs.docker.com/engine/images/architecture.svg)

从图中可以看出， `Docker` 的组成部分包括：

* `docker client`: `docker` 命令行工具
* `docker host`: 宿主机，即 `docker daemon` 的运行环境服务器
* `docker daemon`: `docker` 的守护进程，`docker client` 通过命令行与 `docker daemon` 进行交互
* `container`: 最小型的一个操作系统环境，可以对各种服务和应用容器化
* `image`: 镜像，可以理解为一个容器的模板配置，通过一个镜像可以启动多个容器
* `registry`: 镜像仓库，存储各种镜像，可以从镜像仓库拉取或推送镜像。

## 安装

> [官方安装文档](https://docs.docker.com/engine/install/)

以下仅说明在 `CentOS` 服务器上的安装过程

### CentOS 安装

1. 安装依赖

```sh
yum install -y yum-utils device-mapper-persistent-data lvm2
```

2. 添加 docker 的yum镜像源，如果在国内，添加阿里云的镜像源

```sh
# 安装 docker 官方的镜像源
yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo

# 如果在国内，安装阿里云的镜像
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
```

3. 安装 docker

```sh
# 安装 docker
sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```

4. 启动服务

```sh
systemctl enable docker

systemctl start docker
```

当 `docker` 安装成功后，可以使用以下命令查看 `docker` 信息

```sh
# 查看版本信息
docker --version

# 查看详细版本信息
docker version

# 查看详细配置信息
docker info
```

### 守护进程配置

`dockerd` 是 `docker` 的守护进程，`dockerd` 可以通过配置文件进行配置，在 `linux` 下的配置文件位置在 `/etc/docker/daemon.json`，更详细内容可以参考 [官方文档](https://docs.docker.com/engine/reference/commandline/dockerd/)。

日志引擎为 `json-file`，对日志结构化，结合合适的日志系统，方便定位日志。 存储引擎为 `overrlay2`。

```sh
mkdir /etc/docker

# 设置 docker daemon
cat > /etc/docker/daemon.json <<EOF
{
  "exec-opts": ["native.cgroupdriver=systemd"],
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "100m"
  },
  "storage-driver": "overlay2",
  "storage-opts": [
    "overlay2.override_kernel_check=true"
  ]
}
EOF

# 重启 docker
systemctl daemon-reload
systemctl restart docker
```

## 镜像

镜像是用于创建容器的配置文件。 容器可以视为是一个最小型的操作系统。

`docker` 的镜像和和容器都使用了 `unionFS` 做分层存储，镜像作为只读层是共享的，容器在镜像之上附加了一层可写层，最大程度的减少了空间的浪费。

![sharing layers](https://docs.docker.com/storage/storagedriver/images/sharing-layers.jpg)

::: info Union file systems
`UnionFS` 是一种分层、轻量级并且高性能的文件系统，支持对文件系统的修改作为一次提交来一层层的叠加。`docker` 的镜像与容器就是分层存储，可用的存储引擎有 `aufs`，`overlay` 等。

关于分层存储的详细内容可以查看官方文档 [docker: About storage drivers](https://docs.docker.com/storage/storagedriver/)
:::

### 镜像仓库与拉取

> [官方镜像仓库](https://hub.docker.com/explore/)

多数情况下，我们不需要自己构建镜像，可以直接从 官方镜像仓库拉取。

使用命令 `docker pull` 进行镜像拉取。 通过 `docker inspect` 查看镜像信息：

```sh
# 加入拉取一个 node:alpine 的镜像
docker pull node:alpine

# 查看镜像信息
docker inspect node:alpine
```

### 构建镜像与发布

使用命令 `docker build` 构建镜像。`docker build` 会使用当前目录的 `dockerfile` 构建镜像。

使用 `-t` 指定标签

```sh
# -t node-base:10: 镜像以及版本号
# .: 指当前路径
docker build -t node-base:10 .
```

当镜像构建成功，使用 `docker push` 推送镜像到仓库。

## Dockerfile

在使用 `docker` 部署自己应用时，往往需要自己构建镜像。

`docker` 使用 `Dockerfile` 作为配置文件构建镜像：

```dockerfile
FROM node:alpine

ADD package.json package-lock.json /code/
WORKDIR /code

RUN npm install --production

ADD . /code

CMD npm start
```

### FROM

基于一个旧有的镜像，格式如下

```dockerfile
FROM <image> [AS <name>]

# 在多阶段构建时会用到
FROM <image>[:<tag>] [AS <name>]
```

### ADD

把目录，或者 url 地址文件加入到镜像的文件系统中

```dockerfile
ADD [--chown=<user>:<group>] <src>... <dest>
```

### RUN

执行命令，由于 ufs 的文件系统，它会在当前镜像的顶层新增一层

```dockerfile
RUN <command>
```

### CMD

指定容器如何启动

一个 `Dockerfile` 中只允许有一个 `CMD`

```dockerfile
# exec form, this is the preferred form
CMD ["executable","param1","param2"]

# as default parameters to ENTRYPOINT
CMD ["param1","param2"]

# shell form
CMD command param1 param2
```

## 容器

镜像与容器的关系，类似于代码与进程的关系。

* `docker run` 创建容器
* `docker stop` 停止容器
* `docker rm` 删除容器

### 创建容器

基于 `nginx` 镜像创建一个最简单的容器：启动一个最简单的 http 服务

使用 `docker run` 来启动容器，`docker ps` 查看容器启动状态

```sh
docker run -d --name nginx -p 8888:80 nginx:alpine

docker ps -l
CONTAINER ID        IMAGE                COMMAND                  CREATED             STATUS              PORTS                    NAMES
404e88f0d90c        nginx:alpine         "nginx -g 'daemon of…"   4 minutes ago       Up 4 minutes        0.0.0.0:8888->80/tcp     nginx
CONTAINER ID        IMAGE                COMMAND                  CREATED             STATUS              PORTS                    NAMES
```

其中:

* `-d`: 启动一个 daemon 进程
* `--name`: 为容器指定名称
* `-p host-port:container-port`: 宿主机与容器端口映射，方便容器对外提供服务
* `nginx:alpine`: 基于该镜像创建容器

此时在宿主机使用 curl 测试容器提供的服务是否正常

```sh
curl localhost:8888
```

进入容器环境中，使用 `docker exec -it container-name` 命令

```sh
docker exec -it nginx sh
/ #
/ #
/ #
```

### 容器管理

* `docker ps` 列出所有容器

```sh
docker ps

CONTAINER ID        IMAGE                COMMAND                  CREATED             STATUS              PORTS                    NAMES
404e88f0d90c        nginx:alpine         "nginx -g 'daemon of…"   4 minutes ago       Up 4 minutes        0.0.0.0:8888->80/tcp     nginx
498e7d74fb4f        nginx:alpine         "nginx -g 'daemon of…"   7 minutes ago       Up 7 minutes        80/tcp                   lucid_mirzakhani
2ce10556dc8f        redis:4.0.6-alpine   "docker-entrypoint.s…"   2 months ago        Up 2 months         0.0.0.0:6379->6379/tcp   apolloserverstarter_redis_1
```

* `docker port` 查看容器端口映射

```sh
docker port nginx

80/tcp -> 0.0.0.0:8888
```

* `docker stats` 查看容器资源占用

```sh
docker stats nginx
CONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS
404e88f0d90c        nginx               0.00%               1.395MiB / 1.796GiB   0.08%               632B / 1.27kB       0B / 0B             2
```

---

---
url: /article/0m2gcz1j/index.md
---
在现代前端开发中，高效的调试能力是区分初级与高级开发者的关键指标。本文将从基础调试技巧到高级工具链，全面解析JavaScript调试的现代化解决方案。

## 一、调试基础：从console.log到专业调试

### 1.1 调试的重要性与演进

在JavaScript开发中，调试已从简单的`console.log`输出演变为完整的工具生态系统。掌握专业调试技能可以：

* 快速定位和修复问题
* 深入理解代码执行流程
* 优化应用性能
* 提升开发效率

### 1.2 调试核心概念

```javascript
// 传统调试方式
console.log('变量值:', variable)
console.trace('调用栈追踪')

// 现代调试方式
debugger // 断点调试
```

## 二、浏览器调试：Chrome DevTools深度解析

### 2.1 Chrome DevTools核心功能

:::code-tabs
@tab Sources面板

```javascript
function processUserData(user) {
  debugger // 在此设置断点
  const processed = {
    name: user.name.toUpperCase(),
    age: user.age * 2,
    timestamp: Date.now()
  }
  return processed
}
```

@tab Console交互

```javascript
// 在断点处执行
user.name = '测试用户'
console.log('当前用户:', user)
// 输出：当前用户: {name: "测试用户", age: 25}
```

@tab 监视表达式

```javascript
// 添加监视表达式
user.age > 18 ? '成年' : '未成年'
processed.name.length
Date.now() - startTime
```

:::

### 2.2 高级断点技巧

#### 条件断点设置

```javascript
function validateForm(data) {
  // 右键设置条件断点：data.email.includes('@')
  if (!data.email.includes('@')) {
    throw new Error('邮箱格式错误')
  }

  // 日志断点：console.log(`验证用户: ${data.username}`)
  return data.username.length >= 3
}
```

#### XHR/Fetch断点

在Sources面板的**XHR/fetch Breakpoints**区域：

* 添加URL包含字符串：`/api/users`
* 当匹配请求发生时自动中断

### 2.3 性能与内存分析

:::steps

* **内存快照对比**：拍摄多个时间点的堆快照，识别内存泄漏
* **性能录制**：使用Performance面板录制操作，分析瓶颈
* **网络分析**：监控请求瀑布图，优化加载性能

:::

## 三、VS Code调试：集成开发环境的力量

### 3.1 基础调试配置

创建`.vscode/launch.json`配置文件：

```json title=".vscode/launch.json"
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "启动调试",
      "program": "${workspaceFolder}/src/app.js",
      "skipFiles": [
        "${workspaceFolder}/node_modules/**/*.js",
        "<node_internals>/**/*.js"
      ],
      "env": {
        "NODE_ENV": "development",
        "DEBUG": "app:*"
      }
    },
    {
      "type": "chrome",
      "request": "launch",
      "name": "Chrome调试",
      "url": "http://localhost:3000",
      "webRoot": "${workspaceFolder}/src"
    }
  ]
}
```

### 3.2 智能调试功能

#### 条件断点与命中计数

```javascript
function processBatch(items) {
  for (let i = 0; i < items.length; i++) {
    // 设置命中次数断点：i > 10
    const item = items[i]

    // 表达式条件断点：item.status === 'error'
    if (item.status === 'error') {
      console.error('处理错误项:', item)
    }
  }
}
```

#### 热重载开发体验

```json title="nodemon配置"
{
  "type": "node",
  "request": "launch",
  "name": "Nodemon热重载",
  "runtimeExecutable": "nodemon",
  "program": "${workspaceFolder}/src/app.js",
  "restart": true,
  "console": "integratedTerminal"
}
```

## 四、Node.js调试：服务端调试全方案

### 4.1 调试启动方式

```bash
# 基础调试模式
node --inspect app.js

# 首行断点模式
node --inspect-brk app.js

# 自定义端口
node --inspect=9229 app.js

# 生产环境安全调试
node --inspect=127.0.0.1:9229 app.js
```

### 4.2 异步代码调试

```javascript title="异步调试示例"
async function fetchUserWithPosts(userId) {
  try {
    const user = await fetchUser(userId)
    debugger // 用户数据获取后中断

    const posts = await fetchUserPosts(userId)
    debugger // 帖子数据获取后中断

    return { user, posts }
  }
  catch (error) {
    // 启用 "Break on uncaught exceptions"
    console.error('获取用户数据失败:', error)
    throw error
  }
}

// 启用异步调用栈追踪
// 在DevTools设置中勾选 Async Stack Traces
```

### 4.3 内存泄漏检测

:::warning
内存泄漏是Node.js应用的常见问题，需要系统化检测和修复。
:::

```javascript
// 内存泄漏检测示例
const leakedReferences = new Set()

function createLeakyReference(data) {
  const reference = { data, timestamp: Date.now() }
  leakedReferences.add(reference) // 潜在的泄漏点
  return reference
}

// 在Memory面板拍摄堆快照，搜索leakedReferences
```

## 五、高级调试工具链

### 5.1 debug模块：智能日志控制

```javascript title="分级日志系统"
const debug = require('debug')

// 定义不同级别的日志
const appLog = debug('app:info')
const dbLog = debug('app:database')
const errorLog = debug('app:error')
const perfLog = debug('app:performance')

function handleRequest(req, res) {
  appLog('处理请求: %s %s', req.method, req.url)

  const startTime = Date.now()
  // 业务逻辑处理
  perfLog('请求处理耗时: %dms', Date.now() - startTime)
}

// 环境变量控制
// DEBUG=app:* node app.js          # 启用所有日志
// DEBUG=app:database node app.js   # 仅启用数据库日志
// DEBUG=app:*,-app:performance     # 排除性能日志
```

### 5.2 Source Map：源码映射调试

:::info
Source Map解决了压缩代码的调试难题，是现代前端构建流程的必备技术。
:::

```javascript title="webpack.config.js"
module.exports = {
  devtool: 'source-map', // 生成完整的Source Map
  // 其他配置选项：
  // - 'eval-source-map': 开发环境推荐
  // - 'cheap-module-source-map': 生产环境调试
  // - 'hidden-source-map': 仅生成但不引用
}
```

### 5.3 性能分析工具

#### Clinic.js性能诊断

```bash
# 安装clinic.js
npm install -g clinic

# 性能分析
clinic doctor -- node app.js
clinic flame -- node app.js
clinic bubbleprof -- node app.js
```

#### 0x火焰图分析

```bash
# 生成火焰图
npx 0x app.js
# 访问生成的HTML报告分析性能瓶颈
```

## 六、调试最佳实践与工作流

### 6.1 系统化调试流程

:::steps

* **问题复现**：创建最小可复现案例
* **假设验证**：基于现象提出可能原因
* **工具选择**：根据问题类型选择合适的调试工具
* **数据收集**：通过断点、日志、性能分析收集数据
* **根本原因分析**：分析收集的数据找到问题根源
* **解决方案验证**：实施修复并验证效果

:::

### 6.2 调试效率技巧

```javascript title="高效调试工具函数"
class DebugHelper {
  static time(label) {
    console.time(label)
    return () => console.timeEnd(label)
  }

  static trace(message = '') {
    console.trace(message)
  }

  static async measureAsync(fn, label) {
    const end = DebugHelper.time(label)
    try {
      return await fn()
    }
    finally {
      end()
    }
  }
}

// 使用示例
const endTimer = DebugHelper.time('数据加载')
// ... 执行代码
endTimer()

await DebugHelper.measureAsync(
  () => fetch('/api/data'),
  'API调用耗时'
)
```

### 6.3 生产环境调试策略

:::caution
生产环境调试需要特别注意安全性和性能影响。
:::

```javascript title="生产环境安全调试"
// 条件调试代码
if (process.env.NODE_ENV === 'development'
  || process.env.ENABLE_DEBUG === 'true') {
  const inspector = require('node:inspector')
  inspector.open(9229, '127.0.0.1')
}

// 通过环境变量控制调试
const debugEnabled = process.env.DEBUG_LEVEL || 'error'
```

## 七、现代化调试生态系统

### 7.1 工具集成方案

:::file-tree

* project/
  * .vscode/
    * launch.json
    * settings.json
  * src/
    * app.js
    * utils/
      * debug.js
  * tests/
    * debug.test.js
  * package.json

:::

### 7.2 调试配置自动化

```json title="package.json调试脚本"
{
  "scripts": {
    "debug": "node --inspect src/app.js",
    "debug:brk": "node --inspect-brk src/app.js",
    "debug:test": "node --inspect test/*.js",
    "debug:chrome": "node --inspect=9229 src/app.js"
  }
}
```

## 总结

掌握现代化JavaScript调试工具链，让开发者从"猜测问题"转变为"精准定位"，从"被动调试"升级为"主动防御"。通过合理运用Chrome DevTools、VS Code调试器、Node.js调试协议以及各种辅助工具，可以显著提升开发效率和代码质量。

### 关键要点回顾

1. **==浏览器调试是基础=={.info}**：熟练掌握Chrome DevTools的断点、性能分析和内存调试
2. **==IDE集成提升效率=={.success}**：VS Code调试配置实现开发闭环体验
3. **==服务端调试不可忽视=={.warning}**：Node.js调试协议支持完整的服务端调试
4. **==工具链组合使用=={.important}**：根据场景选择合适的调试工具组合
5. **==生产环境安全第一=={.caution}**：生产调试需要平衡安全性和实用性

## 参考

* [Chrome DevTools官方文档](https://developer.chrome.com/docs/devtools/)
* [VS Code调试指南](https://code.visualstudio.com/docs/editor/debugging)
* [Node.js调试指南](https://nodejs.org/en/docs/guides/debugging-getting-started/)

---

---
url: /article/1w4onzn1/index.md
---
# 为你的站点开启HSTS
`HTTP-Strict-Transport-Security` 简称为 `HSTS`，是一个 HTTP 响应头。
用于通知浏览器应该只通过 HTTPS 访问该站点，并且以后使用 HTTP 访问该站点的所有尝试都应自动转换为 HTTPS。

## 中间人劫持

当用户在未知风险的网络环境中访问 某个网站的时候，如访问 `http://example.com`，在这个未知风险的网络环境中，
可能会被其他人拦截到用户发出的网络请求，然后跳转到一个一模一样的钓鱼网站，或者在请求内容中，注入有危害的代码、广告等，
这种攻击行为，被称为 **中间人劫持**。

当 `example.com` 也支持 `https` 协议进行访问后，如果用户直接通过 `https` 协议访问，那么在一定程度上可以有效防止
`中间人劫持`。

如果用户依然通过 `http` 协议访问，虽然服务器可以重定向到 `https` 请求，然而在这个过程中，中间人依然可以
通过拦截 `http` 请求，然后向服务器发起 `https` 请求获取内容，再注入新的内容 返回给用户。

用户在浏览器地址栏中 输入 `example.com`, 浏览器默认发起的是 `http` 请求，这导致了我们很难要求用户在通过域名访问
网站时，一定要输入 `https://example.com`。

为了限制 `中间人劫持` 这种潜在的攻击手段，一种处理方式就是 强制浏览器使用 `https` 协议访问网站。
为此，我们需要给网站开启 `HSTS`。

## HSTS

`HSTS` 通过声明 `HTTP` 头部字段 `HTTP-Strict-Transport-Security` 来启用和配置策略：

```
Strict-Transport-Security: max-age=<expire-time>
Strict-Transport-Security: max-age=<expire-time>; includeSubDomains
Strict-Transport-Security: max-age=<expire-time>; preload
```

### 指令

#### `max-age=<expire-time>`

设置在浏览器收到这个请求后的`<expire-time>`秒的时间内凡是访问这个域名下的请求都使用 HTTPS 请求。

#### `includeSubDomains` 可选

如果这个可选的参数被指定，那么说明此规则也适用于该网站的所有子域名。

#### `preload` 可选

查看 [预加载 HSTS](https://www.chromium.org/hsts/) 获得详情。不是标准的一部分。

### 浏览器处理

> 当网站已开启 `HSTS`

用户在第一次通过 `https` 协议访问网站时，服务器响应`Strict-Transport-Security` 头，浏览器记录下信息，
在以后重新访问访问网站时，会把访问这个网站的 `http` 请求自动替换为 `https`。

当 `HSTS` 头设置的过期时间到了，后面通过 `HTTP` 的访问恢复到正常模式，不会再自动跳转到 `HTTPS。`

每次浏览器接收到 `Strict-Transport-Security` 头，它都会更新这个网站的过期时间，所以网站可以刷新这些信息，防止过期发生。

Chrome、Firefox 等浏览器里，当尝试访问该域名下的内容时，会产生一个 307 Internal Redirect（内部跳转），自动跳转到 HTTPS 请求。

## 预加载

如果用户首次访问网站时，依然使用的是 `http` 协议，浏览器会忽略`Strict-Transport-Security`，而且中间人依然可以劫持请求内容，删除 `Strict-Transport-Security`。

为了进一步处理这个问题， `Google`、`Firefox` 等浏览器厂商，维护了一个 `HSTS` 预加载服务。

你可以将你已开启了 `HSTS` 的 站点域名，提交到 预加载服务中，浏览器将会永不使用非安全的方式连接到你的域名。

但是，这不是 HSTS 标准的一部分，也不该被当作正式的内容。

[`HSTS`预加载服务](https://hstspreload.org/)

## 示例

当前域名，以及所有子域名，开启 `HSTS`, 过期时间为 一年。

```
Strict-Transport-Security: max-age=31536000; includeSubDomains
```

---

---
url: /article/284xp17b/index.md
---
# tsconfig.json 完全使用指南
`TSConfig` 文件是用于表明其所在的目录是一个 `typescript` 或 `javascript` 项目的根目录。
`TSConfig` 文件可以是 `tsconfig.json` 或 `jsconfig.json`，它们的配置和行为相同。

> [官方文档](https://www.typescriptlang.org/tsconfig)

## 基础

使用 `TSConfig` 是一个很容易的事情，只需要在目录下创建一个 `tsconfig.json` 或 `jsconfig.json` 文件即可：

::: code-tabs
@tab tsconfig.json

```json
{}
```

@tab jsconfig.json

```json
{}
```

:::

`TSConfig` 包含了默认配置。

`TSConfig` 主要包含了以下 `top level` 的配置字段：

```json
{
  "extends": "",
  "compilerOptions": {},
  "files": [],
  "include": [],
  "exclude": [],
  "references": [],
  "watchOptions": {},
  "typeAcquisition": {}
}
```

## `extends`

**Type**： `string`

`extends` 属性用于从另一个 `TSConfig` 文件继承配置。它的值是一个路径， 或者是一个 `Node.js` 风格的路径。
如果是一个相对路径，则相对于配置文件对路径进行解析，如果是一个 `Node.js` 风格的路径，则从 `node_modules`解析获取路径。

`extends` 不会继承 配置文件中的 `files`, `include`, `exclude` 字段，同时，不允许配置文件之间循环引用。

### example

`tsconfig.base.json`

```json
{
  "compilerOptions": {
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
```

`tsconfig.json`

```json
{
  "extends": "./tsconfig.base",
  "files": ["main.ts"]
}
```

`tsconfig.noStrictNullChecks.json`

```json
{
  "extends": "./tsconfig",
  "compilerOptions": {
    "strictNullChecks": false
  }
}
```

## `compilerOptions`

指定 `typescript` 的编译配置。

`compilerOptions` 主要包含以下配置内容：

**Type checking:**

[`allowUnreachableCode`](#allowunreachablecode), [`allowUnusedLabels`](#allowunusedlabels),
[`alwaysStrict`](#alwaysstrict), [`exactOptionalPropertyTypes`](#exactoptionalpropertytypes),
[`noFallthroughCasesInSwitch`](#nofallthroughcasesinswitch), [`noImplicitAny`](#noimplicitany),
[`noImplicitOverride`](#noimplicitoverride), [`noImplicitReturns`](#noimplicitreturns),
[`noImplicitThis`](#noimplicitthis),
[`noPropertyAccessFromIndexSignature`](#nopropertyaccessfromindexsignature),
[`noUncheckedIndexedAccess`](#nouncheckedindexedaccess),[`noUnusedLocals`](#nounusedlocals),
[`noUnusedParameters`](#nounusedparameters), [`strict`](#strict),
[`strictBindCallApply`](#strictbindcallapply), [`strictFunctionTypes`](#strictfunctiontypes),
[`strictNullChecks`](#strictfunctiontypes),
[`strictPropertyInitialization`](#strictpropertyinitialization),
[`useUnknownInCatchVariables`](#useunknownincatchvariables)

**Modules:**

[`allowUmdGlobalAccess`](#allowumdglobalaccess), [`baseUrl`](#baseurl), [`module`](#module),
[`moduleResolution`](#moduleresolution), [`moduleSuffixes`](#modulesuffixes), [`noResolve`](#noresolve),
[`paths`](#paths), [`resolveJsonModule`](#resolvejsonmodule), [`rootDir`](#rootdir),
[`rootDirs`](#rootdirs), [`typeRoots`](#typeroots), [`types`](#types)

**Emit:**

[`declaration`](#declaration), [`declarationDir`](#declarationdir), [`declarationMap`](#declarationmap),
[`downlevelIteration`](#downleveliteration), [`emitBOM`](#emitbom),
[`emitDeclarationOnly`](#emitdeclarationonly), [`importHelpers`](#importhelpers),
[`importsNotUsedAsValues`](#importsnotusedasvalues), [`inlineSourceMap`](#inlinesourcemap),
[`inlineSources`](#inlinesources), [`mapRoot`](#maproot), [`newLine`](#newline), [`noEmit`](#noemit),
[`noEmitHelpers`](#noemithelpers), [`noEmitOnError`](#noemitonerror), [`outDir`](#outdir),
[`outFile`](#outfile), [`preserveConstEnums`](#preserveconstenums),
[`preserveValueImports`](#preservevalueimports), [`removeComments`](#removecomments),
[`sourceMap`](#sourcemap), [`sourceRoot`](#sourceroot), [`stripInternal`](#stripinternal)

**JavaScript Support:**

[`allowJs`](#allowjs), [`checkJs`](#checkjs), [`maxNodeModuleJsDepth`](#maxnodemodulejsdepth)

**Editor Support:**

[`disableSizeLimit`](#disablesizelimit), [`plugins`](#plugins)

**Interop Constraints:**

[`allowSyntheticDefaultImports`](#allowsyntheticdefaultimports), [`esModuleInterop`](#esmoduleinterop),
[`forceConsistentCasingInFileNames`](#forceconsistentcasinginfilenames), [`isolatedModules`](#isolatedmodules), [`preserveSymlinks`](#preservesymlinks)

**Backwards Compatibility:**

[`charset`](#charset), [`keyofStringsOnly`](#keyofstringsonly),
[`noImplicitUseStrict`](#noimplicitusestrict), [`noStrictGenericChecks`](#nostrictgenericchecks),
[`out`](#out), [`suppressExcessPropertyErrors`](#suppressexcesspropertyerrors), [`suppressImplicitAnyIndexErrors`](#suppressimplicitanyindexerrors)

**Language and Environment:**

[`emitDecoratorMetadata`](#emitdecoratormetadata), [`experimentalDecorators`](#experimentaldecorators),
[`jsx`](#jsx), [`jsxFactory`](#jsxfactory), [`jsxFragmentFactory`](#jsxfragmentfactory),
[`jsxImportSource`](#jsximportsource), [`lib`](#lib), [`moduleDetection`](#moduledetection),
[`noLib`](#nolib),[`reactNamespace`](#reactnamespace),[`target`](#target),
[`useDefineForClassFields`](#usedefineforclassfields)

**Compiler Diagnostics:**

[`diagnostics`](#diagnostics), [`explainFiles`](#explainfiles),
[`extendedDiagnostics`](#extendeddiagnostics), [`generateCpuProfile`](#generatecpuprofile),
[`generateCpuProfile`](#generatecpuprofile), [`listFiles`](#listfiles),
[`traceResolution`](#traceresolution)

**Projects:**

[`composite`](#composite), [`disableReferencedProjectLoad`](#disablereferencedprojectload),
[`disableSolutionSearching`](#disablesolutionsearching),
[`disableSourceOfProjectReferenceRedirect`](#disablesourceofprojectreferenceredirect),
[`incremental`](#incremental), [`tsBuildInfoFile`](#tsbuildinfofile)

**Output Formatting:**

[`noErrorTruncation`](#noerrortruncation), [`preserveWatchOutput`](#preservewatchoutput), [`pretty`](#pretty)

**Completeness:**

[`skipDefaultLibCheck`](#skipdefaultlibcheck),[`skipLibCheck`](#skiplibcheck)

**watch options:**

[`assumeChangesOnlyAffectDirectDependencies`](#assumechangesonlyaffectdirectdependencies)

### allowUnreachableCode

是否允许代码中包含不会被执行的代码

* `undefined` default 向编辑器提供建议作为警告
* `true` 允许包含
* `false` 不允许，并给出错误警告

**example** `"allowUnreachableCode": false`

```ts
function fn(n: number) {
  if (n > 5) {
    return true
  }
  else {
    return false
  }
  return true
  // error: Unreachable code detected.
}
```

### allowUnusedLabels

是否允许 未被使用的 `labels`。

* `undefined` default 向编辑器提供建议作为警告
* `true` 允许包含
* `false` 不允许，并给出错误警告

**example:**

```ts
function verifyAge(age: number) {
  // Forgot 'return' statement
  if (age > 18) {
    verified: true
    // error: Unused label.
  }
}
```

### alwaysStrict

确保文件在ECMAScript严格模式下解析，并对每个源文件添加 `use strict`。

### exactOptionalPropertyTypes

如果启用 `exactOptionalPropertyTypes`，`typescript` 将会用更加严格的模式，对 通过 `type` 或者 `interface`
声明的包含 `?` 的可选属性的检查

**example:**

```ts
interface Theme {
  colorThemeOverride?: 'dark' | 'light'
}
```

如果没有启用这个配置，那么 `colorThemeOverride` 的值可以是 `'dark'`, `'light'`, `undefined`。
如果启用了这个配置，则值不能被显式的赋值为 `undefined`。

`"exactOptionalPropertyTypes": true`

```ts
const theme: Theme = {}

theme.colorThemeOverride = 'dark'
theme.colorThemeOverride = 'light'

theme.colorThemeOverride = undefined // error
```

### noFallthroughCasesInSwitch

如果配置为 `true`, 则表示 `switch` 语句中的 任何一个非空的 `case` 分支，都必须包含 `break` 或 `return` 。

### noImplicitAny

在没有类型注释的情况下，`typescript` 在无法推断类型时，会将类型回退到 `any`。这可能会导致一些错误被遗漏。

启用此配置，`typescript` 会在类型回退到 `any` 时报告一个错误。

```ts
function fn(s) {
  // Parameter 's' implicitly has an 'any' type.
  console.log(s.subtr(3))
}
```

### noImplicitOverride

### noImplicitReturns

### noImplicitThis

### noPropertyAccessFromIndexSignature

### noUncheckedIndexedAccess

### noUnusedLocals

### noUnusedParameters

### strict

是否启用 严格模式的类型检查，当开启这个选项时，也会启用所有 `strict` 系列的配置。

### strictBindCallApply

当开启时，`TypeScript` 会检查 `call`、`bind`和`apply`是否使用正确的参数调用底层函数。

### strictFunctionTypes

当开启时，`TypeScript` 会对 函数的参数类型使用更严格的检查。

需要注意的是，该配置只适用于 `function` 语法，而不适用于 `method` 语法。

```ts
function fn(x: string) {
  return x
}
type Fn = (ns: string | number) => string | number

const fn1: Fn = fn // error: Types of parameters 'x' and 'ns' are incompatible.
```

### strictNullChecks

当开启时，`typescript` 会把 `undefined` 和 `null` 作为不同的类型。

### strictPropertyInitialization

当启用时，`typescript` 会检查 在 `class` 中已声明的属性，是否有在 `constructor` 中进行初始化。

### useUnknownInCatchVariables

### allowUmdGlobalAccess

允许 Umd 全局访问。

当 `allowUmdGlobalAccess` 设置为 `true` 时，将允许你在模块文件中以全局变量的形式访问 UMD 的导出。 模块文件是具有或同时导入、导出的文件。当未设置这个选项时，使用 UMD 模块的导出需要首先导入声明。

比如，在一个 Web 项目中， 知道特定的库（如 jQuery 或 Lodash ）在运行时总是可用的，但无法通过导入来使用他们。

### baseUrl

设置解析非绝对路径模块名时的基准目录。

### module

设置程序的模块系统。

可选值包括： `CommonJS`， `UMD`，`AMD`， `System`，`ESNext`， `ES2020`， `ES6/ES2015`，`ES2022`， `Node16`， `NodeNext`， `None`

### moduleResolution

指定模块解析策略。

可选值包括： `node` ，`classic`。

如果未指定值，当 `module` 为 `CommonJS`时，为 `node`，当 `module` 为 `UMD`，`AMD`， `System`，`ESNext`，`ES2015`时，为 `classic` 。

### moduleSuffixes

声明在模块解析时，默认搜索的文件名后缀列表

```json
{
  "compilerOptions": {
    "moduleSuffixes": [".ios", ".native", ""]
  }
}
```

`import * as foo from "./foo";`， `typescript` 将会检索 `./foo.ios.ts`, `./foo.native.ts`, `./foo.ts`。

### noResolve

### paths

路径设置。将模块导入重新映射到相对于 baseUrl 路径的配置。

paths 可以允许你声明 TypeScript 应该如何解析你的 require/import。

```json
{
  "compilerOptions": {
    "baseUrl": ".", // this must be specified if "paths" is specified.
    "paths": {
      "jquery": ["node_modules/jquery/dist/jquery"]
    }
  }
}
```

告诉 TypeScript 文件解析器支持一些自定义的前缀来寻找代码。 这种模式可以避免在你的代码中出现过长的相对路径:

```json
{
  "compilerOptions": {
    "baseUrl": "src",
    "paths": {
      "app/*": ["app/*"],
      "config/*": ["app/_config/*"],
      "environment/*": ["environments/*"],
      "shared/*": ["app/_shared/*"],
      "helpers/*": ["helpers/*"],
      "tests/*": ["tests/*"]
    }
  }
}
```

### resolveJsonModule

允许直接导入 `.json` 模块。并基于json生成静态类型。

### rootDir

根目录。

**默认**: 所有输入的非声明文件中的最长公共路径。若 composite 被指定，则是包含 tsconfig.json 文件的目录。

### rootDirs

根目录。

通过 `rootDirs`，你可以告诉编译器有许多“虚拟”的目录作为一个根目录。
这将会允许编译器在这些“虚拟”目录中解析相对应的模块导入，就像它们被合并到同一目录中一样。

### typeRoots

默认情况下，所有 可见 的 `@types` 包都将包含在你的编译过程中。
在 `node_modules/@types` 中的任何包都被认为是 可见 的。
例如，这意味着包含 `./node_modules/@types/`，`../node_modules/@types/`，`../../node_modules/@types/` 中所有的包。

当 `typeRoots` 被指定，仅有 在 `typeRoots` 下的包会被包含。例如：

```json
{
  "compilerOptions": {
    "typeRoots": ["./typings", "./vendor/types"]
  }
}
```

这个配置文件将包含 `./typings` 和 `./vendor/types` 下的所有包，而不包括 `./node_modules/@types` 下的。其中所有的路径都是相对于 `tsconfig.json`。

### types

默认情况下，所有 可见 的 `@types` 包都将包含在你的编译过程中。
在 `node_modules/@types` 中的任何包都被认为是 可见 的。
例如，这意味着包含 `./node_modules/@types/`，`../node_modules/@types/`，`../../node_modules/@types/` 中所有的包。。

当 types 被指定，则只有列出的包才会被包含在全局范围内。例如：

```json
{
  "compilerOptions": {
    "types": ["node", "jest", "express"]
  }
}
```

这个 `tsconfig.json` 文件将 只会 包含 `./node_modules/@types/node`，`./node_modules/@types/jest`
和 `./node_modules/@types/express`。 其他在 `node_modules/@types/*` 下的包将不会被包含。

此选项不会影响 `@types/*` 如何被包含在你的代码中。

当你设置了这个选项，通过不在 types 数组中包含，它将：

* 不会再你的项目中添加全局声明（例如 node 中的 process 或 Jest 中的 expect）
* 导出不会出现再自动导入的建议中

### declaration

为你工程中的每个 `TypeScript` 或 `JavaScript` 文件生成 `.d.ts`文件。 这些 `.d.ts` 文件是描述模块外部 API 的类型定义文件。 可以通过 `.d.ts` 文件为非类型化的代码提供 `intellisense` 和精确的类型。

### declarationDir

配置 声明文件生成的输出目录。

### declarationMap

### downlevelIteration

`downlevel (降级）` 是 `TypeScript` 的术语，指用于转换到旧版本的 `JavaScript。` 这个选项是为了在旧版 `Javascript` 运行时上更准确的实现现代 `JavaScript` 迭代器的概念。

`ECMAScript 6` 增加了几个新的迭代器原语：`for / of` 循环（`for (el of arr)`），数组展开（`[a, ...b]`），参数展开（`fn(...args)`）和 `Symbol.iterator`。

如果 `Symbol.iterator` 存在的话，`--downlevelIteration` 将允许在 ES5 环境更准确的使用这些迭代原语。

### emitBOM

### emitDeclarationOnly

只生成 `.d.ts` 文件，但不生成 `.js` 文件

### importHelpers

### importsNotUsedAsValues

### inlineSourceMap

是否 内联 `sourceMap`

### inlineSources

### mapRoot

### newLine

指定输出文件时使用的行尾序列: `CRLF` (dos)或 `LF` (unix)。

### noEmit

禁止编译器生成文件，例如 `JavaScript` 代码，`source-map` 或声明。

这为另一个工具提供了空间，例如用 `Babel` 或 `swc` 来处理将 `TypeScript` 转换为可以在 `JavaScript` 环境中运行的文件的过程。

然后你可以使用 `TypeScript` 作为提供编辑器集成的工具，或用来对源码进行类型检查。

### noEmitHelpers

### noEmitOnError

如果报告了任何错误，不允许编译器输出文件，如JavaScript源代码、源映射或声明。
默认为false，这使得在类似监听的环境中使用TypeScript更容易，
在这种环境中，您可能希望在确保所有错误都得到解决之前，再在另一个环境中查看代码更改的结果。

### outDir

如果被指定，`.js` （以及 .d.ts, .js.map 等）将会被生成到这个目录下。
原始源文件的目录将会被保留，如果计算出的根目录不是你想要的，可以查看 [`rootDir`](#rootdir)。

如果没有指定，`.js` 将被生成至于生成它们的 `.ts` 文件相同的目录中。

### outFile

如果被指定，所有 全局 （非模块） 文件将被合并到指定的单个输出文件中。

如果 `module` 为 `system` 或 `amd`，所有模块文件也将在所有全局内容之后被合并到这个文件中。

注：除非 `module` 是 `None``，System` 或 `AMD`， 否则不能使用 `outFile`。 这个选项 不能 用来打包 `CommonJS` 或 `ES6` 模块。

### preserveConstEnums

### preserveValueImports

### removeComments

当转换为 `JavaScript` 时，忽略所有 TypeScript 文件中的注释。默认为 `false`。

### sourceMap

启用生成 `sourcemap files`。 这些文件允许调试器和其他工具在使用实际生成的 `JavaScript` 文件时，
显示原始的 `TypeScript` 代码。 Source map 文件以 `.js.map` （或 `.jsx.map`）文件的形式被生成到相应的 `.js` 文件输出旁。

`.js` 文件将会包含一个 `sourcemap` 注释，以向外部工具表明文件在哪里。

### sourceRoot

### stripInternal

### allowJs

允许 `JavaScript` 文件在你的工程中被引入，而不是仅仅允许 `.ts` 和 `.tsx` 文件。

这个选项是一种可以允许 `.ts` 和 `.tsx` 与现有的 `JavaScript` 文件共存的方式。可以用于逐步将 `TypeScript` 文件逐步添加到 JS 工程中。

### checkJs

与 `allowJs` 配合使用，当 `checkJs` 被启用时，`JavaScript` 文件中会报告错误。也就是相当于在项目中所有 `JavaScript` 文件顶部包含 `// @ts-check`。

### maxNodeModuleJsDepth

### disableSizeLimit

在处理非常大的`JavaScript`项目时，为了避免可能出现的内存膨胀问题，`TypeScript`分配的内存数量有一个上限。
打开此标志将取消限制。

### plugins

可在编辑器内运行的语言服务插件列表。

语言服务插件是一种基于现有 `TypeScript` 文件向用户提供额外信息的方法。它们可以改进 `TypeScript` 和编辑器之间的现有信息，或提供自己的错误信息。

### allowSyntheticDefaultImports

当设置为 true， 并且模块没有显式指定默认导出时，allowSyntheticDefaultImports 可以让你这样写导入：

```ts
import React from 'react'
```

而不是：

```ts
import * as React from 'react'
```

本选项不会影响 `TypeScript` 生成的 `JavaScript`，它仅对类型检查起作用。当你使用 `Babel` 生成额外的默认导出，从而使模块的默认导出更易用时，本选项可以让 `TypeScript` 的行为与 `Babel` 一致。

### esModuleInterop

默认情况下（未设置 `esModuleInterop` 或值为 `false``），TypeScript` 像 ES6 模块一样对待 `CommonJS/AMD/UMD`。这样的行为有两个被证实的缺陷：

* 形如 `import * as moment from "moment"` 这样的命名空间导入等价于 `const moment = require("moment")`

* 形如 `import moment from "moment"` 这样的默认导入等价于 `const moment = require("moment").default`

这种错误的行为导致了这两个问题：

* ES6 模块规范规定，命名空间导入（`import * as x`）只能是一个对象。TypeScript 把它处理成 `= require("x")` 的行为允许把导入当作一个可调用的函数，这样不符合规范。

* 虽然 `TypeScript` 准确实现了 `ES6` 模块规范，但是大多数使用 `CommonJS/AMD/UMD` 模块的库并没有像 `TypeScript` 那样严格遵守。

开启 `esModuleInterop` 选项将会修复 `TypeScript` 转译中的这两个问题。

### forceConsistentCasingInFileNames

### isolatedModules

虽然你可以使用 `TypeScript` 来从 `TypeScript` 中生成 `JavaScript` 代码，
但是使用其他转译器例如 `Babel` 也很常见。 但其他转译器一次只能在一个文件上操作，
这意味着它们不能进行基于完全理解类型系统后的代码转译。
这个限制也同样适用于被一些构建工具使用的 `TypeScript` 的 `ts.transpileModule` 接口。

这些限制可能会导致一些 `TypeScript` 特性的运行时问题，例如 `const enum` 和 `namespace`。 设置 `isolatedModules` `选项后，TypeScript` 将会在当你写的某些代码不能被单文件转译的过程正确处理时警告你。

它不会改变你代码的行为，也不会影响 `TypeScript` 的检查和代码生成过程。

如果设置了 `isolatedModules`，则所有的实现文件必须是 模块 （也就是它有某种形式的 `import/export`）。

### preserveSymlinks

### charset

配置从磁盘读取文本文件时使用的编码。

### keyofStringsOnly

### noImplicitUseStrict

### noStrictGenericChecks

### out

已弃用。

### suppressExcessPropertyErrors

### suppressImplicitAnyIndexErrors

### emitDecoratorMetadata

启用对使用`reflect-metadata`模块的装饰器发射类型元数据的实验性支持。

### experimentalDecorators

### jsx

控制 JSX 在 JavaScript 文件中的输出方式。 这只影响 .tsx 文件的 JS 文件输出。

* `react`: 将 JSX 改为等价的对 `React.createElement` 的调用并生成 .js 文件。
* `react-jsx`: 改为 `__jsx` 调用并生成 .js 文件。
* `react-jsxdev`: 改为 `__jsx` 调用并生成 .js 文件。
* `preserve`: 不对 JSX 进行改变并生成 .jsx 文件。
* `react-native`: 不对 JSX 进行改变并生成 .js 文件。

### jsxFactory

更改使用经典JSX运行时编译JSX Elements时在.js文件中调用的函数。
最常见的变化是使用`h`或`preact.h`而不是默认的`React`。

### jsxFragmentFactory

### jsxImportSource

### lib

`TypeScript` 包括一组默认的内建 JS 接口（例如 Math）的类型定义，以及在浏览器环境中存在的对象的类型定义
（例如 `document`）。 `TypeScript` 还包括与你指定的 `target` 选项相匹配的较新的 JS 特性的 API。
例如如果`target` 为 `ES6` 或更新的环境，那么 Map 的类型定义是可用的。

你可能出于某些原因改变这些：

* 你的程序不运行在浏览器中，因此你不想要 "dom" 类型定义。
* 你的运行时平台提供了某些 JavaScript API 对象（也许通过 polyfill），但还不支持某个 ECMAScript 版本的完整语法。
* 你有一些 （但不是全部）对于更高级别的 ECMAScript 版本的 polyfill 或本地实现。

**高阶库:**

| 名称       | 内容                                                                                                                        |
| ---------- | --------------------------------------------------------------------------------------------------------------------------- |
| ES5        | ES3 和 ES5 的核心功能定义                                                                                                   |
| ES2015     | ES2015 中额外提供的 API (又被称为 ES6) —— array.find， Promise，Proxy，Symbol，Map，Set，Reflect 等。                       |
| ES6        | ES2015 的别名。                                                                                                             |
| ES2016     | ES2016 中额外提供的 API —— array.include 等。                                                                               |
| ES7        | ES2016 的别名。                                                                                                             |
| ES2017     | ES2017 中额外提供的 API —— Object.entries，Object.values，Atomics，SharedArrayBuffer，date.formatToParts，typed arrays 等。 |
| ES2018     | ES2018 中额外提供的 API —— async iterables，promise.finally，Intl.PluralRules，rexexp.groups 等。                           |
| ES2019     | ES2019 中额外提供的 API —— array.flat，array.flatMap，Object.fromEntries，string.trimStart，string.trimEnd 等。             |
| ES2020     | ES2020 中额外提供的 API —— string.matchAll 等。                                                                             |
| ESNext     | ESNext 中额外提供的 API —— 随着 JavaScript 的发展，这些会发生变化。                                                         |
| DOM        | DOM 定义 —— window，document 等。                                                                                           |
| WebWorker  | WebWorker 上下文中存在的 API。                                                                                              |
| ScriptHost | Windows Script Hosting System 的 API。                                                                                      |

**库的各个组件:**

`DOM.Iterable`， `ES2015.Core`， `ES2015.Collection`， `ES2015.Generator`， `ES2015.Iterable`，
`ES2015.Promise`， `ES2015.Proxy`， `ES2015.Reflect`， `ES2015.Symbol`，
`ES2015.Symbol.WellKnown`， `ES2016.Array.Include`， `ES2017.object`，
`ES2017.Intl`， `ES2017.SharedMemory`， `ES2017.String`， `ES2017.TypedArrays`，
`ES2018.Intl`， `ES2018.Promise`， `ES2018.RegExp`， `ES2019.Array`，
`ES2019.Full`， `ES2019.Object`， `ES2019.String`， `ES2019.Symbol`，
`ES2020.Full`， `ES2020.String`， `ES2020.Symbol.wellknown`， `ESNext.AsyncIterable`，
`ESNext.Array`， `ESNext.Intl`， `ESNext.Symbol`

### moduleDetection

模块检查。

* `auto` (default): `typescript` 会不仅检查 `import` 或 `export` 语句，
  还会检查 `package.json` 是否有 `type` 字段，且当 配置文件中 `module` 值是否为 `nodenext` 或 `node16`时，`type` 字段值为 `module`。以及检查。
  当使用 `jsx: react-jsx` 配置时，当前文件是否是 `jsx` 文件。

* `legacy`: 检查文件是否包含 检查 `import` 或 `export` 语句。

* `force` : 确保每个非声明文件都被视为是一个模块。

### noLib

禁用自动包含任何库文件。如果设置了该选项，lib将被忽略。

### reactNamespace

已弃用，改用 [\`jsxFactory](#jsxfactory)

### target

编译目标

现代浏览器支持全部 `ES6` 的功能，所以 `ES6` 是一个不错的选择。 如果你的代码部署在旧的环境中，你可以选择设置一个更低的目标；如果你的代码保证会运行在新的环境中，你可以选择一个更高的目标。

`target` 的配置将会改变哪些 JS 特性会被降级，而哪些会被完整保留 例如，如果 `target` 是 `ES5` 或更低版本，箭头函数 `() => this` 会被转换为等价的 函数 表达式。

改变 `target` 也会改变 `lib` 选项的默认值。 你可以根据需要混搭 `target` 和 `lib` 的配置，你也可以为了方便只设置 `target`。

特殊的 `ESNext` 值代表你的 `TypeScript` 所支持的最高版本。这个配置应当被谨慎使用，因为它在不同的 `TypeScript` 版本之间的含义不同，并且会导致升级更难预测。

可选值： `es3` (default)， `es5`， `es6/es2015`， `es2016`， `es2017`， `es2018`， `es2019`， `es2020`， `es2021`， `es2022`， `esnext`

### useDefineForClassFields

### diagnostics

### explainFiles

### extendedDiagnostics

### generateCpuProfile

### listEmittedFiles

### listFiles

### traceResolution

### composite

`composite` 选项会强制执行某些约束，使得构建工具（包括 在 `--build` 模式下的 `TypeScript` 本身）可以快速确定一个工程是否已经建立。

当此设置开启时：

* 如果没有明确指定 `rootDir`，则默认为包含 `tsconfig.json` 文件的目录。

* 所有实现的文件必须由 `include` 来匹配，或在 `files` 数组中指定。如果违反了这一约束，`tsc` 将告诉你哪些文件没有被指定。

* `declaration` 默认为 `true`。

### disableReferencedProjectLoad

### disableSolutionSearching

### disableSourceOfProjectReferenceRedirect

### incremental

使 TypeScript 将上次编译的工程图信息保存到磁盘上的文件中。这将会在您编译输出的同一文件夹中创建一系列 `.tsbuildinfo` 文件。 它们不会再运行时被您的 `JavaScript` 使用，并且可以被安全的删除。

### tsBuildInfoFile

这个选项可以让您指定一个文件来存储增量编译信息，以作为复合工程的一部分，从而可以更快的构建更大的 `TypeScript` 代码库。

这个选项提供了一种方法，可以配置 `TypeScript` 追踪它存储在磁盘上的文件的位置，用来指示项目的构建状态。—— 默认情况下，它们与你生成的 `JavaScript` 在同一个文件夹中。

### noErrorTruncation

启用时，错误信息不会被截断。

### preserveWatchOutput

是否在控制台保留历史监听信息，而不是清空它们。

### pretty

是否使用 颜色和样式 格式化 输出信息。

### skipDefaultLibCheck

使用 `skipLibCheck` 此配置。

### skipLibCheck

跳过声明文件的类型检查。

这可以在编译期间节省时间，但代价是类型系统的准确性。例如，两个库可以以不一致的方式定义同一类型的两个副本。TypeScript不会对所有`d.ts`文件进行全面检查，而是会对你在应用源代码中特别引用的代码进行类型检查。

### assumeChangesOnlyAffectDirectDependencies

当这个选项被启用时，TypeScript将避免重新检查/重建所有可能真正受影响的文件，只检查/重建已经更改的文件以及直接导入这些文件的文件。

这可以被认为是监视算法的“快速和松散”实现，它可以大幅减少增量重建时间，代价是不得不偶尔运行完整的构建以获得所有编译器错误消息。

## `files`

**Types**： `string[]`

显式的指定需要编译的文件列表。

如果列表中的文件不存在，则会发生错误。

### example

```json
{
  "files": ["main.ts", "core.ts", "shared.ts", "utils.ts"]
}
```

## `include`

**Type**: `string[]`

指定需要编译的文件列表，可以是目录，文件，也可以是模式匹配。
这些文件路径是相对于包含`tsconfig.json`的目录进行解析。

### example

```json
{
  "include": ["src/**/*.ts", "test/**/*.ts"]
}
```

它将会匹配：

```sh
.
├── scripts                ⨯
│   ├── lint.ts            ⨯
│   ├── update_deps.ts     ⨯
│   └── utils.ts           ⨯
├── src                    ✓
│   ├── client             ✓
│   │    ├── index.ts      ✓
│   │    └── utils.ts      ✓
│   ├── server             ✓
│   │    └── index.ts      ✓
├── tests                  ✓
│   ├── app.test.ts        ✓
│   ├── utils.ts           ✓
│   └── tests.d.ts         ✓
├── package.json
├── tsconfig.json
└── yarn.lock
```

### patterns

`include` 和 `exclude` 支持使用 通配符 模式匹配：

* `*` 匹配零个到多个字符（不包含目录分隔符）
* `?` 匹配任意一个字符（不包含目录分隔符）
* `**/` 匹配任意嵌套深度的目录

## `exclude`

**Type**: `string[]`

指定在解析 `include` 包含的文件时，应该跳过的文件列表，可以是目录，文件，也可以是模式匹配。

### example

```json
{
  "exclude": ["src/**/*.spec.ts"]
}
```

**提示**：
`exclude` 仅排除已包含在 `include` 设置中的文件。
但有时候即使`exclude` 已配置了排除某个文件，但在代码中仍然使用`import` 语句引入该文件，或在 `types` 中包含该文件， 或通过 `/// <reference` 引入， `typescript` 仍然会编译它。

`exclude` 并不是一个阻止文件被包含代码组织里的机制，它只是作用于 `include` 查找文件时排除文件。

## `references`

**Type**： `{ path: string }[]`

项目引用是一种将TypeScript项目解构为更小片段的方法。
使用项目引用可以大大提高构建和编辑器交互时间，加强组件之间的逻辑分离，并以新方式改进代码组织。

## `watchOptions`

配置`typescript`编译器 监听 文件和目录 的行为。

当使用 命令行 `--watch` 启用 编译器编译器会使用 `fs.watch` 和 `fs.watchFile` 对 文件和目录进行监听，
但两种方式各有利弊。

`fs.watch` 使用 **file system events** 通知 文件和目录的变更。
但它依赖于操作系统，并且通知并不可靠，在许多操作系统上并不能正常工作。
此外，它还限制了创建监听数量，在一些操作系统上如 `linux`，我们可能会因为包含很多文件的大型项目而很快耗尽它。
但由于它是使用的 **file system events**，它不会消耗过多的 `CPU cycle` 。
在`typescript`编译器中，使用`fs.watch`用于监听允许精度缺失的 **目录** 变更（配置文件的 `include`，
或者模块解析失败的目录）。

但只有 `Windows` 和 `OSX` 支持 递归监听，这意味着在其他系统上需要通过其它方式来支持 递归监听。

`fa.watchFile` 通过 轮询 的方式实现监听，因此需要消耗比较多的 `CPU cycle` 。但是 `fs.watchFile` 是获取 **目录/文件** 状态更新的最可靠的方式。编译器使用 `fs.watchFile` 监听源文件、配置文件和缺失文件引用。

```json
{
  "watchOptions": {
    "watchFile": "",
    "watchDirectory": "",
    "fallbackPolling": "",
    "synchronousWatchDirectory": true,
    "excludeDirectories": [],
    "excludeFiles": []
  }
}
```

### `watchFile`

配置监听单个文件的策略。支持以下可选值：

|                                      | 描述                                                                                                                                                    |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `fixedPollingInterval`               | 每秒钟以固定时间间隔多次检查文件变更                                                                                                                    |
| `priorityPollingInterval`            | 使用 `fs.watchFile` 轮询检查文件变更。但对 源文件、配置文件、和缺失文件使用不同的时间间隔                                                               |
| `dynamicPriorityPolling`             | 使用动态队列的方式轮询检查文件变更。对于频繁变更的文件使用较短的时间间隔检查，对于低频变更的文件使用较长的时间间隔检查                                  |
| `useFsEvents` default | 使用 `fs.watch`(file system events) 监听文件变更（但在某些操作系统上可能不能正常监听变更）, 当超过了系统允许创建的监听数量限制时使用 `fs.watchFile`替代 |
| `useFsEventsOnParentDirectory`       | 使用 `fs.watch`(file system events) 监听文件的父目录的变更，精度较低                                                                                    |

### `watchDirectory`

配置在缺失递归文件监听功能的系统上，监听整个目录的策略。 支持以下可选值：

|                                      | 描述                                                                                                                   |
| ------------------------------------ | ---------------------------------------------------------------------------------------------------------------------- |
| `fixedPollingInterval`               | 每秒钟以固定时间间隔多次检查所有目录变更                                                                               |
| `dynamicPriorityPolling`             | 使用动态队列的方式轮询检查目录变更。对于频繁变更的目录使用较短的时间间隔检查，对于低频变更的目录使用较长的时间间隔检查 |
| `useFsEvents` default | 使用 `fs.watch`(file system events) 监听目录变更（但在某些操作系统上可能不能正常监听变更）                             |

### `fallbackPolling`

在使用文件系统事件时，此选项指定在系统耗尽本机文件监视器和/或不支持本机文件监视器时使用的轮询策略。

|                             | 描述                                                                                                                                                                    |
| --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `fixedPollingInterval`      | 每秒钟以固定时间间隔多次检查文件变更                                                                                                                                    |
| `priorityPollingInterval`   | 使用 `fs.watchFile` 轮询检查文件变更。但对 源文件、配置文件、和缺失文件使用不同的时间间隔                                                                               |
| `dynamicPriorityPolling`    | 使用动态队列的方式轮询检查文件变更。对于频繁变更的文件使用较短的时间间隔检查，对于低频变更的文件使用较长的时间间隔检查                                                  |
| `synchronousWatchDirectory` | 禁用目录的延迟监视。当大量文件更改可能同时发生时(例如，运行npm install导致node\_modules发生更改)，延迟监视是有用的，但在一些不太常见的设置中，你可能想用这个标志禁用它。 |

### `synchronousWatchDirectory`

在不支持本地递归监听的平台上同步调用回调并更新目录监听器的状态。而不是给一个小的超时，以允许在一个文件上可能发生多次编辑。

```json
{
  "watchOptions": {
    "synchronousWatchDirectory": true
  }
}
```

### `excludeDirectories`

**Type**: `string[]`

配置不需要被 监听的 目录。此配置可以减少需要被监听的文件数量。

### `excludeFiles`

**Type**: `string[]`

配置不需要被 监听的 文件。此配置可以减少需要被监听的文件数量。

## `typeAcquisition`

指向项目 类型获取 的行为。

类型获取 只有在 `javascript` 中有重要作用。在 `javascript` 项目中， `typescript` 工具会在后台或者 `node_modules`外部下载模块的类型声明。

而在 `typescript` 项目中，你需要显式的在项目中指定包含的类型。

```json
{
  "typeAcquisition": {
    "enable": true,
    "include": [],
    "exclude": [],
    "disableFilenameBasedTypeAcquisition": true
  }
}
```

### `enable`

指定是否在 `javascript` 项目中是否启用 类型获取。

### `include`

显式的声明需要包含的依赖类型。用于在 `javascript`项目中帮助`typescript`工具理解依赖跟踪，或者 `disableFilenameBasedTypeAcquisition` 设置为`true`时需要手动添加依赖。

#### example

```json
{
  "typeAcquisition": {
    "include": ["lodash"]
  }
}
```

### `exclude`

禁用某些模块的类型获取，这对于在测试基础设施中包含主应用程序不需要的其他库的项目非常有用。

#### example

```json
{
  "typeAcquisition": {
    "exclude": ["jest", "mocha"]
  }
}
```

### `disableFilenameBasedTypeAcquisition`

TypeScript的类型获取可以根据项目中的文件名推断应该添加什么类型。
这意味着在你的项目中有一个像 `JQuery` 这样的文件会自动从 `DefinitelyTyped` 下载`JQuery`的类型。

---

---
url: /article/2cbrh4qw/index.md
---
# JavaScript 进阶 十：内存管理与垃圾回收
在前端开发中，内存管理往往是被忽视的环节，直到应用程序变得缓慢或突然崩溃时才引起关注。随着Web应用程序复杂度的增加，理解JavaScript的内存管理模型已成为构建高性能、可靠应用的关键能力。

## 一、JavaScript内存模型：城市构造的隐喻

JavaScript的内存模型主要分为两个区域：栈内存（Stack）和堆内存（Heap），就像一座现代化城市的不同功能区。

### 栈内存：临时办公区

栈内存是一种结构简单且高效的内存空间，遵循后进先出（LIFO）的原则：

```javascript title="栈内存使用示例"
// 原始类型直接存储在栈内存中
let number = 42 // 直接在栈内存中分配并存储值42
let string = 'Hello' // 直接在栈内存中分配并存储字符串"Hello"
let boolean = true // 直接在栈内存中分配并存储布尔值true

function processOrder(orderId) {
  const tempData = [] // 栈内存中的临时数组引用
  // 函数执行完毕后自动清理
}
```

### 堆内存：核心商务区

堆内存是一个更大且结构复杂的内存区域，用于存储引用类型数据：

```javascript title="堆内存使用示例"
// 引用类型在堆内存中创建，栈中存储引用
let array = [1, 2, 3] // 数组在堆内存中创建
let object = { name: 'JavaScript' } // 对象在堆内存中创建
let function1 = function () {
  console.log('Hello')
} // 函数在堆内存中创建
```

## 二、垃圾回收机制详解

垃圾回收（Garbage Collection，简称GC）是JavaScript引擎自动执行的过程，用于识别并释放不再需要的内存。

### 2.1 标记清除算法（Mark-and-Sweep）

这是现代JavaScript引擎采用的主要垃圾回收算法：

```javascript title="标记清除算法示例"
function processData() {
  let data = loadLargeData() // 在堆内存中分配大量空间

  let result = data.process() // 处理数据

  return result // 只返回处理结果
} // 函数执行完毕后，data不再可从根对象到达，会被回收
```

:::tip 算法工作原理
标记清除算法分为两个阶段：

* **标记阶段**：从根对象开始，递归遍历所有可访问的对象并进行标记
* **清除阶段**：遍历整个堆内存，释放所有未被标记的对象
  :::

### 2.2 分代回收策略

现代JavaScript引擎采用分代回收策略，基于"代际假说"：

```javascript title="分代回收示例"
// 短生命周期对象（在新生代中回收）
function processRequest() {
  let requestData = parseRequest() // 创建临时对象
  let response = generateResponse(requestData)
  return response
} // requestData在函数执行完毕后即可回收

// 长生命周期对象（晋升到老生代）
const cache = new Map() // 全局缓存对象，长期存在
```

:::warning 内存划分

* **新生代**：存储新创建的对象，空间较小但回收频繁
* **老生代**：存储经过多次垃圾回收后仍然存活的对象，空间较大但回收频率低
  :::

## 三、常见内存泄漏场景及解决方案

### 3.1 全局变量滥用

```javascript title="全局变量泄漏示例"
function leakGlobal() {
  variable = 'I am global' // 缺少let/const/var声明，成为全局变量
}

function anotherLeak() {
  this.leakyProperty = Array.from({ length: 1000000 }) // 在非严格模式下创建全局泄漏
}
```

:::important 解决方案

* 使用严格模式（`'use strict';`）
* 始终使用`let`、`const`或`var`声明变量
* 使用ESLint等静态分析工具检测未声明的变量
  :::

### 3.2 被遗忘的定时器和回调

```javascript title="定时器泄漏示例"
function startTimerWithCleanup() {
  let largeData = Array.from({ length: 10000000 }).fill('data')

  // 保存定时器ID以便后续清除
  const timerId = setInterval(() => {
    console.log('Timer running, data length:', largeData.length)
  }, 1000)

  // 返回清理函数
  return function stopTimer() {
    clearInterval(timerId)
    largeData = null // 明确解除引用
  }
}

// 使用示例
const cleanup = startTimerWithCleanup()
// 不再需要时调用 cleanup();
```

### 3.3 闭包导致的泄漏

```javascript title="闭包优化示例"
function avoidLeak() {
  let largeData = Array.from({ length: 10000000 }).fill('data')

  // 只提取需要的数据
  let firstItem = largeData[0]

  // 返回仅捕获所需数据的闭包
  return function optimizedFunction() {
    console.log('First item:', firstItem)
  }

  // largeData在此函数执行完毕后可以被垃圾回收
}
```

### 3.4 DOM引用问题

```javascript title="DOM引用管理"
class DOMReferenceManager {
  constructor() {
    this.elements = new Map()
  }

  registerElement(id, element) {
    this.elements.set(id, element)
  }

  removeElement(id) {
    const element = this.elements.get(id)
    if (element && element.parentNode) {
      element.parentNode.removeChild(element)
    }
    this.elements.delete(id) // 清除引用
  }
}
```

## 四、内存优化高级技术

### 4.1 使用WeakMap和WeakSet

```javascript title="WeakMap应用示例"
const privateData = new WeakMap()

class User {
  constructor(name, age) {
    // 存储私有数据
    privateData.set(this, {
      name,
      age,
      loginHistory: []
    })
  }

  getName() {
    return privateData.get(this).name
  }
}

// 当user对象被回收时，WeakMap中的私有数据自动清理
```

### 4.2 对象池模式

```javascript title="对象池实现"
class ParticlePool {
  constructor(size) {
    this.pool = Array.from({ length: size }).fill().map(() => ({
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
      active: false
    }))
  }

  get() {
    for (let i = 0; i < this.pool.length; i++) {
      if (!this.pool[i].active) {
        this.pool[i].active = true
        return this.pool[i]
      }
    }
    return null
  }

  release(particle) {
    particle.active = false
    // 重置属性
    particle.x = particle.y = particle.vx = particle.vy = 0
  }
}
```

### 4.3 数据虚拟化

```javascript title="虚拟列表实现"
class VirtualList {
  constructor(container, itemHeight, totalItems, renderItem) {
    this.container = container
    this.itemHeight = itemHeight
    this.totalItems = totalItems
    this.renderItem = renderItem
    this.init()
  }

  render() {
    const scrollTop = this.container.scrollTop
    const startIndex = Math.floor(scrollTop / this.itemHeight)
    const visibleItems = Math.ceil(this.container.clientHeight / this.itemHeight) + 2
    const endIndex = Math.min(startIndex + visibleItems, this.totalItems)

    // 只渲染可见项
    this.renderVisibleItems(startIndex, endIndex)
  }
}
```

## 五、内存检测与分析工具

### 5.1 Chrome DevTools内存分析

:::steps

* 打开Performance面板，勾选Memory选项记录内存使用趋势
* 使用Memory面板的堆快照功能比较不同时间点的内存状态
* 通过Allocation Timeline分析内存分配模式

:::

### 5.2 编程式内存监控

```javascript title="内存监控工具"
class MemoryMonitor {
  constructor(interval = 5000) {
    this.interval = interval
    this.history = []
  }

  start() {
    this.timer = setInterval(() => {
      if (window.performance?.memory) {
        const memory = performance.memory
        const data = {
          used: memory.usedJSHeapSize,
          total: memory.totalJSHeapSize,
          limit: memory.jsHeapSizeLimit,
          timestamp: Date.now()
        }
        this.history.push(data)
        this.analyzeTrend()
      }
    }, this.interval)
  }

  analyzeTrend() {
    if (this.history.length > 5) {
      const growthRate = this.calculateGrowthRate()
      if (growthRate > 1048576) { // 1MB/s
        console.warn('Possible memory leak detected!')
      }
    }
  }
}
```

## 六、框架特定的内存管理

### 6.1 React内存优化

```javascript title="React优化示例"
import React, { useCallback, useMemo, useState } from 'react'

function SearchComponent({ onSearch }) {
  const [query, setQuery] = useState('')

  // 使用useCallback防止不必要的函数重新创建
  const handleSearch = useCallback(() => {
    onSearch(query)
  }, [query, onSearch])

  // 使用useMemo缓存计算结果
  const processedData = useMemo(() => {
    return processLargeDataSet(data)
  }, [data])

  return (
    <div>
      <input value={query} onChange={e => setQuery(e.target.value)} />
      <button onClick={handleSearch}>Search</button>
    </div>
  )
}
```

### 6.2 Vue内存优化

```vue title="Vue优化示例"
<script>
export default {
  data() {
    return {
      items: []
    }
  },
  computed: {
    // 使用computed属性缓存计算结果
    processedItems() {
      return this.items.map(item => this.process(item))
    }
  },
  beforeUnmount() {
    // 清理资源
    clearInterval(this.intervalId)
  }
}
</script>

<template>
  <header v-once>
    <h1>{{ appTitle }}</h1>
  </header>

  <main>
    <data-list :items="processedItems" />
  </main>
</template>
```

## 七、未来趋势与新技术

### 7.1 WebAssembly内存控制

```javascript title="WebAssembly内存管理"
async function initWasmProcessor() {
  const result = await WebAssembly.instantiateStreaming(
    fetch('/processor.wasm')
  )

  const wasmModule = result.instance
  const memory = wasmModule.exports.memory

  return {
    process: (data) => {
      // 使用WASM内存进行高效处理
      const bufferPtr = wasmModule.exports.allocateBuffer(data.length)
      const wasmBuffer = new Uint8Array(memory.buffer, bufferPtr, data.length)
      wasmBuffer.set(data)

      wasmModule.exports.processData(bufferPtr, data.length)

      // 手动释放内存
      wasmModule.exports.freeBuffer(bufferPtr)
    }
  }
}
```

## 总结

:::important 关键要点

1. **理解内存模型**：掌握栈内存和堆内存的区别是内存管理的基础
2. **识别泄漏模式**：熟悉常见的泄漏场景并采用相应的预防措施
3. **善用工具**：熟练使用浏览器开发者工具进行内存分析
4. **采用优化模式**：对象池、数据虚拟化等模式可显著提升性能
5. **框架最佳实践**：遵循React、Vue等框架的内存管理指南
   :::

:::tip 黄金法则

* 闭包引用记心上，用后即焚保平安
* 定时任务守纪律，临走要留请假条
* DOM元素易缠身，解绑删除要彻底
* 大对象操作如履冰，池化管理效率高
* 弱引用工具随身带，适时使用解烦恼
  :::

通过深入理解JavaScript的内存管理机制，我们能够编写出更加高效、稳定的应用程序。内存管理不是一劳永逸的工作，而是需要持续关注的领域，只有不断学习和实践，才能在复杂的前端应用中游刃有余。

## 参考

* [MDN Web Docs: JavaScript 内存管理](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Memory_management)
* [V8 开发者博客: 垃圾回收](https://v8.dev/blog/trash-talk)
* [Chrome DevTools 内存分析指南](https://developers.google.com/web/tools/chrome-devtools/memory-problems)

---

---
url: /article/2f45bq9x/index.md
---
# 跨域资源共享(CORS)
**跨域资源共享（CORS）** 是一种基于 **HTTP Header** 的机制。
该机制通过允许服务器标示除了它自己的 origin（域，协议和端口），使这些 origin 有权限访问加载服务器上的资源。

跨域资源共享 通过 **预检请求** 的机制，检查服务器是否允许要发送的真实请求。
浏览器向服务器发送一个到服务器托管的跨域资源 **预检请求**，
在预检请求中，浏览器发送的头部中标示有HTTP方法和真实请求会用到的头。

## 前言

浏览器出于安全性的原因，会限制脚本内发起的跨域资源请求，
比如 **XMLHttpRequest** 和 **Fetch API** 遵循 **同源策略**，默认情况下不允许发起非同源的资源请求。
使用这些API的Web应用，只能加载从应用程序的同一个域的请求HTTP资源，
**除非响应报文中包含了正确的CORS响应头**

## 概述

跨域资源共享 新增了一组 HTTP首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。
同时，对于可能对服务器数据产生副作用的 HTTP 请求方法，浏览器必须首先使用 `OPTIONS` 方法发起一个预检请求，
从而获取服务器是否允许跨域请求，服务器确认允许之后，才发起实际的HTTP请求。

CORS 请求失败会产生错误，但是为了安全，在 JavaScript 代码中，是无法获取具体是哪里出了问题。
我们只能通过查看浏览器的控制台来获取具体出现的错误。

若要开启 CORS ，我们需要配置 CORS 相关的 HTTP首部字段。

## HTTP 响应首部字段

在 CORS 中，HTTP 响应首部字段主要有以下几个：

* **Access-Control-Allow-Origin**
* **Access-Control-Allow-Methods**
* **Access-Control-Allow-Headers**
* **Access-Control-Max-Age**
* **Access-Control-Expose-Headers**
* **Access-Control-Allow-Credentials**

### Access-Control-Allow-Origin

**Access-Control-Allow-Origin** 响应首部字段，用于 **指定允许访问该资源的外域URI**。

对于不需要携带身份凭证的请求，服务器可以指定改字段的值为通配符(`*`)，表示允许来自所有域的请求。

语法：

```
Access-Control-Allow-Origin: <origin>
Access-Control-Allow-Origin: *
```

如果服务器 指定了具体的域名而非 `*`，那么响应首部中的 **Vary** 字段的值必须包含 `Origin`。
用于告诉客户端：服务器对不同的源站返回不同的内容。

::: info 注意
当响应的是附带身份凭证的请求时，服务端 必须 明确 **Access-Control-Allow-Origin** 的值，而不能使用通配符`“*”`。
:::

**示例1：**

允许所有域访问

```
Access-Control-Allow-Origin: *
```

**示例2：**

允许来自 <https://pengzhanbo.cn> 的请求

```
Access-Control-Allow-Origin: https://pengzhanbo.cn
Vary: Origin
```

### Access-Control-Allow-Methods

**Access-Control-Allow-Methods** 响应首部字段用于 预检请求的响应。
**指明了实际请求所允许使用的HTTP方法或方法列表**。

语法：

```
Access-Control-Allow-Methods: <method>[, <method>]*
```

示例：

```
Access-Control-Allow-Methods: POST, GET, OPTIONS
```

### Access-Control-Allow-Headers

**Access-Control-Allow-Headers** 响应首部字段用于 预检请求的响应。
**指明了实际请求中允许携带的首部字段**。

语法：

```
Access-Control-Allow-Headers: <header-name>[, header-name]*
Access-Control-Allow-Headers: *
```

以下特定的首部是一直允许的，无需特意声明他们：

* Accept
* Accept-Language
* Content-Language
* Content-Type，但只在其值属于MIME类型 `application/x-www-form-urlencoded`,`multipart/form-data`,`text/pain` 中的一种。

**示例1：**

自定义请求头。 除了 CORS 安全清单列出的请求头外，支持 自定义请求头 X-Custom-Header

```
Access-Control-Allow-Headers: X-Custom-Header
```

**示例2：**

多个自定义请求头。

```
Access-Control-Allow-Headers: X-Custom-Header, X-My-Header
```

### Access-Control-Max-Age

**Access-Control-Max-Age** 响应首部字段表示 **预检请求的返回结果可以被缓存多久**。

返回结果是指： **Access-Control-Allow-Methods** 和 **Access-Control-Allow-Headers** 提供的信息。

语法：

```
Access-Control-Max-Age: <delta-seconds>
```

**delta-seconds** 表示返回结果可以被缓存的最长时间（秒）。
在 Firefox 中， 上限是 **24小时（86400秒）**。
在 Chromium 中，上限是 **2小时（7200秒）**，同时 Chromium 还规定了默认值是 **5秒**。
如果值为 **-1** ， 表示禁用缓存，则每次请求前都需要使用 OPTIONS 预检请求。

**示例：**

将预检请求缓存 10分钟：

```
Access-Control-Max-Age: 600
```

### Access-Control-Expose-Headers

**Access-Control-Expose-Headers** 响应首部字段，列出了 哪些首部可以作为响应的一部分暴露给外部。

在 跨源访问时，XMLHttpRequest 对象的 `getResponseHeader()` 方法默认只能拿到一些最基本的响应头。

默认情况下，只有七种 简单响应首部 可以暴露给外部:

* Cache-Control
* Content-Language
* Content-Length
* Content-Type
* Expires
* Last-Modified
* Pragma

如果期望让客户端可以访问到其他的首部信息，可以将它们 该字段受列出来。

语法：

```
Access-Control-Expose-Headers: <header-name>[, <header-name>]*
```

**示例：**

暴露一个非简单响应首部：

```
Access-Control-Expose-Headers: X-My-Header
```

暴露多个非简单响应首部：

```
Access-Control-Expose-Headers: X-My-Header, X-Custom-Header
```

### Access-Control-Allow-Credentials

**Access-Control-Allow-Credentials** 响应首部字段 用于在 请求包含 Credentials 时，
告知浏览器是否可以将对请求的响应暴露给前端 JavaScript 代码。

当请求的 Credentials 模式 （Request.credentials）为 `include` 时，浏览器尽在相应头 **Access-Control-Allow-Credentials** 的值为 `true` 时将响应暴露给前端的 JavaScript 代码。

Credentials 可以是 `cookies`、 `authorization headers` 或 `TLS client certificates`。

语法：

```
Access-Control-Allow-Credentials: true
```

**Access-Control-Allow-Credentials** 需要与 `XMLHttpRequest.withCredentials`
或 **Fetch API** 的 `Request()` 构造函数中的 `credentials` 选项结合使用。
Credentials 必须在前后端都被配置，才能使带 credentials 的 CORS 请求成功。

**示例：**

允许 credentials

```
Access-Control-Allow-Credentials: true
```

使用带 credentials 的 XHR:

```js
const xhr = new XMLHttpRequest()
xhr.open('GET', 'https://pengzhanbo.cn', true)
xhr.withCredentials = true
xhr.send(null)
```

使用带 credentials 的 Fetch:

```js
fetch('https://pengzhanbo.cn', {
  credentials: 'include',
})
```

## HTTP 请求首部字段

在 CORS 中，可用于发起跨域请求的首部字段，如下：

* Origin
* Access-Control-Request-Method
* Access-Control-Request-Headers

这些首部字段无需手动设置。

当开发者使用 XMLHttpRequest 发起跨域请求时，它们已经被设置就绪。

### Origin

**Origin** 请求首部字段表明预检请求或实际请求的源站。

语法：

```
Origin: <origin>
```

origin 参数的值为源站的URI。不包含任何路径信息，仅表示服务器名称。

### Access-Control-Request-Method

**Access-Control-Request-Method** 请求首部字段用于预检请求。作用是 将实际情况所使用的HTTP方法告诉服务器。

语法：

```
Access-Control-Request-Method: <method>
```

### Access-Control-Request-Headers

**Access-Control-Request-Headers** 请求首部字段用于预检请求。作用是 将实际请求所携带的首部字段告诉服务器。

语法：

```
Access-Control-Request-Headers: <header-name>[, <header-name>]*
```

## 预检请求

一个 CORS 预检请求时用于 检查服务器使用支持 CORS， 即 跨域资源共享。

预检请求 通过 发送一个 OPTIONS 请求，请求头部包含了以下字段：

* Access-Control-Request-Method
* Access-Control-Request-Headers
* Origin

浏览器会在有必要的时候，自动发出一个预检请求。

所以在正常情况下，前端开发者不需要自己去发送这样的请求。

### 预检请求与凭据

CORS 预检请求不能包含凭据。预检请求的响应必须指定 Access-Control-Allow-Credentials: true 来表明可以携带凭据进行实际的请求。

## 简单请求

某些情况下，不会触发 CORS预检请求，这样的请求，可表述为 *简单请求*。

若请求满足以下所有条件，则可视为 简单请求：

* 使用 GET, HEAD POST 请求方法
* 除了被用户代理自动设置的首部字段（Connection，User-Agent等），
  以及在 Fetch 规范中定义为 [禁用首部名称](https://fetch.spec.whatwg.org/#forbidden-header-name) 的其他首部，
  允许人为设置的字段为 Fetch 规范定义的 对 [CORS 安全的首部字段集合](https://fetch.spec.whatwg.org/#cors-safelisted-request-header)
* 请求中任意的 XMLHttpRequest 对象均没有注册任何监听事件，
  XMLHttpRequest 对象可以使用 XMLHttpRequest.upload 属性访问。
* 请求中没有使用 ReadableStream 对象。

## 附带身份的请求与通配符

在响应附带身份凭证的请求时：

* 服务器不能将 **Access-Control-Allow-Origin** 的值设为通配符 `*`，而应将其设置为特定的域，如：Access-Control-Allow-Origin: <https://pengzhanbo.cn。>

* 服务器不能将 **Access-Control-Allow-Headers** 的值设为通配符 `*`，而应将其设置为首部名称的列表，如：Access-Control-Allow-Headers: X-Custom-Header, Content-Type

* 服务器不能将 **Access-Control-Allow-Methods** 的值设为通配符 `*`，而应将其设置为特定请求方法名称的列表，如：Access-Control-Allow-Methods: POST, GET

## 需要CORS的场景

1. 使用 **XMLHttpRequest** 发起的 HTTP请求
2. 使用 **Fetch API** 发起的 HTTP 请求
3. Web字体，CSS通过 `@font-face` 使用的跨域字体资源
4. WebGL 贴图
5. 使用 drawImage 将 Images/video 画面绘制到 canvas
6. 来自图像的 CSS 图形

## 安全

在实际的使用场景中，尽可能的少使用 通配符 `*`，来允许所有域访问，或允许所有自定义首部字段，
这可能在 web 安全上来带风险。

---

---
url: /article/4ef5e74b/index.md
---
# 一文读懂 CSS 自定义滚动条
有时候，为了保持我们的应用程序 UI 交互体验在不同系统的一致性，需要覆盖默认的滚动条，
通过自定义滚动条的方式，获得更好的用户体验。

:::demo-wrapper img
![scrollbar intro](/images/scrollbar/scrollbar-intro.jpg)
:::

## 滚动条的组成

首先，需要了解 滚动条由哪些部分组成的。

滚动条主要包含两个部分： **滚动轨道 Track** 和 **滑块 Thumb**。

:::demo-wrapper img
![scrollbar parts](/images/scrollbar/scrollbar-parts.jpg)
:::

**Track** 是滚动条的底部， **Thumb** 是提供用户交互的， 当用户拖动它控制页面或容器的滚动内容。

滚动条可以出现在 **水平** 或者 **垂直** 方向，而且在 多语言环境下，也会随着 从左到右 `LTR` 和 从右到左 `RTL`
而变化。

:::demo-wrapper img
![scrollbar places dir](/images/scrollbar/scrollbar-places-dir.jpg)
:::

## 自定义滚动条

在过去，能够进行 自定义滚动条的， 只有 基于 `webkit` 内核的浏览器 得到了支持，而像 `Firefox` 和 `IE`
浏览器则不具备 自定义滚动条 的能力。但是，对于 `Firebox`， CSS 有了新的语法帮助我们完成滚动条的自定义。

我将分别介绍 `webkit` 下的旧的语法，然后是 新的语法。

### 旧的语法

#### 滚动条宽度

首先，我们需要定义滚动条的大小，它可以是垂直滚动条的宽度，也可以是水平滚动条的高度。

```css
.container::-webkit-scrollbar {
  width: 10px;
}
```

然后，我们就可以开始自定义滚动条的样式了。

#### 滚动条 Track

Track 表示滚动条的底部，我们可以通过添加 `background-color`、`box-shadow`、 `border-radius` 和 `border` 来控制 Track 的样式。

```css
.container::-webkit-scrollbar-track {
  background-color: darkgrey;
}
```

#### 滚动条 Thumb

准备好 滚动条的底部后，我们还需要设置滚动条 `Thumb` 的样式。用户可以拖动 `Thumb` 来与滚动条进行交互。

```css
.container::-webkit-scrollbar-thumb {
  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
}
```

#### 旧语法浏览器兼容

@[caniuse](mdn-css_selectors_-webkit-scrollbar)

至此，我们已经介绍了 CSS 中设置 自定义滚动条的旧语法以及兼容性。
接下来，我们将介绍 CSS 中设置 自定义滚动条的新语法。

### 新语法

#### 滚动条宽度

这定义了滚动条宽度，我们需要关注的值是 `auto` 和 `thin` 。
需要注意的是，我们无法像 `webkit` 语法那样定义一个特定的数字。

```css
.section {
  scrollbar-width: thin;
}
```

#### 滚动条颜色

使用此属性，我们可以将滚动条 `Track` 和 `Thumb` 的颜色定义为成对的值。

```css
.section {
  scrollbar-color: #6969dd #e0e0e0;
}
```

尽管这种语法很简单，但是我们只能使用 纯色，无法添加 阴影、渐变、圆角边框 等其他相关的样式。

#### 滚动条装订线 Gutter

你有没有想过，当内容在滚动容器中增加时，我们如何避免布局变化？让我们以以下案例为例。

:::demo-wrapper img
![scrollbar gutter](/images/scrollbar/scrollbar-gutter-1.jpg)
:::

```css
.box {
  padding: 1rem;
  max-height: 220px;
  overflow-y: auto;
}
```

我们有一个四周都有 1rem 的内边距的容器。到目前为止，内容很短，滚动条不会显示，因为使用了 `overflow-y: auto`。

> \[!note]
> 当我们使用 `overflow-y: auto` ，当内容很短时不会显示滚动条，直到内容超过了容器的高度，滚动条才显示。

当内容增长时，将显示滚动条，从而减少内容的可用空间。

:::demo-wrapper img
![scrollbar gutter](/images/scrollbar/scrollbar-gutter-2.jpg)
:::

可以看到，当内容过长出现滚动条时，内容会发生偏移。
这是由于浏览器为滚动条保留了一个空间，导致内容空间收到挤压变小。

但幸运的是，现在可以通过 [`scrollbar-gutter`](https://developer.mozilla.org/en-US/docs/Web/CSS/scrollbar-gutter) 属性来解决这个问题。它帮助为滚动条提前预留足够的空间。
它的默认值为 `auto`，可选值有 `stable` 和 `both-edges` 。

```css
.box {
  padding: 1rem;
  max-height: 220px;
  overflow-y: auto;
  scrollbar-gutter: stable;
}
```

:::demo-wrapper img
![scrollbar gutter](/images/scrollbar/scrollbar-gutter-3.jpg)
:::

当内容增加时，就不会影响布局的空间变化，因为浏览器已经为 滚动条预留了空间。

:::demo-wrapper
![scrollbar gutter](/images/scrollbar/scrollbar-gutter-4.jpg)
:::

好消息是，`scrollbar-gutter` 的兼容性，从 `Chrome@94` 就开始得到了支持。

#### 新语法浏览器兼容

@[caniuse](mdn-css_properties_scrollbar-width)

## 自定义滚动条的使用范围

有一点需要考虑的，我们的 自定义滚动条，它应该在哪里生效。
是希望所有的 可滚动的元素都应用 自定义滚动条，还是只有特定的元素应用自定义滚动条呢。

### 所有可滚动元素

对于 旧的语法， 想要使所有 可滚动元素都 生效，我们可以直接编写 选择器，而无需将它们附加到元素。

```css
::-webkit-scrollbar {
  width: 10px;
}

::-webkit-scrollbar-track {
  background-color: darkgrey;
}

::-webkit-scrollbar-thumb {
  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
}
```

而对于新语法，只需要将它们 应用于 `<html>` 元素即可

```css
html {
  scrollbar-color: #6969dd #e0e0e0;
  scrollbar-width: thin;
}
```

### 特定可滚动元素

对于 旧的语法，想要使特定的 可滚动元素生效，我们在特定元素之后编写 选择器。

```css
.container::-webkit-scrollbar {
  width: 10px;
}

.container::-webkit-scrollbar-track {
  background-color: darkgrey;
}

.container::-webkit-scrollbar-thumb {
  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
}
```

对于新语法，也是是相同的。

```css
.container {
  scrollbar-color: #6969dd #e0e0e0;
  scrollbar-width: thin;
}
```

## 设计自定义滚动条

在深入研究 自定义滚动条之前，首先需要了解 默认的滚动条的样式。

默认的滚动条在 不同的操作系统之中是不同的。

在 MacOS Safari 中， Track 两侧都有边框， 背景色为纯色，Thumb 是圆形的，左右两侧都有空间。
:::demo-wrapper img
![scrollbar use case](/images/scrollbar/use-case-1.jpg)
:::
而在 MacOS Chrome 中，Track 是透明的，`Thumb` 是原型的，而且整个滚动条只在滚动时才显示，且不占据空间。

在 Windows 中，Track 是 灰色背景，Thumb 是 矩形的。
::: demo-wrapper img
![scrollbar use case](/images/scrollbar/use-case-1-2.jpg)
:::

### 示例1

以下是根据上面的模型，自定义的滚动条

```css
.container::-webkit-scrollbar {
  width: 16px;
}

.container::-webkit-scrollbar-track {
  background-color: #e4e4e4;
  border-radius: 100px;
}

.container::-webkit-scrollbar-thumb {
  background-color: #d4aa70;
  border-radius: 100px;
}
```

为 `Track` 和 `Thumb` 添加 `border-radius` 是必要的，因为 `border-radius` 无法在 `::-webkit-scrollbar`
上生效。

:::demo-wrapper no-padding

如果是使用的 新的语法，我们不能调整 滚动条的宽度，能做的事情只有设置 `Track` 和 `Thumb` 的颜色：

```css
.container {
  scrollbar-color: #d4aa70 #e4e4e4;
}
```

***

> \[!warning]
> 以下示例仅适用于 `webkit` 内核的浏览器。对于实际项目，你还可以同时添加新的语法支持 `Firefox`。

### 示例2：阴影+渐变

在这个示例中，我们给滚动条添加了 阴影 和 渐变。来看看效果如何：

```css
.container::-webkit-scrollbar-thumb {
  background-image: linear-gradient(180deg, #d0368a 0%, #708ad4 99%);
  box-shadow: inset 2px 2px 5px 0 rgba(#fff, 0.5);
  border-radius: 100px;
}
```

:::demo-wrapper no-padding title="渐变"

### 示例3: 带边框

我们还可以为 `Track` 和 `Thumb` 添加 边框，这可以帮助我们解决一些棘手的设计。

```css
.container::-webkit-scrollbar-thumb {
  border-radius: 100px;
  background: #8070d4;
  border: 6px solid rgba(0, 0, 0, 0.2);
}
```

:::demo-wrapper no-padding

基于相同的示例，我们还可以调整 `Thumb` 的 边框，获得一些有趣的效果。

```css
.container::-webkit-scrollbar-thumb {
  border-radius: 100px;
  background: #8070d4;
  border: 6px solid rgba(0, 0, 0, 0.2);
  border-left: none;
  border-right: none;
}
```

:::demo-wrapper no-padding

### 示例4：Thumb 带间隔

在此示例中，我们希望 `Thumb` 的四周与 `Track` 都带有一定的间隔。 由于它无法与 滚动条一起使用 `padding`。
因此我们需要使用 `border` 和 `background-clip` 实现效果。

```css
.container::-webkit-scrollbar-thumb {
  border: 5px solid transparent;
  border-radius: 100px;
  background-color: #8070d4;
  background-clip: content-box;
}
```

:::demo-wrapper no-padding title="Thumb 带间隔"

## 增加 hover 效果

我们可以为 滚动条添加 `hover` 效果吗?

是的, 可以。我们可以为 新旧的语法添加 `hover` 效果。

```css
/* 旧语法 */
.section::-webkit-scrollbar-thumb:hover {
  background-color: #5749d2;
}

/* 新语法 */
.section {
  scrollbar-color: #d4aa70 #e4e4e4;
  transition: scrollbar-color 0.3s ease-out;
}

.section:hover {
  scrollbar-color: #5749d2;
}
```

同时，在使用新语法上，我们还可以添加 过渡效果，但是在 旧语法 上则不支持。

:::demo-wrapper no-padding title="hover 效果"

## 在需要时显示滚动条

通过向 `overflow` 属性添加值以外的 `visible` 值，可以创建可滚动元素。
建议使用关键字， `auto` 因为它只会在内容超出其容器时显示滚动条。

```css
.container {
  overflow: auto;
}
```

---

---
url: /article/4nop90ge/index.md
---
# 浏览器指纹
在当今互联网环境中，用户隐私保护日益受到关注，而**浏览器指纹**技术作为网站识别用户的重要手段，既带来了便利也引发了隐私担忧。本文将深入探讨浏览器指纹的工作原理、技术实现以及防护策略。

## 什么是浏览器指纹？

浏览器指纹是通过收集用户浏览器和设备的各类信息，组合成一个**唯一标识符**的技术。就像人类的指纹一样，这个数字指纹能够以极高的准确率识别和追踪特定用户。

:::info 核心概念
浏览器指纹不是传统意义上的Cookie，它无需在用户设备上存储任何数据，而是通过分析浏览器特征来创建用户画像。
:::

## 浏览器指纹的构成要素

### 1. 基础信息组件

```javascript
// 获取基础浏览器指纹信息
function getBasicFingerprint() {
  return {
    userAgent: navigator.userAgent,
    language: navigator.language,
    platform: navigator.platform,
    screenResolution: `${screen.width}x${screen.height}`,
    colorDepth: screen.colorDepth,
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    hardwareConcurrency: navigator.hardwareConcurrency,
    deviceMemory: navigator.deviceMemory || 'unknown'
  }
}
```

### 2. 高级指纹技术

#### Canvas 指纹

```javascript
function generateCanvasFingerprint() {
  const canvas = document.createElement('canvas')
  const ctx = canvas.getContext('2d')

  // 绘制文本和图形
  ctx.textBaseline = 'top'
  ctx.font = '14px Arial'
  ctx.fillText('Browser fingerprint test', 2, 2)

  // 返回Canvas数据哈希
  return hashCanvasData(canvas.toDataURL())
}
```

#### WebGL 指纹

```javascript
async function getWebGLFingerprint() {
  const canvas = document.createElement('canvas')
  const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl')

  if (!gl)
    return null

  const debugInfo = gl.getExtension('WEBGL_debug_renderer_info')
  return {
    vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
    renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL),
    // 其他WebGL参数...
  }
}
```

#### 音频指纹

```javascript
function getAudioFingerprint() {
  const audioContext = new (window.AudioContext || window.webkitAudioContext)()
  const oscillator = audioContext.createOscillator()
  const analyser = audioContext.createAnalyser()

  oscillator.connect(analyser)
  oscillator.start()

  // 分析音频信号特征
  const data = new Float32Array(analyser.frequencyBinCount)
  analyser.getFloatFrequencyData(data)

  return hashAudioData(data)
}
```

## 浏览器指纹的独特性分析

:::code-tabs
@tab 指纹组合示例

```javascript
const fingerprint = {
  // 用户代理信息
  userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',

  // 屏幕特性
  screen: '1920x1080@24bit',

  // 插件列表
  plugins: ['Chrome PDF Viewer', 'Chrome PDF Plugin'],

  // 字体列表
  fonts: ['Arial', 'Times New Roman', 'Verdana'],

  // 时区和语言
  timezone: 'Asia/Shanghai',
  language: 'zh-CN'
}
```

@tab 唯一性计算

```javascript
function calculateUniqueness(fingerprint) {
  // 基于信息熵计算指纹唯一性
  const entropyBits = Object.values(fingerprint)
    .map(value => calculateEntropy(value))
    .reduce((sum, entropy) => sum + entropy, 0)

  return 2 ** entropyBits // 可能的组合数量
}
```

:::

## 实际应用场景

### 1. 反欺诈系统

```javascript
class FraudDetection {
  constructor() {
    this.fingerprint = this.collectFingerprint()
  }

  detectSuspiciousActivity() {
    const currentFp = this.collectFingerprint()
    const previousFp = this.getStoredFingerprint()

    // 检测指纹变化模式
    if (this.hasRapidFingerprintChanges(currentFp, previousFp)) {
      this.flagForReview()
    }
  }
}
```

### 2. 个性化体验

```javascript
function enhanceUserExperience() {
  const fingerprint = getDeviceFingerprint()

  // 根据设备能力优化体验
  if (fingerprint.hardwareConcurrency > 4) {
    enableAdvancedFeatures()
  }

  // 根据屏幕尺寸调整布局
  adjustLayoutForScreen(fingerprint.screenResolution)
}
```

## 隐私保护与应对策略

### 1. 浏览器内置防护

现代浏览器提供了多种防护机制：

:::steps

* **Firefox**：通过 `privacy.resistFingerprinting` 配置项提供指纹防护
* **Chrome**：正在开发 Privacy Sandbox 技术限制指纹追踪
* **Safari**：智能防跟踪预防（ITP）技术
* **Tor Browser**：标准化用户代理和屏幕尺寸

:::

### 2. 用户防护措施

```javascript
// 使用浏览器扩展防护示例
class FingerprintProtection {
  static methods = {
    canvasNoise: () => this.injectCanvasNoise(),
    fontSpoofing: () => this.spoofFontList(),
    webglMasking: () => this.maskWebGLInfo()
  }

  static injectCanvasNoise() {
    // 为Canvas添加随机噪声
    const originalMethod = HTMLCanvasElement.prototype.toDataURL
    HTMLCanvasElement.prototype.toDataURL = function () {
      const ctx = this.getContext('2d')
      // 添加微小随机像素
      this.addRandomNoise(ctx)
      return originalMethod.call(this)
    }
  }
}
```

### 3. 开发者伦理指南

:::warning 重要提醒
开发者在实现指纹技术时应：

* 明确告知用户数据收集目的
* 提供选择退出机制
* 遵循数据最小化原则
* 遵守GDPR、CCPA等隐私法规
  :::

## 技术发展趋势

### 1. 联邦学习与差分隐私

```javascript
// 使用差分隐私的指纹处理
class DifferentialPrivacyFingerprint {
  addLaplaceNoise(sensitivity, epsilon) {
    // 添加拉普拉斯噪声保护隐私
    const noise = this.generateLaplaceNoise(sensitivity / epsilon)
    return this.fingerprintData + noise
  }

  generateAnonymousFingerprint() {
    // 生成匿名化指纹标识
    return this.hashFingerprint(
      this.addLaplaceNoise(this.fingerprintData)
    )
  }
}
```

### 2. 隐私增强技术（PETs）

```javascript
// 零知识证明应用示例
class ZeroKnowledgeFingerprint {
  async generateProof(fingerprint) {
    // 生成证明而不泄露具体指纹信息
    const proof = await zkSnark.generateProof(
      fingerprint,
      this.verificationKey
    )
    return proof
  }

  verifyWithoutRevealing(proof) {
    // 验证用户身份而不获取具体指纹
    return zkSnark.verify(proof, this.verificationKey)
  }
}
```

## 总结

浏览器指纹技术是一把双刃剑：

**积极方面**：

* \==增强安全性=={.success}，防止账户盗用和欺诈
* \==改善用户体验=={.success}，提供个性化服务
* \==业务分析=={.success}，理解用户行为模式

**挑战方面**：

* \==隐私风险=={.warning}，用户可能被无感知追踪
* \==法规合规=={.warning}，需要遵守日益严格的隐私法规
* \==技术滥用=={.caution}，可能被用于不正当目的

### 最佳实践建议

1. **对用户**：使用隐私保护浏览器和扩展，定期清理浏览器数据
2. **对开发者**：实施隐私设计原则，最小化数据收集
3. **对企业**：建立透明的数据使用政策，尊重用户选择

随着技术发展和法规完善，浏览器指纹技术将在**隐私保护**和**功能需求**之间寻找更好的平衡点。

***

**参考**：

* [W3C Privacy Interest Group](https://www.w3.org/Privacy/)
* [Electronic Frontier Foundation - Panopticlick](https://panopticlick.eff.org/)
* [Mozilla Developer Network - Fingerprinting](https://developer.mozilla.org/en-US/docs/Glossary/Fingerprinting)

::: important 保护用户隐私，共建可信网络环境 🔒
:::

---

---
url: /article/4sfcfmws/index.md
---
## 理解 Git Rebase

Git rebase（变基）是 Git 版本控制系统中一个功能强大但需要谨慎使用的工具，它允许开发者重新整理提交历史。简而言之，rebase 能够将一系列提交从一个分支“移植”到另一个分支，并在此过程中重新组织提交记录。

### 核心概念解析

假设你正在开发一个新功能，从主分支（main）创建了一个特性分支（feature）。在开发过程中，主分支上产生了新的提交。此时，你面临两个选择：

* **Merge（合并）**：保留两个分支的完整历史，创建一个合并提交
* **Rebase（变基）**：将特性分支的提交“重放”到主分支的最新提交之上

## Git Rebase 的核心应用场景

### 1. 维护清晰的提交历史

```bash
# 在特性分支上执行
git rebase main
```

此命令将特性分支的所有提交重新应用到主分支的最新提交上，形成一条线性的提交历史。

### 2. 交互式提交管理

```bash
# 交互式 rebase，编辑最近3个提交
git rebase -i HEAD~3
```

交互式 rebase 支持以下操作：

* 重新排列提交顺序
* 合并多个提交
* 编辑提交信息
* 拆分提交内容
* 删除指定提交

### 3. 解决分支分叉问题

当多个开发者协作于同一分支时，rebase 有助于维护线性的提交历史。

## Git Rebase 实战指南

### 基础操作

#### 1. 特性分支变基到主分支

```bash
# 切换到特性分支
git checkout feature-branch

# 获取远程最新变更
git fetch origin

# 变基到主分支
git rebase origin/main
```

#### 2. 交互式变基操作

```bash
# 编辑最近5个提交
git rebase -i HEAD~5
```

编辑器将显示类似内容：

```
pick a1b2c3d 添加用户登录功能
pick e4f5g6h 修复登录bug
pick h7i8j9k 添加用户注册
pick k0l1m2n 优化表单验证
pick n3o4p5q 添加密码重置功能
```

可用的操作命令：

* `pick`：保留提交
* `reword`：修改提交信息
* `edit`：修改提交内容
* `squash`：合并到前一个提交
* `fixup`：合并并丢弃提交信息
* `drop`：删除提交

### 3. 冲突处理策略

rebase 过程中遇到冲突时：

```bash
# 1. 解决冲突文件
# 2. 添加已解决的文件
git add <冲突文件>

# 3. 继续 rebase 过程
git rebase --continue

# 如需取消 rebase 操作
git rebase --abort
```

## Git Rebase 使用注意事项

### ⚠️ 核心原则：避免对已推送提交进行变基

**绝对不要**对已经推送到远程仓库的提交执行 rebase，除非你确认没有其他协作者在此分支上工作。

```bash
# ❌ 危险操作：对已推送提交执行 rebase
git push origin feature-branch
git rebase main  # 这会重写历史，引发协作问题

# ✅ 安全操作：在推送前执行 rebase
git rebase main
git push origin feature-branch
```

### 其他关键注意事项

1. **分支备份**：执行复杂 rebase 前创建备份分支
2. **小步提交**：保持提交的原子性，每次只完成一个小改动
3. **功能验证**：rebase 完成后务必验证代码功能
4. **团队协调**：在团队项目中建立统一的 rebase 使用规范

## Git Rebase 与 Git Merge 深度对比

### 工作机制分析

#### Merge（合并）

```bash
# 创建合并提交，保留完整历史
git checkout main
git merge feature-branch
```

特点：

* 生成新的合并提交
* 完整保留两个分支历史
* 历史呈现树状结构

#### Rebase（变基）

```bash
# 重写历史，创建线性记录
git checkout feature-branch
git rebase main
git checkout main
git merge feature-branch
```

特点：

* 重写提交历史
* 创建线性提交记录
* 不产生额外合并提交

### 历史记录可视化对比

**Merge 后的历史结构：**

```
*   Merge branch 'feature'
|\
| * Feature commit 3
| * Feature commit 2
| * Feature commit 1
* | Main commit 2
* | Main commit 1
|/
* Base commit
```

**Rebase 后的历史结构：**

```
* Feature commit 3
* Feature commit 2
* Feature commit 1
* Main commit 2
* Main commit 1
* Base commit
```

## Git Rebase 的优势与局限

### 核心优势

#### 1. 清晰的历史记录

* 线性历史更易阅读和理解
* 避免复杂的合并提交
* 便于使用 `git bisect` 进行问题追踪

#### 2. 提升代码审查效率

* 每个提交都是独立完整的单元
* 便于按功能模块审查代码
* 减少合并冲突干扰

#### 3. 灵活的历史管理

* 自由调整提交顺序
* 合并相关小提交
* 修正提交信息错误

### 潜在风险

#### 1. 历史重写风险

* 可能丢失重要历史信息
* 对已推送提交变基会破坏团队协作

#### 2. 学习成本较高

* 初学者容易误用
* 需要深入理解 Git 内部机制

#### 3. 冲突处理复杂

* 可能在每个提交点遇到冲突
* 需要重复解决冲突

## 最佳实践指南

### 1. 个人分支管理策略

```bash
# 推送前整理本地提交
git rebase -i HEAD~3  # 整理最近3个提交
git push origin feature-branch
```

### 2. 团队协作规范

* 仅在个人特性分支使用 rebase
* 主分支和开发分支采用 merge 策略
* 建立团队统一的 rebase 使用规范

### 3. 实用工作流示例

```bash
# 完整工作流演示
git checkout -b feature/login
# 进行功能开发，完成多次提交...

# 准备推送代码
git fetch origin
git rebase origin/main

# 处理可能出现的冲突
git rebase --continue

# 推送到远程仓库
git push origin feature/login
```

## 总结与展望

Git rebase 是一个功能强大的工具，但需要谨慎使用。掌握 rebase 的关键要点：

1. **理解机制**：深入理解 rebase 如何重写提交历史
2. **遵守规范**：严格避免对已推送提交执行变基
3. **持续实践**：在个人项目中积累使用经验
4. **团队协作**：建立统一的工作流标准

正确使用 rebase 能够帮助我们维护清晰、整洁的提交历史，提升代码审查效率，是现代 Git 工作流中的重要工具。

谨记：**能力越大，责任越大**。在享受 rebase 带来的便利时，必须时刻警惕其潜在风险。

***

*推荐学习资源：*

* [Pro Git 书籍 - Rebasing 章节](https://git-scm.com/book/en/v2/Git-Branching-Rebasing)
* [Git 官方文档 - git-rebase](https://git-scm.com/docs/git-rebase)
* [GitHub 学习实验室 - Git 工作流](https://lab.github.com/)

---

---
url: /article/4v4g4vmb/index.md
---
在 Node.js 开发中，经常需要在不同项目间切换不同版本的 Node.js。多版本管理器应运而生，让我们能够轻松安装、切换和管理多个 Node.js 版本。本文将详细介绍目前主流的四种工具：n、nvm、fnm 和 volta。

## 1. n

### 安装

```bash
# 使用 npm 安装
npm install -g n

# 或者使用官方脚本
curl -L https://bit.ly/n-install | bash
```

### 基本使用

```bash
# 安装最新的稳定版
n latest

# 安装最新的 LTS 版本
n lts

# 安装特定版本
n 18.12.1

# 查看已安装版本
n

# 删除版本
n rm 14.17.0

# 查看所有远程版本
n ls-remote
```

### 功能特点

* **简单易用**：命令直观，学习成本低
* **直接覆盖**：通过替换二进制文件实现版本切换
* **快速安装**：下载预编译的二进制包

### 优缺点

**优点：**

* 安装和使用极其简单
* 不需要修改环境变量
* 切换速度快

**缺点：**

* 官方不支持 Windows
* 全局包在不同版本间不隔离
* 版本切换可能不够灵活

## 2. nvm (Node Version Manager)

### 安装

```bash
# Linux/macOS 安装
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.4/install.sh | bash

# 或者使用 wget
wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.4/install.sh | bash

# Windows 用户使用 nvm-windows
# 下载地址：https://github.com/coreybutler/nvm-windows/releases
```

### 基本使用

```bash
# 安装指定版本
nvm install 18.12.1

# 安装最新 LTS
nvm install --lts

# 使用特定版本
nvm use 16.18.0

# 设置默认版本
nvm alias default 18.12.1

# 查看已安装版本
nvm ls

# 查看远程可用版本
nvm ls-remote

# 在当前目录创建 .nvmrc 文件
echo "18.12.1" > .nvmrc
# 然后运行
nvm use
```

### 功能特点

* **完全隔离**：每个版本有独立的全局包
* **项目级配置**：支持 .nvmrc 文件
* **跨平台**：有专门的 Windows 版本

### 优缺点

**优点：**

* 成熟的生态系统
* 完整的版本隔离
* 良好的项目集成
* 社区支持强大

**缺点：**

* 启动速度相对较慢
* 不同 shell 需要重新加载
* Windows 版本功能有限

## 3. fnm (Fast Node Manager)

### 安装

```bash
# 使用安装脚本
curl -fsSL https://fnm.vercel.app/install | bash

# 使用 Homebrew (macOS)
brew install fnm

# 使用 Scoop (Windows)
scoop install fnm

# 使用 Cargo
cargo install fnm
```

### 基本使用

```bash
# 安装 Node.js
fnm install 18.12.1

# 使用版本
fnm use 18.12.1

# 设置默认版本
fnm default 18.12.1

# 列出所有版本
fnm list

# 配置自动版本切换
# 在 shell 配置文件中添加
eval "$(fnm env --use-on-cd)"
```

### 功能特点

* **极速性能**：Rust 编写，启动速度快
* **自动检测**：支持 .node-version 和 .nvmrc 文件
* **跨平台支持**：完整的 Windows 支持

### 优缺点

**优点：**

* 极快的启动速度
* 现代化的架构
* 良好的跨平台支持
* 自动版本检测

**缺点：**

* 相对较新，生态系统不如 nvm 成熟
* 某些高级功能可能缺失

## 4. volta

### 安装

```bash
# 一键安装 (Linux/macOS)
curl https://get.volta.sh | bash

# Windows
# 下载安装器：https://volta.sh/

# 使用 Homebrew
brew install volta
```

### 基本使用

```bash
# 安装 Node.js
volta install node@18.12.1

# 查看当前工具链
volta list

# 固定项目 Node.js 版本
volta pin node@18

# 安装全局包
volta install prettier

# 查看当前工具版本
volta which node
```

### 功能特点

* **项目级锁定**：自动管理项目特定版本
* **工具链管理**：同时管理 Node.js、npm、Yarn
* **无感知切换**：进入项目目录自动切换版本
* **跨平台一致**：统一的跨平台体验

### 优缺点

**优点：**

* 优秀的项目版本管理
* 工具链完整管理
* 自动版本切换
* 优秀的性能

**缺点：**

* 学习曲线相对陡峭
* 对现有工作流改变较大

## 5. 详细对比分析

### 性能对比

| 工具  | 启动速度 | 内存占用 | 安装速度 |
| ----- | -------- | -------- | -------- |
| n     | 快       | 低       | 快       |
| nvm   | 慢       | 中       | 中       |
| fnm   | 很快     | 低       | 快       |
| volta | 快       | 中       | 中       |

### 功能对比

| 功能         | n    | nvm | fnm | volta  |
| ------------ | ---- | --- | --- | ------ |
| Windows 支持 | ❌   | ✅   | ✅   | ✅     |
| 自动版本切换 | ❌   | ✅   | ✅   | ✅     |
| 全局包隔离   | ❌   | ✅   | ✅   | ✅     |
| 多工具管理   | ❌   | ❌   | ❌   | ✅     |
| 项目配置文件 | ❌   | ✅   | ✅   | ✅     |
| 二进制管理   | ❌   | ❌   | ❌   | ✅     |

### 生态系统成熟度

* **nvm**: ⭐⭐⭐⭐⭐ (最成熟，社区支持最好)
* **n**: ⭐⭐⭐⭐ (简单可靠，历史悠久)
* **volta**: ⭐⭐⭐⭐ (功能丰富，官方推荐)
* **fnm**: ⭐⭐⭐ (新兴工具，快速发展)

## 6. 选择建议

### 根据使用场景选择

**个人开发者/初学者：**

* 推荐：**n** 或 **fnm**
* 理由：简单易用，学习成本低

**团队项目/企业环境：**

* 推荐：**volta** 或 **nvm**
* 理由：版本锁定严格，协作友好

**Windows 用户：**

* 推荐：**fnm** 或 **volta**
* 理由：完整的 Windows 支持

**性能敏感用户：**

* 推荐：**fnm**
* 理由：极快的启动速度

**全栈工具链管理：**

* 推荐：**volta**
* 理由：完整的工具链管理

### 迁移建议

```bash
# 从 nvm 迁移到 fnm
nvm ls > versions.txt
# 然后使用 fnm 逐个安装列出的版本

# 从 n 迁移到 volta
# volta 会自动检测现有安装，无需特殊迁移
```

## 7. 最佳实践

### 项目版本配置

```bash
# .nvmrc (nvm/fnm)
18.12.1

# package.json (volta)
{
  "volta": {
    "node": "18.12.1",
    "npm": "9.1.0"
  }
}
```

### CI/CD 集成

```yaml
# GitHub Actions 示例
- name: Setup Node.js
  uses: actions/setup-node@v3
  with:
    node-version-file: .nvmrc

# 或者使用 fnm
- name: Install fnm
  run: curl -fsSL https://fnm.vercel.app/install | bash
- name: Install Node.js
  run: fnm use
```

## 总结

选择合适的 Node.js 版本管理器取决于你的具体需求：

* **追求简单**：选择 **n**
* **需要稳定性**：选择 **nvm**
* **追求性能**：选择 **fnm**
* **需要完整工具链**：选择 **volta**

无论选择哪个工具，重要的是保持团队一致性，并在项目中正确配置版本约束文件，这样才能确保开发环境的一致性。

## 延伸资源

* [n 官方文档](https://github.com/tj/n)
* [nvm 官方文档](https://github.com/nvm-sh/nvm)
* [fnm 官方文档](https://github.com/Schniz/fnm)
* [volta 官方文档](https://volta.sh/)

希望本文能帮助你选择最适合的 Node.js 版本管理工具！

---

---
url: /article/5fmy4kla/index.md
---
# WebComponent——template
在web开发领域中，模板并不少见。从服务器端的模板语言，如`Django`、`jsp`等，应用十分广泛，存在了很长时间。又如前端，早期例如`art(artTemplate)`，以及近年来，大多数的MV\*框架涌现，绝大多数在展现层使用了同样的渲染机制：模板。

> **定义**
> 模板，一个拥有预制格式的文档或者文件，可作为特定应用的出发点，这样就避免在每次使用格式的时候都重复创建。

从模板的定义中，我们可以发现，“避免在每次使用格式的时候重复创建”，从这句话来看，模板可以让我们避免重复的工作。那么，web平台有没有提供原生支持呢？

答案是，有，在 [WhatWG HTML 模板规范](https://html.spec.whatwg.org/multipage/scripting.html#the-template-element)中，它定义了一个新的`<template>` 元素，
用于描述一个标准的以DOM为基础的方案来实现客户端模板。该模板允许你定义一段可以被转为 HTML 的标记，在页面加载时不生效，但可以在后续进行动态实例化。

### 声明

跟普通的html标签一样，`template`标签包含的内容，即是声明的模板内容。

```html
<template>
  <img src="" />
  <p>content</p>
</template>
```

“模板内容”本质上，是 **一大块的惰性可复制DOM**。在这个例子中，标签内的元素并不会被渲染，图片资源也不会发出请求。模板可以理解为单个零件，在整个应用的生命周期中，你都可以使用、以及重用它。

### 特性

使用`<template>`标签包裹我们的内容，可以为我们提供一下几个重要的特性。

1. **它的内容在激活前都是惰性的。** template标签默认是隐藏的，它的内容也是不可见的，同时也不会被渲染。
2. **处于模板中的内容不会产生副作用。** 放在模板中的脚本、音频、视频、图片资源不会被加载，不会被播放，直到模板中的内容被使用。
3. **内容不在文档中。** 在主页面使用`document.getElementById()`，不会返回模板子节点。
4. **模板能够放置在任何位置。** 你可以把`<template>` 放置在`<head>`、`<body>`、`<frameset>`，
   并且任何能够出现在以上元素的内容，都可以放置在模板中。**“任何位置”** 意味着`<template>`标签可以出现在HTML解析器不允许出现的位置 *(必须是在`<html>`标签内)*，几乎可以作为任何元素的子节点。
   它也可以作为`<table>`、`<select>`的子节点。当然，如果写在声明`type="text/javascript"`的`<script>`标签中，绝对报错，原因我就不说了。（同时实测发现，如果`<template>`标签放在`<head>`、`<body>`同级，放在`<body>`前面，都会被解析到`<head>`标签内，放在`<body>`后，会被解析到`<body>`内）。

   ```html
   <table>
     <tr>
       <templete>
         <td>content</td>
       </templete>
     </tr>
   </table>
   ```

### 使用模板

想要使用模板，首先需要激活模板，否则它的内容将无法被渲染。模板对象包含了一个`content`属性，该属性是只读属性，关联一个包含模板内容的`DocumentFragment`，
我们可以使用`document.importNode()`对模板的`.content`进行深拷贝。

```html
<template id="template1">
  <img src="" />
  <p>content</p>
</template>
```

```javascript
let tmp = document.querySelector('#template1')
// 可以在获取模板的时候，对内容进行填充
tmp.content.querySelector('img').scr = 'logo.png'
let clone = document.importNode(tmp.content, true)
document.body.appendChild(clone)
```

模板中的资源，比如图片资源，只有被激活后，才会发出请求。

### 浏览器支持

想要检测浏览器是否支持该标签，需要创建一个template元素，并检查它是否拥有`.content`属性。

```javascript
function supportTemplate() {
  return 'content' in document.createElement('template')
}
if (supportsTemplate()) {
  // 浏览器支持 template 元素
}
else {
  // 浏览器不支持template元素
}
```

从目前来看，IE13+开始支持，低于此版本的IE均无法使用，如果有项目只需要考虑 webkit内核的浏览器，template标签还是可以一用。

@[caniuse](mdn-html_elements_template)

如果浏览器不支持template标签，那么就会认为是一个普通的自定义元素，内部的标签会被作为一般的标签被渲染。

### 模板标准之路

HTML 模板标准化进程耗时十分长久。从过去到现在，出现了很多各种各样的方法去创建可重用的模板。

**方法一：使用隐藏的DOM元素，将模板内容放在某个标签内，使用`display:none`隐藏元素。**

```html
<div style="display:none">
  <img src="" />
</div>
```

使用这种方式，有利有弊：

1. √ 使用DOM，浏览器能够很好的处理DOM结构，我们可以方便的复制、使用DOM。
2. √ 没有内容渲染，`display: none` 阻止了内容渲染。
3. × 非惰性， 图片资源依然会发出请求。
4. x 难以设置样式和主题，需要为所有CSS增加规则。

**方法二：使用textarea 标签，并使用`display:none`隐藏元素。**

```html
<textarea style="display:none">
    <img src="" />
</textarea>
```

这种方法是对方法一的一种改进，但也有新的利弊：

1. √ 没有内容渲染，`display: none` 阻止了内容渲染。
2. √ 惰性，由于模板内容是字符串，图片资源不会发出请求。
3. x 模板内容是字符串，需要进一步将其转为DOM。

**方法三： 重载脚本。**

```html
<script type="text/x-handlebars-template">
  <img src='' />
</script>
```

利弊：

1. √ 没有内容渲染，script 标签默认`display:none`。
2. √ 惰性，脚本类型不为 `text/javascript`，浏览器不会认为是脚本，不会将其作为JS解析。
3. x 安全问题，由于使用 `innerHTML`获取内容，对用户提供的字符串进行运行时解析，很容易倒是 XSS漏洞。

### 总结

模板标准化，使得我们在做web开发整个过程更加健全，更容易维护。

---

---
url: /article/5ypqvw0e/index.md
---
# 设计原则—— SOLID 原则
> 在快速迭代的前端开发中，如何设计出既灵活又稳定的代码结构？SOLID 原则为我们提供了答案。

## 什么是 SOLID 原则？

SOLID 原则是面向对象编程和设计的五个基本原则，由 Robert C. Martin 提出。虽然起源于后端开发，但这些原则在前端架构设计中同样具有重要价值，特别是在现代前端框架如 React、Vue、Angular 的组件化开发中。

:::info 原则概览
SOLID 是五个设计原则首字母的缩写：

* **S** - 单一职责原则 (Single Responsibility Principle)
* **O** - 开闭原则 (Open/Closed Principle)
* **L** - 里氏替换原则 (Liskov Substitution Principle)
* **I** - 接口隔离原则 (Interface Segregation Principle)
* **D** - 依赖倒置原则 (Dependency Inversion Principle)
  :::

## 单一职责原则 (SRP)

### 核心思想

一个类或模块应该只有一个引起变化的原因。

### 在前端中的应用

**反例：承担过多职责的组件**：

```jsx title="违反 SRP 的组件"
// 这个组件同时处理数据获取、用户交互和样式渲染
class UserProfile extends React.Component {
  state = { user: null, loading: true }

  async componentDidMount() {
    const response = await fetch('/api/user')
    const user = await response.json()
    this.setState({ user, loading: false })
  }

  handleEdit = () => {
    // 编辑逻辑
  }

  handleDelete = () => {
    // 删除逻辑
  }

  render() {
    if (this.state.loading)
      return <div>Loading...</div>

    return (
      <div className="profile-card">
        <img src={this.state.user.avatar} alt="avatar" />
        <h2>{this.state.user.name}</h2>
        <p>{this.state.user.email}</p>
        <button onClick={this.handleEdit}>Edit</button>
        <button onClick={this.handleDelete}>Delete</button>
      </div>
    )
  }
}
```

**改进后的设计**：

```jsx title="遵循 SRP 的组件拆分"
// 数据获取职责
function withUserData(Component) {
  return class extends React.Component {
    state = { user: null, loading: true }

    async componentDidMount() {
      const user = await userService.getUser(this.props.userId)
      this.setState({ user, loading: false })
    }

    render() {
      return <Component {...this.props} {...this.state} />
    }
  }
}

// 展示职责
function UserProfileView({ user, onEdit, onDelete }) {
  return (
    <div className="profile-card">
      <img src={user.avatar} alt="avatar" />
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <button onClick={onEdit}>Edit</button>
      <button onClick={onDelete}>Delete</button>
    </div>
  )
}

// 业务逻辑职责
const UserProfileContainer = withUserData(({ user, loading }) => {
  const handleEdit = () => { /* 编辑逻辑 */ }
  const handleDelete = () => { /* 删除逻辑 */ }

  if (loading)
    return <div>Loading...</div>

  return (
    <UserProfileView
      user={user}
      onEdit={handleEdit}
      onDelete={handleDelete}
    />
  )
})
```

## 开闭原则 (OCP)

### 核心思想

软件实体应该对扩展开放，对修改关闭。

### 实际应用

**反例：需要频繁修改的组件**：

```jsx title="违反 OCP 的组件"
function Notification({ type, message }) {
  if (type === 'success') {
    return <div className="success">{message}</div>
  }
  else if (type === 'error') {
    return <div className="error">{message}</div>
  }
  else if (type === 'warning') {
    return <div className="warning">{message}</div>
  }
  // 每次新增类型都需要修改这个组件
}
```

**改进：可扩展的设计**：

```jsx title="遵循 OCP 的组件"
// 定义通知类型映射
const notificationTypes = {
  success: ({ message }) => <div className="success">{message}</div>,
  error: ({ message }) => <div className="error">{message}</div>,
  warning: ({ message }) => <div className="warning">{message}</div>,
}

// 可扩展的通知组件
function Notification({ type, message }) {
  const NotificationComponent = notificationTypes[type]
  return NotificationComponent ? <NotificationComponent message={message} /> : null
}

// 扩展新的通知类型时无需修改原有组件
notificationTypes.info = ({ message }) => <div className="info">{message}</div>
```

## 里氏替换原则 (LSP)

### 核心思想

子类应该能够替换其父类，并且不会影响程序的正确性。

### 在前端组件中的应用

**反例：违反替换原则的组件继承**：

```jsx title="违反 LSP 的组件设计"
class BaseButton extends React.Component {
  render() {
    return <button onClick={this.handleClick}>{this.props.children}</button>
  }

  handleClick = () => {
    console.log('Button clicked')
  }
}

class SubmitButton extends BaseButton {
  handleClick = () => {
    if (!this.props.formValid) {
      throw new Error('Form is not valid') // 改变了父类的行为约定
    }
    super.handleClick()
  }
}
```

**改进：使用组合而非继承**：

```jsx title="遵循 LSP 的组件设计"
function BaseButton({ onClick, children, ...props }) {
  return <button onClick={onClick} {...props}>{children}</button>
}

function SubmitButton({ formValid, onSubmit, ...props }) {
  const handleClick = () => {
    if (formValid) {
      onSubmit()
    }
    else {
      console.warn('Form is not valid')
    }
  }

  return <BaseButton onClick={handleClick} {...props} />
}
```

## 接口隔离原则 (ISP)

### 核心思想

客户端不应该被迫依赖于它们不使用的接口。

### 在 TypeScript 中的应用

**反例：臃肿的接口**：

```typescript title="违反 ISP 的接口设计"
interface UserAPI {
  getUser: (id: string) => Promise<User>
  createUser: (user: User) => Promise<void>
  updateUser: (user: User) => Promise<void>
  deleteUser: (id: string) => Promise<void>
  sendEmail: (user: User, message: string) => Promise<void>
  // 很多方法...
}

// 显示用户信息的组件被迫依赖整个接口
class UserProfile extends React.Component<{ userAPI: UserAPI }> {
  // 只使用了 getUser 方法，但被迫依赖其他不相关的方法
}
```

**改进：细粒度的接口**：

```typescript title="遵循 ISP 的接口设计"
interface UserReader {
  getUser: (id: string) => Promise<User>
}

interface UserWriter {
  createUser: (user: User) => Promise<void>
  updateUser: (user: User) => Promise<void>
  deleteUser: (id: string) => Promise<void>
}

interface EmailService {
  sendEmail: (user: User, message: string) => Promise<void>
}

// 组件只依赖需要的接口
class UserProfile extends React.Component<{ userReader: UserReader }> {
  // 现在只依赖真正需要的方法
}
```

## 依赖倒置原则 (DIP)

### 核心思想

高层模块不应该依赖于低层模块，二者都应该依赖于抽象。

### 实际应用

**反例：直接依赖具体实现**：

```jsx title="违反 DIP 的组件"
class UserService {
  async getUser(id) {
    const response = await fetch(`/api/users/${id}`)
    return response.json()
  }
}

class UserProfile extends React.Component {
  userService = new UserService() // 直接依赖具体实现

  async componentDidMount() {
    const user = await this.userService.getUser(this.props.userId)
    this.setState({ user })
  }
}
```

**改进：依赖抽象**：

```tsx title="遵循 DIP 的组件"
// 定义抽象
interface IUserService {
  getUser: (id: string) => Promise<User>
}

// 具体实现
class UserService implements IUserService {
  async getUser(id) {
    const response = await fetch(`/api/users/${id}`)
    return response.json()
  }
}

// 高层组件依赖抽象
class UserProfile extends React.Component<{ userService: IUserService }> {
  async componentDidMount() {
    const user = await this.props.userService.getUser(this.props.userId)
    this.setState({ user })
  }
}

// 依赖注入
const userService = new UserService()
ReactDOM.render(
  <UserProfile userService={userService} userId="123" />,
  document.getElementById('root')
)
```

## 在前端框架中的综合应用

### React Hooks + SOLID

```jsx title="现代 React 中的 SOLID 实践"
// 自定义 Hook - 单一职责
function useUser(userId) {
  const [user, setUser] = useState(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    userService.getUser(userId).then(setUser).finally(() => setLoading(false))
  }, [userId])

  return { user, loading }
}

// 展示组件 - 开闭原则
function UserCard({ user, onAction, actionType = 'default' }) {
  const ActionComponent = actionComponents[actionType]

  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      {ActionComponent && <ActionComponent user={user} onAction={onAction} />}
    </div>
  )
}

// 业务组件 - 依赖倒置
function UserProfile({ userId, userService = defaultUserService }) {
  const { user, loading } = useUser(userId, userService)

  if (loading)
    return <div>Loading...</div>

  return <UserCard user={user} onAction={handleUserAction} />
}
```

### Vue 3 Composition API

```vue title="Vue 3 中的 SOLID 实践"
<script setup>
// 单一职责 - 数据逻辑
const { user, loading } = useUser(props.userId)

// 单一职责 - 业务逻辑
const { handleEdit, handleDelete } = useUserActions(user)

// 依赖注入
provide('userService', userService)
</script>

<template>
  <UserCard
    :user="user"
    :loading="loading"
    @edit="handleEdit"
    @delete="handleDelete"
  />
</template>
```

## 实践建议与最佳实践

:::steps

* **从小处着手**：==不要试图一次性应用所有原则=={.warning}，从最影响代码质量的痛点开始
* **代码审查**：在团队代码审查中加入 SOLID 原则的检查项
* **渐进式重构**：在维护现有项目时，逐步应用这些原则改进代码结构
* **工具辅助**：使用 ESLint、TypeScript 等工具帮助识别违反原则的代码模式
* **平衡过度设计**：避免为了原则而原则，保持代码的实用性和可读性

:::

## 总结

SOLID 原则为前端开发提供了强大的设计指导：

* **单一职责原则** 帮助我们创建==专注且可测试=={.success}的组件
* **开闭原则** 使我们的代码==易于扩展=={.success}而无需修改现有实现
* **里氏替换原则** 确保组件之间的==一致性=={.success}和可替换性
* **接口隔离原则** 避免==不必要的依赖=={.success}，提高代码的模块化
* **依赖倒置原则** 促进==松耦合=={.success}和更好的可测试性

:::important 关键收获
SOLID 原则不是僵化的规则，而是帮助我们思考代码设计的工具。在前端开发中，这些原则与组件化、函数式编程等现代范式完美结合，能够显著提升代码的可维护性、可测试性和可扩展性。
:::

通过合理应用 SOLID 原则，我们可以构建出更加健壮、灵活的前端架构，从容应对需求变化和技术演进。

---

---
url: /article/675ocjcc/index.md
---
# 从 tsup 到 tsdown
## 前言

最近，==VoidZero== 推出了一个 基于 [rolldown](https://rolldown.rs/) 的全新的构建工具 [tsdown](https://tsdown.dev/)。
本着尝鲜的态度，我把我在开发维护中的一部分开源项目，将构建工具从 [tsup](https://tsup.egoist.dev/) 切换到 [tsdown](https://tsdown.dev/)。

## 迁移过程

### 自动迁移

`tsdown` 提供了迁移脚本，可以直接运行以下命令完成迁移:

:::npm-to

```sh
npx tsdown migrate
```

:::

### 手动迁移

::::steps

* 卸载 tsup，安装 tsdown

  ::: npm-to

  ```sh
  npm uninstall -D tsup
  npm install -D tsdown
  ```

  :::

* 重命名 `tsup.config.{js,ts}` 为 `tsdown.config.{js.ts}`

* 修改 `tsdown.config.{js,ts}` 文件，将 `tsup` 的配置替换为 `tsdown` 的配置

  ```ts title="tsdown.config.ts"
  import { defineConfig } from 'tsdown' // [!code ++]
  import { defineConfig } from 'tsup' // [!code --]

  export default defineConfig({
    entry: 'src/index.ts',
    shims: true,
    dts: true,
    format: ['esm', 'cjs'],
  })
  ```

* 修改 `package.json` 中的 `scripts` 字段

  ```json title="package.json"
  {
    "scripts": {
      // "build": "tsup", // [!code --]
      "build": "tsdown" // [!code ++]
    }
  }
  ```

* 完成

::::

迁移过程很简单，`tsdown` 几乎完全兼容 `tsup` 的所有配置项。

完成以上步骤后就可以直接运行 `build` 命令检查构建结果了。

## 收益

以 [pengzhanbo/vuepress-theme-plume](https://github.com/pengzhanbo/vuepress-theme-plume) 为例，
在迁移前，使用 `tsup` 进行构建的时间开销大约在 **7s** 左右，而使用 `tsdown` 进行构建，时间开销缩短到了
**0.3s** ！！！ 这收益无疑是巨大的！

### 为什么快这么多？

事实上锅并不在于 tsup，而是在于 `typescript` 的 `slow types` 的存在。最主要的时间开销是在构建 `dts` 时。
由于 `slow types` 的存在，`typescript` 需要进行大量的类型推断才能确定导出的类型，这导致了构建 `dts` 的时间开销大大增加。

实际上我在做这次迁移时，我在 `tsconfig.json` 中新增了一项配置：`isolatedDeclarations: true`，这项配置要求我们
对于代码中的每一个 `export` ，都需要进行显式的类型声明：

```ts
export const foo = 1 // ❌ Bad
export const foo: number = 1 // ✅ Good

export function foo(a: number, b: number) { // ❌ Bad
  return a + b
}

export function foo(a: number, b: number): number { // ✅ Good
  return a + b
}
```

当每一个 `export` 都有明确的类型声明时，`typescript` 就可以在构建 `dts` 时快速的完成类型推断，从而大大缩短了构建 `dts` 的时间开销。

同时，`tsdown` 使用 `oxc-transform` 生成 `d.ts` 文件，它比 `typescript` 编译器要更快一些。

二者的结合，使得构建时间极大的缩短了。

## 为什么选择 tsdown ？

从目前 `tsdown` 的更新进度而言，说实话我选择它的原因主要是 **秉着尝鲜的态度**。

`tsdown` 基于 `rolldown` 实现，而 `rolldown` 是下一代 `vite` 的底层构建工具，它使用 `rust` 编写，
得益于 `vite` 团队的优秀实践，全新的构建工具 `rolldown` 的性能表现非常出色，它比 `esbuild` 和 `swc` 要更快，
更小的内存开销。

---

---
url: /article/6itrx1jz/index.md
---
# 消除异步传染性
**异步传染性** 是指，当一个函数使用了 `async / await`，其调用者也需要使用 `async / await` 处理异步操作，
这导致了与之相关的整个调用链，都变成了异步的。这种情况可能导致代码变得复杂，不易于维护。

## 概述

在之前的某一个面试中， 恰好遇到了这么一个问题：

> \[!note]
> 我个人是很反感这种类型的面试的，它只会变成面试中的八股文，让人去背答案，
> 但却在大多数的开发场景中，都不会这么去做，甚至于，这道题目本身的答案，可能
> 还会列在开发规范的禁止规则中，以至于无法通过 code-review。
>
> 这道题目虽然可以利用 JavaScript 本身的特性解决，但大多数时候，谁会去这么写代码呢？
> 我是不支持这样去滥用语言特性的，也许你在做一个基础建设时，搭建某些库或框架，不得不去
> 这么做，那么我是支持的，但是，大多数的业务开发，这么写就是在给其他人埋坑。

消除下面代码中的异步传染性， 通过同步调用 打印 正确的结果。

```ts
async function getData() {
  return fetch('/api/data').then(res => res.json())
}

async function foo() {
  // other work
  return await getData()
}

async function bar() {
  // other work
  return await foo()
}

async function main() {
  // other work
  const data = await bar()

  console.log(data)
}

main()
```

期望的结果是：

```ts
function main() {
  // other work
  const data = bar()

  console.log(data) // 打印正确的结果
}
```

这道题目乍一看， `data` 的源头是从 `getData()` 中，调用 服务接口获取的，需要等待 服务器响应后才能
获取数据，那又怎么做到 同步执行获取结果呢？

## 解决方案

在代码中，可以看到，最初的异步是从 `getData()` 函数中的 `fetch()` 发起的，想要解决这个问题，就需要
从这里开始下手。

试想一下，`fetch()` 获取数据结果必然是需要等待时间的，除非它立即抛出了错误:

```ts
async function getData() {
  const res = fetch('/api/data').then(res => res.json())
  throw new Error('error')
  return res // 演示用，实际情况代码不会这么写，因为这里永远不执行
}
```

此时，如果我们不手动捕获该错误，则会导致程序中断。但是可以看到，抛出错误是 立即执行的，符合 同步执行的要求。

那么我们可以沿着这个思路，继续尝试。

我们可以通过 `try {} catch {}` 手动捕获这个错误，然后继续执行其他的代码。但是，应该捕获什么样的错误，才是
我们想要的呢？ 如果仅仅是抛出一个 普通的 请求错误，或者是 执行时错误，这对于 我们的问题 没有任何的用处，
因为它们不能告诉我们 数据准备好了。

那么，谁能告诉我们 数据准备好了？ 还是 只有 `fetch()` 返回给我们的 `Promise` 才能告诉我们数据准备好了。
既然如此，那么我们就直接将 这个 `Promise` 作为 错误抛出，然后再重新捕获它不就好了吗？

```ts
async function getData() {
  const res = fetch('/api/data').then(res => res.json())
  throw res
  return res // 演示用，实际情况代码不会这么写，因为这里永远不执行
}

function main() {
  // other work
  try {
    const data = getData()
    console.log(data)
  }
  catch (err) {
    if (err instanceof Promise) {
      // do something
    }
  }
}
```

接着，我们可以在 `catch` 块中， 检查 `Promise` 是不是有返回结果。这样我们就可以知道 数据是否准备好了。

但是，知道数据准备好了，然后呢？`main()` 方法已经执行完毕了， `console.log(data)` 并没有被执行到。
由此产生了下面的问题：

* 如何让 `console.log(data)` 执行?
* 数据准备好又该从哪里去拿？

重新执行必然需要重新调用 `main()` 函数，但是 重新调用 `main()` 函数，又必然重新抛出错误。
因此，还需要 让 `getData()` 知道什么时候该抛出错误，什么时候不需要抛出错误。

我们可以 增加一个 缓存机制， 当 `Promise` 状态从 `pending` 变更后，将结果 缓存起来。
然后在 `getData()` 中，判断 是否有 缓存，有缓存就直接返回 缓存结果。
当然还有最重要的一步， 将 `Promise` 状态从 `pending` 变更后，需要重新调用一次 `main()` 函数。

```ts
// 缓存数据
let cache = null

function getData() {
  // 发现有缓存立即返回 缓存数据
  if (cache) {
    if (cache.status === 'fulfilled') {
      return cache.data
    }
    else {
      throw new Error(cache.reason)
    }
  }
  const res = fetch('/api/data').then(res => res.json())
  throw res
}

function main() {
  // other work
  try {
    const data = getData()
    console.log(data)
  }
  catch (err) {
    // 捕获 `getData`抛出的错误， 判断 err 是不是 `Promise`
    if (err instanceof Promise) {
      // 对结果进行缓存
      err
        .then(
          (data) => {
            cache = {
              status: 'fulfilled',
              data,
            }
          },
          (reason) => {
            cache = {
              status: 'rejected',
              reason,
            }
          },
        )
        // 重新调用 `main()`
        .finally(() => main())
    }
  }
}
```

::: note
这不能作为最终答案，因为它对 `getData()` 和 `main()` 做了太多的改动。
实际上的答案应该将这部分改写的逻辑封装到一个单独的函数中。

这里就不给出实现代码的示例了，不妨自己尝试一下？
:::

将 `fetch` 部分 替换为一个 假数据接口来进行测试：

```ts
function sleep(num, func) {
  return new Promise((resolve) => {
    setTimeout(() => {
      func?.()
      resolve()
    }, num || 0)
  })
}

async function mockData() {
  await sleep(100)
  return { a: 1 }
}

// 缓存数据
let cache = null

function getData() {
  // 发现有缓存立即返回 缓存数据
  if (cache) {
    if (cache.status === 'fulfilled') {
      return cache.data
    }
    else {
      throw new Error(cache.reason)
    }
  }
  const res = mockData()
  throw res
}

function main() {
  // other work
  try {
    const data = getData()
    console.log(data)
  }
  catch (err) {
    // 判断 错误是不是 `Promise`
    if (err instanceof Promise) {
      // 对结果进行缓存
      err
        .then(
          (data) => {
            cache = {
              status: 'fulfilled',
              data,
            }
          },
          (reason) => {
            cache = {
              status: 'rejected',
              reason,
            }
          },
        )
        // 重新调用 `main()`
        .finally(main)
    }
  }
}

main()
```

> \[!tip]
> 你可以直接复制这段代码到 浏览器的控制台中直接运行，看看结果。

::: code-tabs
@tab Console

```txt
{ a: 1 }
```

:::

## 总结

从代码角度分析，实现的同步执行获取结果的过程中，利用的是 抛出错误会阻断后续代码的执行，
然后捕获错误，在 `catch` 中 等待 异步结果并缓存，最后再重新调用 `main()` 函数，直接返回 缓存结果。

实现了 看似同步执行的结果。实际上， `main()` 函数执行了两次，这就产生了副作用。

如果 `main()` 函数内容 在 `getData()` 调用之前的代码中， 包含了会影响外部作用域的代码，
那么两次执行 `main()` 就可能产生意想不到的影响。

于是，这就又要求了 在 `main()` 的整个调用链上的函数，应该都是 纯函数，不应该有副作用。

---

---
url: /article/6lgzinfk/index.md
---
# React 原理解析：Fiber 架构与双缓冲机制
## Fiber 架构的核心概念

### Fiber 节点的本质

Fiber 节点是 React 16 引入的核心架构元素，它代表了 **组件树中的工作单元** 。
每个 Fiber 节点对应一个 React 元素，构成了一种 **基于链表的虚拟 DOM 实现**。

```javascript
function FiberNode(tag, pendingProps, key, mode) {
  // 树形结构指针
  this.return = null // 指向父节点
  this.child = null // 指向第一个子节点
  this.sibling = null // 指向下一个兄弟节点
  this.index = 0 // 在父节点中的索引位置

  // 静态数据结构
  this.tag = tag // 组件类型标记
  this.key = key // 唯一标识
  this.elementType = null // 元素类型
  this.type = null // 实际类型（函数/类/DOM标签）
  this.stateNode = null // 关联的DOM节点

  // 动态工作单元
  this.pendingProps = pendingProps // 待处理props
  this.memoizedProps = null // 已应用的props
  this.memoizedState = null // 当前状态
  this.updateQueue = null // 状态更新队列
  this.flags = NoFlags // 生命周期标记
  this.subtreeFlags = NoFlags // 子树标记
  this.lanes = NoLanes // 优先级标记
}
```

### Fiber 的三重含义

Fiber 架构包含三个维度的设计理念：

1. **架构层面**：取代传统递归更新（Stack Reconciler）的 **可中断异步架构**
2. **静态数据结构**：表示组件树结构的 **链表节点**
3. **动态工作单元**：封装组件状态、副作用和更新操作的 **执行单元**

这种设计使 React 能够将渲染工作拆分为可增量执行的小任务单元，实现时间切片和优先级调度。

## 双缓冲技术解析

### 双缓冲核心概念

双缓冲（Double Buffering）是一种图形渲染优化技术，在 React 中应用为：

* **当前树（Current Tree）**：代表屏幕上实际渲染的内容
* **工作树（WorkInProgress Tree）**：内存中构建的新树，用于准备下一次更新

两棵树通过 `alternate` 属性相互引用：

```javascript
current.alternate = workInProgress
workInProgress.alternate = current
```

### 双缓冲工作流程

```mermaid
graph TD
    A[开始] --> B{阶段}
    B -->|首次渲染| C[创建FiberRoot]
    C --> D[构建WorkInProgress树]
    D --> E[提交渲染]
    E --> F[切换Current指针]

    B -->|状态更新| G[创建新WorkInProgress树]
    G --> H[复用节点/Diff算法]
    H --> I[提交更新]
    I --> F

    F --> J[结束]
```

## 首次渲染（Mount）流程

### 关键数据结构

```mermaid
classDiagram
    class FiberRootNode {
        +current: FiberNode
        +containerInfo: DOMContainer
    }

    class FiberNode {
        +tag: number
        +key: string
        +stateNode: DOMNode
        +alternate: FiberNode
        +return: FiberNode
        +child: FiberNode
        +sibling: FiberNode
    }

    FiberRootNode --> FiberNode : current
    FiberNode --> FiberNode : alternate
```

### 挂载过程

```javascript
// 创建应用根节点
const root = ReactDOM.createRoot(document.getElementById('root'))

// 内部执行流程
function createFiberRoot() {
  const root = new FiberRootNode()
  const hostRootFiber = createHostRootFiber()

  // 建立关联
  root.current = hostRootFiber
  hostRootFiber.stateNode = root

  return root
}
```

1. **初始化阶段**：

   * 创建 `fiberRootNode`（应用根节点）
   * 创建 `hostRootFiber`（组件树根节点）
   * 建立相互引用关系

2. **渲染阶段**：

   * 基于组件 JSX 深度优先构建 WorkInProgress 树
   * 新节点与 current 树节点建立 `alternate` 关联

3. **提交阶段**：

   * 将 WorkInProgress 树渲染到 DOM
   * 切换 `fiberRootNode.current` 指向新树
   * WorkInProgress 树变为 Current 树

## 更新（Update）流程

### 更新触发机制

当组件状态变更触发更新：

```jsx
function Counter() {
  const [count, setCount] = useState(0)

  return (
    <button onClick={() => setCount(c => c + 1)}>
      Count:
      {' '}
      {count}
    </button>
  )
}
```

### 更新处理流程

```mermaid
sequenceDiagram
    participant User as 用户交互
    participant React as React运行时
    participant Renderer as 渲染器

    User->>React: 触发状态更新
    React->>React: 创建新WorkInProgress树
    React->>React: Diff算法节点复用
    React->>Renderer: 提交更新
    Renderer->>Renderer: DOM操作
    React->>React: 切换Current指针
    React-->>User: 更新完成
```

1. **构建新树**：

   * 基于 current 树创建新 WorkInProgress 树
   * 通过 `alternate` 属性复用现有节点

2. **Diff 算法**：

   * 对比新旧树确定最小变更集
   * 标记需要更新的节点（`flags`）

3. **提交阶段**：

   * 应用 DOM 更新
   * 切换 `fiberRootNode.current` 指针
   * 新树成为 current 树

### 节点复用机制

在更新过程中，React 通过 Diff 算法决定节点复用策略：

```mermaid
flowchart TD
    A[开始更新] --> B{节点是否存在}
    B -->|是| C[检查属性和类型]
    C -->|可复用| D[复用现有节点]
    C -->|不可复用| E[创建新节点]
    B -->|否| F[创建新节点]
    D & E & F --> G[继续处理子节点]
    G --> H[完成更新]
```

## 双缓冲机制的优势

1. **无闪烁更新**：在内存中完成整棵树构建后一次性提交
2. **状态一致性**：确保渲染过程中状态不会部分更新
3. **异步可中断**：允许高优先级任务中断当前渲染
4. **高效回退**：更新失败可回退到完整旧树
5. **资源复用**：节点复用减少内存分配开销

## 总结

React Fiber 架构通过双缓冲机制实现了：

* **增量渲染**：将大型更新拆分为可中断的小任务
* **优先级调度**：确保高优先级交互（如动画）即时响应
* **高效更新**：通过节点复用和精确 DOM 操作优化性能
* **错误隔离**：组件树错误不影响整个应用

双缓冲机制作为核心优化策略，使 React 能够平衡渲染性能与用户体验，为复杂应用提供流畅的交互体验。理解这一机制有助于开发者编写更高效的 React 组件，并深入掌握框架底层原理。

---

---
url: /article/6snk1b6c/index.md
---
# JavaScript 进阶 四： 执行上下文栈
\==理解JavaScript执行上下文栈是掌握JavaScript核心机制的关键一步=={.important}。本文将深入探讨执行上下文栈的工作原理，通过实际代码示例帮助你彻底理解这个重要的概念。

## 什么是执行上下文？

执行上下文是JavaScript代码被评估和执行的环境。它决定了在特定时刻哪些变量、函数和对象是可访问的。

:::info 执行上下文的类型

* **全局执行上下文（GEC）**：当JavaScript开始执行时默认创建，包含全局变量和函数
* **函数执行上下文（FEC）**：每次函数调用时创建，管理函数的局部变量和参数
* **Eval执行上下文**：由`eval()`函数创建（不推荐使用）
  :::

## 执行上下文的两个阶段

每个执行上下文都经历两个主要阶段：

### 1. 创建阶段

```javascript title="创建阶段示例"
console.log(name) // undefined
var name = '张三'
console.log(name) // "张三"
```

在创建阶段：

* 为变量和函数分配内存
* 变量被初始化为`undefined`
* 函数声明被完全提升到内存中
* 定义作用域链和`this`值

### 2. 执行阶段

在执行阶段：

* 代码逐行执行
* 变量被赋予实际值
* 函数被调用执行

## 执行上下文栈（调用栈）

执行上下文栈是JavaScript引擎用来管理执行上下文的数据结构，遵循 **后进先出（LIFO）** 原则。

```javascript
function first() {
  console.log('第一个函数开始')
  second()
  console.log('第一个函数结束')
}

function second() {
  console.log('第二个函数开始')
  third()
  console.log('第二个函数结束')
}

function third() {
  console.log('第三个函数执行')
}

// 执行函数调用
first()
```

## 详细执行流程分析

让我们通过一个具体例子来理解整个执行过程：

```javascript title="执行上下文栈详细示例"
let globalVar = '全局变量'

function outer() {
  let outerVar = '外部变量'

  function inner() {
    let innerVar = '内部变量'
    console.log(innerVar) // 内部变量
    console.log(outerVar) // 外部变量（通过作用域链访问）
    console.log(globalVar) // 全局变量（通过作用域链访问）
  }

  inner()
}

outer()
```

:::steps

* **步骤1**：创建全局执行上下文，压入栈底
  * 变量：`globalVar = undefined`
  * 函数：`outer = function() {...}`
* **步骤2**：执行阶段，`globalVar`被赋值为"全局变量"
* **步骤3**：调用`outer()`，创建函数执行上下文并压入栈顶
* **步骤4**：在`outer()`中创建`inner()`的执行上下文并压入栈顶
* **步骤5**：`inner()`执行完毕，其上下文从栈中弹出
* **步骤6**：`outer()`执行完毕，其上下文从栈中弹出
* **步骤7**：程序结束，全局上下文被清除

:::

## 作用域链与变量查找

JavaScript使用**词法作用域**，这意味着函数的作用域在定义时就已经确定。

```javascript title="作用域链示例"
let x = 10

function parent() {
  let y = 20

  function child() {
    let z = 30
    console.log(x + y + z) // 60
    // JavaScript会沿着作用域链查找变量：
    // 1. 当前上下文（child）→ 2. 父上下文（parent）→ 3. 全局上下文
  }

  child()
}

parent()
```

## 常见的执行上下文问题

### 1. 栈溢出错误

```javascript title="栈溢出示例"
function infiniteRecursion() {
  infiniteRecursion() // 无限递归，导致栈溢出
}

// infiniteRecursion(); // 不要执行这行代码！
```

:::warning 栈溢出预防

* 为递归函数设置明确的终止条件
* 使用尾调用优化（在支持的环境中）
* 对于深度递归，考虑使用迭代解决方案
  :::

### 2. 变量提升的陷阱

```javascript title="变量提升问题"
console.log(a) // undefined
var a = 5

console.log(b) // ReferenceError: Cannot access 'b' before initialization
let b = 10

// 函数声明 vs 函数表达式
sayHello() // "Hello!" - 函数声明被完全提升

function sayHello() {
  console.log('Hello!')
}

sayHi() // TypeError: sayHi is not a function
var sayHi = function () {
  console.log('Hi!')
}
```

## 异步代码与执行上下文栈

:::tip 异步执行机制
JavaScript是单线程的，但通过事件循环机制处理异步操作。异步回调函数会在调用栈为空时执行。
:::

```javascript title="异步执行示例"
console.log('开始')

setTimeout(() => {
  console.log('定时器回调')
}, 0)

console.log('结束')

// 输出顺序：
// 开始
// 结束
// 定时器回调
```

## 调试技巧：查看调用栈

现代浏览器提供了查看调用栈的功能：

```javascript title="调用栈调试"
function functionA() {
  functionB()
}

function functionB() {
  functionC()
}

function functionC() {
  console.trace('当前调用栈') // 在控制台显示调用栈
}

functionA()
```

## 最佳实践

:::important 执行上下文最佳实践

1. **避免深层嵌套**：减少函数调用深度，防止栈溢出
2. **合理使用变量**：理解`var`、`let`、`const`的不同提升行为
3. **注意闭包使用**：闭包会保持对外部变量的引用，可能影响内存
4. **利用作用域**：合理组织代码结构，利用作用域链的优势
   :::

## 总结

执行上下文栈是JavaScript运行时的核心机制：

* 🎯 **执行上下文**为代码执行提供环境
* 🔄 **两个阶段**：创建阶段（内存分配）和执行阶段（代码运行）
* 📚 **调用栈**管理执行上下文的顺序（LIFO原则）
* 🔗 **作用域链**实现变量查找机制
* ⚡ **异步操作**通过事件循环与调用栈协同工作

掌握执行上下文栈的概念，能够帮助你编写更高效、更可预测的JavaScript代码，并在调试时快速定位问题根源。

## 参考

* [MDN - 执行模型](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Execution_model)

---

---
url: /article/73ybcbmj/index.md
---
在团队协作开发中，Git 分支合并策略的选择直接影响代码库的整洁度和可维护性。本文将深入解析 **Git Squash Merge**，并与普通 Merge 和 Rebase Merge 进行详细对比，帮助你选择最适合项目的合并策略。

## 什么是 Git Squash Merge？

Git Squash Merge 是一种特殊的合并方式，它将**多个提交压缩成一个提交**后再合并到目标分支。这种策略特别适用于功能分支开发完成后，希望保持主分支历史线性整洁的场景。

### 基本语法

```bash
# 切换到目标分支（如 main）
git checkout main

# 执行 squash merge
git merge --squash feature-branch

# 提交压缩后的更改
git commit -m "feat: 添加用户认证功能"
```

### 实际工作流程示例

:::steps

* **创建功能分支并开发**

  ```bash
  git checkout -b feature-auth
  # 进行多次提交
  git commit -m "feat: 添加登录表单"
  git commit -m "feat: 实现 JWT 认证"
  git commit -m "fix: 修复登录状态持久化问题"
  ```

* **准备合并到主分支**

  ```bash
  git checkout main
  git merge --squash feature-auth
  ```

* **查看状态并提交**

  ```bash
  git status  # 显示所有更改已暂存
  git commit -m "feat: 完整用户认证功能"
  ```

:::

## 三种合并策略的深度对比

### 1. 普通 Merge（`git merge`）

普通 Merge 是最直接的合并方式，会创建一个**新的合并提交**，保留分支的完整历史。

```bash
git checkout main
git merge feature-branch
```

**历史记录效果：**

```bash
*   a1b2c3d (main) Merge branch 'feature-branch'
|\
| * d4e5f6g feat: 功能C
| * e7f8h9i feat: 功能B
| * f0g1h2j feat: 功能A
|/
* k3l4m5n 之前的提交
```

**优点：**

* 完整保留开发历史
* 便于追踪每个功能的详细演进过程
* 合并冲突处理相对简单

**缺点：**

* 主分支历史可能变得冗长复杂
* 对于小型功能，多个提交可能显得冗余

:::info 适用场景

* 需要完整审计轨迹的大型项目
* 长期存在的功能分支
* 开源项目，需要透明展示贡献者的工作流程
  :::

### 2. Rebase Merge（`git rebase`）

Rebase 通过重新应用提交来重写历史，创建线性的提交序列。

```bash
git checkout feature-branch
git rebase main
git checkout main
git merge feature-branch  # 快进合并
```

**历史记录效果：**

```bash
* m8n9o0p (main) feat: 功能C
* l5m6n7o feat: 功能B
* j2k3l4m feat: 功能A
* k3l4m5n 之前的提交
```

**优点：**

* 创建干净、线性的历史
* 避免不必要的合并提交
* 更容易使用 `git bisect` 进行问题定位

**缺点：**

* 重写历史，可能影响团队协作
* 冲突解决可能更复杂（需要在每个重放提交时解决）
* 不适合已推送到远程的分支

:::warning 注意事项
Rebase 会重写提交历史，==不要对已共享的分支使用 rebase=={.warning}，这会给协作者带来严重困扰。
:::

### 3. Squash Merge（`git merge --squash`）

Squash Merge 结合了两者的优点：保留功能分支的详细开发历史，同时在主分支上保持整洁。

**历史记录效果：**

```bash
* x9y0z1a (main) feat: 完整用户认证功能
* k3l4m5n 之前的提交

# 功能分支仍然保留完整历史
* d4e5f6g (feature-auth) fix: 修复登录状态持久化问题
* e7f8h9i feat: 实现 JWT 认证
* f0g1h2j feat: 添加登录表单
* k3l4m5n 之前的提交
```

**优点：**

* 主分支历史保持简洁清晰
* 功能分支仍保留完整开发过程
* 便于代码审查和问题追踪

**缺点：**

* 丢失了主分支上的详细开发步骤
* 需要手动编写有意义的提交信息
* `git blame` 可能不够精确

:::tips 最佳实践
为压缩后的提交编写==描述性的提交信息=={.success}，概括整个功能的变化，便于后续维护和理解。
:::

## 详细对比表格

| 特性 | 普通 Merge | Rebase Merge | Squash Merge |
|------|------------|--------------|--------------|
| **历史保留** | 完整保留 | 重写历史 | 主分支压缩，功能分支保留 |
| **提交图** | 有合并节点 | 线性 | 线性 |
| **冲突解决** | 一次解决 | 可能多次解决 | 一次解决 |
| **适用分支** | 所有分支 | 本地/私有分支 | 功能分支 |
| **审计能力** | 优秀 | 良好 | 主分支一般，功能分支优秀 |
| **团队影响** | 无 | 可能影响他人 | 无 |

## 实际场景选择指南

### 场景 1：短期功能开发

```bash
# 推荐使用 Squash Merge
git checkout -b feature-payment
# ... 开发过程，多次提交
git checkout main
git merge --squash feature-payment
git commit -m "feat: 集成支付网关（Stripe）"
```

### 场景 2：长期功能分支

```bash
# 推荐使用普通 Merge
git checkout -b refactor-architecture
# ... 数周开发，多人协作
git checkout main
git merge refactor-architecture
```

### 场景 3：个人功能分支，保持线性历史

```bash
# 推荐使用 Rebase
git checkout feature-ui-improvement
git rebase main
git checkout main
git merge feature-ui-improvement
```

## 高级技巧与注意事项

### 1. 配置 Git 默认使用 Squash Merge

```bash title="设置全局配置"
git config --global merge.ff false
git config --global pull.rebase true
```

### 2. 在 GitHub/GitLab 中启用 Squash Merge

:::steps

* 进入仓库设置
* 找到 "Merge requests" 或 "Pull requests" 设置
* 启用 "Squash commits when merging" 选项
* 保存设置

:::

### 3. 处理 Squash Merge 后的分支清理

```bash
# 合并后删除本地分支
git branch -d feature-branch

# 删除远程分支
git push origin --delete feature-branch
```

## 总结

选择合适的 Git 合并策略是团队协作中的重要决策：

* **Squash Merge**：==功能分支开发的黄金标准=={.success}，平衡了历史整洁性和开发过程可追踪性
* **普通 Merge**：适合需要完整审计轨迹的重要功能
* **Rebase Merge**：个人分支整理历史的利器，但需谨慎使用

:::important 核心建议
对于大多数团队项目，推荐采用 **Squash Merge** 作为默认策略，它为代码审查、问题追踪和发布管理提供了最佳平衡点。
:::

通过理解每种策略的特点和适用场景，你的团队可以建立更高效、更规范的 Git 工作流程，提升整体的开发体验和代码质量。

---

---
url: /article/7jzjudus/index.md
---
# 在NodeJs项目中使用ECMAScript module
随着 `Nodejs v16` 成为长期稳定支持的版本，`ESM` 也随之成为 `NodeJs` 正式支持的标准化模块系统，这允许我们通过
`ESM` 来开发我们的 `NodeJs` 项目，并在项目中通过`ESM` 来导入其他的`ESM`包。

## 创建项目

我们以新建一个 NodeJs 项目为例， 它有如下的结构：

```sh
./my-esm-package
├── lib
│   ├── resolve.js
│   └── index.js
└── package.json
```

这个项目的功能是导出一个 resolve 方法，是 `path.resolve` 的封装实现。

::: code-tabs
@tab lib/index.js

```js
export * from './resolve.js'
```

@tab lib/resolve.js

```js
import path from 'node:path'

export const resolve = (...arg) => path.resolve(...arg)
```

:::

## package.json

在 `package.json` 中，我们需要进行以下声明：

* 声明 `type` 字段值为 `module`

  这个字段声明了你的包将作为一个 `ECMAScript module` 被`NodeJs` 加载并解析，并允许使用`.mjs`格式的文件。

* 声明 `exports` 字段

  该字段描述了 项目如何导出模块给到其他包使用。

  * 默认导出

    ::: code-tabs
    @tab package.json

    ```json
    {
      "exports": "./lib/index.js"
    }
    ```

    :::

    即当使用`import { resolve } from 'my-esm-package'`时，默认引入的文件是 `lib/index.js`。

  * 导出多个模块

    ::: code-tabs
    @tab package.json

    ```json
    {
      "exports": {
        ".": "./lib/index.js",
        "resolve": "./lib/resolve.js"
      }
    }
    ```

    :::

    声明了导出了两种模块：一个是默认导出，使用`"."` 作为key；一个是具名导出。

    当使用`import { resolve } from 'my-esm-package'`时，默认引入的文件是 `lib/index.js`。

    当使用`import { resolve } from 'my-esm-package/resolve'` 时，引入的文件是 `lib/resolve.js`。

  * `exports` 还支持其他形式的值，这里暂不赘述。

* 声明 `engines` 字段

  由于 `Nodejs` 并不是全版本支持`esm`的，而是从`v14.16.0`版本开始试验性的支持，并到了`v16`版本才作为正式支持，
  且当前`v16`版本作为目前的长期稳定支持的版本。这个项目运行环境的`NodeJs` 版本，最低应该推荐使用 `v16` 以上的版本。
  即它的值应该为 `{ "node": ">=16" }`

到这里，这个项目的`package.json` 文件，包含以下内容:

::: code-tabs
@tab package.json

```json
{
  "name": "my-esm-package",
  "description": "My first esm package.",
  "type": "module",
  "exports": {
    ".": "./lib/index.js",
    "resolve": "./lib/resolve.js"
  },
  "engines": {
    "node": ">=16"
  }
}
```

:::

## 编写项目代码

1. 由于是一个 `esm` 项目，所以理所当然的不能项目中使用 `require()`/`module.exports` 来导入导出模块。
   而是应该全部使用`import`/`export` 的方式来导入导出模块。

2. 不需要在项目代码中 使用 `use strict`。

3. 由于 `esm` 项目中，`NodeJs` 不再支持 `__dirname`/`__filename`，所以有相关场景需要使用时，需要使用其他的方式来实现相同功能：

```js
import { basename, dirname } from 'node:path'
import { fileURLToPath } from 'node:url'

const _dirname = typeof __dirname !== 'undefined' ? __dirname : dirname(fileURLToPath(import.meta.url))

const _filename = typeof __filename !== 'undefined' ? __filename : basename(fileURLToPath(import.meta.url))
```

## TypeScript

如果在项目中使用了 `TypeScript`，那么除了需要遵循以上的内容，还需要在 `tsconfig.json` 配置文件中补充以下配置：

```json
{
  "module": "node16",
  "moduleResolution": "node16"
}
```

并且，应该将 `.ts` 文件，编译为 `.js` 文件，`package.json` 配置的 `exports` 导出的，是编译后的 `.js` 文件。

## 最后

当完成了以上步骤，就可以得到一个`NodeJs ESM` 项目。它也只能在另一个支持 `esm` 的项目中使用。

---

---
url: /article/84nu27cz/index.md
---
# pnpm 包管理器
`pnpm` 是一款新兴不久的包管理器，相比于 `npm` 和 `yarn`，`pnpm` 拥有更快的安装速度，同时节约磁盘空间。

## 介绍

![pnpm](https://pnpm.io/zh/img/pnpm-no-name-with-frame.svg)

`pnpm` 是一个类似于 `npm` 、`yarn` 的包管理器。

`pnpm` 安装的包都会被存储在硬盘的某个相同位置，软甲包通过硬链接到这个位置，实现共享同一版本的依赖，
对于同一依赖的不同版本，`pnpm update` 时，只会向存储中心添加新版本更新的文件，而不是仅仅应为一个文件的改变而复制整个新版本包的内容。

`pnpm` 内置支持 `monorepo`，即单仓库多包。

## 比较

### pnpm/yarn/npm

| 功能                     |              pnpm              |        yarn        |           npm            |
| ------------------------ | :----------------------------: | :----------------: | :----------------------: |
| 工作空间支持（monorepo） |               ✔️               |         ✔️         |            ✔️            |
| 隔离的`node_modules`     |           ✔️ - 默认            |         ✔️         |            ❌            |
| 提升的`node_modules`     |               ✔️               |         ✔️         |         ✔️ -默认         |
| 自动安装peers            | ✔️ - `auto-install-peers=true` |         ❌         |            ✔️            |
| Plug'n'Play              |               ✔️               |     ✔️ - 默认      |            ❌            |
| 零安装                   |               ❌               |         ✔️         |            ❌            |
| 修复依赖项               |               ✔️               |         ✔️         |            ❌            |
| 管理nodejs版本           |               ✔️               |         ❌         |            ❌            |
| 有锁文件                 |     ✔️ - `pnpm-lock.yaml`      |  ✔️ - `yarn.lock`  | ✔️ - `package-lock.json` |
| 支持覆盖                 |               ✔️               | ✔️ - `resolutions` |            ✔️            |
| 内容可寻址存储           |               ✔️               |         ❌         |            ❌            |
| 动态包执行               |        ✔️ - `pnpm dlx`         |  ✔️ - `yarn dlx`   |        ✔️ - `npx`        |
| Side-effects cache       |               ✔️               |         ❌         |            ❌            |

### 区别

与 `yarn/npm` 不同的是，`pnpm` 并非采用 *扁平的`node_modules`* 来管理依赖项，
而是基于符号链接的`node_modules` 结构。

`node_modules` 中每个包的每个文件都是来自内容可寻址存储的硬链接。 假设安装了依赖于 `bar@1.0.0` 的 `foo@1.0.0`。 `pnpm` 会将两个包硬链接到 `node_modules` 如下所示：

```sh
node_modules
└── .pnpm
    ├── bar@1.0.0
    │   └── node_modules
    │       └── bar -> <store>/bar
    │           ├── index.js
    │           └── package.json
    └── foo@1.0.0
        └── node_modules
            └── foo -> <store>/foo
                ├── index.js
                └── package.json
```

这是 `node_modules` 中的唯一的“真实”文件。 一旦所有包都硬链接到 `node_modules`，
就会创建符号链接来构建嵌套的依赖关系图结构。

`bar` 将被符号链接到 `foo@1.0.0/node_modules` 文件夹，然后处理依赖关系，`foo` 将被符号链接至根目录的 `node_modules` 文件夹:

```sh
node_modules
├── foo -> ./.pnpm/foo@1.0.0/node_modules/foo
└── .pnpm
    ├── bar@1.0.0
    │   └── node_modules
    │       └── bar -> <store>/bar
    └── foo@1.0.0
        └── node_modules
            ├── foo -> <store>/foo
            └── bar -> ../../bar@1.0.0/node_modules/bar
```

这种布局的好处在于，只有真正在依赖项中的包才能访问。
如果是平铺的 `node_modules` 结构，所有被提升的包都可以访问。

### 优势

* 节约磁盘空间

  包存储在全局存储中，pnpm 创建从全局存储到项目下 `node_modules` 文件夹的 硬链接，硬链接指向磁盘上原始文件所在的同一位置。不同软件包可以共享相同依赖项所占用的空间。

  如果是单个依赖的不同版本，如版本更新，`pnpm` 仅安装版本更新的文件，而不是全量安装整个新版本的包。

* 安装速度快

  软件包中安装依赖时，如果检索到在本地的全局存储中已安装过该依赖，那么不会从网络下重新安装，而是直接创建硬链接到软件包中。

* 内置支持 monorepo

  支持 单仓库多包，通过 `pnpm-workspace.yaml` 配置工作空间，通过 `workspace:*` 协议引用工作空间的依赖包。

## 安装

### 通过 npm 安装

```sh
npm install -g pnpm
```

### 通过 Corepack 安装

从 v16.13 开始，Node.js 发布了 `Corepack` 来管理包管理器。 这是一项实验性功能，因此需要通过运行如下脚本来启用它：

```sh
corpack enabled
```

这将自动在系统上安装 pnpm。 但是，它可能不是最新版本的 pnpm。
若要升级，请检查 [最新的 pnpm 版本](https://github.com/pnpm/pnpm/releases/tag/v7.9.1) 并运行：

```sh
corepack prepare pnpm@<version> --activate
```

### 使用独立脚本安装

在 POSIX 系统上，即使没有安装 Node.js，也可以使用以下脚本安装 pnpm：

```sh
curl -fsSL https://get.pnpm.io/install.sh | sh -
```

如果没有安装 `curl` ，也可以使用 `wget`:

```sh
wget -qO- https://get.pnpm.io/install.sh | sh -
```

在 Windows 系统中，如果使用 Powershell:

```sh
iwr https://get.pnpm.io/install.ps1 -useb | iex
```

### 使用 Homebrew 安装

```sh
brew install pnpm
```

### 使用 Scoop 安装

```sh
scoop install nodejs-lts pnpm
```

## 使用

`pnpm` 在使用上 与 `npm` 、`yarn` 的使用上差别不大，但需要注意的区别，`pnpm` 会严格校验所有参数，
比如，`pnpm install --target_arch x64` 会执行失败，因为 `--target_arch x64` 不是 `pnpm install` 的有效参数。

### 常用命令

#### `pnpm install`

别名 `pnpm i`

等效于 `npm install` / `yarn`

用于安装项目所有依赖。

[pnpm install 官方文档](https://pnpm.io/zh/cli/install)

#### `pnpm add <pkg>`

安装软件包及其依赖的任何软件包。 默认情况下，任何新软件包都安装为生产依赖项。

[pnpm add 官方文档](https://pnpm.io/zh/cli/add)

#### `pnpm remove`

别名： `rm` `uninstall` `un`

从 `node_modules` 和项目的 `package.json` 中删除相关 packages。

[pnpm remove 官方文档](https://pnpm.io/zh/cli/remove)

#### `pnpm update`

别名： `up` `upgrade`

`pnpm update` 根据指定的范围更新软件包的最新版本。

在不带参数的情况下使用时，将更新所有依赖关系。 您可以使用一些模式来更新特定的依赖项。

[pnpm update 官方文档](https://pnpm.io/zh/cli/update)

更多命令请查阅[官方文档](https://pnpm.io/zh/cli/add)

### 配置

#### `.npmrc`

`pnpm` 从命令行、环境变量和 `.npmrc` 文件中获取其配置。

`pnpm config` 命令可用于更新和编辑 用户和全局 .npmrc 文件的内容。

四个相关文件分别为：

* 每个项目的配置文件（`/path/to/my/project/.npmrc`）
* 每个工作区的配置文件（包含 `pnpm-workspace.yaml` 文件的目录）
* 每位用户的配置文件（ `~/.npmrc` ）
* 全局配置文件（ `/etc/.npmrc` ）

#### `pnpm-workspace.yaml`

`pnpm-workspace.yaml` 定义了 工作空间 的根目录，并能够使工作空间中包含 / 排除目录 。 默认情况下，包含所有子目录。

```yaml
packages:
  # 定义 packages 目录下的所有子目录都为一个 package
  - 'packages/*'
  # 定义 components 目录下的所有子目录都为一个 package
  - 'components/**'
  # 排除任何目录中的 test 目录下的所有目录
  - '!**/test/**'
```

## 工作空间

pnpm 内置了对单一存储库（也称为多包存储库、多项目存储库或单体存储库）的支持， 你可以创建一个 workspace 以将多个项目合并到一个仓库中。

一个 workspace 的根目录下必须有 `pnpm-workspace.yaml` 文件， 也可能会有 `.npmrc` 文件。

### Workspace 协议 (workspace:)

默认情况下，如果可用的 packages 与已声明的可用范围相匹配，pnpm 将从工作区链接这些 packages。
例如，如果 `bar` 中有 `"foo"："^1.0.0"` 的这个依赖项，则 `foo@1.0.0` 链接到 `bar` 。
但是，如果 `bar` 的依赖项中有 `"foo": "2.0.0"`，而 `foo@2.0.0` 在工作空间中并不存在，则将从 `npm registry` 安装 `foo@2.0.0` 。 这种行为带来了一些不确定性。

幸运的是，pnpm 支持 workspace 协议 `workspace:` 。
当使用此协议时，pnpm 将拒绝解析除本地 workspace 包含的 package 之外的任何内容。
因此，如果设置为 `"foo": "workspace:2.0.0"` 时，安装将会失败，因为 `"foo@2.0.0"` 不存在于此 workspace 中。

使用示例：

工作空间中存在以下项目：

```sh
+ packages/
  + foo/
  + bar/
  + qar/
  + zoo/
```

如果各个项目以其目录名作为其 package name，那么可以在其他项目中如下引入依赖：

```json
{
  "dependencies": {
    "foo": "workspace:*",
    "bar": "workspace:~",
    "qar": "workspace:^",
    "zoo": "workspace:^1.5.0"
  }
}
```

::: tip
引入依赖的包名，是由包的 `package.json name` 确定，而不是 workspace 目录下的目录名确定。
:::

### 发布 Workspace

当以上示例进行发布时，会被转换为

```json
{
  "dependencies": {
    "foo": "1.5.0",
    "bar": "~1.5.0",
    "qar": "^1.5.0",
    "zoo": "^1.5.0"
  }
}
```

这个功能允许你发布转化之后的包到远端，并且可以正常使用本地 workspace 中的 packages，而不需要其它中间步骤。包的使用者也可以像常规的包那样正常使用，且仍然可以受益于语义化版本。

---

---
url: /article/8givn0nz/index.md
---
## 什么是 CDN？

CDN（Content Delivery Network，内容分发网络）是一种构建在现有网络基础之上的智能虚拟网络。它通过将内容分发到全球各地的边缘节点，使用户能够就近获取所需内容，从而显著提升访问速度和稳定性。

## CDN 工作原理深度解析

### 1. 传统访问 vs CDN 访问

**传统访问模式：**

```
用户 → DNS 解析 → 源站服务器 → 返回内容
```

**CDN 访问模式：**

```
用户 → DNS 解析 → CDN 智能调度 → 最优边缘节点 → 返回内容
```

### 2. CDN 工作流程详解

```javascript
// 模拟 CDN 访问决策过程
class CDNRequest {
  constructor(userLocation, resourceType) {
    this.userLocation = userLocation
    this.resourceType = resourceType
    this.edgeNodes = this.getAvailableNodes()
  }

  // 获取可用边缘节点
  getAvailableNodes() {
    return [
      { id: 'node-us-west', location: 'US', load: 0.3, latency: 50 },
      { id: 'node-eu-central', location: 'EU', load: 0.2, latency: 80 },
      { id: 'node-asia-east', location: 'Asia', load: 0.4, latency: 30 }
    ]
  }

  // 智能路由选择
  selectOptimalNode() {
    return this.edgeNodes
      .filter(node => node.load < 0.8)
      .sort((a, b) => a.latency - b.latency)[0]
  }

  // 缓存检查
  checkCache(node, resourceKey) {
    const cacheStatus = node.cache?.[resourceKey]
    if (cacheStatus && !this.isCacheExpired(cacheStatus)) {
      return 'HIT' // 缓存命中
    }
    return 'MISS' // 缓存未命中
  }

  // 处理请求
  async processRequest(resourceKey) {
    const optimalNode = this.selectOptimalNode()
    const cacheStatus = this.checkCache(optimalNode, resourceKey)

    if (cacheStatus === 'HIT') {
      return this.serveFromEdge(optimalNode, resourceKey)
    }
    else {
      return await this.fetchFromOrigin(optimalNode, resourceKey)
    }
  }
}
```

### 3. 核心技术组件

#### DNS 智能解析

```bash
# 传统 DNS 解析
dig example.com
# 返回：93.184.216.34

# CDN DNS 解析
dig cdn.example.com
# 根据用户位置返回最近节点 IP：
# 美国用户：104.16.123.96
# 欧洲用户：172.67.68.240
# 亚洲用户：104.18.24.97
```

#### 缓存策略

```http
# HTTP 缓存头示例
Cache-Control: public, max-age=3600
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
```

## CDN 的核心优势

### 1. 性能提升

* **降低延迟**：边缘节点距离用户更近，减少网络传输时间
* **提高吞吐量**：分布式架构支持更高并发访问
* **优化首屏时间**：静态资源快速加载提升用户体验

### 2. 可靠性增强

* **负载均衡**：自动将流量分发到健康节点
* **故障转移**：单个节点故障不影响整体服务
* **DDoS 防护**：分布式架构天然具备抗攻击能力

### 3. 成本优化

```javascript
// 带宽成本对比示例
function calculateCostSavings(monthlyTraffic, originBandwidthCost, cdnCost) {
  const originCost = monthlyTraffic * originBandwidthCost
  const cdnTotalCost = monthlyTraffic * cdnCost
  const savings = originCost - cdnTotalCost

  return {
    originCost: `$${originCost.toFixed(2)}`,
    cdnCost: `$${cdnTotalCost.toFixed(2)}`,
    savings: `$${savings.toFixed(2)}`,
    savingsPercentage: `${((savings / originCost) * 100).toFixed(1)}%`
  }
}

// 示例：1TB 流量成本对比
console.log(calculateCostSavings(
  1000, // 1TB 流量
  0.08, // 源站带宽成本 $0.08/GB
  0.03 // CDN 成本 $0.03/GB
))
// 输出：{ originCost: "$80.00", cdnCost: "$30.00", savings: "$50.00", savingsPercentage: "62.5%" }
```

### 4. 安全性提升

* **SSL/TLS 终端**：在边缘节点处理加密解密
* **WAF 集成**：Web 应用防火墙保护
* **防盗链**：防止资源被非法站点引用

## 前端开发中的 CDN 应用场景

### 1. 静态资源加速

```html
<!-- 传统方式 -->
<script src="/js/app.js"></script>
<link rel="stylesheet" href="/css/style.css">

<!-- CDN 优化方式 -->
<script src="https://cdn.example.com/js/app.v2.min.js"></script>
<link rel="stylesheet" href="https://cdn.example.com/css/style.v2.min.css">
```

### 2. 图片和媒体文件优化

```javascript
// 图片 CDN 最佳实践
class ImageOptimizer {
  constructor(cdnBaseUrl) {
    this.cdnBaseUrl = cdnBaseUrl
  }

  // 生成优化后的图片 URL
  generateOptimizedUrl(originalUrl, options = {}) {
    const params = new URLSearchParams()

    if (options.width)
      params.append('w', options.width)
    if (options.quality)
      params.append('q', options.quality)
    if (options.format)
      params.append('fm', options.format)

    const queryString = params.toString()
    const encodedUrl = encodeURIComponent(originalUrl)

    return `${this.cdnBaseUrl}/${encodedUrl}${queryString ? `?${queryString}` : ''}`
  }
}

// 使用示例
const optimizer = new ImageOptimizer('https://img-cdn.example.com')
const optimizedImage = optimizer.generateOptimizedUrl(
  '/products/phone.jpg',
  { width: 800, quality: 85, format: 'webp' }
)
// 输出：https://img-cdn.example.com/%2Fproducts%2Fphone.jpg?w=800&q=85&fm=webp
```

### 3. 前端框架和库的 CDN 使用

```html
<!-- 生产环境使用 CDN -->
<script src="https://cdn.jsdelivr.net/npm/vue@3.2.47/dist/vue.global.prod.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>

<!-- 配合 fallback 机制 -->
<script>
  if (typeof Vue === 'undefined') {
    document.write('<script src="/lib/vue.global.prod.js"><\/script>');
  }
</script>
```

### 4. 单页应用（SPA）部署

```nginx
# CDN 配置示例：SPA 路由支持
location / {
    try_files $uri $uri/ /index.html;
}

# 静态资源长期缓存
location /static/ {
    expires 1y;
    add_header Cache-Control "public, immutable";
}

# API 请求不缓存
location /api/ {
    proxy_pass http://api-backend;
    expires -1;
    add_header Cache-Control "no-cache";
}
```

## CDN 配置最佳实践

### 1. 缓存策略配置

```javascript
// 不同资源类型的缓存策略
const cacheStrategies = {
  static: {
    'Cache-Control': 'public, max-age=31536000, immutable',
    'CDN-Cache-Control': 'public, max-age=31536000'
  },
  dynamic: {
    'Cache-Control': 'no-cache',
    'CDN-Cache-Control': 'max-age=0'
  },
  html: {
    'Cache-Control': 'public, max-age=300',
    'CDN-Cache-Control': 'max-age=300'
  }
}

// 根据文件类型应用缓存策略
function setCacheHeaders(res, fileType) {
  const strategy = cacheStrategies[fileType] || cacheStrategies.dynamic
  Object.entries(strategy).forEach(([header, value]) => {
    res.setHeader(header, value)
  })
}
```

### 2. 版本控制和缓存刷新

```bash
# 文件版本化，避免缓存问题
app.v1.2.3.js -> app.v1.2.4.js

# CDN 缓存刷新
curl -X POST "https://api.cdnprovider.com/purge" \
  -H "Authorization: Bearer $API_KEY" \
  -d '{"files":["/js/app.v1.2.3.js"]}'
```

## 性能监控和优化

### 1. CDN 性能指标监控

```javascript
// 使用 Performance API 监控 CDN 性能
class CDNPerformanceMonitor {
  constructor() {
    this.metrics = {}
  }

  measureResourceTiming() {
    const resources = performance.getEntriesByType('resource')

    resources.forEach((resource) => {
      if (resource.name.includes('cdn')) {
        this.metrics[resource.name] = {
          dnsTime: resource.domainLookupEnd - resource.domainLookupStart,
          connectTime: resource.connectEnd - resource.connectStart,
          ttfb: resource.responseStart - resource.requestStart,
          downloadTime: resource.responseEnd - resource.responseStart,
          totalTime: resource.duration
        }
      }
    })

    return this.metrics
  }

  // 报告性能问题
  reportIssues() {
    const issues = []

    Object.entries(this.metrics).forEach(([url, timing]) => {
      if (timing.ttfb > 1000) {
        issues.push(`高延迟: ${url} - TTFB: ${timing.ttfb}ms`)
      }
      if (timing.downloadTime > 3000) {
        issues.push(`下载缓慢: ${url} - 下载时间: ${timing.downloadTime}ms`)
      }
    })

    return issues
  }
}
```

## 总结

CDN 已经成为现代前端开发不可或缺的基础设施，它通过：

1. **智能内容分发**：将内容缓存在离用户最近的节点
2. **性能优化**：显著降低延迟，提高加载速度
3. **成本效益**：减少源站带宽压力，优化成本结构
4. **可靠性保障**：提供高可用性和抗攻击能力

对于前端开发者来说，合理利用 CDN 可以：

* 提升用户体验和核心业务指标
* 简化部署和运维复杂度
* 增强应用的安全性和稳定性

## 相关阅读

[MDN Web Docs: HTTP 缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching){.read-more}
[Google Web Fundamentals: 缓存](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching){.read-more}
[CDN 性能测试工具: WebPageTest](https://www.webpagetest.org/){.read-more}

\[各大 CDN 提供商文档：Cloudflare、Akamai、AWS CloudFront]

通过深入理解 CDN 的工作原理和最佳实践，前端开发者可以更好地利用这一强大工具，为用户提供更快、更稳定的 Web 体验。

---

---
url: /article/8kq3oe32/index.md
---
# React 渲染机制解析：从调度到提交
## 核心概念回顾

在深入渲染流程前，先回顾 Fiber 架构的三个核心模块：

* **Scheduler（调度器）**：基于任务优先级调度任务执行顺序
* **Reconciler（协调器）**：计算新旧虚拟 DOM 树的差异
* **Renderer（渲染器）**：将更新后的虚拟 DOM 转换为实际 UI

这三个模块共同构成了 React 高效灵活的渲染机制。下面通过完整渲染流程解析它们如何协同工作。

## 整体渲染流程概述

React 渲染流程分为两个关键阶段：

```mermaid
graph LR
    A[Scheduler] --> B[Reconciler]
    B --> C[Renderer]
    style A fill:#b8e0b1,stroke:#388E3C
    style B fill:#a3c1e0,stroke:#1976D2
    style C fill:#e3e14d,stroke:#F57C00
```

1. **Render 阶段（协调阶段）**：Reconciler 负责调用组件渲染方法，构建 Fiber 树
2. **Commit 阶段（渲染阶段）**：Renderer 将变更同步应用到真实 DOM

### 示例场景分析

```jsx
export default function CounterApp() {
  const [count, setCount] = useState(0)

  const increment = () => setCount(prev => prev + 1)

  return (
    <div className="counter">
      <h3>
        当前计数:
        {count}
      </h3>
      <button onClick={increment}>增加</button>
    </div>
  )
}
```

当用户点击按钮触发状态更新时：

1. Scheduler 接收更新任务并调度执行
2. Reconciler 计算变更并标记需要更新的部分
3. Renderer 将变更同步应用到真实 DOM

```mermaid
flowchart LR
  I(点击 button<br>count = count + 1)
  Scheduler(**Scheduler**<br>接收到更新，开始调度<br>*没有更高的优先级更新，把 count=count+1交给Reconciler*)
  Reconciler(**Reconciler**<br>接收到更新，计算更新<br>*h3>0 变更为 h3>1 并打上标记 update，把打了标记的 VDom交给 Renderer*)
  Renderer(**Renderer**<br>接收到更新，根据 update 标记执行操作<br>*h3标记了 update，对其执行 DOM 更新操作*)
  I --> Scheduler
  subgraph 随时可以被中断
  Scheduler --> Reconciler
  end
  Reconciler --> Renderer

  style Scheduler fill:#b8e0b1,stroke:#388E3C
  style Reconciler fill:#a3c1e0,stroke:#1976D2
  style Renderer fill:#e3e14d,stroke:#F57C00
```

## 调度器（Scheduler）工作原理

Scheduler 是 React 16 引入的调度系统，核心作用是管理任务优先级和执行时机。虽然浏览器提供了 `requestIdleCallback` API，但 React 基于以下原因实现了自定义调度器：

1. **浏览器兼容性问题**：部分浏览器不支持 `requestIdleCallback`
2. **触发频率不稳定**：原生 API 受多种因素影响
3. **优先级控制需求**：需要更细粒度的任务优先级管理

```mermaid
flowchart TD
    A[高优先级任务] --> B[调度队列]
    C[低优先级任务] --> B
    B --> D{当前帧是否有空闲时间？}
    D -- 是 --> E[执行任务]
    D -- 否 --> F[等待下一帧]
```

Scheduler 采用 **时间切片（Time Slicing）** 技术，将任务分解为小块，在浏览器空闲时执行，避免阻塞主线程。

## 协调器（Reconciler）与 Render 阶段

### 可中断的协调过程

React 16 将协调过程从递归改为可中断的循环：

```js
// 同步模式工作循环
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress)
  }
}

// 并发模式工作循环
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress)
  }
}
```

* `workInProgress`：当前正在处理的 Fiber 节点
* `shouldYield()`：检查当前帧是否有剩余时间
* `performUnitOfWork()`：处理当前 Fiber 节点并连接后续节点

### Fiber 节点处理流程

`performUnitOfWork` 采用深度优先遍历（DFS）策略，分为两个阶段：

```mermaid
sequenceDiagram
    participant Root
    participant A as 组件A
    participant B as 组件B
    participant C as 组件C
    participant D as 叶子组件

    Root->>A: beginWork（递）
    A->>B: beginWork（递）
    B->>C: beginWork（递）
    C->>D: beginWork（递）
    D-->>C: completeWork（归）
    C-->>B: completeWork（归）
    B->>A: 同级节点处理
    A-->>Root: completeWork（归）
```

1. **递阶段（beginWork）**：

   * 从根节点开始深度优先遍历
   * 为每个 Fiber 节点调用 `beginWork`
   * 创建子节点并建立连接
   * 到达叶子节点后进入归阶段

2. **归阶段（completeWork）**：

   * 收集副作用（如 DOM 更新需求）
   * 存在兄弟节点则进入兄弟节点的递阶段
   * 不存在兄弟节点则返回父节点继续归阶段
   * 最终回到根节点完成协调

::: info **设计细节**
Fiber 节点指向父节点的字段名为 `return` 而非 `parent`，因为从子节点角度看，完成工作后是"返回"到父节点继续工作。
:::

## 渲染器（Renderer）与 Commit 阶段

当协调阶段完成，进入不可中断的 Commit 阶段。此阶段将协调结果提交到真实 DOM，分为三个子阶段：

```mermaid
flowchart TD
    A[Commit 阶段] --> B[Before Mutation]
    B --> C[Mutation]
    C --> D[Layout]
    D --> E[结束]
```

### 1. Before Mutation 阶段（DOM 操作前）

* 处理 DOM 渲染/删除后的自动聚焦逻辑
* 调用 `getSnapshotBeforeUpdate` 生命周期
* 调度 `useEffect`

### 2. Mutation 阶段（执行 DOM 操作）

* 根据协调结果执行 DOM 增删改操作
* 解绑旧节点的 ref 引用
* 执行函数组件的销毁清理函数

### 3. Layout 阶段（DOM 操作后）

* 绑定新节点的 ref 引用
* 调用 `componentDidMount`/`componentDidUpdate`
* 执行 `useLayoutEffect` 回调

### 完整 Commit 流程

```mermaid
sequenceDiagram
    participant React
    participant DOM

    React->>DOM: Before Mutation
    Note over React: 准备阶段操作
    React->>DOM: Mutation（DOM 操作）
    Note over DOM: 实际DOM更新
    React->>DOM: Layout
    Note over React: 布局相关操作
    React->>React: 后续处理
    Note over React: useEffect调度等
```

## 关键设计优势

1. **可中断渲染**：
   * Scheduler 和 Reconciler 工作可被高优先级任务中断
   * 所有计算在内存中进行，不会显示中间状态

2. **双缓存机制**：
   * 内存中同时存在两棵 Fiber 树（current 和 workInProgress）
   * 减少界面闪烁，提升用户体验

3. **副作用隔离**：
   * 协调阶段收集副作用（effect）
   * 提交阶段统一执行副作用

## 总结

React 的渲染流程通过精密的模块化设计实现高效渲染：

1. **Scheduler** 智能调度任务，优先处理用户交互
2. **Reconciler** 使用可中断的 DFS 遍历计算变更
3. **Renderer** 通过三阶段提交保证 DOM 更新一致性

```mermaid
flowchart TD
    A[交互事件] --> B[Scheduler]
    B --> C{高优先级?}
    C -- 是 --> D[中断当前任务]
    C -- 否 --> E[Reconciler]
    E --> F[Render阶段]
    F --> G[Commit阶段]
    G --> H[DOM更新]
```

这种架构使 React 能够平衡响应性和性能，在复杂应用场景下仍能保持流畅的用户体验。理解这些底层机制对于优化 React 应用性能和解决渲染相关问题至关重要。

---

---
url: /article/8rv45yuy/index.md
---
# HTML5新特性
## 语义标签

如 `<header>` `<footer>` `<nav>` `<section>` `<article>` `<aside>` `<details>` `<summary>`
`<dialog>` `<figure>` `<main>` `<mark>` `<time>` `<hgroup>` 等

## 增强型表单

### 新增表单元素

`<detailist>` ：数据列表，为input提供输入建议列表

`<progress>`：进度条，展示连接/下载进度

`<meter>`：刻度尺/度量衡，描述数据所处的阶段，红色(危险)=>黄色(警告)=>绿色(优秀)

`<output>`：输出内容，语义上表示此处的数据是经过计算而输出得到的

其他

### 新增表单属性

placehoder： 输入框默认提示文字

required： 要求输入的内容是否可为空

pattern： 描述一个正则表达式验证输入的值

min/max： 设置元素最小/最大值

step： 为输入域规定合法的数字间隔

height/wdith： 用于image类型`<input>`标签图像高度/宽度

autofocus： 规定在页面加载时，域自动获得焦点

multiple： 规定`<input>`元素中可选择多个值

### 新增 input type 类型

color： 颜色选取

date： 日期选择

datetime： 日期选择（UTC时间）

datetime-local： 日期选择（无时区）

month： 月份选择

week： 周和年 选择

time： 选择时间

email： 包含 email的地址输入域

number: 数值选择

url： url输入域

tel： 电话号码和字段

search： 搜索域

range： 数字范围输入域

## 视频和音频

`<audio>` 音频元素

```html
<audio controls>
  <source src="horse.ogg" type="audio/ogg" />
  <source src="horse.mp3" type="audio/mpeg" />
  您的浏览器不支持 audio 元素
</audio>
```

`<video>` 视频元素

```html
<video width="320" height="240" controls>
  <source src="movie.mp4" type="video/mp4" />
  <source src="movie.ogg" type="video/ogg" />
  您的浏览器不支持Video标签。
</video>
```

## Canvas绘图

`<canvas>` 是 HTML5 新增的，一个可以使用脚本(通常为 JavaScript) 在其中绘制图像的 HTML 元素。它可以用来制作照片集或者制作简单(也不是那么简单)的动画，甚至可以进行实时视频处理和渲染。

[](https://www.runoob.com/w3cnote/html5-canvas-intro.html)

## 地理位置

使用getCurrentPosition()方法来获取用户的位置。以实现“LBS服务”

```js
// 监听地理位置变化
window.navigator.geolocation.watchPosition((pos) => {})
// 清除地理位置变化监听
window.navigator.geolocation.clearWatch()
window.navigator.geolocation.getCurrentPosition((pos) => {
  // '定位成功'
  // 定位时间：pos.timestamp
  // 维度：pos.coords.latitude
  // 经度：pos.coords.longitude
  // 海拔：pos.coords.altitude
  // 速度：pos.coods.speed
}, (err) => {
  // '定位失败'
  console.error(err)
})
```

## 拖放API

### 拖动的源对象(source)可能触发的事件

**dragstart**：拖动开始

**drag**：拖动中

**dragend**：拖动结束

### 拖动的目标对象(target)可能触发的事件

**dragenter**：拖动进入

**dragover**：拖动悬停

**drop**：松手释放

**dragleave**：拖动离开

拖放API事件句柄中所有的事件对象都有一个dataTransfer属性（数据运输对象），用于在源对象和目标对象间传递数据。

**源对象**：event.dataTransfer.setData(key, value)

**目标对象**：var value = event.dataTransfer.getData(key)

## WebWorker

[使用 Web Workers - Web API 接口参考 | MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers)

### 背景

Chrome浏览器中发起资源请求的有6个线程；但是只有1个线程负责渲染页面——称为UI主线程——浏览器中所有的代码只能由一个线程来执行。

### 问题

若浏览器加载了一个很耗时的JS文件(可能影响DOM树结构)，浏览器必须等待该文件执行完成才会继续执行后续的代码(HTML/CSS/JS等)——如果一个JS文件要执行10s(可能有很深的循环/递归等科学计算/解密)，会发生什么？——执行耗时JS任务过程中，会暂停页面中一切内容的渲染以及事件的处理。

### 作用

一个执行指定任务的独立线程；且该线程可以与UI主线程进行消息数据传递。

使用方式：

```jsx
// 主线程
let worker = new Worker('xx.js')
worker.postMessage('message') // 发送消息到worker线程
worker.onmessage = function (e) {
  console.log(e.data) // 来自worker线程的信息
}

// worker线程
onmessage = function (e) {
  console.log(e.data) // 接收主线程的消息

  postMessage('message') // 发送消息到主线程
}
```

### 共享 worker

一个共享worker可以被多个脚本使用——即使这些脚本正在被不同的window、iframe或者worker访问。

> 如果共享worker可以被多个浏览上下文调用，所有这些浏览上下文必须属于同源（相同的协议，主机和端口号）。

```js
let myWorker = new SharedWorker('worker.js')

// 主线程中调用
myWorker.port.start()

myWorker.port.postMessage('message')

myWorker.port.onmessage = function (e) {
  console.log('Message received from worker')
}

// worker 线程调用
port.start()
// worker 需要在 onconnect事件处理函数来执行代码
onconnect = function (e) {
  let port = e.ports[0]

  port.onmessage = function (e) {
    let workerResult = `Result: ${e.data}`
    port.postMessage(workerResult)
  }
}
```

## WebStorage

### localStorage

本地跨会话级，持久化存储

### sessionStorage

会话级存储

## WebSocket

在用户的浏览器和服务器之间打开交互式通信会话。

```js
const ws = new WebSocket('wx://xx')
ws.onopen = function () {}
ws.onmessage = function (e) {
  console.log(e.data)
}
```

## History API

对history栈中内容进行操作。

### pushState(stateObj, title, url)

```js
history.pushState({}, 'foo', 'foo.html')
```

添加历史记录条目

### replaceState(stateObj, title, url)

```js
history.replaceState({}, 'bar', 'bar.html')
```

修改历史记录条目，浏览器不会检查替换的路径是否存在。

### popState 事件

每当活动的历史记录项发生变化时， popstate 事件都会被传递给window对象。如果当前活动的历史记录项是被 pushState 创建的，或者是由 replaceState 改变的，那么 popstate 事件的状态属性 state 会包含一个当前历史记录状态对象的拷贝。

### 获取当前状态

页面加载时，或许会有个非null的状态对象。
这是有可能发生的，举个例子，假如页面（通过pushState() 或 replaceState() 方法）设置了状态对象而后用户重启了浏览器。
那么当页面重新加载时，页面会接收一个onload事件，但没有 popstate 事件。
然而，假如你读取了history.state属性，你将会得到如同popstate 被触发时能得到的状态对象。

```js
// 尝试通过 pushState 创建历史条目,然后再刷新页面查看state状态对象变化;
window.addEventListener('load', () => {
  let currentState = history.state
  console.log('currentState', currentState)
})
```

[History API - Web API 接口参考 | MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/History_API)

---

---
url: /article/8vac55c7/index.md
---
# vite插件推荐
本文列出了一些在工作中常会用到的、比较好用的 `vite` 插件。

## Framework

### Vue

* [@vitejs/plugin-vue](https://github.com/vitejs/vite/tree/main/packages/plugin-vue) - `vue3` 官方支持。
* [@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite/tree/main/packages/plugin-vue-jsx) - `vue3` JSX 语法插件，官方支持
* [@vitejs/plugin-vue2](https://github.com/vitejs/vite-plugin-vue2) - vue2 支持
* [vite-plugin-pages](https://github.com/hannoeru/vite-plugin-pages) - 基于文件系统自动创建路由。
* [unplugin-vue-i18n](https://github.com/intlify/bundle-tools/tree/main/packages/unplugin-vue-i18n) - `vue-i18n` 国际化方案的配套插件

### React

* [@vitejs/plugin-react](https://github.com/vitejs/vite/tree/main/packages/plugin-react) - `React` 官方支持
* [vite-plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) - 使用 `swc` 编译 `React`，速度更快

### Preact

* [@preact/preset-vite](https://github.com/preactjs/preset-vite) - `preact` 支持

### Electron

* [electron-vite](https://github.com/alex8088/electron-vite) - `electron` 支持

### Tauri

* [vite-plugin-tauri](https://github.com/amrbashir/vite-plugin-tauri) - `Tauri` 支持

## 常用

* [vite-tsconfig-paths](https://github.com/aleclarson/vite-tsconfig-paths) - 支持 `tsconfig.json`的 `paths` mapping
* [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect) - 审查`vite-plugin`中间状态
* [vite-plugin-mock-dev-server](https://github.com/pengzhanbo/vite-plugin-mock-dev-server) - 在 vite
  开发服务中注入 `mock-server` ，提供 `API Mock data` 支持
* [unplugin-icons](https://github.com/antfu/unplugin-icons) - 将 icons 资源转化为组件
* [vite-plugin-windicss](https://github.com/windicss/vite-plugin-windicss) - widicss 支持
* [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) - 低版本浏览器支持
* [unplugin-auto-import](https://github.com/antfu/unplugin-auto-import) - 自动导入模块
* [vite-plugin-remove-console](https://github.com/xiaoxian521/vite-plugin-remove-console) - 可配置的删除代码中的 `console`

## 其他

### WASM

* [vite-plugin-wasm-pack](https://github.com/nshen/vite-plugin-wasm-pack) - rust `wasm-pack` 支持

### Federation

* [vite-plugin-federation](https://github.com/originjs/vite-plugin-federation) - 提供模块联邦支持

### PWA

* [vite-plugin-pwa](https://github.com/antfu/vite-plugin-pwa) - 提供 PWA 支持

---

---
url: /article/8vev8ixl/index.md
---
# CSS选择器
## Basic Selectors 基础选择器

### Element selector

根据 element type 匹配 一组元素

```html
...
<style>
  p {
    color: red;
  }
</style>
...
<p>content</p>
...
```

### Class selector

根据 element 声明的 class属性值 匹配一组元素

```html
...
<style>
  .red {
    color: red;
  }
</style>
...
<p class="red">content</p>
...
```

### ID selector

根据 element 声明的 ID属性值，匹配一个元素（一个页面中，ID具有唯一性）

```html
...
<style>
  #red {
    color: red;
  }
</style>
...
<p id="red">content</p>
...
```

### Universal selector

通配符，匹配所有 element

```html
...
<style>
  * {
    color: red;
  }
</style>
...
<p>content</p>
<span>span</span>
...
```

## Attribute Selectors

### \[attribute] selector

匹配声明了该attribute的 一组 element

```html
...
<style>
  [href] {
    color: red;
  }
</style>
...
<a href="">content</a>
...
```

### \[attribute="x"] selector

匹配声明了该attribute，且值为 x 的一组 element

```html
...
<style>
  [title='a'] {
    color: red;
  }
</style>
...
<abbr title="a">abbr</abbr>
...
```

### \[attribute~="x"] selector

匹配声明了该attribute，且值包含了 单词 x 的一组 element

```html
...
<style>
  [title~='style'] {
    color: red;
  } /* 匹配包含了 独立单词  style 的 element， */
</style>
...
<abbr title="sheet style">abbr</abbr>
<abbr title="sheetstyle"></abbr>
<!-- no match -->
...
```

### \[attribute|="x"] selector

匹配声明了该attribute，且值包含了一个 `x-` 开头的连字符拼接的词 的一组 element

```html
...
<style>
  /* lang的值必须 包含 en 通过连接符 - 连接另一个单词的 词 */
  [lang|='en'] {
    color: red;
  }
</style>
...
<abbr lang="en-US">abbr</abbr>
<!-- no match  lang="en" lang="enUS" -->
...
```

### \[attribute^="x"] selector

匹配声明了该attribute，且值是以 x 作为开头的 一组 element

```html
...
<style>
  [href^="https://"]
  {
    color: red;
  }
</style>
...
<a href="https://example.com">content</a>
...
```

### \[attribute$="x"] selector

匹配声明了该attribute，且值是以 x 作为结尾的 一组 element

```html
...
<style>
  [href$='.pdf'] {
    color: red;
  }
</style>
...
<a href="https://example.com/a.pdf">content</a>
...
```

### \[attribute\*="x"] selector

匹配声明了该attribute，且值包含了子串 x 的 一组 element

```html
...
<style>
  [href*='example'] {
    color: red;
  }
</style>
...
<a href="https://example.com">content</a>
...
```

## Combinators 关系选择器

关系选择器适用于 任意选择器 的组合

### selector1 selector2 后代关系选择器

匹配 selector1 的元素中，所有 selector2 的 元素

```html
...
<style>
  section span {
    color: red;
  }
</style>
...
<section>
  <span></span>
  <!-- match -->
  <p><span></span></p>
  <!-- match -->
</section>
...
```

### selector1 > selector2 子代关系选择器

匹配 selector1 的下一级满足 selector2 的 一组元素

```html
...
<style>
  section > span {
    color: red;
  }
</style>
...
<section>
  <span></span>
  <!-- match -->
  <p><span></span></p>
  <!--  no match -->
</section>
...
```

### selector1 + selector2 相邻兄弟选择器

匹配selector1后同级的紧跟的selector2的一个元素

```html
...
<style>
  h2 + p {
    color: red;
  }
</style>
...
<p></p>
<!--  no match -->
<h2></h2>
<p></p>
<!-- match -->
<p></p>
<!--  no match -->
...
```

### selector ~ selector2 一般兄弟选择器

匹配selector1后同级的selector2的一组元素

```html
...
<style>
  h2 ~ p {
    color: red;
  }
</style>
...
<p></p>
<!--  no match -->
<h2></h2>
<p></p>
<!-- match -->
<p></p>
<!-- match -->
<span></span>
<p></p>
<!-- match -->
...
```

## Group Selectors 组合选择器

### selector1, selector2

匹配用`,` 隔开的所有选择器

```html
...
<style>
  p,
  span {
    color: red;
  }
</style>
...
<section>
  <span></span>
  <p><span></span></p>
</section>
...
```

## Pseudo-elements 伪元素选择器

### ::first-letter

匹配 element中的首个字符（字母、中文字、符号均可）

```html
...
<style>
  p::first-letter {
    color: red;
  }
</style>
...
<p>One</p>
<!-- match: O -->
...
```

### ::first-line

匹配 element中的首行文字

```html
...
<style>
  p::first-line {
    color: red;
  }
</style>
...
<p>
  One Two <br />
  <!-- match -->
  Three
</p>
...
```

### ::before

和 `content` 属性一起使用，在匹配的元素内容之前生成的内容

```html
...
<style>
  p::before {
    content: 'before ';
  }
</style>
...
<p>
  One Two
  <!-- render: before One Two -->
</p>
...
```

### ::after

和 `content` 属性一起使用，在匹配的元素内容之后生成的内容

```html
...
<style>
  p::after {
    content: ' after';
  }
</style>
...
<p>
  One Two
  <!-- render: One Two after -->
</p>
...
```

## Pseudo-classes 伪类选择器

### :link

匹配一个没有被访问过的链接

```html
...
<style>
  a:link {
    color: red;
  }
</style>
...
<a href="">link</a>
...
```

### :visited

匹配一个已访问过的链接

```html
...
<style>
  a:visited {
    color: red;
  }
</style>
...
<a href="">link</a>
...
```

### :active

匹配一个正在被激活的链接

```html
...
<style>
  a:active {
    color: red;
  }
</style>
...
<a href="">link</a>
...
```

### :hover

匹配一个被光标悬停的链接

```html
...
<style>
  a:hover {
    color: red;
  }
</style>
...
<a href="">link</a>
...
```

### :focus

匹配一个具有焦点的元素

```html
...
<style>
  input:focus {
    color: red;
  }
</style>
...
<input type="text" />
...
```

### :target

匹配一个已被链接到的元素。
例如通过`<a href="#heading"></a>`链接的head元素

```html
...
<style>
  h2:target {
    color: red;
  }
</style>
...
<h2 id="heading">heading</h2>
...
```

### :first-child

匹配在同一个父元素内的的第一个子元素

```html
...
<style>
  p:first-child {
    color: red;
  }
</style>
...
<p>first child</p>
<!-- match -->
<p>second child</p>
...
```

### :last-child

匹配在同一个父元素内的的最后一个子元素

```html
...
<style>
  p:last-child {
    color: red;
  }
</style>
...
<p>first child</p>
<p>last child</p>
<!-- match -->
...
```

### :nth-child(n)

匹配在同一个父元素内的从上往下数的第N子个元素

```html
...
<style>
  p:nth-child(2) {
    color: red;
  }
</style>
...
<p>first child</p>
<p>second child</p>
<!-- match -->
...
```

### :nth-last-child(n)

匹配在同一个父元素内的从下往上数的第N个子元素

```html
...
<style>
  p:nth-last-child(2) {
    color: red;
  }
</style>
...
<p>first child</p>
<!-- match -->
<p>second child</p>
...
```

### :first-of-type

匹配在同一个父元素中的同类型的第一个元素

```html
...
<style>
  p:first-of-type {
    color: red;
  }
</style>
...
<p>first child</p>
<!-- match -->
<p>second child</p>
...
```

### :last-of-type

匹配在同一个父元素中的同类型的最后一个元素

```html
...
<style>
  p:last-of-type {
    color: red;
  }
</style>
...
<p>first child</p>
<!-- match -->
<p>second child</p>
...
```

### :nth-of-type(n)

匹配在同一个父元素中的同类型的从上往下数的第N个元素

```html
...
<style>
  p:nth-of-type(2) {
    color: red;
  }
</style>
...
<p>first child</p>
<p>second child</p>
<!-- match -->
...
```

### :nth-last-of-type(n)

匹配在同一个父元素中的同类型的从下往上数的第N个元素

```html
...
<style>
  p:nth-last-of-type(2) {
    color: red;
  }
</style>
...
<p>first child</p>
<!-- match -->
<p>second child</p>
...
```

### :only-child

如果元素是其父元素的唯一子元素，则匹配该元素

```html
...
<style>
  section p:only-child {
    color: red;
  }
</style>
...
<section>
  <p>only child</p>
</section>
...
```

### :only-type

如果元素是其父元素的唯一的同类型的子元素，则匹配该元素

```html
...
<style>
  section p:only-of-type {
    color: red;
  }
</style>
...
<section>
  <p>only</p>
  <!-- match -->
  <span></span>
</section>
...
```

### :lang(lang)

匹配给定语言的元素

```html
...
<style>
  div:lang(fr) {
    color: red;
  }
</style>
...
<section>
  <div lang="fr">
    <q>This French quote has a <q>nested</q> quote inside.</q>
  </div>
</section>
...
```

### :empty

匹配没有子元素或内容的元素

```html
...
<style>
  div:empty {
    background-color: red;
  }
</style>
...
<section>
  <div></div>
</section>
...
```

### :root

匹配文档的根元素， （即匹配的 `<html>`元素）

### :enabled

匹配未被禁用的表单控件元素

### :disabled

匹配被禁用的表单控件元素

### :checked

匹配选中的单选或复选框类型的输入元素。

### :not(selector)

协商伪类。匹配不匹配选择器的元素。

## 实验中的 Selectors

这些选择器在某些浏览器中尚处于开发中，功能对应的标准文档可能被修改，在未来的版本中可能发生变化，谨慎使用。

### :any-link

匹配有链接锚点的元素，而不管元素是否被访问过。
即会匹配每一个有 `href`属性的`<a>`，`<area>`，`<link>`的元素，匹配到所有的`:link`或`:visited`。

```html
...
<style>
  a:any-link {
    border: 1px solid blue;
    color: orange;
  }
</style>
...
<a href="https://example.com">External link</a><br />
<a href="#">Internal target link</a><br />
<a>Placeholder link (won't get styled)</a>
...
```

@[caniuse](css-any-link)

### :dir(dir)

如果元素的内容的书写方向是 dir , 则匹配该元素

*dir* : ltr | rtl

```html
...
<style>
  :dir(ltr) {
    background-color: yellow;
  }

  :dir(rtl) {
    background-color: powderblue;
  }
</style>
...
<div dir="rtl">
  <span>test1</span>
  <div dir="ltr">
    test2
    <div dir="auto">עִבְרִית</div>
  </div>
</div>
...
```

@[caniuse](css-dir-pseudo)

### :has(selector)

如果一个元素A恰好满足包含了selector 匹配的元素，则匹配元素A

```html
...
<style>
  a:has(> img) {
    background-color: yellow;
  }
</style>
...
<a><img src="example.jpg" /></a>
<!-- match -->
<a></a>
...
```

@[caniuse](css-has)

### :is() / :any()

匹配一组选择器选中的元素。

优先级是由它的选择器列表中优先级最高的选择器决定。

```html
...
<style>
  :is(header, main, footer) p:hover {
    color: red;
    cursor: pointer;
  }
</style>
...
<!-- 等价于 -->
<style>
  header p:hover,
  main p:hover,
  footer p:hover {
    color: red;
    cursor: pointer;
  }
</style>
...
```

@[caniuse](css-matches-pseudo)

### :where()

匹配一组选择器选中的元素。

:where() 的优先级总是为 0。

```html
...
<style>
  :where(header, main, footer) p:hover {
    color: red;
    cursor: pointer;
  }
</style>
...
<!-- 等价于, 但优先级不同 -->
<style>
  header p:hover,
  main p:hover,
  footer p:hover {
    color: red;
    cursor: pointer;
  }
</style>
...
```

---

---
url: /article/96gtr7pj/index.md
---
# 前端优化之状态压缩
一个很常见的场景，在页面埋点的上报数据中，保存着多个状态，直接传输这组状态可能数据体积较大。
此时我们可以考虑使用 **二进制** 的方式进行优化。

## 为什么需要状态压缩？

在现代前端监控中，我们经常需要上报用户行为数据：

```json
{
  "isFirstView": true,
  "isHugeDocument": false,
  "isLoggedIn": true,
  "isMobile": true,
  "isDarkMode": false,
  "isSubscribed": true
  // ...
}
```

这样的JSON结构虽然可读性好，但存在两个致命问题：

* **数据冗余**：键名重复占用大量空间
* **传输成本**：每个状态至少占用5-10字节

当每日PV达到百万级时，这些冗余数据会让：

* 用户消耗更多流量
* 服务器承受更大压力
* 分析延迟增加

## 二进制位运算

想象有一排开关，每个开关控制一个状态：

```txt
   [开]     |    [关]        |   [开]     |   [开]   |   [关]     |   [开]
isFirstView | isHugeDocument | isLoggedIn | isMobile | isDarkMode | isSubscribed
```

计算机用 **二进制** 表示这些开关状态：

```txt
101101
```

如果我们将这个二进制转换为 十进制，那么就是：

```txt
45
```

可以发现，从原本的JSON 数据需要的大量字节空间压缩到了 **两个字节**。

这个神奇转换就是 **位掩码技术** 的核心！

那么我们如何将状态转换为二进制？以及如何从二进制中还原状态？

我们知道，在位运算中有三种常见的操作：

* **左移（`<<`）**

  [MDN - 运算符 - 左移](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Left_shift){.read-more}

  **左移操作符 (<<)** 将第一个操作数向左移动指定位数，左边超出的位数将会被清除，右边将会补零。

  ```ts
  const A = 1 << 0 // 000001 = 1
  const B = 1 << 1 // 000010 = 2
  const C = 1 << 2 // 000100 = 4
  ```

* **按位或 (`|`)**

  [MDN - 运算符 - 按位或](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_OR){.read-more}

  **按位或（|）** 运算符在其中一个或两个操作数对应的二进制位为 1 时，该位的结果值为 1。

  ```ts
  const AorB = A | B // 000011 = 3
  const BorC = A | B // 000110 = 6
  const AorBorC = A | B | C // 000111 = 7
  ```

* **按位与 (`&`)**

  [MDN - 运算符 - 按位与](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_AND){.read-more}

  **按位与（&）** 运算符在两个操作数对应的二进位都为 1 时，该位的结果值才为 1。

  ```ts
  const hasB = AorB & B // 000010 = 2
  const hasC = AorB & C // 000000 = 0
  ```

由此，我们可以：

* 通过 **左移** 运算，为不同的状态分配不同的二进制位。
* 通过 **按位或** 运算，将不同状态的二进制位进行合并。
* 通过 **按位与** 运算，判断合并后的二进制位是否有对应的状态。

## 实现方法

### 定义每个状态的二进制位

```ts
interface State {
  isFirstView: boolean
  isHugeDocument: boolean
  isLoggedIn: boolean
  isMobile: boolean
  isDarkMode: boolean
  isSubscribed: boolean
}

const STATE_MAP: Record<keyof State, number> = {
  isFirstView: 1 << 0,
  isHugeDocument: 1 << 1,
  isLoggedIn: 1 << 2,
  isMobile: 1 << 3,
  isDarkMode: 1 << 4,
  isSubscribed: 1 << 5,
}
```

### 状态压缩器

```ts
/**
 * 合并状态
 * @returns combinedState 合并后的状态
 */
function combineStates(state: Partial<State>): number {
  return (Object.keys(state) as (keyof typeof STATE_MAP)[]).reduce((combinedStates, key) => {
    return state[key] ? combinedStates | STATE_MAP[key] : combinedStates
  }, 0)
}
```

### 状态还原器

```ts
/**
 * 判断状态是否存在
 */
function hasState(combinedState: number, state: number): boolean {
  return (combinedState & state) === state
}

/**
 * 还原状态
 */
function restoreStates(combinedState: number): State {
  return (Object.keys(STATE_MAP) as (keyof typeof STATE_MAP)[]).reduce((result, key) => {
    result[key] = hasState(combinedState, STATE_MAP[key])
    return result
  }, {} as State)
}
```

### 使用示例

客户端压缩状态：

```ts
// 用户当前状态
const state: State = {
  isFirstView: false,
  isHugeDocument: false,
  isLoggedIn: true,
  isMobile: true,
  isDarkMode: true,
  isSubscribed: false
}
// 合并状态
const combinedState = combineStates(state) // 011100 = 28
```

后台服务还原状态:

```ts
restoreStates(combinedState /* 011100 = 28 */)
// 输出： {
//  isFirstView: false,
//  isHugeDocument: false,
//  isLoggedIn: true,
//  isMobile: true,
//  isDarkMode: true,
//  isSubscribed: false
// }
```

## 性能对比

假设有20个状态需要上报：

| 指标           | JSON格式 | 二进制压缩 | 优化效果 |
| -------------- | -------- | ---------- | -------- |
| 数据大小       | ~200字节 | 4字节      | 98%      |
| 百万次传输成本 | 200MB    | 4MB        | 98%      |

::: tip 在 Chrome 性能测试中，位运算操作比JSON解析快100倍以上
:::

## 注意事项

* **32位限制**：JavaScript位运算使用32位整数，最多支持31个状态（第32位是符号位）

  ```ts
  // 错误示例：超出32位
  const invalidStatus = 1 << 32
  ```

* **扩展性**：新增状态只需新增 `STATE_MAP` 键值对

  ```ts
  const STATE_MAP = {
    // ...
    isVip: 1 << 6,
  }
  ```

* **数据传输格式**：推荐使用紧凑结构

  ```ts
  // 优化后的上报数据结构
  const reportData = {
    t: Date.now(), // 时间戳
    u: 'user123', // 用户ID
    s: compressedStatus // 压缩状态
  }
  ```

## 总结

**位运算** 就像程序员的瑞士军刀——在特定场景下能发挥惊人效果。

下次当你面对膨胀的埋点数据时，不妨试试这个二进制方法。毕竟，在编程世界里，有时候 **少即是多，小即是美** ！

---

---
url: /article/ag2zktg5/index.md
---
在人工智能飞速发展的今天，==AI Agent=={.info} 的概念越来越火热，它不再是简单的问答机器人，而是能够自主感知环境、独立思考、并采取行动以达成目标的智能实体。想象一下一个能帮你管理日常事务、自动处理邮件，甚至帮你写代码的“数字助理”，这就是 AI Agent 的魅力所在。

但对于许多开发者来说，AI Agent 似乎是一个复杂且遥不可及的系统。别担心！本文将带你从零开始，手把手实现一个**最小化的 AI Agent**，揭开其神秘面纱。

:::tip 为什么从最小化 Agent 开始？
最小化 Agent 旨在通过最精简的代码和最核心的组件，让你快速理解 AI Agent 的基本工作原理和构建逻辑，避免一开始就被复杂的框架和概念劝退。当我们掌握了其核心，再扩展到更复杂的应用场景就会得心应手。
:::

## AI Agent 到底是什么？

要实现一个最小化的 AI Agent，我们首先需要理解它的核心要素。简单来说，一个 ==AI Agent=={.info} 是一个能够：

1. **感知 (Perception)**：从环境中获取信息。
2. **规划 (Planning)**：根据感知到的信息和目标，制定行动策略。
3. **行动 (Action)**：执行规划中的步骤，与环境交互。
4. **记忆 (Memory)**：存储和回忆过去的经验，从而学习和改进。
5. **反思 (Reflection)**：审视和修正自己生成的输出，以优化性能。

这些能力相互协同，构成了一个 AI Agent 的完整闭环。

而我们今天要构建的“最小化” Agent，将主要聚焦于 **感知、规划、行动** 这三大核心能力，并辅以简单的**记忆**机制。

## 最小化 Agent 的核心组件

要构建一个最小化的 AI Agent，我们离不开以下核心组件：

### 大语言模型 (LLM) — Agent 的“大脑”

LLM 是 AI Agent 的核心计算引擎，扮演着“大脑”的角色。 它们经过海量数据训练，能够理解和生成文本，并从中进行推理。 就像我们人类思考问题一样，LLM 负责理解我们的指令、分析问题、并生成解决问题的步骤。

LLM 的主流架构主要有三种类型：仅编码器 (Encoder-only)、仅解码器 (Decoder-only) 和编码器-解码器 (Encoder-Decoder)，它们大多基于 ==Transformer 架构=={.info}。

### 工具 (Tools) — Agent 的“双手”

大语言模型虽然强大，但它们的知识通常截止于训练数据，并且无法直接与外部世界互动，比如查询实时信息、执行代码或者调用 API。 这时候就需要“工具”登场了！

工具是赋予 Agent 与外部环境交互能力的接口，就像我们的双手一样。通过工具，Agent 可以完成很多 LLM 本身无法完成的任务，比如：

* **网络搜索**：获取实时信息或最新数据。
* **计算器**：进行精确的数学计算。
* **代码解释器**：执行代码并获取结果。
* **API 调用**：与各种外部服务（如天气预报、数据库等）进行交互。

### 记忆 (Memory) — Agent 的“经验”

没有记忆的 Agent 将是“健忘”的，每次交互都像是第一次，无法从过去的经验中学习。记忆机制允许 Agent 存储和回忆信息，从而在不同会话中变得更加个性化和智能。

记忆通常分为：

* **短期记忆 (Short-Term Memory, STM)**：用于维持单个交互中的上下文，例如当前会话的最近几次对话。
* **长期记忆 (Long-Term Memory, LTM)**：用于存储跨会话、跨任务的知识，通常通过数据库或向量嵌入实现。

在最小化实现中，我们可以从简单的短期记忆开始，例如维护一个固定长度的对话历史。

### 规划 (Planning) — Agent 的“思维过程”

规划是 Agent 决定下一步行动的关键，它涉及将复杂任务分解为更小的步骤，并按计划执行。

常用的规划模式包括：

* **子目标分解 (Sub-goal Decomposition)**：将复杂任务拆解成一系列可管理、可执行的子任务。
* **反思与改进 (Reflection & Refinement)**：Agent 审视自身输出，并根据反馈进行修正。

## 架构设计与技术选型

为了实现最小化的 Agent，我们将采用如下架构并选择相应的技术栈：

:::file-tree

* project\_root
  * chat\_agent.py
  * tools.py
  * README.md
  * requirements.txt

:::

### 技术选型

* **核心语言**：Python (易学易用，生态丰富)
* **LLM 交互**：OpenAI API (或其他兼容 OpenAI 接口的 LLM, 如 Google Gemini / 千帆大模型)
* **Agent 框架**：本次我们将“手搓”核心逻辑，不依赖大型框架，以便深入理解原理。但实际开发中，LangChain 等框架能极大简化开发。
* **记忆**：一个简单的列表来存储对话历史。

### 工作原理流程

我们的最小 Agent 将遵循一个基于 ==ReAct (Reasoning and Acting)=={.info} 模式的简化 Agentic Workflow：

1. **用户输入**：Agent 接收用户的问题。
2. **思考 (Reasoning)**：LLM 根据用户输入和工具描述，判断是否需要调用工具。
3. **行动 (Action)**：如果需要，调用相应的工具，并获取结果。
4. **观察 (Observation)**：Agent 获取工具返回的结果。
5. **循环**：将观察结果再次输入 LLM，重复“思考-行动-观察”循环，直到任务完成或 LLM 认为可以直接回答。

## 动手实现最小 Agent

接下来，我们开始编码实现。

### 环境准备

:::steps

* **创建项目目录和虚拟环境**

  ```bash
  mkdir mini-ai-agent
  cd mini-ai-agent
  python -m venv .venv
  source .venv/bin/activate # macOS/Linux
  # .venv\Scripts\activate # Windows
  ```

* **安装必要的库**

  ```bash
  pip install openai python-dotenv
  ```

* **配置 API 密钥**
  在项目根目录创建 `.env` 文件，并添加你的 OpenAI API 密钥：

  ```ini
  OPENAI_API_KEY="你的OpenAI API Key"
  ```

  如果你使用其他兼容 OpenAI API 的服务 (如千帆大模型)，请根据其文档配置 `OPENAI_API_BASE`。

:::

### 定义工具 (tools.py)

首先，我们需要定义 Agent 可以使用的工具。这里我们简单实现一个“计算器”和一个“获取当前时间”的工具。

```python title="tools.py"
import datetime

class Tools:
    def calculator(self, expression: str) -> str:
        """
        用于执行数学计算，例如：计算 '1 + 1'，'Math.sqrt(9)'。
        请将数学表达式作为字符串传入。
        """
        try:
            # 这是一个简化的实现，实际应用中需要更安全的沙箱环境来执行代码
            result = eval(expression)
            return str(result)
        except Exception as e:
            return f"计算出错: {e}"

    def get_current_time(self) -> str:
        """
        获取当前的日期和时间。
        """
        return datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

# 可以将所有工具作为字典导出，方便 Agent 调用
AVAILABLE_TOOLS = {
    "calculator": Tools().calculator,
    "get_current_time": Tools().get_current_time,
}

# 为 LLM 提供工具的描述（Function Calling 格式）
TOOL_SCHEMA = [
    {
        "type": "function",
        "function": {
            "name": "calculator",
            "description": "用于执行数学计算，例如：计算 '1 + 1'，'Math.sqrt(9)'。请将数学表达式作为字符串传入。",
            "parameters": {
                "type": "object",
                "properties": {
                    "expression": {
                        "type": "string",
                        "description": "要计算的数学表达式",
                    },
                },
                "required": ["expression"],
            },
        },
    },
    {
        "type": "function",
        "function": {
            "name": "get_current_time",
            "description": "获取当前的日期和时间。",
            "parameters": {
                "type": "object",
                "properties": {},
            },
        },
    },
]
```

:::tip 关于 `eval()` 的安全提示
在 `calculator` 工具中使用了 `eval()` 函数，这在生产环境中是非常危险的，因为它允许执行任意代码。本例仅为教学目的而简化。在实际项目中，应使用更安全的数学表达式解析库或沙箱环境。
:::

### 实现 Agent 核心逻辑 (chat\_agent.py)

```python title="chat_agent.py"
import os
import json
from openai import OpenAI
from dotenv import load_dotenv
from tools import AVAILABLE_TOOLS, TOOL_SCHEMA

# 加载环境变量
load_dotenv()

class MiniAIAgent:
    def __init__(self, api_key: str):
        self.client = OpenAI(api_key=api_key)
        self.conversation_history = [] # 简化记忆：存储对话历史

    def add_message(self, role: str, content: str):
        """将消息添加到对话历史中"""
        self.conversation_history.append(message)
        # 保持对话历史在一个合理长度，防止超出LLM上下文窗口
        if len(self.conversation_history) > 10:
            self.conversation_history = self.conversation_history[-10:]

    def run(self, user_query: str):
        """
        Agent 的主运行逻辑，感知、规划、行动循环
        """
        self.add_message({ 'role': 'user', 'content': user_query })
        print(f"用户: {user_query}")

        while True:
            # 1. 思考 (Reasoning) - 调用 LLM 决定下一步行动
            response = self.client.chat.completions.create(
                model="gpt-3.5-turbo", # 你也可以尝试 gpt-4 或其他支持 Function Calling 的模型
                messages=self.conversation_history,
                tools=TOOL_SCHEMA,
                tool_choice="auto", # 允许 LLM 自主选择是否调用工具
            )

            response_message = response.choices[0].message
            self.add_message(response_message)

            # 2. 检查 LLM 是否决定调用工具
            tool_calls = response_message.tool_calls
            if tool_calls:
                # 3. 行动 (Action) - 执行工具调用
                for tool_call in tool_calls:
                    function_name = tool_call.function.name
                    function_args = json.loads(tool_call.function.arguments)

                    if function_name in AVAILABLE_TOOLS:
                        print(f"Agent 调用工具: {function_name}，参数: {function_args}")
                        tool_output = AVAILABLE_TOOLS[function_name](**function_args)
                        print(f"工具 {function_name} 返回: {tool_output}")

                        # 将工具输出添加到对话历史，作为 LLM 的新的"观察"
                        self.add_message({
                            'role': 'tool',
                            'content': tool_output,
                            'tool_call_id': tool_call.id,
                        })
                    else:
                        print(f"Agent 尝试调用未知工具: {function_name}")
                        self.add_message({
                            'role': 'tool',
                            'content': f"错误: 未知工具 {function_name}",
                            'tool_call_id': tool_call.id,
                        } )
                # LLM 在获取工具结果后，会再次思考，因此继续循环
                continue
            else:
                # LLM 没有调用工具，直接返回内容，结束循环
                print(f"Agent: {response_message.content}")
                break

if __name__ == "__main__":
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        print("请在 .env 文件中设置 OPENAI_API_KEY。")
        exit(1)

    agent = MiniAIAgent(api_key=api_key)

    # 运行示例
    print("--- Mini AI Agent 启动！输入'exit'或'退出'结束对话 ---")
    while True:
        try:
            user_input = input("你: ")
            if user_input.lower() in ["exit", "退出"]:
                print("Agent 停止。")
                break
            agent.run(user_input)
            print("-" * 30)
        except Exception as e:
            print(f"运行出错: {e}")
            break
```

### 代码解释

:::steps

* **`MiniAIAgent` 类**：
  * `__init__`：初始化 OpenAI 客户端，并创建一个 `conversation_history` 列表作为 Agent 的短期记忆。
  * `add_message`：负责将用户和助手的消息添加到 `conversation_history` 中。
    这里我们限制了历史记录的长度（-10: 保持在10条），防止超出 LLM 的上下文窗口。
    实际生产中，会涉及更复杂的 ==记忆管理策略=={.info}，例如结合摘要或 ==向量数据库=={.info} 实现长期记忆。
* **`run` 方法**：这是 Agent 的核心控制循环。
  * 它首先将用户输入添加到对话历史。
  * 然后进入 `while True` 循环，模拟 Agent 的思考-行动过程。
  * **思考**：通过 `self.client.chat.completions.create` 方法调用 LLM，并将 `TOOL_SCHEMA` 作为 `tools` 参数传递。这告诉 LLM 我们有哪些工具可用，并让它自行决定是否使用。
  * **获取 LLM 响应**：`response.choices[0].message` 包含了 LLM 的回复。重要的部分在于 `response_message.tool_calls`。如果 LLM 决定调用工具，这个字段会包含工具调用的信息。
  * **判断并行动**：
    * 如果 `tool_calls` 存在，说明 LLM 决定调用工具。Agent 会解析工具名称和参数，并在 `AVAILABLE_TOOLS` 字典中查找并执行相应的 Python 函数。
    * 工具执行的结果会被再次格式化为 `role="tool"` 的消息，重新添加到 `conversation_history` 中，作为 LLM 的“观察结果”，然后循环继续，让 LLM 根据工具结果进行下一步思考。
    * 如果 `tool_calls` 为空，说明 LLM 已经得到了最终答案，直接将其内容打印出来，并结束循环。

:::

### 运行 Agent

在项目根目录运行 `chat_agent.py`：

```bash
python chat_agent.py
```

你将看到类似以下的交互：

```bash title="终端输出 (Sample)"
--- Mini AI Agent 启动！输入'exit'或'退出'结束对话 ---
你: 今天深圳的天气怎么样？
Agent: 我无法直接获取实时天气信息。但我可以帮你查找。
Agent 调用工具: get_current_time，参数: {}
工具 get_current_time 返回: 2025-11-15 21:55:30
Agent: 很抱歉，我目前无法获取您提问的实时天气信息。
------------------------------
你: 计算 123 * 45
Agent 调用工具: calculator，参数: {'expression': '123 * 45'}
工具 calculator 返回: 5535
Agent: 123 乘以 45 的结果是 5535。
------------------------------
你: 给我讲个笑话
Agent: 一个程序员去算命，算命的说：“你会在35岁遇到一个重要的转折点，你的命运将发生翻天覆地的变化。” 程序员问：“是会升职加薪吗？” 算命的说：“不，你会在那一年学会使用 Vim。”
------------------------------
你: 退出
Agent 停止。
```

通过上述交互，你可以观察到 Agent 是如何“思考”并决定调用工具的。
当它收到“计算 123 \* 45”时，它能识别出这是一个计算任务，并调用 `calculator` 工具。
当它处理“今天深圳的天气怎么样？”时，由于**只提供了获取当前时间的工具，而没有提供天气查询工具**，LLM 可能会尝试调用 `get_current_time`，但最终也会发现无法直接满足用户需求而进行解释。
这体现了 Agent 在 **感知局限性** 后，依然尝试运用已有工具或解释自身能力的“智能”行为。

## 进阶的方向

现在你已经成功实现了一个最小化的 AI Agent，但这只是冰山一角。要构建更强大、更实用的 Agent，可以从以下几个方向继续深入：

* **更复杂的工具集成**：集成更多实用工具，如搜索引擎（结合 ==检索增强生成 RAG=={.info}）、文件读写、图像处理 API 等。
* **完善记忆系统**：
  * **上下文管理**：使用摘要技术减少历史记录，保持关键信息。
  * **长期记忆**：引入向量数据库，将过去的对话或知识嵌入存储，并在需要时进行检索。 这也是 ==RAG (Retrieval Augmented Generation)=={.info} 技术的核心，通过外部知识库增强 LLM 的回答能力。
  * **不同类型的记忆**：概念上，记忆还有情景记忆（特定事件）、语义记忆（通用知识）和程序记忆（如何执行任务）。
* **高级规划能力**：
  * **Chain-of-Thought (CoT)**：让 LLM 输出思考过程，提高可解释性。
  * **Tree-of-Thought (ToT)**：探索多条思考路径，进行剪枝和优化。
  * **ReAct 模式**：我们当前实现的简化 Agent 就基于此模式，其通过语言模型设计行动，并实现连续的思考和行动。
  * **反思 (Reflection)**：让 Agent 能够审视自己的决策和结果，并从中学习和改进。
* **多智能体协作 (Multi-Agent Collaboration)**：构建多个 Agent，每个 Agent 承担不同的角色，协同完成复杂任务。
* **Prompt Engineering**：优化给 LLM 的指令和提示词，以获得更准确、更符合预期的输出。 ==Prompt Engineering=={.info} 是一门艺术和科学，通过精心设计提示词，可以显著提升 LLM 的性能。

## 总结

通过本文，我们从零开始，==“手搓”了一个最小化的 AI Agent=={.success}。
我们理解了 AI Agent 的核心组成部分：LLM 作为大脑，工具作为手，以及简单的记忆和规划机制。
虽然这个 Agent 很小，但它的核心逻辑—— **感知 (用户输入) -> 思考 (LLM 推理) -> 行动 (工具调用) -> 观察 (工具结果) -> 反思 (LLM 根据结果更新思考)** ——完美地展现了一个智能体的工作原理。

希望这个最小化的实现能为你打开 AI Agent 世界的大门，激励你进一步探索这个充满无限可能的前沿领域！

## 参考

[**LangChain 官方文档** - 一个流行的 Agent 构建框架，提供了丰富的工具和组件。](https://docs.langchain.com/){.read-more}
[**OpenAI Function Calling 文档** - 了解 LLM 如何有效调用外部函数](https://platform.openai.com/docs/guides/function-calling){.read-more}
[**Prompt Engineering Guide** - 学习如何更好地设计提示词以提升 LLM 表现](https://www.promptingguide.ai/zh){.read-more}
[**《LLM Powered Autonomous Agents》 by Lilian Weng (OpenAI)** - 深入理解 LLM 驱动的自主 Agent 设计框架](https://lilianweng.github.io/posts/2023-06-23-agent/){.read-more}

---

---
url: /article/ah1jpife/index.md
---
# CSS @layer：彻底解决样式冲突
:::info 作者前言
今天我们来聊聊 CSS 中的一个"革命性"特性——`@layer` 规则。如果你曾经被样式冲突折磨得死去活来，或者为了覆盖第三方框架的样式而不得不使用 `!important`，那么这篇文章就是为你准备的！
:::

## 什么是 CSS @layer？

简单来说，`@layer` 就像是给你的 CSS 样式**建立了一个分层系统**。想象一下，你的样式表就像是一个多层蛋糕：

* 最底层：重置样式（reset）
* 中间层：基础样式（base）
* 上层：组件样式（components）
* 最上层：工具类样式（utilities）

`@layer` 让你能够明确定义这些层的**优先级顺序**，从而彻底告别"样式战争"！

## 为什么需要 @layer？

在传统的 CSS 中，我们经常会遇到这样的困境：

```css title="传统CSS的痛点"
/* 第三方框架的样式 */
.framework-button {
  background: blue !important; /* 不得不加 !important */
}

/* 我们自己的样式 */
.my-button {
  background: red; /* 这个样式被覆盖了！ */
}
```

\==有了 @layer，一切都变得简单了！=={.success}

## 基础语法：从零开始

### 1. 创建命名层

```css title="基础层定义"
@layer reset {
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
}

@layer base {
  body {
    font-family: 'Inter', sans-serif;
    line-height: 1.6;
  }
}

@layer components {
  .button {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
  }
}
```

### 2. 定义层顺序

```css title="明确定义层优先级"
/* 定义层的优先级：从左到右，优先级递增 */
@layer reset, base, components, utilities;
```

:::tip
**重要提示**：层声明的顺序决定了优先级！先声明的层优先级低，后声明的层优先级高。
:::

## 实战演示：看 @layer 如何工作

:::: demo normal title="层优先级演示" desc="展示不同层之间的样式覆盖关系"
::: code-tabs
@tab HTML

```html
<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="container">
    <button class="btn-primary">点击我</button>
  </div>
</body>
</html>
```

@tab CSS

```css
/* 定义层顺序 */
@layer reset, base, components;

/* 重置层 */
@layer reset {
  button {
    margin: 0;
    padding: 8px 16px;
    background: gray;
  }
}

/* 基础层 */
@layer base {
  .btn-primary {
    background: blue;
    color: white;
  }
}

/* 组件层 - 这个会覆盖前面的样式 */
@layer components {
  .btn-primary {
    background: #007bff;
    padding: 12px 24px;
    border-radius: 6px;
  }
}
```

@tab 效果说明

```markdown
最终按钮会显示：
- 背景色：#007bff（来自components层）
- 内边距：12px 24px（来自components层）
- 圆角：6px（来自components层）

即使reset层和base层有相同的选择器，components层的样式仍然会生效！
```

:::
::::

## 匿名层 vs 命名层

### 匿名层

```css title="匿名层示例"
@layer {
  /* 这是一个匿名层 */
  body {
    background: #f5f5f5;
  }
}

@layer {
  /* 这是另一个匿名层 */
  body {
    background: white; /* 这个会生效！ */
  }
}
```

### 命名层

```css title="命名层示例"
@layer theme {
  .dark-mode {
    background: #1a1a1a;
    color: white;
  }
}

/* 稍后可以继续往这个层添加样式 */
@layer theme {
  .dark-mode .button {
    background: #333;
  }
}
```

:::warning
**注意**：匿名层不能被重复使用或引用，所以对于大型项目，建议使用命名层。
:::

## 高级用法：与 @import 结合

```css title="导入外部样式到指定层"
/* 将第三方框架导入到低优先级层 */
@import url('bootstrap.css') layer(framework);

/* 我们的自定义样式在高优先级层 */
@layer custom {
  .btn {
    background: linear-gradient(45deg, #ff6b6b, #ee5a24);
  }
}
```

:::steps

* **第一步**：导入第三方框架到 `framework` 层
* **第二步**：在 `custom` 层定义我们的样式
* **第三步**：`custom` 层的样式会自动覆盖 `framework` 层的样式

:::

## 处理 !important 的特殊情况

这里有个有趣的现象：

```css title="!important 在层中的行为"
@layer low-priority {
  button {
    color: blue !important;
  }
}

@layer high-priority {
  button {
    color: red; /* 这个不会生效！ */
  }
}
```

:::caution
**重要提醒**：在层中，`!important` 的行为有些特殊。低优先级层中的 `!important` 可以覆盖高优先级层的普通样式！
:::

## 实际项目中的层结构建议

:::file-tree

* styles
  * reset.css
  * base.css
  * components
    * button.css
    * card.css
    * form.css
  * utilities.css
* main.css

:::

```css title="项目层结构示例"
/* main.css */
@layer reset, base, components, utilities;

/* 重置样式 */
@layer reset {
  @import url('./styles/reset.css');
}

/* 基础样式 */
@layer base {
  @import url('./styles/base.css');
}

/* 组件样式 */
@layer components {
  @import url('./styles/components/button.css');
  @import url('./styles/components/card.css');
  @import url('./styles/components/form.css');
}

/* 工具类 */
@layer utilities {
  @import url('./styles/utilities.css');
}
```

## 浏览器支持和兼容性

@[caniuse](mdn-css_at-rules_layer)

## 最佳实践总结

1. **规划层结构**：在项目开始时就设计好层的组织结构
2. **统一命名**：使用有意义的层名称（reset、base、components、utilities）
3. **避免滥用 !important**：让层来处理优先级问题
4. **利用 DevTools**：现代浏览器开发者工具都支持层调试

## 常见问题解答

:::code-tabs
@tab Q: @layer 会影响选择器特异性吗？

```markdown
A: 不会！@layer 只影响层的优先级，选择器的特异性规则仍然适用。
在同一个层内，高特异性的选择器仍然会覆盖低特异性的选择器。
```

@tab Q: 可以动态改变层顺序吗？

```markdown
A: 不可以。层顺序在首次声明时就确定了，后续无法改变。
所以一定要在样式表开头就定义好层顺序！
```

@tab Q: 未分层的样式会怎样？

```markdown
A: 所有未分层的样式会被收集到一个"匿名层"中，
这个匿名层的优先级高于所有已命名的层！
```

:::

## 结语

CSS `@layer` 规则是近年来 CSS 生态中最实用的特性之一。它让我们能够：

* 🎯 **精确控制样式优先级**
* 🛡️ **避免特异性战争**
* 📚 **更好地组织大型项目**
* 🔧 **轻松集成第三方库**

现在就开始在你的项目中使用 `@layer` 吧！你会发现，管理 CSS 从未如此简单和愉快。

## 参考

* [MDN 的 @layer 文档](https://developer.mozilla.org/en-US/docs/Web/CSS/@layer)
* [CSS Cascade Layers 规范](https://www.w3.org/TR/css-cascade-5/)

---

---
url: /article/bmtl5ah4/index.md
---
[Jenkins](https://jenkins.io/) 是一款功能强大的应用程序，允许持续集成和持续交付项目。这里记录一些 Jenkins 使用的方法。

*以下基于 `CentOS` 系统。*

### 安装

安装详见 官网 [Jenkins 安装](https://jenkins.io/download/) 流程，各个系统如何安装均有说明。

环境依赖： `java`

CentOS 下安装：

```bash
sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat/jenkins.repo
sudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key
yum install jenkins
```

* **默认安装目录** : `/var/lib/jenkins`
* **默认日志目录** ：`/var/log/jenkins`
* **默认缓存目录** : `/var/cache/jenkins`
* **默认admin密码文件** : `/var/lib/jenkins/secrets/initialAdminPassword`
* **配置文件** : `/etc/sysconfig/jenkins`

### 运行

```bash
# 启动 Jenkins
service jenkins start
# 重启 Jenkins
service jenkins restart
# 停止 Jenkins
service jenkins stop
```

默认运行在 `8080` 端口， 本机可通过 `localhost:8080` 访问。

### 卸载

```bash
service jenkiins stop
yum clean all
yum remove jenkins
rm -rf /var/lib/jenkins
rm -rf /var/cache/jenkins
rm -rf /var/log/jenkins
```

### 修改端口

1. 打开`Jenkins` 配置文件

```bash
vim /etc/sysconfig/jenkins
```

1. 修改 `$HTTP_PORT`

```bash
$HTTP_PORT="8080"
```

### 获取root用户权限

1. 打开`Jenkins` 配置文件

```bash
vim /etc/sysconfig/jenkins
```

1. 修改 `HTTP_PORT`

```bash
$JENKINS_USER="root"
```

1. 修改`Jenkins` 相关目录权限

```bash
chown -R root:root /var/lib/jenkins
chown -R root:root /var/log/jenkins
chown -R root:root /var/cache/jenkins
```

1. 重启`Jenkins`并验证

```bash
service jenkins restart
ps -ef|grep jenkins
# 若显示为root用户，则表示修改完成
```

### 开机自启

```bash
chkconfig jenkins on
```

### 全局工具配置

全局工具配置可以 配置相关工具如`Maven`、`GIT`等工具的路径、或者安装新的不同版本的工具。

配置该设置需要获取 `admin`权限，进入`系统管理 > 全局工具配置`。

如：配置全局 GIT：

![jenkins global config](/images/jenkins_globalconfig.png)

### 用户管理以及用户权限

* 使用`admin`权限的账号，进入`系统管理 > 用户管理`, 可以添加/修改/删除 用户。
* 进入`系统管理 > 全局安全配置` 中，勾选 **启用安全**。访问控制选择 **Jenkins专有用户数据库**，使用 **项目矩阵授权策略**, 可以为每个用户分配全局权限。
* 进入项目配置中，权限 **启用项目安全** 可以单独为该项目分配用户权限。 从而确保每个项目的安全性。

### Git Parameter

为项目添加 `git`分支/标签选择参数构建配置，从而方便通过不同分支构建项目。

项目配置：
![git parameter](https://wiki.jenkins-ci.org/download/attachments/58917601/image2018-9-20_22-0-7.png?version=1\&modificationDate=1537473611000\&api=v2)

参数化构建：
![git parameter](https://wiki.jenkins-ci.org/download/attachments/58917601/image2018-9-20_22-2-47.png?version=1\&modificationDate=1537473769000\&api=v2)

基础`pipeline`配置：

```groovy
// Using git without checkout
pipeline {
  agent any
  parameters {
    gitParameter branchFilter: 'origin/(.*)', defaultValue: 'master', name: 'BRANCH', type: 'PT_BRANCH'
  }
  stages {
    stage('Example') {
      steps {
        git branch: "${params.BRANCH}", url: 'https://github.com/jenkinsci/git-parameter-plugin.git'
      }
    }
  }
}
```

[阅读插件原文（git-parameter）](https://plugins.jenkins.io/git-parameter)

### 其他

相关工具以及项目配置，都只是小问题而已...

---

---
url: /article/bp1nxjs6/index.md
---
# meta 标签说明
&#x20;标签提供关于 HTML 文档的元数据。它不会显示在页面上，但是对于机器是可读的。可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。

## 定义

提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。

## 用法

标签位于文档的头部，不包含任何内容。 标签的属性定义了与文档相关联的名称/值对。

## 属性

|    属性    | 是否可选 | 描述                                         |
| :--------: | :------: | :------------------------------------------- |
|  content   |   必选   | 定义与 http-equiv 或 name 属性相关的元信息。 |
| http-equiv |   可选   | 把 content 属性关联到 HTTP 头部。            |
|    name    |   可选   | 把 content 属性关联到一个名称。              |
|  charset   |   可选   | 定义编码格式                                 |

## 常用meta标签说明

### charset

charset是声明文档使用的字符编码，主要用于解决编码问题导致的乱码。 charset一定要写在第一行。

两种charset的写法

```html
<meta charset="utf-8" /> <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
```

## viewport

viewport主要是影响移动端页面布局

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
```

**content 参数：**

1. **width**： viewport 宽度(数值/device-width)
2. **height**： viewport 高度(数值/device-height)
3. **initial-scale**： 初始缩放比例
4. **maximum-scale**： 最大缩放比例
5. **minimum-scale**： 最小缩放比例
6. **user-scalable**： 是否允许用户缩放(yes/no)

### SEO优化相关

```html
<!-- 页面标题<title>标签(head 头部必须) -->
<title>your title</title>
<!-- 页面关键词 keywords -->
<meta name="keywords" content="your keywords" />
<!-- 页面描述内容 description -->
<meta name="description" content="your description" />
<!-- 定义网页作者 author -->
<meta name="author" content="author,email address" />
<!-- 定义网页搜索引擎索引方式，robotterms 是一组使用英文逗号「,」分割的值，
通常有如下几种取值：none，noindex，nofollow，all，index和follow。 -->
<meta name="robots" content="index,follow" />
```

**robots具体参数如下：**

1. none : 搜索引擎将忽略此网页，等价于noindex，nofollow。
2. noindex : 搜索引擎不索引此网页。
3. nofollow: 搜索引擎不继续通过此网页的链接索引搜索其它的网页。
4. all : 搜索引擎将索引此网页与继续通过此网页的链接索引，等价于index，follow。
5. index : 搜索引擎索引此网页。
6. follow : 搜索引擎继续通过此网页的链接索引搜索其它的网页。

### 移动端常用的meta

```html
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<!-- 删除苹果默认的工具栏和菜单栏 -->
<meta name="apple-mobile-web-app-status-bar-style" content="black" />
<!-- 设置苹果工具栏颜色 -->
<meta name="format-detection" content="telphone=no, email=no" />
<!-- 忽略页面中的数字识别为电话，忽略email识别 -->

<!-- 启用360浏览器的极速模式(webkit) -->
<meta name="renderer" content="webkit" />
<!-- 避免IE使用兼容模式 -->
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 -->
<meta name="HandheldFriendly" content="true" />
<!-- 微软的老式浏览器 -->
<meta name="MobileOptimized" content="320" />
<!-- uc强制竖屏 -->
<meta name="screen-orientation" content="portrait" />
<!-- QQ强制竖屏 -->
<meta name="x5-orientation" content="portrait" />
<!-- UC强制全屏 -->
<meta name="full-screen" content="yes" />
<!-- QQ强制全屏 -->
<meta name="x5-fullscreen" content="true" />
<!-- UC应用模式 -->
<meta name="browsermode" content="application" />
<!-- QQ应用模式 -->
<meta name="x5-page-mode" content="app" />
<!-- windows phone 点击无高光 -->
<meta name="msapplication-tap-highlight" content="no" />
```

### 百度禁止转码

百度会自动对网页进行转码，这个标签是禁止百度的自动转码

```html
<meta http-equiv="Cache-Control" content="no-siteapp" />
```

### Microsoft Internet Explorer

```html
<!-- 优先使用最新的ie版本 -->
<meta http-equiv="x-ua-compatible" content="ie=edge" />
<!-- 是否开启cleartype显示效果 -->
<meta http-equiv="cleartype" content="on" />
<meta name="skype_toolbar" content="skype_toolbar_parser_compatible" />

<!-- Pinned Site -->
<!-- IE 10 / Windows 8 -->
<meta name="msapplication-TileImage" content="pinned-tile-144.png" />
<meta name="msapplication-TileColor" content="#009900" />
<!-- IE 11 / Windows 9.1 -->
<meta name="msapplication-config" content="ieconfig.xml" />
```

### Google Chrome

```html
<!-- 优先使用最新的chrome版本 -->
<meta http-equiv="X-UA-Compatible" content="chrome=1" />
<!-- 禁止自动翻译 -->
<meta name="google" value="notranslate" />
```

### 360浏览器

```html
<!-- 选择使用的浏览器解析内核 -->
<meta name="renderer" content="webkit|ie-comp|ie-stand" />
```

### UC手机浏览器

```html
<!-- 将屏幕锁定在特定的方向 -->
<meta name="screen-orientation" content="landscape/portrait" />
<!-- 全屏显示页面 -->
<meta name="full-screen" content="yes" />
<!-- 强制图片显示，即使是"text mode" -->
<meta name="imagemode" content="force" />
<!-- 应用模式，默认将全屏，禁止长按菜单，禁止手势，标准排版，强制图片显示。 -->
<meta name="browsermode" content="application" />
<!-- 禁止夜间模式显示 -->
<meta name="nightmode" content="disable" />
<!-- 使用适屏模式显示 -->
<meta name="layoutmode" content="fitscreen" />
<!-- 当页面有太多文字时禁止缩放 -->
<meta name="wap-font-scale" content="no" />
```

### QQ手机浏览器

```html
<!-- 锁定屏幕在特定方向 -->
<meta name="x5-orientation" content="landscape/portrait" />
<!-- 全屏显示 -->
<meta name="x5-fullscreen" content="true" />
<!-- 页面将以应用模式显示 -->
<meta name="x5-page-mode" content="app" />
```

### Apple iOS

```html
<!-- Smart App Banner -->
<meta name="apple-itunes-app" content="app-id=APP_ID,affiliate-data=AFFILIATE_ID,app-argument=SOME_TEXT" />

<!-- 禁止自动探测并格式化手机号码 -->
<meta name="format-detection" content="telephone=no" />

<!-- Add to Home Screen添加到主屏 -->
<!-- 是否启用 WebApp 全屏模式 -->
<meta name="apple-mobile-web-app-capable" content="yes" />
<!-- 设置状态栏的背景颜色,只有在 “apple-mobile-web-app-capable” content=”yes” 时生效 -->
<meta name="apple-mobile-web-app-status-bar-style" content="black" />
<!-- 添加到主屏后的标题 -->
<meta name="apple-mobile-web-app-title" content="App Title" />
```

### Google Android

```html
<meta name="theme-color" content="#E64545" />
<!-- 添加到主屏 -->
<meta name="mobile-web-app-capable" content="yes" />
```

---

---
url: /article/browser-event-loop/index.md
---
# Event Loop 浏览器端的事件循环
事件循环，即 Event-Loop。

## 什么是 Event-Loop ？

Event-Loop 是一个执行模型，在 [html5规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops) 中进行了浏览器端的 Event-Loop 的明确定义。

## 宏任务与微任务

javascript 有两种异步任务，分别是`宏任务`和`微任务`

### 宏任务

宏任务，`macro task`，也叫 `tasks`，一些异步任务的回调会依次进入 `macro task queue`，等待后续被调用。

这些异步任务包括：

* setTimeout
* setInterval
* setImmediate (Node独有)
* requestAnimationFrame (浏览器独有)
* I/O
* UI rendering

### 微任务

微任务， `micro task`, 也叫 `jobs`，另一些异步任务的回调会依次进入`micro task queue`，等待后续被调用。

这些异步任务包括：

* process.nextTick(Node独有)
* Promise
* Object.observe
* MutationObserver

## 事件循环 Event Loop

1. 执行全局 `script` 代码，这些代码有一些是同步语句，有一些是异步语句（如： setTimeout）；
2. 全局`script`同步代码执行完毕后，调用栈Stack会清空；
3. 从微任务`micro task queue` 中取出位于队首的任务，放入调用栈Stack中执行，执行完后`micro task queue`长度减一；
4. 继续取出微任务`micro task queue`位于队首的任务，放入调用栈Stack中执行，
   以此类推，直到把`micro task queue`中的所有任务都执行完毕。**注意，如果在执行micro task的过程中，产生了`micro task`那么会加入到队列的末尾，也会在这个周期被调用执行**；
5. `micro task`中的所有无人都执行完毕，此时 `micro task queue` 为空队列，调用栈Stack也为空；
6. 取出宏队列 `macro task queue` 中位于队首的任务，放入Stack中执行；
7. 执行完毕后，调用栈Stack为空；
8. 重复第3-7个步骤；
9. 以此继续循环重复；

::: tip 重点

1. 宏任务`marco task` 一次只从队列中取出一个任务执行，执行后就去执行微任务队列中的任务；
2. 微任务队列中所有的任务都会依次取出来执行，直到`micro task queue`为空，
   且当前微任务执行过程中产生新的`micro task`，也会加入到当前`micro task queue`;
3. `UI Rendering`由浏览器自定判断决定执行节点。但是只要执行`UI Rendering`，它的节点是在执行完所有
   `micro task`之后，下一个`macro task`之前，紧跟着执行`UI Rendering`

:::

尝试从代码层面来分析 event-loop:

::: note 抖个机灵
代码人看代码应该比看流程图要来得好理解了吧（bushi）
:::

```js
// 执行器
// 接收一段javascript代码
class Execution {
  constructor(code) {
    this.code = code
    this.macroTaskQueue = []
    this.microTaskQueue = []
  }

  // 启动执行
  exec() {
    // 首次运行，将 传入的 code 推入到 Track中执行
    // 并获取其中的 宏任务和 微任务
    const { macroTaskQueue, microTaskQueue } = this.run(this.code)
    // 将宏任务和微任务 推入到 各自的 队列中
    this.macroTaskQueue.push(...macroTaskQueue)
    this.microTaskQueue.push(...microTaskQueue)
    // 开始执行微任务
    this.runMicroTaskQueue()
  }

  // 执行微任务队列
  runMicroTaskQueue() {
    // 遍历 微任务队列中的所有任务
    // 当当前的 微任务队列清空时，遍历才结束
    while (this.microTaskQueue.length) {
      // 取出 队首的微任务
      const task = this.microTaskQueue.shift()
      // 将 当前微任务 推入到 执行栈中执行
      // 并将返回的 宏任务和微任务 继续 推入到 各自的队列中
      const { macroTaskQueue, microTaskQueue } = this.run(task)
      this.macroTaskQueue.push(...macroTaskQueue)
      this.microTaskQueue.push(...microTaskQueue)
    }
    // 当前微任务执行完毕，继续执行宏任务
    this.runMacroTaskQueue()
  }

  // 执行宏任务队列
  runMacroTaskQueue() {
    // 从 宏任务队列队首 取出一个 宏任务
    const task = this.macroTaskQueue.shift()
    // 将当前 宏任务 推入到 执行栈中执行
    // 并将返回的 宏任务和微任务 继续 推入到 各自的队列中
    const { macroTaskQueue, microTaskQueue } = this.run(task)
    this.macroTaskQueue.push(...macroTaskQueue)
    this.microTaskQueue.push(...microTaskQueue)
    // 再一次执行 微任务队列中的任务
    this.runMicroTaskQueue()
  }

  // 执行栈调用
  run(task) {
    // track 函数表示 执行栈
    // 执行完毕返回 产生的 微任务队列 和 宏任务队列
    const { macroTaskQueue, microTaskQueue } = track(task)
    return { macroTaskQueue, microTaskQueue }
  }
}
const execute = new Execution(scriptCode)
execute.exec()
```

`event-loop` 概念性的内容大体就这么多，接下来从示例中来实际执行情况。

## 示例

::: warning 注意
以下示例是在 `Chrome` 中执行后获得的结果，在其他浏览器的表现并不一定完全相同。
:::

可以尝试自己心中执行这段代码后的打印顺序，再切换到`Console`中看实际的运行结果，是否符合你的预期结果。

::: code-tabs

@tab javascript

```js
console.log('script')

setTimeout(() => {
  console.log('timeout 1')
  Promise.resolve().then(() => {
    console.log('promise 1')
  })
})

new Promise((resolve) => {
  console.log('promise resolver')

  Promise.resolve().then(() => {
    console.log('promise 3')
  })

  resolve('promise 2')
}).then((data) => {
  console.log(data)
})

setTimeout(() => {
  console.log('timeout 2')
})

console.log('end')
```

@tab Console

```txt
script
promise resolver
end
promise 3
promise 2
timeout 1
promise 1
timeout 2
```

:::

---

---
url: /article/btkqop1a/index.md
---
# CSS At-Rules
## @charset

### 概述

指定样式表中使用的字符编码。 它必须位于样式表中的第一个元素，且前面不得有任何字符。

不能在 `<style>` 元素内的样式属性内使用。

### 示例

```css
@charset "UTF-8";
@charset "utf-8"; /*大小写不敏感*/
/* 设置css的编码格式为Unicode UTF-8 */
@charset 'UTF-8'; /* 无效的, 使用了错误的引号 */
@charset "UTF-8"; /* 无效的, 多于一个空格 */
@charset "UTF-8"; /* 无效的, 在at-rule之前多了一个空格 */
@charset UTF-8; /* Invalid, without ' or ", the charset is not a CSS <string> */
```

## @font-face

### 概述

指定一个用于显示文本的自定义字体。

字体可以从远程服务器，也可以是用户本地安装的字体。

`@font-face` 可以解除对用户电脑字体的依赖。

### 语法

```css
@font-face {
  [ font-family: <family-name>; ] ||
  [ src: <src>; ] ||
  [ unicode-range: <unicode-range>; ] ||
  [ font-variant: <font-variant>; ] ||
  [ font-feature-settings: <font-feature-settings>; ] ||
  [ font-variation-settings: <font-variation-settings>; ] ||
  [ font-stretch: <font-stretch>; ] ||
  [ font-weight: <font-weight>; ] ||
  [ font-style: <font-style>; ] ||
  [ size-adjust: <size-adjust>; ] ||
  [ ascent-override: <ascent-override>; ] ||
  [ descent-override: <descent-override>; ] ||
  [ line-gap-override: <line-gap-override>; ]
}
```

* `font-family`: 指定的 `<family-name>` 将会被用于 `font`或`font-family`的属性
* `src`: 远程字体文件的位置，或者通过`local`函数通过字体名字从本地加载字体。

### 使用示例

加载远程字体文件：

```html
...
<style>
  @font-face {
    font-family: custom-font;
    src: url('http://example.com/custom-font.ttf');
  }
  body {
    font-family: custom-font;
  }
</style>
...
```

加载字体文件，先尝试从用户本地加载，如果加载失败则从远程服务器下载:

```html
...
<style>
  @font-face {
    font-family: MgOpenModernaBold;
    src: local('Helvetica Neue Bold'), url(MgOpenModernaBold.ttf);
  }
  body {
    font-family: MgOpenModernaBold;
  }
</style>
...
```

加载不同文件格式的字体，根据用户环境判断使用兼容的字体文件格式：

```html
...
<style>
  @font-face {
    font-family: custom;
    src:
      url('custom.ttf') format('tff'),
      url('custom.woff') format('woff'),
      url('custom.woff2') format('woff2');
  }
  body {
    font-family: custom;
  }
</style>
...
```

## @import

### 概述

从其他样式表导入样式规则。

`@import` 必须优先于其他类型的规则，即需要在文件顶部声明。`@charset` 除外。

### 语法

```css
@import url;
@import url list-of-media-queries;
```

* `url` 样式规则文件资源位置
* `list-of-media-queries` [媒体查询](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries)，支持用逗号分隔多个查询条件。资源仅在满足媒体查询条件时才会被加载。

## @keyframes

### 概述

通过在动画序列中定义关键帧的样式来控制CSS动画序列中的中间步骤。

### 示例

使用 `from`,`to` 定义起始和结束关键帧的样式 实现动画

```css
@keyframes slidein {
  from {
    transform: translateX(0%);
  }

  to {
    transform: translateX(100%);
  }
}
```

使用 百分比 定义触发关键帧的时间点

```css
@keyframes slidein {
  0% {
    transform: translateX(0%);
  }

  50% {
    transform: translateX(50%);
  }

  100% {
    transform: translateX(100%);
  }
}
```

## @media

媒体查询，详见 [CSS @media 媒体查询](/post/fe5ruia1/)

---

---
url: /article/c3ez957l/index.md
---
# HTTP缓存机制
::: note
老生常谈！老生常谈！老生常谈啊！
:::

## 什么是HTTP缓存

当客户端向服务器发起资源请求时，会先抵达浏览器缓存，如果浏览器有要请求的资源的副本，
那么就可以直接从浏览器缓存中提取而不是从原始服务器中获取这个资源。

http缓存都是从对同一资源的第二次请求开始的。

* 第一次请求时，服务器返回资源，并在`response header`中回传资源的缓存参数；
* 第二次请求时，浏览器会根据这些缓存参数，判断是否使用浏览器缓存的资源副本还是从服务器获取资源。

## HTTP缓存分类

HTTP缓存，根据是否需要重新向服务器发起请求，可分为两大类：

* 强缓存： 强制缓存，在缓存有效时间内，不再向服务器发起资源请求，直接使用浏览器缓存的资源副本
* 协商缓存：在缓存有效时间内，需要向服务器询问资源是否需要更新，如果需要更新，则从服务器获取新的资源，
  如果不需要更新，则继续使用浏览器缓存的资源副本；

::: tip 另一种缓存分类
根据资源是否可以被单个用户或多个用户使用来分类，还可以分为 私有缓存和共享缓存。

这种一般是对于 代理服务器的，即 浏览器发起请求 -> 代理服务器 -> 原始服务器。

* 私有缓存： 在代理服务器中，仅针对单个用户使用的资源缓存，其他用户发起的对同一个资源的首次请求，仍然需要从原始服务器获取资源
  并为该用户建立新的缓存资源。

* 共享缓存：只要有一个用户发起的对同一个资源的首次到达代理服务器的请求，代理服务器对该资源缓存后，其他用户请求代理服务器上的资源，
  在缓存有效时间内，代理服务器不再向原始服务器获取新的资源，返回代理服务为缓存的资源副本。

:::

## 主要的HTTP Headers

* 通用首部字段

  | 字段          | 说明                                        |
  | ------------- | ------------------------------------------- |
  | Cache-Control | 控制缓存行为                                |
  | Pragma        | http1.0时代的产物，值为 no-cache 时禁用缓存 |

* 请求头部字段 Request Headers

  | 字段                | 说明                           |
  | ------------------- | ------------------------------ |
  | If-Match            | 比较 ETag 是否一致             |
  | If-None-Match       | 比较 ETag 是否不一致           |
  | If-Modified-Since   | 比较资源最后更新时间是否一致   |
  | If-Unmodified-Since | 比较资源最后更新时间是否不一致 |

* 响应头部字段 Response Headers

  | 字段 | 说明         |
  | ---- | ------------ |
  | ETag | 资源匹配信息 |

* 实体头部字段

  | 字段          | 说明                                |
  | ------------- | ----------------------------------- |
  | Expires       | http1.0时代的产物，实体主体过期时间 |
  | Last-Modified | 资源的最后一次更新时间              |

::: warning 提醒
`Pragma`、`Expires` 这两个header是 http1.0中的内容，在 http1.1及往后的版本中逐步被弃用。

但为了能够对浏览器向下兼容，大多数网站在设置 缓存机制时，仍然在 response headers 中保留这两个字段的声明。

本文同样也会对这两个字段进行说明，以及为什么http1.1后会使用 `Cache-Control` 代替。
:::

::: warning 提醒
在某些技术文章分享中，常常会直接把这些headers字段各自分类到 强缓存 或 协商缓存中，
个人认为这种简单粗暴的划分方式是有待商榷，就比如`Cache-Control`的不同取值，其行为会根据值表现为强缓存或协商缓存。
:::

### Pragma

`Pragma` 字段仅有一个 `no-cache`的可选值，会告知客户端不要对该资源进行缓存读取，应该每次都向服务器发送资源请求。

在客户端使用时，通常做法是在 HTML中加上一个 meta 标签：

```html
<meta http-equiv="Pragma" content="no-cache" />
```

::: caution 警告

* 这个标签声明仅有 IE才能识别含义，其他主流浏览器不兼容。
* 在IE浏览器中，虽然能够识别含义，但并不一定会在请求Request Header中加上Pragma，但确实会让当前页面每次都发起新请求。
  （仅限页面html文件，页面内使用的其他资源不受影响。）

:::

在服务端配置为 Response Header 时，浏览器读取到该字段，会禁用缓存行为，后续的对同一资源的请求会重新发起请求而不使用缓存。

::: warning 提醒
由于`Pragma` 在浏览器端的兼容问题，在服务器端又有其他字段能更好的控制缓存行为，Pragma 字段基本已经被抛弃，不再使用，

*除了部分网站出于兼容性考虑，还会带上该字段。*
:::

### Expires

在 http1.0中，Pragma 用于禁用缓存，也需要有一个字段用于启用缓存和定义缓存时间。Expires 就是用于这个目的。

Expires 的值是一个 GMT时间， 如：`Thu Jun 07 2018 14:26:45 GMT`，用于告诉浏览器资源的缓存过期时间，如果还没有超过该时间
则不发起新的资源请求。

在客户端，可以使用 meta标签来告知浏览器缓存时间

```html
<meta http-equiv="expires" content="Thu Jun 07 2018 14:26:45 GMT" />
```

如果希望不走缓存，每次页面请求都发起新的请求，可以把 content 设置为 -1 或 0。

::: caution 提醒
跟 Pragma 字段一样， 该 meta 标签只有 IE 能够正确识别。
而且该方式仅是告知 IE 缓存时间的标记，并不能在 Request Header 中找到该字段。
:::

服务端在 Response Headers 中设置 Expires 字段，则在任何浏览器中都能正确设置资源缓存时间；

::: info 说明
如果同时使用 Pragma 和 Expires 字段， 则 Pragma 优先级会更好，页面会发起新的请求
:::

::: warning 提醒
Expires 字段虽然能够定义缓存有效时间，但是这个时间的设置是相对于本地时间的。
如果在服务端定义，则这个时间是相对于服务端时间的，
这个时间返回到客户端， 客户端是拿着客户端的本地时间与返回的服务端时间做对比。
那么就会导致一种情况，当用户更改了客户端的时间，如超过了 Expires定义的缓存时间，那么缓存就立即失效了。

也正是应该存在着这样的问题，Expires并不能保证缓存能够达到预期的表现，所以也被逐步弃用。
:::

### Cache-Control

`Cache-Control` 是从 `http1.1` 开始支持的 header 属性，该属性的值描述了使用缓存的行为以及缓存的有效时间。

`Cache-Control` 可以在 发起请求时，在`Request Headers` 中声明该属性，（如果资源请求是通过代理服务器再到原始服务器，）
通知代理服务器对资源的缓存方式，以及是否向原始服务器请求最新的资源。

`Cache-Control` 做为 `Response Headers` 属性返回时，通知浏览器对该资源的缓存方式和有效时间。

Cache-Control 语法如下：

```
Cache-Control: <cache-directive>
```

* 作为 `Request Headers` 时， `cache-directive` 支持以下可选值

| 字段名称                   | 说明                                                                                                                      |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------- |
| no-cache                   | 告知(代理)服务器不直接使用缓存，要求从原始服务器发起请求                                                                  |
| no-store                   | 所有内容都不会被保存到缓存或 Internet临时文件中                                                                           |
| max-age=delta-seconds      | 告知服务器 客户端希望接收一个存在时间（age）不大于 delta-seconds 秒的资源                                                 |
| max-stale\[=delta-seconds] | 告知(代理)服务器 客户端愿意接收一个超过缓存时间的资源，若有定义delta-seconds，则为delta-seconds秒，若没有则为超过任意时间 |
| min-fresh=delta-seconds    | 告知(代理)服务器 客户端希望接收一个在delta-seconds秒内被更新过的资源                                                      |
| no-transform               | 告知(代理)服务器 客户端希望获取一个实体数据没有被转换(如压缩)过的资源                                                     |
| only-if-cached             | 告知(代理)服务器 客户端希望获取缓存的资源（若有）,而不用向原服务器发起请求                                                |

* 作为 `Response Headers`时，`cache-directive` 支持以下可选值

| 字段名称                | 说明                                                                                                                                   |
| ----------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| public                  | 表明任何情况下都需要缓存该资源                                                                                                         |
| private\[="file-name"]   | 表明返回报文中全部或部分(若指定了*file-name*的字段数据)仅开放给某些用户(服务器指定的*share-use*)做缓存使用，其他用户则不能缓存这些数据 |
| no-cache                | 不直接使用缓存，要求向服务器发起（新鲜度校验）请求                                                                                     |
| no-store                | 所有内容都不会被保存到缓存或 Internet临时文件中                                                                                        |
| max-age=delta-seconds   | 告知客户端该资源在*delta-seconds*秒内是新鲜的，无需向服务器发起请求                                                                    |
| s-max-age=delta-seconds | 同 max-age，但仅应用于 共享缓存                                                                                                        |
| no-transform            | 告知客户端缓存文件时不得对实体数据做任何改变                                                                                           |
| must-revalidate         | 当前资源一定是向原始服务器发去验证请求的，若请求失败会返回504(而非代理服务器上的缓存)                                                  |
| proxy-revalidate        | 和 must-revalidate类似，但仅应用于 共享缓存                                                                                            |

* 可以直接在 HTML页面的`<head>` 中通过 meta标签来给请求头加上 `Cache-Control` 字段：

  ```html
  <meta http-equiv="Cache-Control" content="no-cache" />
  ```

* `Cache-Control` 允许自由组合可选值：

  ```
  Cache-Control: max-age=3600, must-revalidate
  ```

  这段声明表示，该资源必须从原始服务器获取，且其缓存有效时间为一个小时，在后续的一个小时内，用户重新访问该资源都无需发送请求。

### 缓存校验

`Pragma`、`Expires`、`Cache-Control` 字段能够让客户端决定是否向服务器发送请求，缓存未过期的从本地缓存获取资源，缓存过期的从服务器端获取资源。

但是，客户端向服务器发送了请求，是否以为着一定要读取并返回该资源的实体内容？

* 如果一个资源在客户端的缓存时间过期了，但服务器并没有更新过这个资源，那服务端是否一定要重新把资源的实体内容返回？

* 如果这个资源过大，虽然缓存过期，但又没有更新过，返回实体内容是否会浪费带宽和时间？

对于这些问题，其实只要采取某种策略，让服务器知道客户端现在保存的缓存文件跟服务端的资源文件是一致的，
然后通知客户端该资源可以继续使用缓存文件，不需要重新返回资源实体内容。
那么就可以解决上述的问题，同时为HTTP请求带来优化和加速。

http1.1 新增了 `Last-Modified`、`ETag`、 `If-Match`、`If-None-Match`、`If-Modified-Since`、
`If-Unmodified-Since` 这些字段，用于对缓存资源的校验，提高缓存的复用率。

### Last-Modified

服务器将资源发送给客户端时，会将资源的最后更新时间以如下格式加载实体首部，一起返回给客户端。

客户端会为该资源标记上该信息，下次在请求时，会把该信息添加在请求报文中发送给服务端去做检查。
如果客户端上报字段时间值和服务端的对应资源的最后修改时间一致，则说明改资源没有被修改过，直接返回 304状态码。

客户端在上报 Last-Modified 时，可以使用的 Request Headers 字段有两个：

* `If-Modified-Since`: 该字段格式如下

  ```
  If-Modified-Since: <Last-Modified-Value>
  ```

  字段告诉服务端，如果客户端上报的最后修改时间和服务器上的最后修改时间一致，则直接返回304和响应报头即可。

  当前各浏览器默认使用该字段用来向服务端上报保存的 Last-Modified 值。

* `If-Unmodified-Since`: 该字段格式如下

  ```
  If-Unmodified-Since: <Last-Modified-Value>
  ```

  字段告诉服务端，如果客户端上报的最后修改时间和服务端上的最后修改时间不一致，
  则应当返回 412（Precondition Failed）状态码给客户端。

Last-Modified 由于是使用的资源最后修改时间来确定资源是否有被修改，
但是在实际情况中，往往存在着一个资源被修改了但实际内容没有发生改变，
而由于资源最后修改时间已经发生改变，依然会返回整个实体内容给客户端，而其实内容跟客户端缓存内容一致。

### ETag

为了解决 `Last-Modified` 可能存在的不准确的问题，http1.1 还推出了 ETag 实体首部字段。

服务器会通过某种算法，给资源计算得出一个唯一标识符，在把资源响应给客户端的时候，会在实体首部加上该字段一起返回给客户端。

```
ETag: ETag-Value
```

客户端为资源标记上该信息，下次在请求时，会把该信息添加在请求报文中发送给服务端去做检查。
服务端只需要比较客户端传来的ETag和对应的该资源的ETag是否一致，就可以判断资源相对于客户端资源是否被修改过。
如果ETag是一致的，那么就直接返回304状态码，否则就返回新的资源实体内容给客户端。

客户端在上报 ETag 时，可以使用的 Request Headers 字段有两个：

* `If-None-Match` 该字段格式如下

  ```
  If-None-Match: <ETag-Value>
  ```

  字段告诉服务端，如果ETag没有匹配上，需要重新返回新的资源实体内容，否则直接返回 304 状态码。

  当前各浏览器默认使用该字段用来向服务端上报保存的 ETag 值。

* `If-Match` 该字段格式如下

  ```
  If-Match: <ETag-Value>
  ```

  字段告诉服务端，如果ETag没匹配到，或者收到了`"*"`值而当前没有该资源实体，
  则应当返回412（Precondition Failed）状态码给客户端。否则服务器直接忽略该字段。

::: tip 提醒
如果 `Last-Modified` 和 `ETag` 同时被使用，则要求它们的验证必须同时通过才返回 304，
若其中一个没有通过，则服务器会按照常规返回资源的实体以及200状态码。
:::

## 次要的 HTTP Headers

以下的字段虽然跟缓存有关系，但没有那么重要。

### Vary

`Vary` 表示 服务端会以什么基准字段来区分、筛选缓存版本。

首先考虑一个问题，服务端有一个请求地址，如果是IE用户则返回针对IE开发的内容，否则返回另一个主流浏览器版本的内容。

一般来说，服务端获取到请求的 `User-Agent` 字段做处理即可。
但是如果用户请求的是代理服务器而非原始服务器，且代理服务器如果直接把缓存的IE版本资源发给了非IE的客户端，那就出问题了。

而 Vary 则是用于处理这类问题的头部字段，只需要在响应报文加上：

```
Vary: User-Agent
```

字段告知代理服务器需要以 User-Agent 这个请求头部字段来区别缓存版本，确定传递给客户端的版本。

Vary 字段也接受条件组合的形式

```
Vary: User-Agent, Accept-Encoding
```

字段告知代理服务器需要以 User-Agent 和 Accept-Encoding 两个请求头部字段来区别缓存版本。

### Date、Age

Date 字段表示原始服务器发送该资源的响应报文时间（GMT时间）。
该字段的作用可以帮助我们判断该资源命中的是原始服务器还是代理服务器。

* 如果`Date`的时间与当前时间差别较大，或者连续F5刷新发现Date值没有变化，那么说明当前请求命中的是代理服务器的缓存。
* 如果每次刷新页面，浏览器每次都会重新发起这条请求，那么其Date的值会不断变化，说明该资源是直接从原始服务器返回的。

Age 字段表示某个文件在代理服务器中存在的时间（秒），如果文件被修改或替换，Age会重新从0开始累计。

## 浏览器表现

### 强缓存

对于强缓存的资源：

* 当用户第一次访问该资源时，服务器返回 200状态码，以及资源实体内容。

* 如果用户访问完第一次后，在没有关闭浏览器的前提下，进行了第二次或更多次资源访问，那么浏览器不再请求服务器，
  而是从 浏览器的内存缓存区取出资源，并且 状态码 标记为 `200 (memory cache)`

* 如果用户访问完第一次后，关闭浏览器后，重新打开浏览器，进行第二次或更多次资源访问，那么浏览器也不会请求服务器，

* 而是从 浏览器的磁盘缓存区取出资源，并且 状态码 标记为 `200（disk cache）`

### 协商缓存

* 当用户第一次访问该资源时，服务器返回 200状态码，以及资源实体内容。

* 如果用户进行第二次访问时，进行缓存校验。 或在缓存时间内，或 资源未被修改，那么 直接返回 304状态码

* 如果用户进行第二次访问时，服务器资源已被更新，则返回 状态码 200 ，以及新的资源实体内容。

---

---
url: /article/c5882xqj/index.md
---
# TypeScript 类型相等性检查：深入实现 IsEqual<X, Y>
在 TypeScript 的类型系统中，判断两个类型是否相等是一个常见但微妙的需求。本文将带你深入探讨如何实现一个真正准确的 `IsEqual<X, Y>` 类型工具。

## 为什么需要 IsEqual？

在日常的 TypeScript 开发中，我们经常需要：

* 编写复杂的条件类型
* 实现类型安全的工具函数
* 进行类型级别的单元测试
* 构建高级类型工具库

:::info 常见误区
很多开发者会尝试使用 `X extends Y ? true : false`，但这只能检查兼容性，而非真正的类型相等性。
:::

## 基础实现方案

让我们从最简单的实现开始，逐步优化：

```typescript title="基础版本"
type IsEqual<X, Y> = X extends Y ? Y extends X ? true : false : false
```

这个版本看起来合理，但实际上存在严重问题：

```typescript title="测试用例"
type Test1 = IsEqual<1, 1> // true ✓
type Test2 = IsEqual<1, 2> // false ✓
type Test3 = IsEqual<any, 1> // boolean ✗ (应该是 false)
type Test4 = IsEqual<never, never> // never ✗ (应该是 true)
```

:::warning 问题分析

* `any` 类型会破坏条件类型的分布特性
* `never` 类型在条件类型中有特殊行为
* 无法区分 `readonly` 修饰符
  :::

## 完整解决方案

经过社区实践，以下是目前最可靠的实现：

```typescript title="完整实现"
type IsEqual<X, Y>
  = (<T>() => T extends X ? 1 : 2) extends
  (<T>() => T extends Y ? 1 : 2)
    ? true
    : false
```

这个实现利用了 TypeScript 的内部类型比较机制，让我们通过测试用例验证：

::: code-tabs
@tab 基础类型

```typescript
type Test1 = IsEqual<string, string> // true
type Test2 = IsEqual<number, string> // false
type Test3 = IsEqual<1, 1> // true
type Test4 = IsEqual<1, 2> // false
```

@tab 特殊类型

```typescript
type Test5 = IsEqual<any, any> // true
type Test6 = IsEqual<any, string> // false
type Test7 = IsEqual<never, never> // true
type Test8 = IsEqual<never, any> // false
```

@tab 对象类型

```typescript
type Test9 = IsEqual<{ a: 1 }, { a: 1 }> // true
type Test10 = IsEqual<{ a: 1 }, { a: 2 }> // false
type Test11 = IsEqual<{ readonly a: 1 }, { a: 1 }> // false
```

:::

## 实现原理深度解析

### 泛型条件类型比较

核心技巧在于使用泛型函数类型：

```typescript title="原理分析"
type Comparator<T> = <U>() => U extends T ? 1 : 2

type IsEqual<X, Y> = Comparator<X> extends Comparator<Y> ? true : false
```

这里的关键是：`<T>() => T extends X ? 1 : 2` 这个类型会捕获 `X` 的完整类型信息，包括：

* 字面量类型
* `readonly` 修饰符
* 可选属性
* 函数参数类型等

### 处理边界情况

:::steps

* **any 类型处理**：传统的 `extends` 检查中，`any` 会匹配任何类型，但我们的实现能正确区分
* **never 类型处理**：避免了 `never` 在条件类型中的特殊分布行为
* **联合类型处理**：正确处理联合类型的相等性检查

:::

## 实际应用场景

### 1. 类型安全的工具函数

```typescript title="类型安全函数示例"
type SafeAssign<T, U> = IsEqual<T, U> extends true
  ? T
  : 'Type mismatch!'

function createConfig<T>(config: T & SafeAssign<T, Config>): T {
  return config
}

interface Config {
  apiUrl: string
  timeout: number
}

// 正确使用
createConfig({ apiUrl: '/api', timeout: 5000 })

// 类型错误
createConfig({ apiUrl: '/api', timeout: '5000' })
// 错误：Type mismatch!
```

### 2. 类型级别测试

```typescript title="类型测试工具"
type Assert<T extends true> = T
type Expect<T extends true> = T

// 测试用例
type Test1 = Assert<IsEqual<1, 1>>
type Test2 = Expect<IsEqual<IsEqual<any, string>, false>>
```

### 3. 高级类型工具

```typescript title="类型工具库应用"
type Filter<T, U> = T extends any
  ? IsEqual<T, U> extends true
    ? T
    : never
  : never

type Result = Filter<1 | 2 | 3, 2> // 2
```

## 替代方案对比

| 方案                                                                    | 优点     | 缺点                    | 适用场景             |
| ----------------------------------------------------------------------- | -------- | ----------------------- | -------------------- |
| `X extends Y ? Y extends X ? true : false : false`                      | 简单易懂 | 无法处理 `any`、`never` | 基础类型比较         |
| `(<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2)` | 准确可靠 | 理解成本高              | 生产环境、类型工具库 |
| 第三方库（如 type-fest）                                                | 功能丰富 | 增加依赖                | 大型项目、团队协作   |

## 常见问题解答

### Q: 为什么不用 `X === Y` 这样的语法？

A: TypeScript 的类型系统在编译时运行，`===` 是运行时操作符，无法用于类型比较。

### Q: 这个实现有性能问题吗？

A: 对于大多数用例，性能影响可以忽略。但在极深嵌套的类型中可能会有编译时性能考虑。

### Q: 如何处理函数类型的比较？

A: 当前的实现已经能正确处理函数类型，包括参数类型、返回值类型和重载。

```typescript title="函数类型测试"
type F1 = (x: number) => string
type F2 = (x: number) => string
type F3 = (x: string) => string

type Test1 = IsEqual<F1, F2> // true
type Test2 = IsEqual<F1, F3> // false
```

## 总结

实现一个真正准确的 `IsEqual<X, Y>` 类型需要深入理解 TypeScript 的类型系统特性：

:white\_check\_mark: **关键要点**：

* 使用泛型条件类型进行深度比较
* 正确处理 `any` 和 `never` 等特殊类型
* 考虑 `readonly` 和可选属性的影响

:rocket: **推荐实践**：

* 在生产项目中使用本文提供的完整实现
* 对于复杂项目，考虑使用成熟的类型工具库
* 编写类型测试确保类型工具的正确性

通过掌握 `IsEqual` 的实现，你不仅解决了一个具体问题，更重要的是深入理解了 TypeScript 类型系统的运作机制，为编写更复杂、更可靠的类型级代码打下了坚实基础。

## 参考

* [TypeScript 官方高级类型文档](https://www.typescriptlang.org/docs/handbook/advanced-types.html)
* [type-challenges](https://github.com/type-challenges/type-challenges) - 类型编程练习
* [type-fest](https://github.com/sindresorhus/type-fest) - 实用的 TypeScript 类型工具集合

---

---
url: /article/ci39ae1o/index.md
---
# 一些好玩的库或者框架汇总
这里收集了一些各种类型的好玩的库或者框架。

***

## Client Framework

### Lit

[![Lit](https://lit.dev/images/logo.svg){style="width:40px"}](https://lit.dev/)

**lit** 是一个简单的、高效的、用于构建 web component 的轻量级库。

它替代了 [polymer](https://github.com/Polymer/polymer) 成为 WebComponent/customElement开发的首选库。

::: code-tabs
@tab my-element.ts

```ts
import { css, html, LitElement } from 'lit'
import { customElement, property } from 'lit/decorators.js'

@customElement('my-element')
export class MyTimer extends LitElement {
  static styles = css`...`

  @property() count = 0

  render() {
    return html`<div>${this.count}</div>`
  }
}
```

@tab index.html

```html
<!doctype html>
<head>
  ...
</head>
<body>
  <my-timer count="7"></my-timer>
</body>
```

:::

### solid-js

[solid-js](https://www.solidjs.com/)

一个用于构建用户界面，简单高效、性能卓越的JavaScript库。

Solid 站在 React, Knockout 等巨人的肩膀上。如果你之前用 React Hooks 开发过，Solid 应该看起来很自然。事实上，Solid 模型更简单，没有 Hook 规则。每个组件执行一次，随着依赖项的更新，钩子和绑定会多次执行。

Solid 遵循与 React 相同的理念，具有单向数据流、读/写隔离和不可变接口。但是放弃了使用虚拟 DOM，使用了完全不同的实现。

> 号称比 react 还 react 的库

```jsx
import { createSignal, onCleanup } from 'solid-js'
import { render } from 'solid-js/web'

function CountingComponent() {
  const [count, setCount] = createSignal(0)
  const interval = setInterval(
    () => setCount(count => count + 1),
    1000
  )
  onCleanup(() => clearInterval(interval))
  return (
    <div>
      Count value is
      {count()}
    </div>
  )
}

render(() => <CountingComponent />, document.getElementById('app'))
```

### inferno

[inferno](https://www.infernojs.org/) 是一个快速的、类似于 React 的库，用于在客户端和服务器上构建高性能用户界面。

```tsx
import { Component, render } from 'inferno'

class MyComponent extends Component {
  constructor(props) {
    super(props)
    this.state = {
      counter: 0,
    }
  }

  render() {
    return (
      <div>
        <h1>Header!</h1>
        <span>
          Counter is at:
          {this.state.counter}
        </span>
      </div>
    )
  }
}

render(<MyComponent />, document.getElementById('app'))
```

### cycle-js

[cycle.js](https://cycle.js.org/)

Cycle.js是一个极简的JavaScript框架,提供了一种函数式，响应式的人机交互接口。

Cycle.js 有别于其他如 React/Vue 等框架，它提供的是一套完整的开发范式，需要在其范式基础上进行开发，相对来说并不
容易入门，但其函数式、响应式的思想，会带来非常好的启示和学习。

```js
import { div, h1, hr, input, label, makeDOMDriver } from '@cycle/dom'
import { run } from '@cycle/run'

function main(sources) {
  const input$ = sources.DOM.select('.field').events('input')

  const name$ = input$.map(ev => ev.target.value).startWith('')

  const vdom$ = name$.map(name =>
    div([label('Name:'), input('.field', { attrs: { type: 'text' } }), hr(), h1(`Hello ${name}`)]),
  )

  return { DOM: vdom$ }
}

run(main, { DOM: makeDOMDriver('#app-container') })
```

### svelte

[svelte](https://svelte.dev/)

Svelte 是一种全新的构建用户界面的方法。传统框架如 React 和 Vue 在浏览器中需要做大量的工作，而 Svelte 将这些工作放到构建应用程序的编译阶段来处理。

与使用虚拟（virtual）DOM 差异对比不同。Svelte 编写的代码在应用程序的状态更改时就能像做外科手术一样更新 DOM。

```html
<script>
  let count = 0

  function handleClick() {
    count += 1
  }
</script>

<button on:click="{handleClick}">Clicked {count} {count === 1 ? 'time' : 'times'}</button>
```

---

---
url: /article/cjeo0sia/index.md
---
# git工作流实践
在现代软件开发中，Git已成为最主流的版本控制工具。它高效、安全且灵活的特性，为团队协作和项目管理提供了坚实基础。而一个合适的分支管理方案，能够最大化发挥Git的潜力，提升开发效率。

虽然经典的Git-flow方案在中大型项目中表现出色，但在实际应用中，我发现其流程略显复杂。经过多个项目的实践验证，我总结出一套简化的分支管理策略，在保证版本管理严谨性的同时，更贴合实际开发需求。

## 现实开发场景分析

### 标准的版本迭代流程

典型的软件版本迭代遵循这样的路径：

```
需求评审 → 需求确认 → 开发阶段 → 测试环境测试 → 预生产发布验证 → 生产环境发布验证 → 发布完成
```

这个流程中，每个环节都可能出现需要返工的情况：

* 测试环境发现bug，需要返回开发阶段修复
* 预生产环境发现问题，同样需要重新开发、测试、发布
* 生产环境出现问题，需要紧急回滚并重新走完整流程

### 需求变更的现实挑战

理论上，版本进入开发阶段后需求应该保持稳定。但现实中，需求变更、功能增删时有发生，这些变更可能出现在开发阶段，也可能出现在测试阶段。

虽然频繁变更需求确实影响项目稳定性，但这是无法完全避免的现实情况，即使最成熟的团队也会遇到类似问题。

### 周期性发布模式

部分成熟项目采用周期性发布策略，比如每两周固定发布一个版本。这种模式下，版本内容取决于各功能的开发进度和周期内的计划安排。

通过建立需求池，为每个需求制定线性迭代计划，可以更清晰地规划未来版本的功能上线。这种情况下，单一develop分支难以满足多需求并行开发和测试的需求。

### 团队Git技能水平

工具效能的发挥不仅取决于工具本身，更取决于团队对工具的掌握程度。早期我认为团队成员Git水平差异不大，只需简单说明流程即可，但实践证明这存在风险：

* 主分支可能被误操作污染
* 多个功能在同一个分支开发造成混乱

解决这些问题需要建立完善且低复杂度的操作规范，并配合适当的分支权限控制。

## 优化的分支管理方案

基于上述场景，我总结出以下分支管理策略：

### 核心分支定义

**`master`分支**

* 主分支，保存正式版本的代码提交记录
* 禁止直接提交改动，仅接受来自`release`分支的合并请求
* 合并后打上版本标签(tag)

**`release`分支**

* 发布分支，用于预生产和生产环境发布
* 发布完成后合并到master分支
* 仅接受来自prerelease分支的合并请求

**`prerelease/*`分支组**

* 预发布分支，按版本号创建新分支
* 合并当前版本相关的`feature/*`分支，进入测试阶段
* 尽量减少直接提交，主要作为代码集成和测试的平台

**`feature/*`分支组**

* 功能开发分支（包括热修复）
* 从master分支创建，每个分支只负责单一业务功能
* 所有开发改动都在feature分支进行
* 只能合并到prerelease分支
* 需要及时同步master分支的更新

### 工作流示意图

![git-work-flow](https://assets.processon.com/chart_image/6251bfce1efad407891be6c8.png)

### 方案优势

**简化流程**：

整个方案只包含四条主要分支，分支间的流向都是单向的，既简单易懂又保持灵活性。

**prerelease分支的价值**：

用prerelease分支组替代单一的develop分支，能够灵活应对需求变更。当计划调整时，可以直接废弃当前prerelease分支，新建分支重新合并feature代码。

**master与release分离**：

将发布、回滚等操作放在release分支进行，保持master分支的提交历史干净整洁，便于维护和追溯。

### 最佳实践建议

**分支权限控制**：

建议对master和release分支设置保护，确保只能通过合并请求的方式接受代码。

**合并策略选择**：

* 需要完整追踪提交记录：使用merge
* 追求线性整洁的提交历史：使用rebase

**代码审查机制**：

feature分支合并到prerelease分支时，建议通过Pull Request流程，在测试前进行代码审查。

```txt
示例流程：
1. 从master创建feature/user-auth分支
2. 完成功能开发后，发起到prerelease/v1.2的PR
3. 团队成员代码审查
4. 合并到prerelease分支进行测试
5. 测试通过后，prerelease合并到release发布
6. 发布完成后，release合并到master并打tag
```

::: warning 重要说明
本方案基于我个人工作实践总结，在团队内部经过两年多的验证和调整。每个团队的情况不同，请根据实际需求评估适用性。

分支管理方案的选择需要考虑团队规模、产品复杂度等多方面因素。没有绝对的最佳方案，只有最适合自己团队的方案。
:::

这套分支管理策略在保持Git强大功能的同时，通过简化流程降低了团队的学习成本，在实践中证明了其可行性和有效性。希望这些经验能为你的团队提供有价值的参考。

---

---
url: /article/d12xkizf/index.md
---
# JavaScript 进阶 三： 执行上下文
## 执行上下文

执行上下文是， `JavaScript` 代码被 **解析** 和 **执行** 时 **所在环境** 的抽象概念。
`JavaScript` 的任何代码都是在执行上下文中执行的。

### 类型

`JavaScript` 有三种 执行上下文 类型：

* **全局执行上下文**

  默认的执行上下文，或者说基础执行上下文。 任何不在函数内部的代码，都是在 全局执行上下文中。
  全局上下文执行两个事情：

  * 创建一个全局的 `window`对象（在浏览器环境中）。
  * 设置 `this` 的值等于 全局的 `window` 对象。

  一个程序只会有一个全局执行上下文。

* **函数执行上下文**

  每当函数被执行时，都会为该函数创建一个新的执行上下文。
  每个函数都有它自己的执行上下文，且是在函数执行的时候进行创建。
  函数上下文可以有任意多个，每当一个函数执行上下文被创建，它会按照定义的顺序，执行一系列步骤。

* **eval函数执行上下文**

  执行在 `eval` 函数内部的代码也会有它属于自己的执行上下文。

### 创建执行上下文

创建执行上下文主要分为两个阶段： **创建阶段** 和 **执行阶段**。

## 创建阶段

在创建阶段，会做三件事：

* this 值的决定，即 This绑定
* 创建词法环境组件
* 创建变量环境组件

### This绑定

* 全局执行上下文

  在全局执行上下文中， `this` 的值指向全局对象。(在浏览器中， `this` 引用 `Window` 对象)。

* 函数执行上下文

  在函数执行上下文中， `this` 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 `this` 会被设置成那个对象，否则 `this` 的值被设置为全局对象或者 `undefined` （在严格模式下）。

  ```js
  let foo = {
    bar() {
      console.log(this)
    },
  }

  // 'this' 引用 'foo', 因为 'baz' 被对象 'foo' 调用
  foo.bar()

  let bar = foo.baz

  // 'this' 指向全局 window 对象，因为没有指定引用对象
  bar()
  ```

### 词法环境

> [ECMAScript 标准](https://262.ecma-international.org/6.0/)
>
> 词法环境是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符和具体变量和函数的关联。
> 一个词法环境由环境记录器和一个可能的引用外部词法环境的空值组成。

词法环境是一种 **持有标识符—变量映射** 的结构。

::: tip
这里的标识符指的是变量/函数的名字，而变量是对实际对象\[包含函数类型对象]或原始数据的引用。
:::

在词法环境的内部有两个组件：**(1) 环境记录器**和 **(2) 一个外部环境的引用**。

* **环境记录器**是存储变量和函数声明的实际位置。
* **外部环境的引用**意味着它可以访问其父级词法环境（作用域）。

词法环境有两种类型：

* **全局环境**（在全局执行上下文中）是没有外部环境引用的词法环境。全局环境的外部环境引用是 `null`。它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 `window` 对象）还有任何用户定义的全局变量，并且 `this` 的值指向全局对象。
* 在**函数环境**中，函数内部用户定义的变量存储在环境记录器中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。

环境记录器也有两种类型：

* **声明式环境记录器**: 存储变量、函数和参数。
* **对象环境记录器**: 用来定义出现在全局上下文中的变量和函数的关系。

可以看出：

* 在**全局环境**中，环境记录器是对象环境记录器。
* 在**函数环境**中，环境记录器是声明式环境记录器。

::: tip 注意
对于**函数环境**，**声明式环境记录器**还包含了一个传递给函数的 `arguments` 对象（此对象存储索引和参数的映射）和传递给函数的参数的 `length`。
:::

使用伪代码描述 词法环境，大致如下：

```
GlobalExecutionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
    }
    outer: <null>
  }
}

FunctionExecutionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
    }
    outer: <Global or outer function environment reference>
  }
}
```

### 变量环境

**变量环境** 同样是一个 **词法环境**，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。

**变量环境** 有着上面定义的词法环境的所有属性。

在 `ES6` 中，**词法环境**和**变量环境**的一个不同就是前者被用来存储函数声明和变量（`let` 和 `const`）绑定，
而后者只用来存储 `var` 变量绑定。

示例代码：

```js
let a = 20
const b = 30
let c

function multiply(e, f) {
  let g = 20
  return e * f * g
}

c = multiply(20, 30)
```

示例代码 执行上下文伪代码：

```
GlobalExectionContext = {

  ThisBinding: <Global Object>,

  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
      a: < uninitialized >,
      b: < uninitialized >,
      multiply: < func >
    }
    outer: <null>
  },

  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
      c: undefined,
    }
    outer: <null>
  }
}

FunctionExectionContext = {
  ThisBinding: <Global Object>,

  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
      Arguments: {0: 20, 1: 30, length: 2},
    },
    outer: <GlobalLexicalEnvironment>
  },

  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
      g: undefined
    },
    outer: <GlobalLexicalEnvironment>
  }
}
```

::: warning
只有遇到调用函数 `multiply` 时，函数执行上下文才会被创建。
:::

**说明：**

可能你已经注意到 `let` 和 `const` 定义的变量并没有关联任何值，但 `var` 定义的变量被设成了 `undefined。`

这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 `undefined`（`var` 情况下），或者未初始化（`let` 和 `const` 情况下）。

这就是为什么你可以在声明之前访问 `var` 定义的变量（虽然是 `undefined`），但是在声明之前访问 `let` 和 `const` 的变量会得到一个引用错误。

这就是我们说的变量声明提升。

## 执行阶段

在此阶段，完成对所有这些变量的分配，最后执行代码。

::: warning
在执行阶段，如果 `JavaScript` 引擎不能在源码中声明的实际位置找到 `let` 变量的值，它会被赋值为 `undefined`。
:::

---

---
url: /article/d5z98qs5/index.md
---
# JavaScript 进阶 十二： Symbol 类型详解
在 JavaScript 的发展历程中，ES6 引入了一个革命性的新特性——**Symbol**。作为 JavaScript 的第七种原始数据类型，Symbol 为开发者提供了创建唯一标识符的能力，从根本上解决了属性名冲突的问题。

## 什么是 Symbol？

Symbol 是一种新的**原始数据类型**（primitive type），与 `string`、`number`、`boolean` 等并列。它的核心特性是**唯一性**——每个 Symbol 值都是独一无二的。

```javascript
// 创建 Symbol
const symbol1 = Symbol('')
const symbol2 = Symbol('')

console.log(symbol1 === symbol2) // false
console.log(typeof symbol1) // 'symbol'
```

:::tip 关键特性

* 每个 Symbol 都是唯一的，即使描述相同
* 不可变性：一旦创建就不能修改
* 原始类型：`typeof` 返回 `'symbol'`
  :::

## Symbol 的基本用法

### 创建 Symbol

```javascript
// 无描述创建
// eslint-disable-next-line symbol-description
const sym1 = Symbol()

// 带描述创建（仅用于调试）
const sym2 = Symbol('description')
const sym3 = Symbol('description')

console.log(sym2 === sym3) // false - 即使描述相同，值也不同
```

### 描述信息的获取

```javascript
const sym = Symbol('用户ID')
console.log(sym.description) // '用户ID' (ES2019+)
console.log(sym.toString()) // 'Symbol(用户ID)'
```

## Symbol 的核心应用场景

### 1. 作为对象属性键

Symbol 的主要价值在于作为对象的属性名，彻底避免命名冲突。

```javascript
const USER_ID = Symbol('user_id')
const USER_NAME = Symbol('user_name')

const user = {
  [USER_ID]: '12345',
  [USER_NAME]: '张三',
  age: 25
}

console.log(user[USER_ID]) // '12345'
console.log(user[USER_NAME]) // '张三'
```

:::warning 重要特性
Symbol 属性在常规遍历中**不可见**：

```javascript
const obj = {
  [Symbol('hidden')]: '隐藏属性',
  visible: '可见属性'
}

console.log(Object.keys(obj)) // ['visible']
console.log(Object.getOwnPropertyNames(obj)) // ['visible']

for (let key in obj) {
  console.log(key) // 只输出 'visible'
}
```

:::

### 2. 获取 Symbol 属性

虽然 Symbol 属性在常规遍历中不可见，但可以通过专门的方法访问：

```javascript
const obj = {
  [Symbol('secret')]: '机密数据',
  public: '公开数据'
}

// 获取所有 Symbol 属性
const symbols = Object.getOwnPropertySymbols(obj)
console.log(symbols) // [Symbol(secret)]
console.log(obj[symbols[0]]) // '机密数据'

// 获取所有键（包括 Symbol）
const allKeys = Reflect.ownKeys(obj)
console.log(allKeys) // ['public', Symbol(secret)]
```

### 3. 替代常量定义

传统字符串常量容易因拼写错误导致 bug，而 Symbol 从根本上解决了这个问题。

:::code-tabs
@tab 传统方式（易出错）

```javascript
const STATUS = {
  PENDING: 'pending',
  SUCCESS: 'succes' // 拼写错误！
}

function handleStatus(status) {
  if (status === STATUS.SUCCES) { // 这里也拼写错误
    // 永远不会执行
  }
}
```

@tab Symbol 方式（安全）

```javascript
const STATUS = {
  PENDING: Symbol('pending'),
  SUCCESS: Symbol('success'),
  ERROR: Symbol('error')
}

function handleStatus(status) {
  if (status === STATUS.SUCCESS) { // 引用正确，不会出错
    console.log('操作成功')
  }
}
```

:::

### 4. 模拟私有属性

在 ES6 引入真正的私有字段之前，Symbol 是模拟私有属性的最佳方案。

```javascript title="user.js"
const PASSWORD = Symbol('password')

class User {
  constructor(username, password) {
    this.username = username
    this[PASSWORD] = password
  }

  checkPassword(inputPassword) {
    return this[PASSWORD] === inputPassword
  }
}

export default User
```

```javascript title="main.js"
import User from './user.js'

const user = new User('admin', '123456')

console.log(user.checkPassword('123456')) // true
console.log(user.PASSWORD) // undefined
console.log(user[Symbol('password')]) // undefined - 无法访问
```

## 全局 Symbol 注册表

如果需要在不同地方共享同一个 Symbol，可以使用全局注册表。

### Symbol.for() 和 Symbol.keyFor()

```javascript
// 创建或获取全局 Symbol
const globalSym1 = Symbol.for('app.config')
const globalSym2 = Symbol.for('app.config')

console.log(globalSym1 === globalSym2) // true

// 获取全局 Symbol 的描述
console.log(Symbol.keyFor(globalSym1)) // 'app.config'

// 非全局 Symbol 返回 undefined
const localSym = Symbol('local')
console.log(Symbol.keyFor(localSym)) // undefined
```

:::info 使用场景
全局 Symbol 适合在多个模块间共享配置、状态或标识符，确保使用同一个 Symbol 实例。
:::

## 内置 Symbol 值（Well-known Symbols）

ES6 提供了一系列内置 Symbol，用于定制对象的内部行为。

### Symbol.iterator - 定义迭代器

```javascript
class Range {
  constructor(start, end) {
    this.start = start
    this.end = end
  }

  [Symbol.iterator]() {
    let current = this.start
    const end = this.end

    return {
      next() {
        if (current <= end) {
          return { value: current++, done: false }
        }
        return { done: true }
      }
    }
  }
}

const range = new Range(1, 3)
for (const num of range) {
  console.log(num) // 1, 2, 3
}
```

### Symbol.toStringTag - 自定义类型标签

```javascript
class Collection {
  constructor() {
    this.items = []
  }

  get [Symbol.toStringTag]() {
    return 'CustomCollection'
  }
}

const coll = new Collection()
console.log(Object.prototype.toString.call(coll)) // '[object CustomCollection]'
```

### Symbol.toPrimitive - 类型转换控制

```javascript
const temperature = {
  value: 25,
  unit: '°C',

  [Symbol.toPrimitive](hint) {
    switch (hint) {
      case 'string':
        return `${this.value}${this.unit}`
      case 'number':
        return this.value
      default:
        return this.value.toString()
    }
  }
}

console.log(String(temperature)) // "25°C"
console.log(Number(temperature)) // 25
console.log(temperature + 5) // 30
```

### 其他重要内置 Symbol

* **Symbol.hasInstance**: 自定义 `instanceof` 行为
* **Symbol.isConcatSpreadable**: 控制数组连接时的展开行为
* **Symbol.species**: 指定派生对象的构造函数
* **Symbol.match/replace/search/split**: 自定义字符串匹配行为

## Symbol 与 JSON

:::caution 注意
Symbol 属性在 JSON 序列化时会被完全忽略：

```javascript
const obj = {
  name: 'Alice',
  [Symbol('id')]: 123
}

console.log(JSON.stringify(obj)) // '{"name":"Alice"}'
```

:::

## 实际开发中的最佳实践

### 1. 库开发中的属性扩展

```javascript
// 安全地为内置对象添加扩展
const CUSTOM_FILTER = Symbol('customFilter')

// eslint-disable-next-line no-extend-native
Array.prototype[CUSTOM_FILTER] = function (predicate) {
  const result = []
  for (let i = 0; i < this.length; i++) {
    if (predicate(this[i], i, this)) {
      result.push(this[i])
    }
  }
  return result
}

const numbers = [1, 2, 3, 4, 5]
const evens = numbers[CUSTOM_FILTER](n => n % 2 === 0)
console.log(evens) // [2, 4]
```

### 2. 元数据存储

```javascript
const METADATA = Symbol('metadata')

class ApiClient {
  constructor(baseURL) {
    this.baseURL = baseURL
    this[METADATA] = {
      requestCount: 0,
      lastRequest: null
    }
  }

  async get(url) {
    this[METADATA].requestCount++
    this[METADATA].lastRequest = new Date()

    // 实际的请求逻辑...
    console.log(`请求 ${this.baseURL}${url}`)
  }

  getStats() {
    return { ...this[METADATA] }
  }
}

const client = new ApiClient('https://api.example.com')
await client.get('/users')
console.log(client.getStats()) // { requestCount: 1, lastRequest: ... }
```

### 3. 事件系统

```javascript
const EVENT_TYPES = {
  CLICK: Symbol('click'),
  HOVER: Symbol('hover'),
  FOCUS: Symbol('focus')
}

class EventEmitter {
  constructor() {
    this.listeners = new Map()
  }

  on(eventType, handler) {
    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, new Set())
    }
    this.listeners.get(eventType).add(handler)
  }

  emit(eventType, data) {
    const handlers = this.listeners.get(eventType)
    if (handlers) {
      handlers.forEach(handler => handler(data))
    }
  }
}

const emitter = new EventEmitter()
emitter.on(EVENT_TYPES.CLICK, (data) => {
  console.log('点击事件:', data)
})

emitter.emit(EVENT_TYPES.CLICK, { x: 100, y: 200 })
```

## 注意事项和限制

:::important 重要提醒

1. **类型转换限制**: Symbol 不能隐式转换为字符串或数字

   ```javascript
   const sym = Symbol('test')
   // console.log('Symbol: ' + sym); // TypeError!
   console.log(String(sym)) // 正确方式
   ```

2. **不是真正的私有**: 通过 `Object.getOwnPropertySymbols()` 仍然可以访问

3. **模块依赖**: 模拟私有属性时，Symbol 必须在同一模块中定义
   :::

## 总结

Symbol 作为 ES6 引入的重要特性，为 JavaScript 带来了：

* **🎯 唯一性保障**: 从根本上解决属性名冲突
* **🔒 半私有属性**: 提供比字符串键更隐蔽的属性定义
* **⚙️ 元编程能力**: 通过内置 Symbol 定制对象行为
* **🔄 跨模块共享**: 全局 Symbol 注册表支持

在实际开发中，Symbol 特别适合：

* 库和框架开发
* 需要避免属性冲突的场景
* 定义内部元数据
* 实现自定义迭代器和类型转换

虽然 ES2022 引入了真正的私有字段（`#` 语法），但 Symbol 在避免命名冲突和元编程方面仍然具有不可替代的价值。

\==掌握 Symbol 是深入理解现代 JavaScript 的关键一步=={.success}，它为我们提供了更安全、更灵活的编程模式。

---

---
url: /article/df11xgdo/index.md
---
# HTML <meta> 标签详解
## 什么是Meta标签？

Meta标签是HTML文档中用于提供关于网页的元数据（metadata）的标签。这些信息不会直接显示在页面上，但对浏览器、搜索引擎和其他网络服务至关重要。

## Meta标签的基本作用

### 1. 字符编码声明

```html
<meta charset="UTF-8">
```

**作用**：确保浏览器正确解析和显示网页内容，避免乱码问题。

### 2. 视口设置（移动端适配）

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

**作用**：控制移动设备上的页面显示比例和尺寸。

### 3. 搜索引擎优化

```html
<meta name="description" content="页面描述内容">
<meta name="keywords" content="关键词1,关键词2,关键词3">
```

**作用**：帮助搜索引擎理解页面内容，提升搜索排名。

## 常见Meta标签属性详解

### 1. name + content 组合

#### 页面描述

```html
<meta name="description" content="这是一个关于前端开发技术博客的页面">
```

**用途**：搜索引擎在搜索结果中显示的页面摘要。

#### 关键词

```html
<meta name="keywords" content="HTML,CSS,JavaScript,前端开发">
```

**用途**：向搜索引擎说明页面的核心关键词（现代搜索引擎已降低其权重）。

#### 作者信息

```html
<meta name="author" content="张三">
```

**用途**：声明页面作者信息。

#### 搜索引擎爬虫指令

```html
<meta name="robots" content="index,follow">
```

**常用值**：

* `index, follow`：允许抓取和跟踪链接（默认）
* `noindex, nofollow`：禁止抓取和跟踪链接
* `noindex, follow`：禁止抓取但允许跟踪链接

#### 移动端特定设置

```html
<meta name="format-detection" content="telephone=no">
<meta name="format-detection" content="email=no">
```

**用途**：防止iOS设备自动将数字识别为电话号码或邮箱。

### 2. http-equiv 属性

#### 页面刷新与重定向

```html
<meta http-equiv="refresh" content="5;url=https://example.com">
```

**用途**：5秒后自动跳转到指定URL（慎用，可能影响用户体验）。

#### 内容安全策略

```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self'">
```

**用途**：防止XSS攻击，控制资源加载来源。

#### 禁用浏览器兼容性视图

```html
<meta http-equiv="X-UA-Compatible" content="IE=edge">
```

**用途**：强制IE浏览器使用最新渲染模式。

### 3. property 属性（Open Graph协议）

主要用于社交媒体分享优化：

```html
<meta property="og:title" content="页面标题">
<meta property="og:description" content="页面描述">
<meta property="og:image" content="https://example.com/image.jpg">
<meta property="og:url" content="https://example.com">
<meta property="og:type" content="website">
```

**用途**：控制在Facebook、Twitter等社交媒体分享时的显示效果。

### 4. charset 属性

```html
<meta charset="UTF-8">
```

**用途**：必须放在`<head>`的最前面，确保字符正确解析。

## 实战应用示例

### 基础SEO优化配置

```html
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="专业的前端开发技术博客，分享最新的前端技术和实战经验">
    <meta name="keywords" content="前端开发,JavaScript,React,Vue,CSS">
    <meta name="author" content="前端技术团队">

    <!-- Open Graph -->
    <meta property="og:title" content="前端技术博客">
    <meta property="og:description" content="专业的前端开发技术分享">
    <meta property="og:image" content="/og-image.jpg">
    <meta property="og:url" content="https://blog.example.com">
    <meta property="og:type" content="website">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="前端技术博客">
    <meta name="twitter:description" content="专业的前端开发技术分享">
</head>
```

### 移动端优化配置

```html
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no">
</head>
```

## 最佳实践建议

1. **必须包含的Meta标签**：
   * `charset`
   * `viewport`（移动端项目）
   * `description`

2. **按需配置**：
   * 社交媒体分享：Open Graph协议
   * PWA应用：manifest相关配置
   * 安全策略：CSP设置

3. **避免使用**：
   * 自动刷新/重定向（影响用户体验）
   * 过时的关键词堆砌

4. **性能考虑**：
   * 合理控制Meta标签数量
   * 避免过长的content值

## 总结

Meta标签虽然不直接显示在页面上，但在现代Web开发中扮演着至关重要的角色。合理配置Meta标签可以：

* 提升搜索引擎排名
* 优化移动端用户体验
* 增强社交媒体分享效果
* 提高网站安全性
* 确保内容正确显示

掌握Meta标签的正确用法，是每个前端开发者必备的基础技能。建议在实际项目中根据具体需求灵活配置，持续优化用户体验和网站性能。

## 参考

[MDN Web Docs - Meta元素](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta){.read-more}
[Open Graph协议官方文档](https://ogp.me/){.read-more}
[Google搜索开发者文档](https://developers.google.com/search/docs){.read-more}

---

---
url: /article/dixuz4sh/index.md
---
# 前端渲染策略 —— CSR、SSR、SSG、ISG
想象一下建设一座城市（你的Web应用）。

你是选择在工厂（服务器）里预先建造好整栋房子运过去（SSG）？

还是派个施工队（浏览器）到现场根据图纸（JS）慢慢盖（CSR）？

或者是让工厂按订单要求快速生产好毛坯房再运过去让施工队装修（SSR）？

甚至是在预制好的房子里预留模块，按需更新（ISG）？

🤔 今天，我们就来拆解这四种主流渲染策略：**客户端渲染 (CSR)**、**服务器端渲染 (SSR)**、**静态站点生成 (SSG)** 和 **增量静态再生 (ISG)**，帮你找到最适合项目的“城市建设方案”。

## 客户端渲染 (CSR - Client-Side Rendering)

### 工作原理

* 用户请求一个URL。
* 服务器返回一个**近乎空白的HTML文件**（通常只有一个根元素`<div id="root"></div>`和指向大量JavaScript文件的链接）。
* 浏览器下载HTML、CSS和**所有必需的JavaScript**（包括框架如React/Vue/Angular，以及应用代码）。
* JavaScript **在用户的浏览器中执行**，负责：
  * 获取数据（通常通过API调用）。
  * 构建DOM（页面结构）。
  * 将构建好的DOM插入到根元素中。
  * 处理后续的交互和路由切换（所有后续页面跳转也由JS处理，无需整页刷新）。

### 典型代表

传统的单页应用 (SPA) 框架如 **Create React App, Vue CLI 默认输出**。

### 优点

* **交互体验流畅：** 首次加载后，后续导航和交互感觉极其快速，接近原生应用，因为只更新变化的部分。
* **服务器压力小：** 服务器主要提供静态文件和API，计算负担转移到客户端。
* **开发体验好：** 前后端分离清晰，前端开发者拥有完全控制权，利用现代框架开发高效。
* **丰富的交互能力：** 非常适合构建高度交互式、类应用（Application-like）的体验。

### 缺点

* **首屏加载慢 (FCP/TTI 差)：** 用户需要等待所有JS下载、解析、执行、数据获取、渲染完成才能看到有意义的内容。尤其对低端设备和慢网络用户不友好。
* **SEO 不友好：** 搜索引擎爬虫早期（现在部分高级爬虫如Googlebot能执行JS，但仍有延迟和不确定性）可能只能看到空HTML或加载状态，难以正确索引内容。
* **内容可见性延迟：** 用户盯着空白屏或加载动画的时间较长。

### 适用场景

* 后台管理系统、Dashboards（对SEO无要求）。
* 高度交互的Web应用（如在线编辑器、复杂表单、实时协作工具）。
* 登录后才能访问的内容（此时SEO不重要）。
* 网络条件较好（或对首屏性能要求不高）的场景。

## 服务器端渲染 (SSR - Server-Side Rendering)

### 工作原理

* 用户请求一个URL。
* 服务器**实时**接收到请求。
* 服务器运行JavaScript应用（如Node.js + React/Vue）。
* 服务器根据请求的URL，**获取所需数据**（查询数据库、调用API等）。
* 服务器执行应用代码，**将组件渲染成完整的HTML字符串**（包含实际内容）。
* 服务器将这个**完整的、包含数据的HTML文档**发送给浏览器。
* 浏览器接收到HTML后能**立即显示有意义的内容**（FCP快）。
* 同时，浏览器会下载JS包（hydration）。JS下载执行后，会“接管”页面，附加事件监听器，使页面变得可交互（TTI可能稍晚于FCP）。后续交互和导航通常又转为CSR模式。

### 典型代表

* **Next.js** (`getServerSideProps`),
* **Nuxt.js** (`server-side rendering mode`)
* **SvelteKit** (适配器如`@sveltejs/adapter-node`)

### 优点

* **优秀的首屏性能 (FCP)：** 用户能快速看到完整内容，提升感知速度。
* **卓越的SEO：** 搜索引擎爬虫直接获取到包含完整内容的HTML，索引无忧。
* **更好的社交分享：** 分享链接时，社交媒体的爬虫也能获取到包含完整元信息（如Open Graph tags）和内容的HTML，生成正确的预览卡片。
* **对低端设备/慢网络更友好：** 用户能尽早看到内容。

### 缺点

* **服务器压力大：** 每个请求都需要服务器实时渲染，消耗CPU资源。高并发时可能成为瓶颈，需要良好的服务器架构和缓存策略（如CDN缓存、反向代理缓存）。
* **TTI可能延迟：** 虽然内容显示快，但页面可交互（TTI）需要等待JS下载和执行完成（hydration）。如果JS包很大，用户看到内容但无法立即点击，体验会打折扣（需优化hydration性能）。
* **开发复杂度稍高：** 需要考虑服务器环境、数据获取方式（`getServerSideProps`等）、hydration过程，调试可能更复杂。

### 适用场景

* 内容密集型且对SEO要求极高的网站（新闻、博客、电商列表/详情页）。
* 需要良好社交分享预览的页面。
* 用户网络条件差异较大的公共网站。
* 需要用户立即看到核心内容的页面。

## 静态站点生成 (SSG - Static Site Generation)

### 工作原理

* **在构建时（Build Time）**，而不是在用户请求时。
* 应用代码运行在**构建服务器**上。
* 为网站中的**每一个可能的页面路径**（基于文件路由或配置），执行以下操作：
  * **获取该页面所需的所有数据**（从CMS、API、数据库、本地文件等）。
  * **将React/Vue/Svelte组件渲染成纯HTML字符串**。
* 将生成的每个HTML文件，连同其CSS、JS、图片等资源，**输出为静态文件**。
* 将这些静态文件部署到CDN或静态文件托管服务。
* 用户请求一个URL时，CDN直接返回**预先渲染好的、包含完整内容的静态HTML文件**，浏览器快速展示（FCP极快）。JS随后下载执行进行hydration，添加交互性（TTI通常也很快，因为资源在CDN边缘）。

### 典型代表

* **Next.js** (`getStaticProps`/`getStaticPaths`)
* **Gatsby**
* **Nuxt.js** (`target: static`)
* **VitePress**
* **Hugo**
* **Jekyll**
* **Eleventy (11ty)**

### 优点

* **极致性能：** 页面直接从全球CDN边缘节点提供，加载速度极快（FCP, TTI, LCP 都优秀）。
* **超强安全性：** 没有实时服务器或数据库暴露给公共网络，攻击面极小。
* **成本低廉：** 静态文件托管（如Vercel, Netlify, GitHub Pages, AWS S3 + CloudFront）通常非常便宜甚至免费，且能轻松应对高流量。
* **优秀的SEO：** 和SSR一样，爬虫直接获取完整HTML内容。
* **简单可靠：** 部署就是上传文件，没有服务器运行时的复杂性和潜在故障点。

### 缺点

* **构建时数据：** 页面内容在构建时就固定了。如果数据源更新，必须**重新构建并部署整个站点（或受影响页面）** 才能更新页面内容。不适合**数据频繁变化**的页面（如实时股票行情、高频更新的评论区）。
* **大规模站点构建时间长：** 如果页面数量成千上万，每次构建可能需要几分钟甚至几十分钟。

### 适用场景

* 博客、文档网站、营销/宣传页（内容相对稳定）。
* 产品展示页、公司官网。
* 基于CMS但内容发布不频繁的网站（可以在CMS更新后触发构建）。
* 任何内容变化频率低于构建/部署频率的场景。追求极致性能、安全和成本效益的场景。

## 增量静态再生 (ISG - Incremental Static Regeneration)

### 工作原理

::: tip Next.js 提出的概念，核心思想
:::

* 在SSG的基础上，增加了**按需或在后台更新静态内容的能力**，**无需重新部署整个应用**。
* 在构建时 (`getStaticProps`) 可以指定一个 `revalidate` 时间（单位：秒）。
* 用户请求一个页面：
  1. **首先**，CDN/服务器会立即返回**上次构建或再生的静态HTML**（极快）。
  2. **同时**，在后台检查该页面自上次生成后是否已超过 `revalidate` 时间。
  3. **如果超过**，则在后台触发一次该页面的“再生”：
     * 重新运行 `getStaticProps` 获取**最新数据**。
     * 用新数据**重新生成该页面的HTML**。
     * 将新HTML**保存/缓存**起来，替换旧版本。
  4. **下次请求**该页面时，用户将直接获得新生成的HTML。
* 第一个触发再生的用户可能看到的还是旧页面，但他“默默”帮助后续用户更新了缓存。
* 也可以使用 `On-Demand Revalidation` (按需再生)：通过API路由手动触发特定页面（或带标签的一组页面）的立即再生（如CMS更新后调用Webhook）。

### 典型代表

**Next.js** (`getStaticProps` with `revalidate` 或 `unstable_revalidate` API / On-Demand ISR)。

### 优点

* **保留SSG的所有优点：** 极致的性能、安全性、成本效益、SEO。
* **解决SSG的最大痛点：** 内容可以**在部署后更新**！数据不再是完全静态的。可以设置一个合理的更新频率（如每10秒、1分钟、1小时）。
* **增量更新：** 只更新过期的页面，而不是全站重建，大大减少构建压力。
* **优雅降级：** 即使后台再生失败或超时，用户看到的仍是有效的（可能稍旧的）缓存内容。

### 缺点

* **内容更新非即时：** 用户可能在 `revalidate` 时间窗口内看到稍旧的数据（但通常可接受）。需要按需再生API才能实现接近实时（但仍有CDN传播延迟）。
* **概念稍复杂：** 需要理解缓存、再生、过期时间等机制。
* **平台依赖：** 主要深度集成在Vercel平台，其他平台实现可能不同或有局限（如Netlify也支持类似功能）。

### 适用场景

**SSG的理想场景，但数据更新频率高于全站部署频率时**：

* 电商网站（商品列表/详情页 - 价格/库存可设置短时刷新，商品增删触发按需再生）。
* 新闻/博客网站（新文章发布触发按需再生，热门文章设置短刷新）。
* 社交媒体Feed（用户主页Feed设置分钟级刷新）。
* 任何需要良好性能+SEO+动态内容组合的页面。

## 对比

| 特性                   | CSR (Client-Side)     | SSR (Server-Side)        | SSG (Static Site Gen)       | ISG (Incremental Static Regen)     |
| :--------------------- | :-------------------- | :----------------------- | :-------------------------- | :--------------------------------- |
| **渲染发生地**         | 浏览器                | 服务器 (每次请求)        | 构建服务器 (一次)           | 构建服务器 + 运行服务器 (按需)     |
| **首次内容加载 (FCP)** | 慢 (需下载执行JS)     | **快** (收到完整HTML)    | **极快** (CDN静态文件)      | **极快** (CDN静态文件)             |
| **可交互时间 (TTI)**   | 慢 (依赖JS下载执行完) | 中 (需Hydration)         | **快** (Hydration快)        | **快** (Hydration快)               |
| **SEO**                | 差/需额外处理         | **优**                   | **优**                      | **优**                             |
| **服务器压力**         | 低 (主要API)          | **高** (每次渲染)        | **极低** (仅静态文件)       | **低** (按需再生)                  |
| **数据实时性**         | 实时 (API调用)        | 实时 (请求时获取)        | 构建时 (固定)               | **可配置** (`revalidate`时间/按需) |
| **内容更新方式**       | JS动态更新            | 重新请求                 | **重新构建部署**            | **后台再生/按需触发**              |
| **成本**               | 中 (需要API服务器)    | 高 (需要计算型服务器)    | **极低** (静态托管)         | **低** (静态托管+少量计算)         |
| **安全性**             | 中 (暴露API)          | 中 (暴露服务器)          | **高** (纯静态)             | **高** (主要静态)                  |
| **开发复杂度**         | 低                    | 中高                     | 低                          | 中                                 |
| **典型用例**           | 后台SPA, 复杂交互应用 | 电商详情, 新闻, 高SEO页  | 博客, 文档, 营销页          | 电商, 新闻Feed, 需更新的SSG页      |
| **代表框架**           | CRA, Vite, Vue CLI    | Next.js, Nuxt, SvelteKit | Next.js, Gatsby, Nuxt, 11ty | **Next.js (最佳支持)**             |

## 如何选择？决策流程图

```mermaid
graph TD
A[开始] --> B{需要动态数据且变化频繁？}
B --> |是| C{对首屏性能和SEO要求高？}
C --> |是| D[SSR 或 ISG]
C --> |否| E[CSR]
B --> |否| F{内容基本静态？}
F --> |是| G[SSG]
F --> |否| H{数据变化频率中等，可接受短暂延迟？}
H --> |是| I[ISG]
H --> |否| D[SSR 或 ISG]
```

**决策要点：**

1. **数据变化频率：** 数据多久变一次？秒级？分钟级？小时级？天级？这是选择SSG vs SSR/ISG的关键。
2. **SEO需求：** 页面是否需要被搜索引擎良好索引？是则优先考虑SSR、SSG、ISG。
3. **性能要求：** 首屏速度 (FCP) 和可交互速度 (TTI) 有多重要？追求极致选SSG/ISG。
4. **用户交互复杂度：** 页面是否高度交互？是则CSR或SSR/SSG/ISG + 强大的客户端JS。
5. **基础设施与成本：** 是否有预算/能力维护服务器（SSR）？还是倾向于零服务器管理/低成本（SSG/ISG）？
6. **内容规模：** 页面数量巨大？SSG全量构建可能慢，ISR或SSR（配合缓存）可能是更好的选择。

## 结论：没有银弹，只有权衡

CSR、SSR、SSG、ISG 代表了Web渲染策略的演进，每一种都有其独特的优势和适用场景。现代框架（尤其是Next.js）的强大之处在于它们**支持混合渲染模式**：你可以为一个应用中的不同页面选择最合适的策略！

* 将营销首页、博客文章页用 **SSG/ISG** 实现极致性能和SEO。
* 将用户个人中心、设置页用 **CSR** 实现流畅交互（SEO不重要）。
* 将需要实时数据的特定页面（如最新交易）用 **SSR** 或 **ISR (短`revalidate`)**。

**理解这些模式的核心原理、优缺点和适用场景，是作为前端工程师做出明智架构决策的基础。** 选择哪种方案，最终取决于你的具体项目需求在性能、SEO、开发体验、成本和数据实时性之间的优先级排序。

---

---
url: /article/djie49el/index.md
---
# CSS @scope：精准控制样式作用域
在现代前端开发中，组件化和模块化已成为主流趋势。然而，CSS的选择器作用域问题一直困扰着开发者。现在，CSS `@scope` 规则的到来为我们提供了原生解决方案，让我们能够更精确地控制样式的应用范围。

## 什么是 @scope？

`@scope` 是CSS的一个at-rule（at规则），它允许你在特定的DOM子树中创建样式作用域。这意味着你可以将样式规则的应用范围限制在文档的特定部分，而无需编写过于具体的选择器或依赖复杂的命名约定。

### 基本语法

```css
@scope (scope-root) to (scope-limit) {
  /* 样式规则 */
}
```

* **scope-root**：定义作用域的起始边界
* **scope-limit**（可选）：定义作用域的结束边界
* **样式规则**：在作用域内应用的CSS规则

## 核心概念详解

### 1. 作用域根（Scope Root）

作用域根定义了样式开始应用的节点。所有在 `@scope` 块内的样式规则都将相对于这个根元素进行匹配。

```css title="基础作用域示例"
@scope (.article-section) {
  a {
    color: blue;
  }

  img {
    border: 2px solid #ccc;
  }
}
```

### 2. 作用域限制（Scope Limit）

作用域限制允许你创建"环形作用域"（donut scope），即排除某些特定区域。

```css title="环形作用域示例"
@scope (.article-body) to (figure) {
  img {
    border: 5px solid black;
    background-color: goldenrod;
  }
}
```

这个例子中，样式只应用于 `.article-body` 内的 `<img>` 元素，但不包括 `<figure>` 元素内的图片。

## 实际应用场景

### 场景1：组件样式隔离

::::demo normal title="组件样式隔离" desc="在不同组件中应用不同的链接样式"
::: code-tabs
@tab HTML

```html
<div class="blog-section">
  <p>博客内容中的<a href="#">链接</a></p>
</div>

<div class="sidebar-section">
  <p>侧边栏中的<a href="#">链接</a></p>
</div>
```

@tab CSS

```css
@scope (.blog-section) {
  a {
    color: #1a73e8;
    text-decoration: none;
  }

  a:hover {
    text-decoration: underline;
  }
}

@scope (.sidebar-section) {
  a {
    color: #34a853;
    font-weight: bold;
  }
}
```

:::
::::

### 场景2：内容区域样式控制

::::demo normal title="内容区域样式" desc="在文章内容区域中控制图片样式，但排除引用区域"
::: code-tabs
@tab HTML

```html
<article class="content">
  <div class="main-content">
    <img src="/images/defensive-css/ratio.png" alt="主图片" width="300px">
    <p>主要内容区域</p>

    <blockquote class="quote">
      <img src="/images/defensive-css/ratio.png" alt="引用图片" width="300px">
      <p>引用内容</p>
    </blockquote>
  </div>
</article>
```

@tab CSS

```css
@scope (.main-content) to (.quote) {
  img {
    border: 3px solid #4285f4;
    border-radius: 8px;
  }

  p {
    line-height: 1.6;
    color: #202124;
  }
}
```

:::
::::

## 高级特性

### 1. :scope 伪类

在 `@scope` 块内，`:scope` 伪类代表匹配的作用域根元素。

```css title=":scope 伪类使用"
@scope (.feature-card) {
  :scope {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 12px;
    padding: 20px;
  }

  :scope:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
  }
}
```

### 2. & 选择器

`&` 选择器在 `@scope` 中代表作用域根的选择器，可以多次链接使用。

```css title="& 选择器使用"
@scope (.container) {
  & > .header {
    font-size: 1.5rem;
    margin-bottom: 1rem;
  }

  & & {
    /* 匹配嵌套在.container内的.container */
    border-left: 3px solid #fbbc05;
  }
}
```

### 3. 内联作用域

你可以在HTML的 `<style>` 元素中使用 `@scope`，此时作用域会自动限定在父元素内。

```html title="内联作用域示例"
<div class="widget">
  <style>
    @scope {
      h3 {
        color: #ea4335;
        border-bottom: 2px solid currentColor;
      }

      p {
        color: #5f6368;
      }
    }
  </style>

  <h3>小部件标题</h3>
  <p>小部件内容...</p>
</div>
```

## 优先级和层叠

### 特异性计算

`@scope` 块本身不会影响内部选择器的特异性：

```css
@scope (#sidebar) {
  img { /* 特异性 = (0,0,1) */
    /* 样式规则 */
  }

  :scope img { /* 特异性 = (0,1,0) + (0,0,1) = (0,1,1) */
    /* 样式规则 */
  }
}
```

### 作用域就近原则

CSS层叠新增了"作用域就近"准则，当两个作用域的样式冲突时，距离作用域根更近的样式胜出。

::::demo normal title="作用域就近原则" desc="演示嵌套主题中作用域就近原则的应用"
::: code-tabs
@tab HTML

```html
<div class="light-theme">
  <p>浅色主题文本</p>
  <div class="dark-theme">
    <p>深色主题文本</p>
    <div class="light-theme">
      <p>嵌套的浅色主题文本</p>
    </div>
  </div>
</div>
```

@tab CSS

```css
@scope (.light-theme) {
  :scope {
    background: #f8f9fa;
  }
  p {
    color: #202124;
  }
}

@scope (.dark-theme) {
  :scope {
    background: #202124;
  }
  p {
    color: #e8eaed;
  }
}
```

:::
::::

## 浏览器兼容性

@[caniuse](mdn-css_at-rules_scope)

## 最佳实践

:::steps

* **合理使用作用域限制**：只在需要排除特定区域时使用作用域限制，避免过度复杂化
* **保持选择器简洁**：利用作用域特性，使用更简洁的选择器
* **注意继承特性**：`@scope` 提供选择器隔离，但样式继承仍然会穿透作用域边界
* **渐进增强**：为不支持 `@scope` 的浏览器提供回退样式

:::

## 与传统方法的对比

| 方法                  | 优点                 | 缺点                   |
| --------------------- | -------------------- | ---------------------- |
| **BEM命名**           | 可预测，工具支持好   | 类名冗长，维护成本高   |
| **CSS Modules**       | 真正的样式隔离       | 需要构建工具，学习曲线 |
| **Styled Components** | 组件化思维，动态样式 | JavaScript依赖，包体积 |
| **`@scope`**          | 原生支持，无需工具   | 浏览器兼容性，继承穿透 |

## 总结

CSS `@scope` 规则为前端开发者提供了一个强大的工具，让我们能够：

* 🎯 **精准控制样式作用域**，避免样式污染
* 🍩 **创建环形作用域**，排除特定区域
* 🔧 **减少选择器特异性**，提高代码可维护性
* 🚀 **原生支持**，无需额外的构建工具

虽然目前浏览器支持仍在完善中，但 `@scope` 无疑是CSS发展的一个重要里程碑。随着浏览器支持的普及，它将成为我们样式工具箱中不可或缺的一部分。

## 参考

* [MDN @scope 文档](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@scope)
* [CSS Cascading and Inheritance Level 6 规范](https://drafts.csswg.org/css-cascade-6/#scoped-styles)
* [Chrome Developers @scope 指南](https://developer.chrome.com/docs/css-ui/at-scope)

---

---
url: /article/e5tdk50d/index.md
---
# TypeScript 中的协变与逆变
> 掌握类型系统的核心概念，让你的 TypeScript 水平更上一层楼

## 引言：为什么需要了解协变与逆变？

作为 TypeScript 开发者，你可能经常遇到一些看似"不合理"的类型错误。比如，为什么 `string[]` 可以赋值给 `(string | number)[]`，但 `(string | number)[]` 却不能赋值给 `string[]`？这背后就是协变与逆变在起作用。

理解这两个概念不仅能帮你解决日常开发中的类型困惑，还能让你写出更安全、更健壮的类型代码。

## 核心概念：用现实世界类比理解

### 什么是协变（Covariance）？

**简单理解**：协变就是"保持方向一致"。

**现实类比**：
想象一个宠物店：

* 如果你承诺"我会照顾任何品种的狗"
* 那么你当然也能"照顾金毛犬"（因为金毛是狗的子类型）

在类型系统中，如果 `金毛犬` 是 `狗` 的子类型，那么 `照顾金毛犬[]` 也是 `照顾狗[]` 的子类型。

```typescript
// 基础类型
class Animal { name!: string }
class Dog extends Animal { bark() {} }
class Cat extends Animal { meow() {} }

// 协变示例：数组类型
let dogs: Dog[] = [new Dog(), new Dog()]
let animals: Animal[] = dogs // ✅ 允许：Dog[] 可以赋值给 Animal[]

// 因为：Dog extends Animal
// 所以：Dog[] 也 "extends" Animal[] （这就是协变）
```

### 什么是逆变（Contravariance）？

**简单理解**：逆变就是"方向反转"。

**现实类比**：
想象一个宠物领养活动：

* 如果你承诺"我能处理任何动物相关的工作"
* 那么你其实也能"处理狗相关的工作"（因为狗是动物的子类型）

注意这里的方向：`处理动物` 是 `处理狗` 的子类型，方向反了！

```typescript
// 函数参数类型的逆变
type AnimalHandler = (animal: Animal) => void
type DogHandler = (dog: Dog) => void

let handleAnimal: AnimalHandler = (animal: Animal) => {
  console.log(animal.name)
}

let handleDog: DogHandler = handleAnimal // ✅ 允许：AnimalHandler 可以赋值给 DogHandler

// 为什么？因为任何需要处理狗的函数，我给它一个能处理所有动物的函数，绝对安全！
```

## TypeScript 中的协变与逆变实践

### 1. 数组和对象是协变的

这是最常见的协变场景：

```typescript
// 数组协变
let stringArray: string[] = ['hello', 'world']
let stringOrNumberArray: (string | number)[] = stringArray // ✅ 允许

// 对象属性协变
interface Base {
  pet: Animal
}

interface Derived {
  pet: Dog // Dog 是 Animal 的子类型
}

let derived: Derived = { pet: new Dog() }
let base: Base = derived // ✅ 允许
```

### 2. 函数参数是逆变的

这是 TypeScript 中最重要的逆变场景：

```typescript
// 函数类型比较
type ProcessAnimal = (animal: Animal) => void
type ProcessDog = (dog: Dog) => void

// 这是安全的：能处理所有动物的人，肯定能处理狗
let processDog: ProcessDog = (dog: Dog) => { /* 只处理狗 */ }
let processAnimal: ProcessAnimal = processDog // ❌ 错误！为什么？

// 等等，这里为什么报错？
```

实际上，在 TypeScript 的严格模式下，函数参数是逆变的：

```typescript
// 正确的逆变示例
let processAnimal: ProcessAnimal = (animal: Animal) => {
  console.log(animal.name)
}

let processDog: ProcessDog = processAnimal // ✅ 允许！

// 理解：任何需要处理狗的地方，我给它一个能处理所有动物的函数，绝对安全
// 因为 processAnimal 能处理 Animal，当然也能处理 Dog（Dog 是 Animal 的子类型）
```

### 3. 函数返回值是协变的

```typescript
type GetAnimal = () => Animal
type GetDog = () => Dog

let getDog: GetDog = () => new Dog()
let getAnimal: GetAnimal = getDog // ✅ 允许

// 理解：任何需要返回动物的地方，我给它一个返回狗的函数，完全没问题
// 因为狗就是动物（Dog extends Animal）
```

## 实际应用场景

### 场景 1：事件处理函数

```typescript
// React 事件处理器的类型安全
interface BaseEvent {
  preventDefault: () => void
}

interface MouseEvent extends BaseEvent {
  clientX: number
  clientY: number
}

// 处理基础事件的函数
function handleBaseEvent(event: BaseEvent) {
  event.preventDefault()
}

// 处理鼠标事件的函数
function handleMouseEvent(event: MouseEvent) {
  console.log(`Click at: ${event.clientX}, ${event.clientY}`)
  event.preventDefault()
}

// 在需要 MouseEventHandler 的地方，我们可以使用更通用的 BaseEventHandler
let mouseHandler: (event: MouseEvent) => void = handleBaseEvent // ✅ 安全！

// 反过来就不安全：
// let baseHandler: (event: BaseEvent) => void = handleMouseEvent; // ❌ 危险！
```

### 场景 2：回调函数类型安全

```typescript
// 数据处理器
type DataProcessor<T> = (data: T) => void

// 具体的处理器
const stringProcessor: DataProcessor<string> = (str) => {
  console.log(str.toUpperCase())
}

const anyProcessor: DataProcessor<any> = (data) => {
  console.log(data)
}

// 逆变的应用：更通用的处理器可以赋值给更具体的处理器
let processString: DataProcessor<string> = anyProcessor // ✅ 安全

// 协变的应用（在返回值中）
type DataFactory<T> = () => T

const stringFactory: DataFactory<string> = () => 'hello'
const anyFactory: DataFactory<any> = stringFactory // ✅ 安全
```

### 场景 3：泛型约束

```typescript
// 协变在 Promise 中的应用
async function getDog(): Promise<Dog> {
  return new Dog()
}

// 可以赋值给返回更通用类型的函数
async function getAnimal(): Promise<Animal> {
  return getDog() // ✅ Promise<Dog> 可以赋值给 Promise<Animal>
}

// 逆变在函数参数中的应用
function processAnimal(processor: (animal: Animal) => void) {
  processor(new Animal())
}

function processDog(processor: (dog: Dog) => void) {
  processor(new Dog())
}

// 可以接受更通用的处理器
processDog((animal: Animal) => console.log(animal.name)) // ✅ 安全
```

## 记忆技巧与理解要点

### 协变记忆口诀

> "子类型可以替代父类型"
> 数组、Promise、返回值都遵循这个规则

### 逆变记忆口诀

> "处理父类型的函数可以替代处理子类型的函数"
> 函数参数遵循这个规则

### 安全原则

始终考虑**类型安全**。TypeScript 的所有类型规则都是为了确保运行时不会出现类型错误。

```typescript
// 为什么这个不安全？思考一下：
let animalArray: Animal[] = [new Animal(), new Animal()]
let dogArray: Dog[] = animalArray // ❌ 错误！

// 如果允许，就会出现这样的运行时错误：
dogArray[0].bark() // 💥 运行时错误！animal 没有 bark 方法
```

## 总结

* **协变**：子类型关系保持不变（`Dog[]` 是 `Animal[]` 的子类型）
* **逆变**：子类型关系反转（`(Animal) => void` 是 `(Dog) => void` 的子类型）
* **应用**：
  * 数组、对象属性、Promise、函数返回值：协变
  * 函数参数：逆变
* **核心思想**：所有规则都是为了类型安全，防止运行时错误

理解了协变和逆变，你就能真正掌握 TypeScript 类型系统的设计哲学，写出更加类型安全的代码！

## 参考

* [TypeScript 官方文档：类型兼容性](https://www.typescriptlang.org/docs/handbook/type-compatibility.html){.read-more}

---

---
url: /article/e8qbp0dh/index.md
---
# 正则表达式
*本文正则表达式基于`javascript`，不同的计算机语言对正则表达式的支持情况以及实现，语法不尽相同，不一定适用于其他语言。*

### 简介

`正则表达式`，是一种文本模式（Regular Expression），是对字符串的一种匹配查找规则。
可以方便的在某一文本字符串中，查找、定位、替换符合某种规则的字符串。

比如说，我们想要找出一段文本中的手机号码，文本内容如下：

```txt
name:Mark  tel:13800138000
name:Jhon  tel:13800138888
```

很明显，在这段文本中，手机号码是以 `tel:`开头，这符合一定的规则，这样我们可以通过正则表达式来书写这个规则，
然后去查找匹配：

```js
let text = `name:Mark  tel:13800138000
name:Jhon  tel:13800138888`

let result = text.match(/tel:(1\d{10})/)
// ["tel:13800138000", "13800138000", index: 0, input: "tel:13800138000", groups: undefined]
let tel = result[1]
// 13800138000
```

`/tel:(1\d{10})/` 便是所说的正则表达式。

### `RegExp` 与字面量

在`javascript`中，我们可以使用构造函数`RegExp` 创建正则表达式。

`new RegExp(pattern[, flags])`

```js
let regExp = new RegExp('\\d', 'g')
```

也可以通过 字面量的方式：

```js
let regExp = /\d/g
```

两种创建正则表达式适用的场景有些细微的不同，一般使用`new RegExp()`来创建动态的正则表达式，使用字面量创建静态的正则表达式。

正则表达式字面量是提供了对正则表达式的编译，当正则表达式保持不变时，用字面量的方式创建正则表达式可以获得更好的性能。

**以下讨论以正则表达式字面量来创建正则表达式：**

`正则表达式`一般由`元字符`和普通字符组成。

### 元字符

元字符也叫特殊字符，是正则表达式规定的，对符合特定的单一的规则的字符的描述。

|   字符   | 含义                                                                                                                                                                                                                                                                           |
| :------: | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
|    \    | 在非特殊字符的前面加反斜杠，表示这个字符是特殊的，不能从字面上解释。比如在`\d`描述的不是一个普通的字符`d`,而是正则表达式中的数值`0-9`。如果在特殊字符前面加反斜杠，这表示将这个字符转义为普通字符，比如`?`在正则中有其特殊含义，前面加反斜杠?，这可以将其转为普通的`?`。 |
|    ^     | 匹配文本开始的位置，如果开启了多行标志，也会匹配换行符后紧跟的位置。比如`^a`会匹配`abc`，但不会匹配到`bac`。                                                                                                                                                              |
|    $     | 匹配文本结束的位置，如果开启了多行标志，也会匹配换行符前紧跟的位置。比如`b$`会匹配`acb`,但不会匹配到`abc`。                                                                                                                                                               |
|    \*    | 匹配前一个表达式0次到多次。 比如，`ab*`会匹配到`abbbbbbc`中的`abbbbbb`,以及`acbbbbb`中的`a`。                                                                                                                                                                              |
|    +     | 匹配前一个表达式1次到多次。 比如，`ab+`会匹配到`abbbbbbc`中的`abbbbbb`,但不会匹配`acbbbbb`。                                                                                                                                                                               |
|    ?     | 匹配前一个表达式0次到1次。 比如，`ab*`会匹配到`abbbbbbc`中的`ab`,以及`acbbbbb`中的`a`。                                                                                                                                                                                    |
|    .     | 匹配除换行符之外的任何单个字符。                                                                                                                                                                                                                                               |
|   x|y   | 匹配 x或者y。                                                                                                                                                                                                                                                                  |
| \[xyz]  | 表示一个字符的集合。匹配集合中的任意一个字符。可以使用破折号`-`来指定一个字符范围。比如，`[0-4]`和`[01234]`，都可以匹配`4567`中的`4`。                                                                                                                                     |
| \[^xyz] | 表示一个方向字符集合。匹配任意一个不包括在集合中的字符。可以使用破折号`-`来指定一个字符范围。比如，`[0-4]`和`[01234]`，都可以匹配`2345`中的`5`。                                                                                                                          |
|  {n}   | n为一个整数，表示匹配前一个匹配项n次。比如`a{2}`不会匹配`abc`中的`a`，但会匹配`aaaabc`中的`aa`。                                                                                                                                                                           |
| {m,n}  | m,n都是一个整数，匹配前一个匹配项至少发生了m次，最多发生了n次。当m，n值为0时，这个值被忽略，当n值不写，如`{1,}`表示1次到多次。当m值不写时，如`{,1}`表示0次到1次。                                                                                                          |
|   (x)    | 匹配`x`并且捕获该匹配项。称为捕获括号，括号中的匹配项也称作子表达式。                                                                                                                                                                                                          |
|  (?:x)   | 匹配`x`但不捕获该匹配项。称为非捕获括号。                                                                                                                                                                                                                                      |
|  x(?=y)  | 匹配`x`且当`x`后面跟着`y`。称为正向肯定查找（正向前瞻）。                                                                                                                                                                                                                      |
|  x(?!y)  | 匹配`x`且当`x`后面不跟着`y`。称为正向否定查找（负向前瞻）。                                                                                                                                                                                                                    |
|   \[\b]   | 匹配一个退格(U+0008)。                                                                                                                                                                                                                                                         |
|   \b    | 匹配一个词的边界。匹配的值的边界并不包含在匹配的内容中。                                                                                                                                                                                                                       |
|   \B    | 匹配一个非单词的边界。                                                                                                                                                                                                                                                         |
|   \d    | 匹配一个数字。等价于`[0-9]`。                                                                                                                                                                                                                                                  |
|   \D    | 匹配一个非数字。等价于`[^0-9]`。                                                                                                                                                                                                                                               |
|   \n    | 匹配一个换行符 (U+000A)。                                                                                                                                                                                                                                                      |
|   \r    | 匹配一个回车符 (U+000D)。                                                                                                                                                                                                                                                      |
|   \s    | 匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于`[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]`                                                                                                                              |
|   \S    | 匹配一个非空白字符。                                                                                                                                                                                                                                                           |
|   \t    | 匹配一个水平制表符 (U+0009)。                                                                                                                                                                                                                                                  |
|   \w    | 匹配一个单字字符（字母、数字或者下划线）。 等价于`[A-Za-z0-9_]`。                                                                                                                                                                                                          |
|   \W    | 匹配一个非单字字符。                                                                                                                                                                                                                                                           |
|  \xhh   | 与代码 hh 匹配字符（两个十六进制数字）                                                                                                                                                                                                                                         |
| \uhhhh  | 与代码 hhhh 匹配字符（四个十六进制数字）。                                                                                                                                                                                                                                     |

上表在多数文章都会提及，但有一些注意的细节，下面我单独拎出来说说。

1. **`[xyz]` 匹配集合中的任意一个字符**&#x20;
   这个字符集的元素，可以是普通字符，也可以是特殊字符，也可以用破折号`-`规定一个字符集范围。
   以匹配数字为例，可以写成`[0123456789]` ，也可以写成`[\d]`,也可以写成`[0-9]`。
   类似于`()`等特殊字符，在`[]`中有其作用，都特殊字符的作用一致，不能直接当做普通字符来使用，所以我们需要使用反斜杠`\`将其转义为普通字符，值得注意的是，上表的特殊字符中，星号`*`、小数点`.`在`[]`中并没有特殊用途，所以不需要做转义处理，当然，即使做了转义，也不会出现问题；而破折号`-`在`[]`中有其特殊作用，所以作为普通字符使用时，需要转义。

2. **`?`：匹配前一个表达式0次到1次。**
   其实这里准确描述来说，匹配前一个表达式，且该表达式 **非任何量词 `*`、 `+`、`?` 或 `{}`** ，匹配前一个表达式0次到1次。
   如果紧跟在 **非任何量词 `*`、 `+`、`?` 或 `{}`** 的后面，将会使量词变为非贪婪的（匹配尽量少的字符）
   *贪婪与非贪婪匹配，我们在下文细说。*

### 等价字符

正则表达式中，有不少特殊字符的写法，是等价的，也可以说是简写形式，下表的左右两边，都是等价的。

| regExp | regExp                                                                            |
| ------ | --------------------------------------------------------------------------------- |
| \*     | {0,}                                                                            |
| +      | {1,}                                                                            |
| ?      | {0,1}                                                                           |
| \d    | \[0-9]                                                                           |
| \D    | \[^0-9]                                                                          |
| \w    | \[a-zA-Z\*]                                                                       |
| \W    | \[^a-zA-Z\*]                                                                      |
| \s    | \[\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff] |

### 贪婪模式与非贪婪

**什么是贪婪模式？**

贪婪是指正则表达式匹配时，是贪心的，会尽可能的匹配多的字符，主要体现在`量词特殊字符`：

```js
// 匹配一个到多个数字
let r = /\d+/
let t1 = '12a'
let t2 = '1234a'
let t3 = 'a12b345'
console.log(t1.match(r)[0]) // 12
console.log(t2.match(r)[0]) // 1234
console.log(t3.match(r)[0]) // 12
```

`非贪婪`，即是让正则表达式匹配尽量少的字符。那么如何改变正则表达式的贪婪模式？

**在量词特殊字符后面紧跟使用`?`**

我们说说的量词包括`*`, `+`, `?`, `{m,n}`。那么紧跟了`?`，会有什么不同的表现呢？

我们从例子来分析：

```js
let r1 = /<div>.*<\/div>/
let r2 = /<div>.*?<\/div>/
let str = '<div>aaa</div>bbb<div></div>ccc'
```

变量`r1`是贪婪匹配，得到的结果会是什么呢？

```js
console.log(str.match(r1)[0])
// <div>aaa</div>bbb<div></div>
```

在这段字符串中，有两个`</div>`的匹配字符串，正则表达式在遇到第一个`</div>`匹配字符项时，同时满足了`/.*/`和`/<\/div>/`的匹配条件，优先作为`/.*/`的匹配值，在遇到第二个时，同样还是优先作为`/.*/`的匹配值，直到匹配的字符串`str`的结束，没有满足条件的匹配字符串，再把第二个`</div>`作为`/<\/div>/`的匹配值。最终得到了`<div>aaa</div>bbb<div></div>`的匹配结果。

变量`r2`这是非贪婪匹配，得到的结果又会有所不同：

```js
console.log(str.match(r1)[0])
// <div>aaa</div>
```

同样，两个`</div>`的匹配字符串，但实际非贪婪匹配模式，在匹配到第一个`</div>`，就不会再继续向下匹配字符串了。

**也就是说，贪婪匹配是，在满足规则下，尽可能多的匹配更多的字符串，直到字符串结束或没有满足规则的字符串了；非贪婪匹配是，在满足规则下，尽可能少的匹配最少的字符串，一旦得到满足规则的字符串，就不再向下匹配。**

1. `x*?`：尽可能少的匹配`x`，匹配的结果可以是0个`x`；
2. `x+?`：尽可能少的匹配`x`，但匹配的结果至少有1个`x`；
3. `x??`：尽可能少的匹配`x`, 匹配的结果可以是0个`x`，但最多可以有一个`x`；
4. `x{m,n}?`：尽可能少的匹配`x`，但匹配的结果至少有m个`x`，最多可以有n个`x`；

可能从字面来说，不好理解 `x??`, `x{m,n}?` ，来看一个例子就可以明白了：

```js
let s1 = '<div>aa</div>'
let s2 = '<div>a</div>'
let s3 = '<div></div>'
let r1 = /<div>a?<\/div>/

console.log(r1.test(s1)) // false
console.log(r1.test(s2)) // true
console.log(r1.test(s3)) // true
```

```js
let s1 = '<div>aaa</div>'
let s2 = '<div>aa</div>'
let s3 = '<div>aaaa</div>'
let r1 = /<div>a{2,3}<\/div>/
let r2 = /<div>a{2,3}?/

console.log(r1.test(s1)) // true
console.log(r1.test(s2)) // true
console.log(r1.test(s3)) // false

console.log(s1.match(r2)[0]) // <div>aa
console.log(s2.match(r2)[0]) // <div>aa
console.log(s3.match(r2)[0]) // <div>aa
```

### 正则表达式标志

| 标志  | 描述                                               |
| :---: | -------------------------------------------------- |
|   g   | 全局搜索                                           |
|   i   | 不区分大小写搜索                                   |
|   m   | 多行搜索                                           |
|   y   | 执行“粘性”搜索,匹配从目标字符串的当前位置开始      |
|   u   | Unicode模式。用来正确处理大于 \uFFFF 的Unicode字符 |

**`m`**

使用`m`标志时，会改变开始（`^`）和结束字符（`$`）的工作模式，变为在多行上匹配，分别匹配每一行的开始和结束，即`\n`或`\r` 分割。

**`y`**

使用`y`标志时，匹配是从`RegExp.lastIndex`指定的位置开始匹配，匹配为真时，会修改 `lastIndex`的值到当前匹配字符串后的位置，下次匹配从这个位置开始匹配，如果匹配为假时，不会修改`lastIndex`的值。

```js
let reg = /o/y
let str = 'foo'

// lastIndex 为 0，从字符 f 开始匹配
reg.test(str) // false
// 由于结果为 false， lastIndex 还是为 0
reg.test(str) // false

let str2 = 'oof'
// lastIndex 为 0 ，从字符 o 开始匹配
reg.test(str2) // true
//  lastIndex 此时修改为 1, 从第二个 o 开始匹配
reg.test(str2) // true
// lastIndex 此时修改为 2
reg.test(str2) // false   此时开始匹配的字符是 f
// lastIndex没有被修改
reg.test(str2) // false
```

### 正则表达式中的捕获—— \1,\2,\3... 以及 $1,$2,$3

在上文中我们介绍了 `(x)` 是匹配 `x` 并捕获，那么有了捕获就必然可以去使用捕获到的结果， `\1,\2,\3...` 以及`$1,$2,$3...` 便是指捕获的结果。

`\1, \2, \3, \4, \5, \6, \7, \8, \9` 在正则表达式中使用，捕获结果为正则表达式的源模式.

在这个正则表达式中`(bc)`被捕获并标记为`\1`, `(ef)`被捕获并标记为`\2`。

```js
let reg = /a(bc)d(ef)/
```

也可以使用来简化正则表达式

```js
let reg = /a(bc)dbc/
let reg2 = /a(bc)d\1/

let str = 'abcdbc'

reg.test(str) // true
reg2.test(str) // true
```

`$1, $2, $3, $4, $5, $6, $7, $8, $9` 是`RegExp`的包含括号子表达式的正则表达式静态的只读属性。

```js
let reg = /a(bc)d/
let str = 'abcd'

reg.test(str)
console.log(RegExp.$1) // bc
```

在 `String.replace()` 中使用：

```js
let reg = /(\w+)\s(\w+)/
let str = 'apple pear'
str.replace(reg, '$2 $1') // pear apple
RegExp.$1 // apple
RegExp.$2 // pear
```

---

---
url: /article/ecdgrife/index.md
---
# 浅谈前端低代码
前端低代码在最近的这两年，不少的公司或技术团队都对此青睐有佳，并各自实现了各自的低代码平台。

## 前言

前端低代码，是指 无需代码或者仅需少量的代码，即可生成可交互的应用。

这个概念的兴起，期望于能够更快的去构建、部署新的应用，并降低门槛，让非技术开发人员也能够构建新的应用。

## 为什么做低代码

传统的应用开发从启动到发布的过程，大致的流程如下：
::: center
![low-code-1](//assets.processon.com/chart_image/6320a2fb637689341d579d34.png)
:::

在这个过程中，我们需要花费大量的时间用于 代码开发 -> 测试 这个过程，在这个过程，还需要根据项目大小，组织多个开发人员、测试人员等参与到项目中，包括制定开发规范、测试规范等。

而对于某些场景的应用，可能整个应用的生命周期相对较短，多个应用之间存在着类似的功能、需求、设计等等，然而在传统的项目开发中，
我们仍然需要按照上述的流程，完整的走一遍，才能正式发布上线，这无疑会花费大量的时间。一般我们会通过抽离重复的功能、需求、UI等为
独立的库、组件等，在新项目中实现复用，从而减少开发时间，然而这并不能对项目的发布速度有质的提升。

而对于一些小型企业，或者个体经营户，期望做一个线上应用，但并没有多余的资金资源去组建一个开发团队，对购买服务器、上线应用等更是一知半解，成为了制约他们发展的一道坎。

对于这些场景、存在的问题，需要需要一种方案，能够实现快速的实现从创建项目到发布部署为可访问的项目，并且能够面向更广泛的用户群体。
这成为了一个非常具有市场潜力的需求。

## 如何做低代码

对于一个前端应用，通常由多个页面组成，在现代前端开发中，我们将页面拆分为一个个组件来进行组合：

![low code 1](//assets.processon.com/chart_image/6320ccbf1efad46b0aa9d631.png)

在 前端低代码 中，我们同样的，可以通过 组件来组装页面，通过可视化的交互方式，将组件拖拽到 页面容器中，
这种交互方式相对来说更加适用于更多的群体。

![low code 2](//assets.processon.com/chart_image/6320d1830e3e743f58315ed7.png)

同时，需要提供能够对组件进行编辑状态的能力，以支持应用的个性化配置。

![low code 3](//assets.processon.com/chart_image/6321b4420e3e743f5833bbc8.png)

在初步确定好 基础的功能、交互方式后，就可以围绕它们，来完善 实现低代码平台的技术方案。

***

初步明确的，我们需要 通过 **组件** 来组装 应用，围绕这一块，需要实现：

* 低代码组件的规范：开发规范、接入规范；
* 用于承载组件、组装组件并渲染的应用容器；
* 组件的状态的更新与保存；

---

---
url: /article/exports-esm-and-cjs/index.md
---
# 单仓库实现同时导出esm、cjs
在开发一些公共模块作为一个独立仓库时，有时候可能会在一个使用 es 的项目中通过 `import` 导入，
有可能在一个 cjs 项目中通过 `require` 导入。

如何实现单个仓库能够同时被 cjs 和 esm 项目导入呢？

## 为什么这么做？

在过去的时间里，JavaScript 并没有一套标准的模块化系统，并且在过去的时间里，逐渐发展出了各种模块化解决方案，
其中最主流的有两种模块化方案：

* `CommonJs`： 即`cjs`,通过 `require('package')` 导入，`module.exports` 导出。
  这套模块化系统应用与在`NodeJs` 和 `NPM packages`。

  ```js
  // in cjs
  const _ = require('lodash')
  console.log(`assignIn: `, _.assignIn({ b: '2' }, { a: '1' }))
  // { a: '1', b: '2' }
  ```

* `Ecmascript modules`: 即`esm`，在2015年，`esm` 最终确定为标准模块化系统，浏览器以及各个社区开始逐渐
  迁移并支持`esm`。

  ```js
  import { assignIn } from 'lodash'
  console.log(`assignIn: `, assignIn({ b: '2' }, { a: '1' }))
  // { a: '1', b: '2' }
  ```

  `ESM`使用 `named exports`，能够更好的支持静态分析，对各种打包工具有利于做`tree-shaking`，
  而且浏览器原生支持，作为一个标准，代表的是JavaScript的未来。

  同时，在`NodeJs` 的 `v12.22.0`、`v14.17.0`版本，开始实验性的支持`ESM`，并在`16.0.0`版本开始正式支持`ESM`。

::: note

* ESM - [ECMAScrip modules](https://nodejs.org/api/esm.html)
* CJS - [CommonJs](https://nodejs.org/api/modules.html#modules-commonjs-modules)

:::

目前有很多包仅支持 `CJS` 或者 `ESM` 格式。 但同时，也有越来越多的包推荐并仅支持导出 `ESM` 格式。

但是相对来说，就目前而言，作为一个库，仅支持`ESM` 格式还是过于激进了。即使在 `NodeJs v16`已开始正式支持`ESM`，
但是整个社区的迁移还是需要大量的时间成本和人力成本的，如果某个版本破坏性的从`CJS`支持迁移到`ESM`，
那么可能导致一系列问题。

所以，如果一个库，能够同时支持`ESM`以及`CJS`，是一种相对来说更为安全的迁移方案。

## 共存问题

我们知道，`Nodejs` 能够很好的同时支持 `ESM` 和 `CJS` 进行工作，但是，有一个最主要的问题是，不能在一个 `CJS` 中
导入`ESM`，这时候会抛出一个错误：

```js
// cjs package
const pkg = require('esm-only-package')
```

```
Error [ERR_REQUIRE_ESM]: require() of ES Module esm-only-package not supported.
```

因为`ESM` 模块本质上是一个异步模块，所以不能用 `require()` 方法同步的导入一个异步的模块。
但是这并不意味着完全不能在 `CJS` 模块中使用`ESM` 模块，我们可以使用 动态 `import()` 的方式，来异步的导入`ESM` 模块。
`import()` 会返回一个 `Promise`：

```js
// CJS
const { default: pkg } = await import('esm-only-package')
```

但是，这并不是一个令人满意的解决方案，它与我们日常使用的模块导入方式来说，显得有点笨拙，不符合一般使用习惯，
我们还是更期望能够符合一般习惯的导入方式：

```js
import cjs from 'cjs-package'
// ESM
import { named } from 'esm-package'
```

## 如何做？

### package.json

在现在的稳定版本的`NodeJs` 中，已经支持同时在一个包中导出两种不同的格式。
在`package.json` 文件中，有一个`exports` 字段，提供给我们有条件的导出不同格式。

```json
{
  "name": "package",
  "exports": {
    ".": {
      "require": "./index.js",
      "import": "./index.mjs"
    }
  }
}
```

这一段声明描述了， 当进行导入包的默认模块时，如果是通过 `require('package')` 进行导入，那么引入的是 `./index.js` 文件，如果是通过`import pkg from 'package'`进行导入，那么引入的是 `./index.mjs` 文件。

`Nodejs` 会根据当前运行环境，选择合适的导入方式将包进行导入。

所以我们可以借助这一特性，来完成我们单仓库支持两个格式的第一步。

然后，下一个要解决的，就是如何构建两个格式的导出文件。

### Building

我们当然不可能为了同时支持`CJS`和 `ESM`，而编写两份代码。

但我们可以借助一些构建打包工具，来生成`ESM`和`CJS`代码。

通常情况下，我们可能会使用 `rollup` 来构建打包我们的模块。
或者也可以使用 `tsup` 来构建。

#### rollup

当我们会选择 `rollup` 来构建一个库时，可能配置如下：

```js
// rollup.config.js
export default {
  input: 'src/index.js',
  output: {
    file: './dist/index.js',
  },
}
```

由于`rollup` 是支持多配置打包的，所以我们可以使用多配置的方式，同时打包输出两种格式的文件：

```js
// rollup.config.js
export default [
  {
    input: 'src/index.js',
    output: {
      file: './dist/index.js',
      format: 'cjs',
    },
  },
  {
    input: 'src/index.js',
    output: {
      file: './dist/index.mjs',
      format: 'es',
    },
  },
]
```

#### tsup

`tsup` 是一个面向 `TypeScript` 的打包工具，基于 `esbuild`， 可以很方便的将我们的库打包成多种模式进行输出：

`tsup` 可以支持零配置，直接使用命令行即可输出两种格式

```sh
tsup src/index.ts --format esm,cjs
```

执行完成后，将会得到两个文件：`cjs` 格式文件`dist/index.js` 和 `esm`格式文件`dist/index.mjs` 。

使用构建工具构建完成后，接下来就是完善 `package.json`，

建议在使用 `type` 字段声明为 `module`, 来声明当前库时一个标准的 esm 库，以及添加 `main`,`module`,`exports`字段,
以便向下兼容：

```json
{
  "name": "my-package",
  "type": "module",
  "main": "./dist/index.js",
  "module": "./dist/index.mjs",
  "exports": {
    ".": {
      "require": "./dist/index.js",
      "import": "./dist/index.mjs"
    }
  },
  "types": "./dist/index.d.ts",
  "files": ["dist"]
}
```

最后，你的 `CJS` 项目中，或者 `ESM` 项目中，均可以根据环境要求，导入这个包。

```js
// cjs
const pkg = require('my-package')
```

```js
// esm
import pkg from 'my-package'
```

## 总结

虽然 `Nodejs` 从 `v14.18.0` 版本开始稳定支持 `esm` ，并且到 `v16` 版本，正式支持 `esm`。
但将库升级到仅支持`esm` 还是一个比较激进的做法，建议从相对安全的 双格式支持 开始迁移，在合适的时机，过渡到仅支持`esm`。

---

---
url: /article/extends-prototype/index.md
---
# 继承与原型链
当谈到继承时，javascript只有一种结构：对象。
每个实例对象（object）都有一个私有属性`__proto__`指向它的构造函数的原型对象 **prototype**。
该原型对象也有自己的原型对象`__proto__`，层层向上，直到有一个的原型对象为null。根据定义，null没有原型，并作为这个原型链的最后一个环节。

几乎所有javascript中的对象，都是位于原型链顶端的`Object`的实例。

## 基于原型链的继承

### 继承属性

`javascript` 对象是动态的属性"包裹"（指自身的属性）。同时，对象还有一个指向一个原型对象的链。
当访问一个对象的属性时，不仅会在该对象上查找，也会在该对象的原型上查找，进而在该对象的原型的原型上查找，
依次层层向上查找，直到找到匹配的属性，或者到达原型链的末尾。

::: info ECMAScript标准
`obj.[[Prototype]]`符号用于指向`obj`的原型。从`ES6`开始`[[Prototype]]`
可以通过`Object.getPrototypeof()`和 `Object.setPrototypeof()` 访问器进行访问。
等同于许多浏览器实现的属性`__proto__`。
:::

从代码示例来分析继承属性：

在这个示例中，定义了一个函数`Foo`， 它拥有自身属性 `a`和`b`。

然后创建一个 `Foo` 的示例 `foo`。

```js
function Foo() {
  this.a = 1
  this.b = 2
}
let foo = new Foo()

Foo.prototype.c = 3
Foo.prototype.d = 4

// 输出自身的所有属性
console.log(foo) // { a: 1, b: 2 }

// 自身拥有属性 a
console.log(foo.a) // 1
// 自身拥有属性 b
console.log(foo.b) // 2
// 自身没有属性 c, 但其原型上有属性 c
console.log(foo.c) // 3
// 自身没有属性 d，但其原型上有属性 d
console.log(foo.d) // 4
```

在这个示例中， 整个原型链如下

```js
// { a: 1, b: 2 } => { c: 3, d: 4 } => Object.prototype => null
```

### 继承方法

在`Javascript` 中，并没有其他基于类的语言所定义的 方法。
任何函数都可以添加到对象上做为对象的属性。
函数属性的继承与其他属性的继承没有差别。

当继承的函数被调用时，`this`指向的是当前继承的对象，而不是继承的函数所在的原型对象。

```js
let o = {
  a: 1,
  f() {
    return this.a + 1
  },
}

// 此时 函数f 中的 this 指向了 o
console.log(o.f()) // 2

let p = Object.create(0)
p.a = 3

// p从o上继承了函数f， 此时函数f中的 this 指向了 p
console.log(p.f()) // 4
```

## 创建对象和生成原型链

### 使用语法结构创建的对象

```js
let o = { a: 1 }
// 原型链： o => Object.prototype => null

let arr = ['a', 'b']
// 原型链： arr => Array.prototype => Object.prototype => null

function f() {}
// 原型链： f => Function.prototype => Object.prototype => null
```

### 使用构造器创建对象

```js
function Person() {
  this.a = 1
}
Person.prototype = {
  f() {
    return this.a
  },
}
let p = new Person()
// 原型链： p => Person.prototype => Object.prototype => null
```

### 使用`Object.create`创建的对象

```js
let a = { a: 1 }
let b = Object.create(a)
// 原型链 b => a => Object.prototype => null

let c = Object.create(null)
// 原型链 c => null
```

## 扩展原型链的方法

### 构造器创建对象，原型赋值给另一个构造函数原型

```js
function Foo() {}
foo.prototype = {
  a: 'foo',
}

function Bar() {}

let proto = new Foo()
proto.b = 'bar'
Bar.prototype = proto

let p = new Bar()
console.log(p.a) // foo
console.log(p.b) // bar
```

### Object.create

```js
function Foo() {}
Foo.prototype = {
  a: 'foo',
}
function Bar() {}

let proto = Object.create(Foo.prototype)
proto.b = 'bar'
Bar.prototype = proto

let p = new Bar()
console.log(p.a) // foo
console.log(p.b) // bar
```

```js
function Foo() {}
Foo.prototype = {
  a: 'foo',
}

function Bar() {}

let proto = Object.create(Foo.prototype, { b: 'bar' })
Bar.prototype = proto

let p = new Bar()
console.log(p.a) // foo
console.log(p.b) // bar
```

---

---
url: /article/fc6faley/index.md
---
在人工智能快速发展的今天，我们与 AI 的交互方式正在发生根本性变化。其中，**Prompt Engineering**（提示工程）作为一门新兴的技能，正成为解锁 AI 潜力的关键所在。

## 什么是 Prompt Engineering？

**Prompt Engineering** 指的是设计、优化和完善输入给 AI 模型的提示（prompt），以获得更准确、相关和有用输出的系统性方法。简单来说，就是**学会如何更好地向 AI 提问**。

这不仅仅是简单的"提问"，而是包含了：

* 理解 AI 模型的工作原理
* 设计清晰、具体的指令
* 提供适当的上下文和约束条件
* 通过迭代优化获得最佳结果

## 为什么 Prompt Engineering 如此重要？

### 1. 质量差距巨大

同样的 AI 模型，不同的提示会产生天壤之别的结果：

```bash
# 普通提示
"写一个函数"

# 工程化提示
"请用 JavaScript 编写一个函数，接收数字数组作为参数，返回去重后的新数组。要求：
1. 不使用 Set 对象
2. 时间复杂度为 O(n)
3. 包含详细的 JSDoc 注释
4. 提供使用示例"
```

### 2. 成本效益显著

精心设计的提示可以减少：

* 重复请求次数
* 结果修正时间
* 总体计算资源消耗

### 3. 专业化需求增长

随着 AI 在各行业的深入应用，专业的 Prompt Engineering 技能成为：

* 开发者的核心竞争力
* 产品经理的必备技能
* 内容创作者的效率工具

## Prompt Engineering 的核心原则

### 1. 明确性 (Clarity)

**模糊提示：**

```bash
"帮我处理数据"
```

**明确提示：**

```bash
"请分析以下销售数据，计算：
- 每个产品的月销售额
- 同比增长率
- 生成前5名产品的排名

数据格式：CSV
输出要求：Markdown 表格"
```

### 2. 上下文提供 (Context Provision)

**缺乏上下文：**

```bash
"优化这段代码"
```

**提供充分上下文：**

```bash
"这是 React 组件中的性能优化问题：
- 组件在每次渲染时都重新计算大量数据
- 用户列表包含 1000+ 项
- 需要避免不必要的重渲染

请提供具体的 useMemo 和 useCallback 优化方案"
```

### 3. 约束条件 (Constraints)

**无约束：**

```bash
"写一篇技术文章"
```

**有约束：**

```bash
"以初级前端开发者为目标读者，写一篇关于 React Hooks 的入门文章：
- 字数：1500字左右
- 包含 useState 和 useEffect 的实用示例
- 避免使用复杂术语
- 采用友好的教学语气"
```

### 4. 示例引导 (Example-driven)

**零样本提示：**

```bash
"分类这些文本"
```

**少样本提示：**

```bash
"根据以下示例进行分类：

示例1：
文本："这个产品太棒了，我非常喜欢！"
情感：积极

示例2：
文本："服务质量很差，不会再来了"
情感：消极

现在请分类：
文本："还行，一般般"
情感："
```

## 实际应用场景

### 前端开发中的 Prompt Engineering

#### 代码生成与优化

```bash
# 工程化提示示例
"作为资深前端专家，请优化以下 React 组件：

问题描述：
1. 组件渲染性能低下
2. 事件处理函数每次渲染都重新创建
3. 缺乏必要的错误边界

优化要求：
- 使用 React.memo 避免不必要渲染
- 合理使用 useCallback 和 useMemo
- 添加 PropTypes 类型检查
- 实现简单的错误处理

请提供优化后的完整代码，并解释每个优化的原因。"
```

#### 技术方案设计

```bash
# 架构设计提示
"项目背景：需要为电商平台设计前端架构

技术要求：
- 使用 Next.js 13+ 和 TypeScript
- 支持服务端渲染和静态生成
- 状态管理使用 Zustand
- 样式方案采用 Tailwind CSS
- 需要良好的 SEO 支持

请提供：
1. 项目目录结构建议
2. 核心模块划分方案
3. 性能优化策略
4. 推荐的开发工具和流程"
```

## 进阶技巧与策略

### 1. 链式思考 (Chain-of-Thought)

引导 AI 展示推理过程：

```bash
"请分步骤解决这个问题：

问题：一个列表包含 [2, 7, 11, 15]，目标值是 9，找出和为目标值的两个数。

第一步：理解问题要求...
第二步：考虑可能的解法...
第三步：实施最优方案...
第四步：验证结果..."
```

### 2. 角色扮演 (Role-playing)

为 AI 分配特定角色：

```bash
"假设你是谷歌的首席前端架构师，正在评审一个大型项目的代码质量。请以专业、严谨但建设性的语气，分析以下代码并提出改进建议："
```

### 3. 模板化提示

创建可复用的提示模板：

```javascript
function codeReviewPrompt(code, requirements) {
  return `
代码审查请求：

代码内容：
${code}

审查要求：
${requirements}

请从以下角度审查：
1. 代码质量和可读性
2. 性能考虑
3. 安全性问题
4. 最佳实践遵循情况
5. 具体的改进建议
`
}
```

## 常见陷阱与避免方法

### 1. 提示过于宽泛

**问题：** "帮我写代码"
**解决：** 提供具体的需求、约束和上下文

### 2. 缺乏具体示例

**问题：** "生成一些数据"
**解决：** 提供期望的输出格式和样本

### 3. 忽略模型限制

**问题：** 要求超出模型能力范围的任务
**解决：** 了解模型的特长和局限，合理设定期望

### 4. 单次尝试心态

**问题：** 期望第一次提示就获得完美结果
**解决：** 采用迭代优化，基于结果调整提示

## 工具与资源推荐

### 1. 提示优化工具

* **OpenAI Playground**：实验和优化提示
* **[PromptPerfect](https://promptperfect.jina.ai/)**：自动提示优化
* **AI Prompt Generator**：生成专业提示

### 2. 学习资源

* **OpenAI 提示工程指南**：官方最佳实践
* **Prompt Engineering Institute**：专业课程和案例
* **[Awesome Prompt Engineering](https://github.com/promptslab/Awesome-Prompt-Engineering)**：GitHub 上的资源集合

### 3. 实践平台

* **ChatGPT**：日常练习
* **Claude**：不同的提示风格测试
* **Midjourney**：视觉领域的提示工程

## 未来展望

Prompt Engineering 正在从"技巧"发展为"学科"：

1. **标准化**：行业标准和工作流的建立
2. **工具化**：专门的提示设计和测试工具
3. **集成化**：与开发流程的深度集成
4. **专业化**：针对不同领域的专业提示模式

## 总结

Prompt Engineering 不是简单的"提问技巧"，而是**系统性的沟通方法论**。它结合了：

* **技术理解**：了解 AI 的工作原理
* **沟通艺术**：清晰表达需求的能力
* **批判思维**：分析和优化结果的眼界
* **创意表达**：激发 AI 创造力的方法

掌握 Prompt Engineering 意味着：

* 更高效的开发工作流
* 更优质的技术产出
* 在 AI 时代保持竞争力

**记住：最好的提示工程师不是那些知道所有命令的人，而是那些最理解如何与智能系统有效协作的人。**

***

*进一步学习建议：尝试在下一个项目中应用这些原则，记录不同提示的效果差异，建立自己的提示库和经验总结。*

---

---
url: /article/fe5ruia1/index.md
---
# CSS 媒体查询
开发响应式网站时，常常需要使用到 media 媒体查询。这里总结下媒体查询的使用方法。

## 概述

媒体查询是通过判断当前媒体是否满足 媒体查询规则，从而使其包含的 CSS规则生效。

从 CSS level 2 开始，就已经支持 `media-queries`，到 CSS level 3 以及之后的版本，媒体查询变得更加的丰富和能够适应更多的场景。

## 使用

媒体查询可以通过以下三种方式进行使用：

### 在 `<link>` 元素引入CSS资源时，声明 `media` 属性

```html
<link rel="stylesheet" type="text/css" href="media/custom.css" media="screen and (min-width: 400px)" />
```

### 在`<style>` 上 声明 `media` 属性

```html
<style media="screen and (min-width: 400px)"></style>
```

### 在`@import` 后 声明 媒体查询条件

```css
@import url('custom.css') screen and (min-width: 400px);
```

### 在样式表中使用 At-Rule `@media` 使用媒体查询规则

```css
@media screen and (min-width: 400px) {
  .example {
    color: red;
  }
}
```

## 语法

```html
<link rel="stylesheet" type="text/css" href="media/custom.css" media="[media-queries-list]" />

<style media="[media-queries-list]"></style>

<style>
    @import url [media-queries-list];

    @media [media-queries-list] {
      <style-sheet-group>
  }
</style>
```

## 媒体查询 \[media-queries-list]

`media-queries-list` 可以由以下三种内容组成：

* `Media types` ：媒体类型, 表示设备
* `Media features` ：媒体特性, 表示设备的状态
* `Logical operators` ： 逻辑操作符, 连接多个 `media-query`

### Media types

`Media types` 描述设备的一般类型。可以使用以下值：

* `all`: 表示适用于所有设备。 默认值。
* `print`: 表示 适用于在屏幕上以打印预览的模式查看页面和文档。
* `screen`: 表示 适用于屏幕 。

> 在 *css2.1* 和 *Media Queries 3* 中还支持 `tty`，`tv`，`projection`，`handheld`，`braille`，`embossed`，`aural`，但这些值都已经在*Media Queries 4* 中被弃用。

### Media features

媒体特性，描述 用户代理、输出设备以及环境的特定特征。

媒体特性表达式是完全是可选的，并且负责测试这些特性是否存在，值为多少。 且每个媒体特性表达式都必须使用括号括起来。

*以下仅列出比较常用到的媒体特性：*

* `width`: 视窗（viewport）的宽度，包括纵向滚动条的宽度。

  值的类型为 number，单位可以是 `px`、`em` 等。

  ```css
  with: 400px;
  ```

* `height`: 视窗（viewport）的高度。

  值的类型为 number，单位可以是 `px`、`em` 等。

  ```css
  height: 600px;
  ```

* `aspect-ratio`： 视窗（viewport）的宽高比。

  值的类型为 number/number。

  ```css
  aspect-ratio: 3/2;
  ```

* `orientation`： 视窗（viewport） 的旋转方向。

  * portrait： 设备竖屏
  * landscape： 设备横屏

  ```css
  orientation: landscape;
  ```

* `resolution`: 输出设备的分辨率

  值的类型为 number，单位为 `dpi`。

  ```css
  resolution: 320dpi;
  ```

* `scan`：输出设备的扫描过程（适用于电视机等）。

#### 媒体特性前缀

大部分的媒体特性均支持前缀，用于约束媒体特性的作用范围。

* `max-[media feature]`： 小于指定的最大值时，返回*true*
* `min-[media feature]`: 大于指定的最小值时，返回*true*

*个人认为使用前缀时其表述稍显拗口，建议使用取值范围的方式声明表达式：*

#### 媒体特性语法

* 以键值对的形式，表述取固定的值

  ```
  ([media-feature-name]: [media-feature-value])
  ```

* 直接书写name， 表示值的结果为 boolean

  ```
  ([media-feature-name])
  ```

* 表述 特性的取值范围

  *声明 range 为描述数学符号 : '<' | '>' | '<=' | '>='*

  ```
  ([media-feature-name] [range] [media-feature-value])
  ([media-feature-name] [range] [media-feature-value] [range] [media-feature-value])
  ```

### Logical operators

逻辑操作符用于组成复合的 media queries。

* `and`: 用于合并多条`media query`, 且 每条 `media query` 均返回 *true* 时，
  媒体查询表达式的结果返回*true*。
* `not`: 取反操作，使用`not [media query]`，当`media query` 返回 *false* 时，
  媒体查询表达式的结果返回*true*。
* `,`: or操作符，组合多个 `media query`，任意一个`media query` 返回 *true*,
  媒体查询表达式的结果返回*true*。
* `only`: 不支持更加高级的媒体类型的浏览器检测到only修饰的时候就会抛弃这个规则

## 使用示例详解

### 示例1

```css
@media screen and (width > 414px) {
}
```

当设备的屏幕视窗宽度大于414px时，应用CSS块中的样式规则。

### 示例2

```css
@media (width > 800px), screen and (orientation: landscape) {
}
```

当前设备 视窗宽度大于 800px， 或者设备方向为横向时，应用css块中的样式规则。

### 示例3

```css
@media screen and (414px < width < 800px) {
}
```

当前设备屏幕视窗宽度 大于 414px 且 小于 800px 时， 应用css块中的样式规则。

---

---
url: /article/fpcpgpod/index.md
---
# JavaScript 进阶 一：词法作用域
在JavaScript的世界中，**词法作用域**是一个既基础又核心的概念，它决定了变量的可访问范围和生命周期。理解词法作用域不仅有助于写出更健壮的代码，更是掌握闭包、模块化等高级特性的前提。

## 什么是作用域？

作用域可以理解为**变量的可见范围和生命周期**。JavaScript中有三种主要的作用域类型：

### 1. 全局作用域

```javascript
// 全局变量，在任何地方都可以访问
const globalVar = '我在全局作用域'

function testGlobal() {
  console.log(globalVar) // 可以访问
}

testGlobal()
console.log(globalVar) // 可以访问
```

:::warning 全局作用域的陷阱
过度使用全局变量会导致**命名冲突**和**变量污染**，应尽量避免。
:::

### 2. 函数作用域

```javascript
function outerFunction() {
  const outerVar = '我在外部函数作用域'

  function innerFunction() {
    const innerVar = '我在内部函数作用域'
    console.log(outerVar) // 可以访问外部变量
  }

  innerFunction()
  // console.log(innerVar); // 错误：无法访问内部变量
}

outerFunction()
```

### 3. 块级作用域（ES6+）

```javascript
{
  let blockVar = '我在块级作用域'
  const constVar = '我也是块级作用域'
  console.log(blockVar) // 可以访问
}

// console.log(blockVar); // 错误：无法访问块级变量
```

## 什么是词法作用域？

**词法作用域**（Lexical Scope）也称为静态作用域，指的是**变量在代码书写阶段就已经确定的作用域**，而不是在运行时确定。

:::info 关键理解
词法作用域由**代码书写的位置**决定，与函数调用位置无关。
:::

### 词法作用域示例

```javascript
const globalName = '全局变量'

function outer() {
  const outerName = '外部函数变量'

  function inner() {
    console.log(outerName) // 可以访问外部变量
    console.log(globalName) // 可以访问全局变量
  }

  return inner
}

const innerFunc = outer()
innerFunc() // 输出："外部函数变量" 和 "全局变量"
```

在这个例子中，`inner`函数在定义时就确定了它能访问哪些变量，这就是词法作用域的体现。

## 作用域链的运作机制

当访问一个变量时，JavaScript引擎会沿着**作用域链**逐级查找：

:::steps

* **第一步**：在当前作用域查找变量
* **第二步**：如果没找到，向上一级作用域查找
* **第三步**：重复第二步，直到全局作用域
* **第四步**：如果全局作用域也没找到，抛出ReferenceError

:::

### 作用域链示例

```javascript
const globalNum = 10

function level1() {
  const num1 = 20

  function level2() {
    const num2 = 30

    function level3() {
      console.log(globalNum) // 10
      console.log(num1) // 20
      console.log(num2) // 30
    }

    level3()
  }

  level2()
}

level1()
```

作用域链关系：

```
level3 → level2 → level1 → 全局作用域
```

## 词法作用域 vs 动态作用域

为了更好地理解词法作用域，让我们对比一下动态作用域：

```javascript
const name = '全局名称'

function showName() {
  console.log(name)
}

function wrapper() {
  const name = '局部名称'
  showName() // 输出什么？
}

wrapper()
```

:::tip 思考题
在词法作用域下输出"全局名称"，在动态作用域下会输出"局部名称"。
JavaScript采用**词法作用域**，所以这里输出"全局名称"。
:::

## 变量查找：LHS vs RHS

理解变量查找的两种方式有助于调试作用域问题：

### LHS（Left-Hand Side）查询

```javascript
let x = 10 // LHS：为变量赋值
x = 20 // LHS：修改变量值
```

LHS查询关注的是**变量的存储位置**。

### RHS（Right-Hand Side）查询

```javascript
console.log(x) // RHS：读取变量值
const y = x + 5 // RHS：读取x的值
```

RHS查询关注的是**变量的值**。

## 闭包与词法作用域

闭包是词法作用域的直接应用：

```javascript
function createCounter() {
  let count = 0 // 词法作用域内的变量

  return function () {
    count++ // 闭包记住了count变量
    return count
  }
}

const counter = createCounter()
console.log(counter()) // 1
console.log(counter()) // 2
console.log(counter()) // 3
```

:::important 闭包的本质
闭包就是函数能够记住并访问其词法作用域，即使函数在其词法作用域之外执行。
:::

## 实际应用场景

### 1. 数据封装

```javascript
function createUser(name) {
  let privateData = {
    loginCount: 0,
    lastLogin: null
  }

  return {
    getName: () => name,
    login: () => {
      privateData.loginCount++
      privateData.lastLogin = new Date()
      console.log(`${name} 登录成功`)
    },
    getStats: () => ({ ...privateData })
  }
}

const user = createUser('张三')
user.login()
console.log(user.getStats())
```

### 2. 模块模式

```javascript
const MyModule = (function () {
  let privateVar = '私有变量'

  function privateMethod() {
    console.log('私有方法')
  }

  return {
    publicMethod() {
      privateMethod()
      return privateVar
    }
  }
})()

console.log(MyModule.publicMethod())
```

### 3. 事件处理

```javascript
function setupButtons() {
  const buttons = document.querySelectorAll('.btn')

  for (let i = 0; i < buttons.length; i++) {
    buttons[i].addEventListener('click', () => {
      console.log(`按钮 ${i} 被点击`)
    })
  }
}
```

## 常见陷阱与最佳实践

### 陷阱1：循环中的闭包

```javascript
// ❌ 错误写法
// eslint-disable-next-line vars-on-top, no-var
for (var i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i) // 总是输出 3
  }, 100)
}

// ✅ 正确写法
for (let i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i) // 输出 0, 1, 2
  }, 100)
}
```

### 陷阱2：内存泄漏

```javascript
// ❌ 可能造成内存泄漏
function createHeavyClosure() {
  const largeData = Array.from({ length: 1000000 }).fill('data')

  return function () {
    // 即使不需要largeData，它仍然被保留在内存中
    console.log('操作完成')
  }
}

// ✅ 及时释放引用
function createOptimizedClosure() {
  let largeData = Array.from({ length: 1000000 }).fill('data')

  const result = function () {
    console.log('操作完成')
  }

  // 使用完后释放大对象
  largeData = null

  return result
}
```

## 调试技巧

:::tip 调试作用域问题

* 使用浏览器开发者工具的Scope面板
* 添加console.log检查变量状态
* 使用debugger语句设置断点
  :::

```javascript
function debugScope() {
  const localVar = '局部变量'
  debugger // 在这里暂停，查看作用域
  console.log(localVar)
}

debugScope()
```

## 总结

词法作用域是JavaScript的基础支柱，它：

* ✅ **在代码书写时确定**作用域关系
* ✅ **支持作用域链**的变量查找机制
* ✅ **实现闭包**功能，允许函数"记住"其创建时的环境
* ✅ **促进模块化**和代码封装

掌握词法作用域不仅有助于理解JavaScript的运行机制，更能帮助你在实际开发中写出更安全、更高效的代码。

记住：**作用域在书写时确定，闭包让作用域"活"得更久**。

\==深入学习建议=={.tip}

* 阅读ECMAScript规范中的作用域相关章节
* 实践闭包在各种场景下的应用
* 学习函数式编程中的相关概念

---

---
url: /article/fybr4lt3/index.md
---
# Webpack场景下的项目优化方案
::: center
![webpack](https://www.webpackjs.com/icon-square-small.85ba630cf0c5f29ae3e3.svg){width=100}
:::

在一个基于 webpack 作为构建工具的前端项目中，通常会有以下两个方面进行优化。

1. [编译构建时间优化](#编译构建时间优化)
2. [构建产物优化](#构建产物优化)

## 编译构建时间优化

编译构建时间优化，旨在加快每次构建的速度，减少构建时间。
它包括，开发时每次修改文件重新编译时的时间开销；为项目构建最终产物时的总体时间开销。

优化的方向包括：

1. [编译构建时间优化](#编译构建时间优化).
2. [缩小文件匹配范围](#缩小文件匹配范围).
3. [文件后缀匹配](#文件后缀匹配).
4. [缓存](#缓存).
5. [并行构建](#并行构建).

### 缩小文件匹配范围

在配置 webpack loader 时，通常会指定两个属性：`test` 和 `use` ，用以声明哪些文件需要被转换。

```js
module.exports = {
  module: {
    rules: [{ test: /\.txt$/, use: 'raw-loader' }],
  },
}
```

在默认情况下，匹配查找范围是相对于项目根目录的上下文进行搜索，当项目文件数量很多时，这个过程会非常耗时。
在这种情况下，可以使用 `include` 和 `exclude` 两个属性来限制文件匹配范围。

```js
const path = require('node:path')
module.exports = {
  module: {
    rules: [
      {
        test: /\.txt$/,
        use: 'raw-loader',
        include: path.resolve(__dirname, 'src'),
        exclude: /node_modules/,
      },
    ],
  },
}
```

* `exclude` : 排除所有符合条件的文件
* `include` : 只包含所有符合条件的文件

合理的使用 `include` 和 `exclude` 属性可以有效的减少文件匹配范围，从而减少构建时间。

> **参考：** [webpack module.rules](https://www.webpackjs.com/configuration/module/#rule)

### 文件后缀匹配

通常我们在导入模块时，习惯忽略文件后缀名，因为 `webpack` 会帮助进行补全。

但这是有代价的，webpack 内部尝试使用内置配置，补全后缀后查找文件时候存在，再尝试加载，直到匹配到文件，
这会造成额外的 I/O 开销。

一方面，可以通过修改 webpack 的配置 `resolve.extensions`，调整 后缀补全的规则，并通过顺序控制补全的优先级，
将最常用的文件后缀放在最前面，并减少非必要的后缀名。

```js
module.exports = {
  resolve: {
    // .md, .json 等非必要的，则不要写入配置
    extensions: ['.tsx', '.ts', '.js'],
  },
}
```

另一方面，在导入模块时，尽量不要忽略文件后缀名。

> **参考**： [webpack resolve.extensions](https://www.webpackjs.com/configuration/resolve/#resolveextensions)

### 缓存

每次启动构建，如果都需要重新编译所有的文件，那么势必会花费很长的时间，
所以需要对编译结果进行缓存，以便下次直接加载缓存的结果，并只对修改的文件进行重新编译。

在 `webpack5` 中，提供了 `cache` 配置，可直接开启缓存。

```js
module.exports = {
  cache: {
    type: 'filesystem',
  },
}
```

> **参考**： [webpack cache](https://www.webpackjs.com/configuration/cache/#cache)

### 并行构建

webpack 运行在 NodeJS 环境中，是单线程的，所以一次只能干一件事。
而目前主流的电脑都是多核的，可以利用这一特性，让 webpack 并行构建。
通常情况下，使用 [thread-loader](https://github.com/webpack-contrib/thread-loader) 来实现并行构建。

```js
module.exports = {
  module: {
    rules: [
      {
        test: /.jsx?$/,
        use: [
          // 开启多进程打包。
          {
            loader: 'thread-loader',
            options: {
              workers: 3, // 开启 3个 进程
            },
          },
          { loader: 'babel-loader' },
        ],
      },
    ],
  },
}
```

放置在 thread-loader 之后的 loader 会在一个单独的 worker 池(worker pool) 中运行。
每个 worker 都是一个单独的有 600ms 限制的 node.js 进程。同时跨进程的数据交换也会被限制。所以建议仅在耗时的 loader 上使用。

如果项目不大，文件不多，则没必要使用 thread-loader。其本身也有额外的性能开销。

## 构建产物优化

构建产物优化，旨在 减少构建产物的体积，合理的组织构建产物，从而提高页面的加载速度，首屏加载速度等。

通用的构建优化包括：

1. [压缩 `js`, `css`，`html` 代码](#压缩-js-csshtml-代码).
2. [压缩图片资源](#压缩图片资源).
3. [代码分割](#代码分割).
4. [按需加载](#按需加载).
5. [preload, prefetch](#preload-prefetch).
6. [tree-shaking](#tree-shaking).

### 压缩 js, css，html 代码

#### 压缩 js

使用 `terser-webpack-plugin` 来压缩 js 代码:

```js
const TerserPlugin = require('terser-webpack-plugin')
module.exports = {
  optimization: {
    minimize: true,
    minimizer: [new TerserPlugin()],
  },
}
```

#### 压缩 css

通过 `css-minimizer-webpack-plugin` 来压缩 css 代码，
同时使用 `mini-css-extract-plugin` 将 css 提取到单独的文件中。

```js
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          // 提取成单独的文件
          MiniCssExtractPlugin.loader,
          'css-loader',
        ],
      },
    ],
  },
  plugins: [
    new MiniCssExtractPlugin({
      // 定义输出文件名和目录
      filename: 'asset/css/style.css',
    }),
  ],
  optimization: {
    minimize: true,
    minimizer: [
      // 压缩 css
      new CssMinimizerPlugin({}),
    ],
  },
}
```

#### 压缩 html

使用 `html-webpack-plugin` 来压缩 html 代码。

```js
const HtmlWebpackPlugin = require('html-webpack-plugin')
module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      // 动态生成 html 文件
      template: './index.html',
      minify: {
        // 压缩HTML
        removeComments: true, // 移除HTML中的注释
        collapseWhitespace: true, // 删除空⽩符与换⾏符
        minifyCSS: true, // 压缩内联css
      },
    }),
  ],
}
```

### 压缩图片资源

压缩 图片资源的方法多种多样，需要根据实际的情况进行选择。
其中还包括多倍图的处理，如：`@2x`、`@3x`、`@4x` 等。

比如，可以使用 `image-webpack-loader` 来实现图片压缩。

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|jpg|gif|jpeg|webp|svg)$/,
        use: [
          'file-loader',
          {
            loader: 'image-webpack-loader',
            options: {
              mozjpeg: { progressive: true },
              optipng: { enabled: false },
              pngquant: { quality: [0.65, 0.9], speed: 4 },
              gifsicle: { interlaced: false },
            },
          },
        ],
        exclude: /node_modules/,
      },
    ],
  },
}
```

### 代码分割

如果是一个 中大型项目，或者是一个 MPA 项目，一般会拥有多个页面，
但都是使用的相同的技术栈，有重复使用的公共资源。
如果每个页面的代码都独自包含这些相同的代码，则会导致资源的浪费，每次加载不同页面都会加载重复的资源，
浪费用户的流量，页面加载缓慢，影响用户体验。

在这种情况下，将第三方的模块、公共资源单独拆分为独立的文件，
利用缓存机制，不同页面加载的时候只需要花费首次加载的时间，减少二次加载等待时间。

```js
module.exports = {
  // ...
  optimization: {
    splitChunks: {
      chunks: 'async', // 值有 `all`，`async` 和 `initial`
      minSize: 20000, // 生成 chunk 的最小体积（以 bytes 为单位）。
      minRemainingSize: 0,
      minChunks: 1, // 拆分前必须共享模块的最小 chunks 数。
      maxAsyncRequests: 30, // 按需加载时的最大并行请求数。
      maxInitialRequests: 30, // 入口点的最大并行请求数。
      enforceSizeThreshold: 50000,
      cacheGroups: {
        defaultVendors: {
          test: /[\/]node_modules[\/]/, // 第三方模块拆出来
          priority: -10,
          reuseExistingChunk: true,
        },
        utilVendors: {
          test: /[\/]utils[\/]/, // 公共模块拆出来
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true,
        },
      },
    },
  },
}
```

> **参考**： [代码分离](https://www.webpackjs.com/guides/code-splitting)

### 按需加载

大多数时候，使页面达到可用，并不需要加载所有的资源。

比如在 SPA/MPA 应用中，通过路由来实现不同的页面，如果所有的页面代码都打包在相同的文件，
那么加载某个页面的代码时，实际上也加载了其它页面的代码，导致页面的加载速度达不到预期。

因为，将 路由页面的资源拆分为不同的文件，使用时才加载这些资源，可以减少当前页面的加载时间。

```js
const List = lazyComponent('list', () => import(/* webpackChunkName: "list" */ '@/pages/list'))
const Detail = lazyComponent('detail', () => import(/* webpackChunkName: "detail" */ '@/pages/detail'))
```

进一步的，越尽快的让页面渲染，就越有利于用户体验。
因此，还可以分析当前页面完成首屏渲染所需要的关键资源，将非关键资源拆分出去，首次只加载
关键资源，完成后再加载非关键资源。

### preload, prefetch

* refetch（预获取）：将来某些导航下可能需要的资源
* preload（预加载）：当前导航下可能需要资源

在webpack中使用 `prefetch` 实现预获取：

```js
// ...
import(/* webpackPrefetch: true */ './path/to/LoginModal.js')
```

这会生成 `<link rel="prefetch" href="login-modal-chunk.js">` 并追加到页面头部，指示浏览器在闲置时间预取 login-modal-chunk.js 文件。

在webpack中使用 `preload` 实现预加载：

```ts
// ...
import(/* webpackPreload: true */ 'ChartingLibrary')
```

在页面中使用 `ChartComponent` 时，在请求 `ChartComponent.js` 的同时，
还会通过 `<link rel="preload">` 请求 `charting-library-chunk`。
假定 `page-chunk` 体积比 `charting-library-chunk` 更小，也更快地被加载完成，
页面此时就会显示 `LoadingIndicator` ，等到 `charting-library-chunk` 请求完成，
`LoadingIndicator` 组件才消失。这将会使得加载时间能够更短一点，因为只进行单次往返，
而不是两次往返，尤其是在高延迟环境下。

> **参考**： [webpack prefetch/preload](https://www.webpackjs.com/guides/code-splitting#prefetchingpreloading-modules)

### tree-shaking

`tree shaking` 在**生产模式下已经默认开启**

需要注意的是：

* 只对ESM生效
* 只能是静态声明和引用的 ES6 模块，不能是动态引入和声明的。
* 只能处理模块级别，不能处理函数级别的冗余。
* 只能处理 JS 相关冗余代码，不能处理 CSS 冗余代码。

对于 CSS资源， 可以使用 `purgecss-webpack-plugin` 插件对 CSS 进行 tree-shaking。

```js
const PurgecssPlugin = require('purgecss-webpack-plugin')
module.exports = {
  plugins: [
    new PurgeCSSPlugin({
      paths: glob.sync('src/**/*', { nodir: true }),
    }),
  ],
}
```

> **参考**： [webpack tree-shaking](https://www.webpackjs.com/guides/tree-shaking/)

---

---
url: /article/gov29h98/index.md
---
# JavaScript 进阶 八：异步编程
在现代前端开发中，异步编程已成为不可或缺的核心技能。无论是处理用户交互、网络请求还是文件操作，异步编程都能帮助我们构建更流畅、响应更快的应用。本文将深入探讨 JavaScript 异步编程的演进历程、核心概念和最佳实践。

## 异步编程的必要性

JavaScript 作为一门单线程语言，如果所有操作都同步执行，遇到耗时任务时就会阻塞整个线程，导致页面卡顿甚至无响应。异步编程通过非阻塞的方式处理这些任务，让主线程能够继续响应其他操作。

:::tip 现实类比
想象你在餐厅点餐：同步方式就像你站在柜台前等待厨师做好每一道菜才点下一道；异步方式则是你点完所有菜后找个座位等待，期间可以玩手机、聊天，服务员会在菜准备好时通知你。
:::

## 异步编程的演进历程

### 1. 回调函数（Callback）

回调函数是最基础的异步处理方式：

```javascript title="回调函数示例"
function fetchData(callback) {
  setTimeout(() => {
    const data = { name: 'John', age: 30 }
    callback(null, data)
  }, 1000)
}

fetchData((error, result) => {
  if (error) {
    console.error('Error:', error)
  }
  else {
    console.log('Data:', result)
  }
})
```

:::warning 回调地狱
当多个异步操作需要顺序执行时，回调函数容易形成"金字塔"结构：

```javascript
getUser(userId, (user) => {
  getPosts(user.id, (posts) => {
    getComments(posts[0].id, (comments) => {
      // 更多嵌套...
    })
  })
})
```

:::

### 2. Promise

ES6 引入的 Promise 提供了更优雅的异步处理方式：

```javascript title="Promise 基础使用"
function fetchUser(userId) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (userId) {
        resolve({ id: userId, name: 'Alice' })
      }
      else {
        reject(new Error('User ID is required'))
      }
    }, 1000)
  })
}

fetchUser(123)
  .then((user) => {
    console.log('User:', user)
    return user.name
  })
  .then((name) => {
    console.log('Name:', name)
  })
  .catch((error) => {
    console.error('Error:', error)
  })
```

::: code-tabs
@tab Promise.all

```javascript
// 并行执行多个异步操作
Promise.all([
  fetchUser(1),
  fetchUser(2),
  fetchUser(3)
]).then((users) => {
  console.log('All users:', users)
}).catch((error) => {
  console.error('One request failed:', error)
})
```

@tab Promise.race

```javascript
// 获取最先完成的结果
Promise.race([
  fetchFromServerA(),
  fetchFromServerB()
]).then((firstResult) => {
  console.log('First response:', firstResult)
})
```

:::

### 3. Async/Await

ES2017 引入的 async/await 让异步代码看起来像同步代码：

```javascript title="Async/Await 使用"
async function getUserData(userId) {
  try {
    const user = await fetchUser(userId)
    const posts = await fetchUserPosts(user.id)
    const comments = await fetchPostComments(posts[0].id)

    return {
      user,
      posts,
      comments
    }
  }
  catch (error) {
    console.error('Failed to fetch user data:', error)
    throw error
  }
}

// 使用
getUserData(123)
  .then(data => console.log('User data:', data))
  .catch(error => console.error('Error:', error))
```

## 异步编程的核心概念

### 1. 事件循环（Event Loop）

JavaScript 的事件循环机制是异步编程的基石：

```javascript title="事件循环示例"
console.log('Start')

setTimeout(() => {
  console.log('Timeout 1')
}, 0)

Promise.resolve().then(() => {
  console.log('Promise 1')
})

console.log('End')

// 输出顺序：
// Start
// End
// Promise 1
// Timeout 1
```

:::info 执行顺序

* 同步任务立即执行
* 微任务（Promise）在当前任务结束后立即执行
* 宏任务（setTimeout）在下一个事件循环中执行
  :::

### 2. 错误处理

:::steps

* **Promise 错误处理**：

  ```javascript
  fetchUser(null)
    .then(user => console.log(user))
    .catch(error => console.error('Caught:', error))
  ```

* **Async/Await 错误处理**：

  ```javascript
  async function safeFetch() {
    try {
      const user = await fetchUser(null)
      return user
    }
    catch (error) {
      console.error('Fetch failed:', error)
      return null
    }
  }
  ```

* **全局错误处理**：

  ```javascript
  window.addEventListener('unhandledrejection', (event) => {
    console.warn('Unhandled promise rejection:', event.reason)
    event.preventDefault()
  })
  ```

:::

## 实际应用场景

### 1. 并发请求优化

```javascript title="并发请求模式"
async function fetchDashboardData() {
  const [user, notifications, messages] = await Promise.all([
    fetchUser(currentUserId),
    fetchNotifications(),
    fetchMessages()
  ])

  return { user, notifications, messages }
}

// 带错误处理的并发
async function fetchWithFallback() {
  try {
    const data = await Promise.allSettled([
      fetchFromPrimary(),
      fetchFromBackup()
    ])

    const successful = data.find(result => result.status === 'fulfilled')
    return successful?.value || null
  }
  catch (error) {
    console.error('All requests failed')
    return null
  }
}
```

### 2. 请求取消

```javascript title="可取消的异步操作"
class CancelableFetch {
  constructor() {
    this.controller = new AbortController()
  }

  async fetch(url) {
    try {
      const response = await fetch(url, {
        signal: this.controller.signal
      })
      return await response.json()
    }
    catch (error) {
      if (error.name === 'AbortError') {
        console.log('Request was canceled')
      }
      throw error
    }
  }

  cancel() {
    this.controller.abort()
  }
}

// 使用
const fetchInstance = new CancelableFetch()
fetchInstance.fetch('/api/data')
  .then(data => console.log(data))
  .catch(error => console.error(error))

// 需要时取消
// fetchInstance.cancel();
```

## 性能优化技巧

### 1. 防抖与节流

::: code-tabs
@tab 防抖

```javascript
function debounce(func, wait) {
  let timeout
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout)
      func(...args)
    }
    clearTimeout(timeout)
    timeout = setTimeout(later, wait)
  }
}

// 搜索框使用
const search = debounce((query) => {
  fetchResults(query)
}, 300)
```

@tab 节流

```javascript
function throttle(func, limit) {
  let inThrottle
  return function (...args) {
    if (!inThrottle) {
      func.apply(this, args)
      inThrottle = true
      setTimeout(() => inThrottle = false, limit)
    }
  }
}

// 滚动事件使用
window.addEventListener('scroll', throttle(() => {
  checkPosition()
}, 100))
```

:::

### 2. 懒加载与预加载

```javascript title="图片懒加载"
class LazyLoader {
  constructor() {
    this.observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          this.loadImage(entry.target)
          this.observer.unobserve(entry.target)
        }
      })
    })
  }

  observe(element) {
    this.observer.observe(element)
  }

  loadImage(img) {
    const src = img.getAttribute('data-src')
    if (src) {
      img.src = src
      img.removeAttribute('data-src')
    }
  }
}
```

## 最佳实践总结

:::important 关键要点

1. **优先使用 async/await**：代码更清晰，错误处理更简单
2. **合理处理错误**：不要忽略 Promise 拒绝，使用 try-catch 或 .catch()
3. **避免过度嵌套**：使用 Promise.all 处理并行任务
4. **考虑性能影响**：适当使用防抖、节流和懒加载
5. **提供加载状态**：给用户明确的反馈
6. **测试异步代码**：确保在各种场景下都能正常工作
   :::

## 参考

* [MDN Web Docs: 使用 Promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises)
* [JavaScript Info: Async/await](https://javascript.info/async-await)
* [Google Developers: Promises](https://developers.google.com/web/fundamentals/primers/promises)

---

---
url: /article/gq88mn6a/index.md
---
# webpack原理的简单入门
::: center
![webpack](https://www.webpackjs.com/icon-square-small.85ba630cf0c5f29ae3e3.svg){width=100}
:::

## 前言

我们知道， `webpack` 作为前端工程化中，主流的模块打包工具之一，应用于各种各样的前端工程化项目中。

虽然大多数项目都或多或少会使用到 `webpack`， 但是可能对于大多数的 前端开发人员来说，
可能只是改改 `webpack` 的配置， 或者甚至从未动过 `webpack` 的相关文件,
或多或少对 `webpack` 的配置以及功能感到陌生。

还有类似于 `vue-cli`、`create-react-app` 、 `umi.js` 等各种基于 `webpack` 封装的 脚手架，
提供了各种开箱即用的功能，这使得 `webpack` 离我们好像越来越远。

但是当我们的某个项目面临了不得不去 深入 `webpack` 才能解决的问题，或者 面试时，被问起 `webpack` 相关的问题，
就难以解决或者回答。

所以我们需要对 `webpack` 至少有基本的了解，了解它的原理、如何编写 `loader` 、 `plugin` 等。

## webpack是什么

> 引用 [webpack官网](https://webpack.js.org/concepts/) ：
>
> At its core, webpack is a static module bundler for modern JavaScript applications.
> When webpack processes your application, it internally builds a dependency graph from one or more
> entry points and then combines every module your project needs into one or more bundles,
> which are static assets to serve your content from.
>
> 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。
> 当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，
> 其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。

从作用上讲，webpack 的功能就是将不同模块的文件，打包整合到一起，并且保证它们之间引用的正确，且有序执行。
这使得我们在做项目架构时，能够从模块的角度去做文件拆分，然后交给 webpack 打包整合。

而一个项目中的文件，不仅有 html文件、CSS文件、JavaScript文件、图片资源、Vue特有的`.vue`文件，
typescript的`.ts` 文件等，以及项目的中的代码还需要进行压缩混淆、浏览器兼容、等等必要的处理，
启动一个本地的开发服务器、模块的热更新替换等， 可以通过`webpack` 提供的各种机制，来一一实现。

对于 `webpack` 来说， 它自身只能识别 JavaScript 文件， 而对于其他的资源，可以通过 webpack提供的 `Loader` 特性来实现
识别。 通过 `Loader`，可以把其它类型的资源文件，转换为 webpack能够处理的有效模块。

而对于 代码混淆、本地开发服务器、模块热更新，则可以通过 webpack 提供的 `Plugin` 特性来实现功能上的扩展。

## 模块打包原理

在 webpack 中，有四个基础且核心的概念：

* **入口（entry）**
* **输出（output）**
* **加载器（Loader）**
* **插件（Plugin）**

### 入口（entry）

指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。

### 输出(output)

告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件

### 加载器（Loader）

webpack 自身只能理解 JavaScript 文件 和 json 文件， loader 可以将其他类型的资源文件转换为 webpack能够处理的有效模块。

本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。

### 插件（Plugin）

用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。
插件接口功能极其强大，可以用来处理各种各样的任务。

### 模块（modules）

在模块化编程中，开发者将程序分解成离散功能块(discrete chunks of functionality)，并称之为模块。

对于 webpack ，任何文件都可以是一个模块。

### 模块打包运行原理

在说 webpack 的 **模块打包运行原理** 之前， 先看下 我们是如何使用 webpack的，
一般情况下， 我们通过编写一个 配置文件`webpack.config.js`， 对 webpack 进行本地化的配置，
大致的配置如下：

```js
module.exports = {
  // 声明模块的入口文件
  entry: './src/entry.js',
  output: {
    path: path.resolve(__dirname, 'dist'), // 输出目录
    filename: 'bundle.js', // 文件名称
  },
  module: {
    rules: [
      // 配置 使用 babel-loader 对 .js 资源进行转换
      {
        test: /\.js$/,
        loader: 'babel-loader',
      },
      // ...more loader
    ],
  },
  // 插件配置
  plugins: [
    new EslintWebpackPlugin(),
    new webpack.NoEmitOnErrorsPlugin(),
    // ...more plugin
  ],
  // ...more config
}
```

`webpack` 读取了 配置文件后，运行的流程大致如下：

1. 读取 `webpack` 的配置参数；
2. 启动 `webpack` , 创建 `compiler` 对象，开始解析项目；
3. 从入口文件 `entry` 开始解析，并找到其导入的**依赖模块**，递归遍历分析，形成**依赖关系树**；
4. 对不同的文件类型资源的依赖模块文件，使用对应的 `Loader` 进行转换，最终转为 webpack的有效模块；
5. 在编译过程中， `webpack` 通过 发布订阅模式，向外抛出一些 `hooks` ，`webpack` 的 `Plugin` 通过监听各个 `hooks` ，
   执行插件任务，扩展 `webpack` 的功能，干预输出结果。
6. 根据 输出配置 `output` ，将打包构建好的资源文件 输出。

`compiler` 对象是一个全局单例，负责控制整个 webpack 构建流程。

在构建过程中，还会产生一个当前构建的上下文对象 `compilation`, 它包含了当前构建的所有信息，在每个热更新或重新构建时， `compiler` 都会产生一个新的`compilation` 对象，负责当前构建过程。

每个模块间的依赖关系，则依赖于`AST`语法树。每个模块文件在通过`Loader`解析完成之后，
会通过`acorn`库生成模块代码的`AST`语法树，通过语法树就可以分析这个模块是否还有依赖的模块，
进而继续循环执行下一个模块的编译解析。

最终， webpack 打包构建出来的 bundle 文件，是一个 IIFE 执行函数。

```js
// webpack5下进行的最小化打包输出文件
;(() => {
  // webpack 模块文件内容
  let __webpack_modules__ = {
    'entry.js': (modules) => {
      /* ... */
    },
    'other.js': (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
      /* ... */
    },
  }

  // 模块缓存
  let __webpack_module_cache__ = {}

  // The require function
  function __webpack_require__(moduleId) {
    // Check if module is in cache
    let cachedModule = __webpack_module_cache__[moduleId]
    if (cachedModule !== undefined) {
      return cachedModule.exports
    }
    // Create a new module (and put it into the cache)
    let module = (__webpack_module_cache__[moduleId] = {
      // no module.id needed
      // no module.loaded needed
      exports: {},
    })

    // Execute the module function
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__)

    // Return the exports of the module
    return module.exports
  }

  // startup
  // Load entry module and return exports
  // This entry module can't be inlined because the eval devtool is used.
  let __webpack_exports__ = __webpack_require__('entry.js')
})()
```

在上面的打包demo中，整个立即执行函数里边只有三个变量和一个函数方法，`__webpack_modules__`存放了编译后的各个文件模块的JS内容，`__webpack_module_cache__` 用来做模块缓存，`__webpack_require__` 是Webpack内部实现的一套依赖引入函数。最后一句则是代码运行的起点，从入口文件开始，启动整个项目。

`__webpack_require__`模块引入函数，我们在模块化开发的时候，通常会使用`ES Module`或者`CommonJS`规范导出/引入依赖模块，webpack打包编译的时候，会统一替换成自己的`__webpack_require__`来实现模块的引入和导出，从而实现模块缓存机制，以及抹平不同模块规范之间的一些差异性。

---

---
url: /article/gu55hnjs/index.md
---
# CSS @function：原生 CSS 函数定义
:::info 重要提示
本文讨论的是 **原生 CSS @function 规则**，而非 Sass/Less 等预处理器中的函数功能。这是 CSS 规范中正在发展的新特性，用于在原生 CSS 中定义可重用的函数逻辑。
:::

::: warning `@function` 目前的浏览器兼容性堪忧，不建议在生产中使用
:::

@[caniuse](mdn-css_at-rules_function)

## 什么是 CSS @function？

CSS `@function` 规则允许开发者定义自定义函数，这些函数可以接受参数并返回计算后的值。这为 CSS 带来了真正的编程能力，让样式代码更加模块化和可维护。

### 基本语法结构

```css title="基础 @function 语法"
@function --function-name(<function-parameter>#?) [returns <css-type>]? {
  <declaration-rule-list>
}
```

## 入门示例：从简单开始

让我们通过一个实际的例子来理解 `@function` 的基本用法。

### 示例 1：基础数值计算

```css title="定义一个简单的加倍函数"
@function --double(--value) {
  result: calc(var(--value) * 2);
}

.container {
  --base-size: 20px;
  padding: --double(var(--base-size)); /* 结果为 40px */
  margin: --double(10px); /* 结果为 20px */
}
```

:::steps

* **函数定义**：使用 `@function` 关键字定义函数，函数名必须以 `--` 开头
* **参数声明**：在括号内声明参数，参数也是自定义属性
* **返回值**：使用 `result` 描述符指定函数的返回值
* **函数调用**：在属性值中使用 `--function-name(arguments)` 语法调用

:::

## 深入理解：高级特性

### 1. 类型约束和默认值

为了编写更健壮的函数，我们可以指定参数和返回值的类型：

```css title="带类型约束的函数"
@function --transparent(--color <color>, --alpha <number>: 0.5) returns <color> {
  result: oklch(from var(--color) l c h / var(--alpha));
}

.card {
  --primary-color: #3498db;
  background-color: --transparent(var(--primary-color), 0.3);
  /* 或者使用默认值 */
  border-color: --transparent(var(--primary-color)); /* alpha 默认为 0.5 */
}
```

### 2. 复杂数据类型处理

当需要处理包含逗号的值列表时，可以使用花括号包裹：

```css title="处理值列表参数"
@function --max-plus-x(--list <length>#, --x <length>) {
  result: calc(max(var(--list)) + var(--x));
}

.element {
  width: --max-plus-x({10px, 20px, 15px}, 5px); /* 结果为 25px */
}
```

## 条件逻辑：使用 CSS `if()` 函数

CSS 提供了 `if()` 函数来实现条件逻辑，这可以在 `@function` 中用于创建复杂的条件判断。

### `if()` 函数基础语法

```css title="if() 函数基本用法"
@function --responsive-value(--mobile, --desktop) {
  result: if(
    media(width < 768px): var(--mobile);
    else: var(--desktop)
  );
}

.container {
  padding: --responsive-value(1rem, 2rem);
}
```

### 在 `@function` 中使用 `if()` 的完整示例

```css title="使用 if() 的条件函数"
@function --narrow-wide(--narrow, --wide) {
  result: if(
    media(width < 700px): var(--narrow);
    else: var(--wide)
  );
}

body {
  display: grid;
  grid-template-columns: repeat(--narrow-wide(1, 3), 1fr);
  gap: --narrow-wide(0, 20px);
  padding: 0 20px;
}

h2 {
  font-size: --narrow-wide(2.5rem, 2rem);
}
```

### 多重条件判断

```css title="多重条件的 if() 函数"
@function --theme-aware-color(--light, --dark, --dim) {
  result: if(
    style(--scheme: dark): var(--dark);
    style(--scheme: dim): var(--dim);
    else: var(--light)
  );
}

.card {
  background-color: --theme-aware-color(white, #333, #555);
  color: --theme-aware-color(black, white, #ccc);
}
```

## 实际应用场景

### 场景 1：响应式设计助手

```css title="响应式布局函数"
@function --responsive-spacing(--mobile, --tablet, --desktop) {
  result: if(
    media(width < 768px): var(--mobile);
    media(width < 1024px): var(--tablet);
    else: var(--desktop)
  );
}

.section {
  padding: --responsive-spacing(1rem, 2rem, 3rem);
  margin-bottom: --responsive-spacing(2rem, 3rem, 4rem);
}
```

### 场景 2：颜色工具函数

```css title="颜色处理函数"
@function --lighten(--color <color>, --amount <percentage>) {
  result: color-mix(in oklch, var(--color), white var(--amount));
}

@function --darken(--color <color>, --amount <percentage>) {
  result: color-mix(in oklch, var(--color), black var(--amount));
}

.button {
  --main-color: #4a90e2;
  background-color: var(--main-color);
  border-color: --darken(var(--main-color), 20%);

  &:hover {
    background-color: --lighten(var(--main-color), 10%);
  }
}
```

### 场景 3：主题感知函数

```css title="主题感知函数"
@function --light-dark(--light, --dark) {
  result: if(
    style(--scheme: dark): var(--dark);
    else: var(--light)
  );
}

.component {
  background-color: --light-dark(white, #1a1a1a);
  color: --light-dark(black, white);
  border: 1px solid --light-dark(#e0e0e0, #333);
}
```

## 函数组合与嵌套

CSS 函数可以相互调用，创建更复杂的逻辑：

```css title="函数组合示例"
@function --scale-factor(--base) {
  result: calc(var(--base) * 1.2);
}

@function --composed-calculation(--value) {
  --scaled: --scale-factor(var(--value));
  result: calc(var(--scaled) + 10px);
}

.container {
  width: --composed-calculation(100px); /* 结果为 130px */
}
```

## 作用域和变量优先级

理解 CSS 函数中的作用域规则非常重要：

```css title="作用域示例"
@function --scope-demo(--param) {
  --local: 100;
  result: calc(var(--global) + var(--param) + var(--local));
}

.element {
  --global: 50;
  --param: 999; /* 这个不会影响函数参数 */
  value: --scope-demo(25); /* 结果为 175 (50 + 25 + 100) */
}
```

:::warning 作用域规则

* 函数参数 > 元素上的自定义属性
* 函数内部局部变量 > 函数参数
* 同名的变量，后定义的会覆盖先定义的
  :::

## 条件逻辑的完整实现

### 使用 `if()` 实现复杂条件

```css title="复杂条件逻辑"
@function --adaptive-spacing(--dense, --normal, --generous) {
  result: if(
    media(width < 480px) and media(any-pointer: coarse): var(--dense);
    media(width < 768px): var(--normal);
    media(width >= 1200px): var(--generous);
    else: var(--normal)
  );
}

.card {
  padding: --adaptive-spacing(0.5rem, 1rem, 1.5rem);
  margin: --adaptive-spacing(0.25rem, 0.5rem, 1rem);
}
```

### 结合 `calc()` 和 `if()`

```css title="计算与条件结合"
@function --dynamic-width(--base) {
  result: calc(
    var(--base) *
    if(
      media(width < 768px): 0.8;
      media(width < 1024px): 0.9;
      else: 1.0
    )
  );
}

.sidebar {
  width: --dynamic-width(300px);
}
```

## 最佳实践和注意事项

### 1. 命名约定

```css
/* ✅ 推荐：使用描述性名称 */
@function --calculate-responsive-width(--base, --multiplier) { ... }

/* ❌ 避免：名称不明确 */
@function --func1(--a, --b) { ... }
```

### 2. 错误处理策略

```css title="安全的函数设计"
@function --safe-multiply(--value, --multiplier: 1) {
  /* 使用默认值和合理的计算来避免错误 */
  result: calc(var(--value) * var(--multiplier));
}
```

### 3. 性能考虑

```css
/* ✅ 推荐：避免不必要的复杂计算 */
@function --optimized-calculation(--value) {
  /* 简单的计算 */
  result: calc(var(--value) * 2);
}

/* ❌ 避免：过于复杂的嵌套函数 */
@function --overly-complex(--value) {
  /* 多层嵌套和复杂逻辑可能影响性能 */
}
```

## 渐进增强策略

对于不支持 `if()` 函数的浏览器，可以使用以下策略：

```css title="渐进增强示例"
/* 基础样式 - 所有浏览器都支持 */
.card {
  padding: 1rem;
  background-color: white;
}

/* 增强样式 - 仅支持 if() 的浏览器应用 */
@supports (padding: if(media(width < 768px): 0.5rem; else: 1rem)) {
  .card {
    padding: if(
      media(width < 768px): 0.5rem;
      else: 1rem
    );
    background-color: if(
      style(--theme: dark): #333;
      else: white
    );
  }
}
```

## 总结

CSS `@function` 规则结合 `if()` 函数为原生 CSS 带来了强大的编程能力：

### 核心优势

* **代码复用**：避免重复的计算逻辑
* **条件逻辑**：通过 `if()` 函数实现复杂的条件判断
* **类型安全**：通过类型约束减少错误
* **维护性**：集中管理复杂计算逻辑
* **表达力**：创建领域特定的语言

### 关键特性

* **`if()` 函数**：支持 `style()`、`media()` 和 `supports()` 查询
* **类型约束**：可指定参数和返回值的类型
* **默认值**：为参数提供默认值
* **作用域**：清晰的变量优先级规则

### 适用场景

* 复杂的数学计算
* 响应式设计助手
* 颜色处理工具
* 动画配置管理
* 布局计算工具
* 主题切换系统

:::tip 实践建议
虽然 `@function` 和 `if()` 功能强大，但在实际项目中建议：

1. 先从简单的工具函数开始
2. 逐步引入复杂的条件逻辑
3. 始终提供兼容性回退
4. 在团队中建立统一的函数命名和使用规范
5. 使用 `@supports` 进行特性检测
   :::

## 参考

* [MDN @function 文档](https://developer.mozilla.org/en-US/docs/Web/CSS/@function)
* [MDN if() 函数文档](https://developer.mozilla.org/en-US/docs/Web/CSS/if)
* [CSS Functions and Mixins 规范](https://drafts.csswg.org/css-mixins-1/#function-rule)
* [CSS 自定义函数使用指南](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_custom_functions_and_mixins/Using_custom_functions)

---

---
url: /article/h3gsxe94/index.md
---
# chokidar 从 v3 到 v4 升级指南
众所周知，[chokidar](https://github.com/paulmillr/chokidar) 是前端最广泛使用的 文件监听工具。
在 NPM 上每周有约 1 亿次的下载量，是 `webpack` / `vite` 等主流的前端构建工具的必不可少的依赖之一。

但是从 `v3` 升级到 `v4` ，它有一个非常重要的破坏性变更，这导致了我们升级过程不够平滑。
在这篇文章中，将说明如何进行升级。

## 从 v3 到 v4 的破坏性变更

我们先看看 [`v3.6.0` 到 `v4.0.0` 的版本更新说明](https://github.com/paulmillr/chokidar/releases/tag/4.0.0)：

> * Remove glob support
> * Remove bundled fsevents
> * Decrease dependency count from 13 to 1
> * Rewrite in typescript. Makes emitted types more precise
> * The package became hybrid common.js / ESM
> * Bump minimum node.js requirement to v14+

其中，我们重点关注的是第一条： **Remove glob support** 。

在 `v3` 中，chokidar 支持 glob 语法的文件匹配，我们可以这么写：

```ts
import process from 'node:process'
import chokidar from 'chokidar'

const watcher = chokidar.watch('foo/**/*.js', { cwd: process.cwd() })

watcher.on('all', (event, path) => {
  console.log(event, path)
})
```

但在 `v4`， **glob** 模式匹配已被移除，这意味着以上的用法已经无效。

## v4 的新特性

`v4` 版本的 `chokidar.watch(paths[, options])` ，第一个参数可以是 文件路径或者目录 以及它们数组，对于目录，会递归地监听目录下的所有文件。

也就是说：

* 如果传入的是一组文件路径，那么这些文件路径都应该是明确的指向具体的文件。
* 如果是一个目录，那么这个目录下的所有文件都会被监听，包括递归的监听所有子目录下的文件。

因此，在 `v4` 中，我们可以这么写的:

```ts
// 监听文件列表
const watcher = chokidar.watch([
  '/foo/a.js',
  '/foo/b.js',
  '/foo/c.js',
])

// 监听目录，包括 递归的监听子目录
const watcher = chokidar.watch('/foo')
```

以及，可以通过 `watcher.add()` 添加新的文件或目录

```ts
watcher.add('/foo/d.js')
watcher.add(['/foo/e.js', '/foo/f.js'])
watcher.add('/bar')
```

## 从 v3 到 v4 的升级

从上面可以看出，从 `v3` 升级到 `v4` 的最大阻碍是如何从 `glob` 模式匹配改写为 `v4` 的文件路径匹配。

我们先来看一个常见的例子：

```ts
import chokidar from 'chokidar'

const watcher = chokidar.watch('foo/**/*.js')
```

这个例子需要监听 `foo` 目录下的包括其所有子目录的下的 `.js` 文件。

如果我们只考虑 **仅监听现有文件的修改和删除**，那么可以这么写:

```ts
import glob from 'node:fs/promises'
import chokidar from 'chokidar'

const files: string[]
for (const file of await glob('foo/**/*.js')) {
  files.push(file)
}

const watcher = chokidar.watch(files)
```

`fs.glob` 是 `NodeJS v22.0.0` 新增的 API，可以通过 `glob` 模式匹配查找文件，并返回文件路径列表。

但是，如果我们需要考虑 **新增 `.js` 文件** 时，以上的方式就不合适了，因为监听的文件列表是一开始就确定的。

因此需要转换下思路，变更为监听文件目录：

```ts
const watcher = chokidar.watch('./foo')
```

我们很容易就想到在 监听事件中过滤 文件的后缀名：

```ts
watcher.on('add', (path) => {
  if (path.endsWith('.js')) {
    // ...
  }
})

watcher.on('change', (path) => {
  if (path.endsWith('.js')) {
    // ...
  }
})
```

但是，这不是推荐的做法，因为在监听该目录时，是包括了目录下的所有文件类型，即使非 `.js` 文件也一并监听了。
这造成了非必要的额外资源开销，特别是如果该目录较大时，可能会导致性能问题。

因此，我们需要借助于 `chokidar` 的 `ignored` 配置项：

```ts
const watcher = chokidar.watch('./foo', {
  ignored: (path, stats) => {
    // 忽略所有非 `.js` 文件
    return Boolean(stats?.isFile()) && !path.endsWith('.js')
  }
})
```

这可以避免非 `.js` 的文件被监听。

我们再来看一个例子：

```ts
const watcher = chokidar.watch('{foo,bar}/**/{baz,qux}/*.{js,ts,css}')
```

此时问题变得比较棘手了，编写 `ignored` 将变得比较复杂

```ts
import path from 'node:path'
const watcher = chokidar.watch(['./foo', './bar'], {
  ignored: (filepath, stats) => {
    const basename = path.basename(filepath)
    const dirname = path.dirname(filepath).split('/').filter(Boolean).pop()
    return Boolean(stats?.isFile())
      && !basename.endsWith('.js')
      && !basename.endsWith('.ts')
      && !basename.endsWith('.css')
      && dirname !== 'baz'
      && dirname !== 'qux'
  }
})
```

而如果 `glob` 再进一步变得更加复杂：

```ts
const watcher = chokidar.watch([
  '{foo,bar}/**/{baz,qux}/*.{js,ts,css}',
  'biz/**/*.{js,ts,css,less}',
  'buzz/**{pizz,puz}/*.{js,ts,css}'
])
```

::: danger `ignored` 谁爱写谁写去
:::

我们知道， `v3` 的 glob 有 `picomatch` 提供支持，因此，我们也可以引入 `picomatch` 来实现类似的功能。
对于 `ignored` ，我们所要做的，就是对结果取反：

```ts
import path from 'node:path'
import process from 'node:process'
import chokidar from 'chokidar'
import picomatch from 'picomatch'

const cwd = process.cwd()

const matcher = picomatch([
  '{foo,bar}/**/{baz,qux}/*.{js,ts,css}',
  'biz/**/*.{js,ts,css,less}',
  'buzz/**{pizz,puz}/*.{js,ts,css}'
])
const watcher = chokidar.watch(['./foo', './bar', './biz', './buzz'], {
  cwd,
  ignored: (filepath, stats) => {
    if (stats?.isFile()) {
      // 结果取反，表示匹配的结果不忽略，反之忽略
      return !matcher(path.relative(cwd, filepath))
    }
    return false
  }
})
```

### `ignored` 的注意事项

`ignored` 检查的 `filepath` ，包括了 文件和 目录，并且包括一级目录，比如 `watch('./foo')`，
`filepath` 会包含 `${cwd}/foo` 的目录路径，如果你在 `ignored` 的结果中不小心忽略了它，
那么会导致整个 `watcher` 不再监听任何文件。因此，在忽略文件时，最好使用 `stats.isFile()` 预先检查：

```ts
const watcher = chokidar.watch('./foo', {
  ignored: (path, stats) => {
    if (stats?.isFile()) {
      // 检查要忽略的文件
    }
    return false // 表示非文件则不忽略
  }
})
```

同理，忽略目录时，最好使用 `stats.isDirectory()` 预先检查。

---

---
url: /article/h4z91gyz/index.md
---
# caniuse
### 工具

将caniuse 的feature 结果，以图片或者iframe的形式，嵌入到站点。
<https://caniuse.bitsofco.de/>

---

---
url: /article/hdx2maf6/index.md
---
# 在 Chrome 中模拟请求和Web内容
在 **Chrome 117** 中，发布了一项极为实用的新功能，这项功能允许 我们在 **本地替换Web内容**
（包括 XHR 和 提取请求数据）

## 概述

在我们的日常开发中，在进行调试时经常需要模拟各种数据场景。
通常情况下，我们可以借助一些开发工具，或者根据项目所使用的脚手架相关的工具进行模拟。

> \[!tip]
> 如果你正在使用 `vite`，推荐使用 [`vite-plugin-mock-dev-server`](https://vite-plugin-mock-dev-server.netlify.app/) 插件为你的项目开启 mock 支持。
> 能够满足绝大多数的需求场景，不仅支持 http 请求，还支持 websocket。

从 `Chrome 117` 开始，为我们提供了 `overrides content` 功能，它带来的功能包括：

* 替换 HTTP 响应头
* 替换 HTTP 响应内容
* 替换 网页资源

同时，它还将替换的内容保存 为 本地的文件夹中形成副本。当重新加载网页时，开发者工具会使用这些 本地的副本，
而不是真实的网络资源。

## 限制

本地替换适用于网络响应标头和大多数文件类型（包括 XHR 和提取请求），但有一些例外情况：

* 开发者工具不会保存对 `Elements` 面板的 DOM 树所做的更改。
* 如果你在 `Styles` 窗格中修改 CSS，且该 CSS 的来源是 HTML 文件，则开发者工具不会保存更改。

不过，你可以在 `Sources` 面板中修改 HTML 文件。

## 设置本地替换项

### 启用

1. 首先打开 `Networks` 面板，首先选择你想要 替换的请求，
   从下拉菜单中选择 `override header`(替换响应头) 或者 `override content` （替换内容）。

   ::: center
   ![open menu](/images/chrome-override/open-menu.png){style="width:275px;max-width:100%;"}
   :::

2. 如果你还未设置过 本地替换项，则开发者工具会在顶部的的操作栏中，提示你 选择一个 本地文件夹，
   用于将 替换的文件保存到 本地的文件夹中作为副本。

   ::: center
   ![select folder](/images/chrome-override/select-folder.png)
   :::

   选择文件夹后，开发者工具 会提示你 进行 文件夹授权，点击 `Allow / 允许` 即可：

   ::: center
   ![allow](/images/chrome-override/allow.png)
   :::

3. 授权完毕后，开发者工具将会跳转到 `Sources` 面板。在这里，你可以看到 新生成的 Mock 文件，
   该文件与你想要替换的 请求内容 相对应， 你可以直接在这里对其进行修改：

   ::: center
   ![mock file](/images/chrome-override/mock-file.png)
   :::

### 停用

在 `Sources > overrides` 面板中， 取消选中 `Enable local override` 即可 停用 本地替换。

::: center
![disable](/images/chrome-override/disable.png){style="width:375px;max-width:100%;"}
:::

## 替换响应内容

使用 替换响应内容 时，我们可以不必等待后端，获得后端支持，即可在本地 实时模拟我们需要的数据进行调试。

在 `Networks` 面板中，右键点击你想要修改的接口，在弹出咋菜单中，选择 `Override content` 选项：

::: center
![override res](/images/chrome-override/override-res-1.png){style="width:375px;max-width:100%;"}
:::

开发者工具将会跳转到 `Sources > Overrides` 面板中，并打开对应的 mock 文件：

::: center
![mock file](/images/chrome-override/mock-file.png)
:::

你可以直接在这里修改 响应内容，然后按 `Command /Ctrl + S` 保存文件, 然后刷新页面

## 替换响应头

### 修改单个请求响应头

在 `Networks` 面板中，选择想要修改的接口，并右键点击，然后在 右键菜单中，选择 `Override header`选项：

::: center
![override header](/images/chrome-override/override-header-1.png){style="width:375px;max-width:100%;"}
:::

此时，面板 `Header` 将会进入 可编辑状态：

::: center
![override header](/images/chrome-override/override-header-2.png)
:::

你可以点击 `Add Header` 添加新的响应头， 也可以直接点击想要修改的值即可修改响应头。

另外，如果你只需要简单的修改某个值，还可以直接鼠标悬停在 想要修改的 `Header` 值上，然后点击 `Edit` 图标 来修改响应头。

::: center
![override header](/images/chrome-override/override-header-3.png)
:::

请看一个示例，添加一个 允许跨域请求的头，删除一个响应头并修改响应头：

::: center
![override header](/images/chrome-override/override-header-4.png)
:::

### 修改所有请求响应头

如果需要在修改所有请求的响应头时，点击 `Response Headers` 面板右侧的 `.headers` 按钮：

::: center
![override header](/images/chrome-override/override-header-5.png){style="width:425px;max-width:100%;"}
:::

开发者工具将会条状到对应的 `Sources > Overrides > .headers` 文件中：

::: center
![override header](/images/chrome-override/override-header-6.png)
:::

在这里，你可以点击 `Add override rule` 按钮，添加新的响应头。

其中 `Apply to` 表示该规则匹配的 请求接口地址， 你可以使用 `*` 通配符 匹配所有的接口， 使用 `?` 指定单个字符。

修改完成后，别忘了 使用 `Commands/Ctrl + S` 保存 `.headers` 文件。

然后，你就可以刷新页面以应用所有的更改。

## 替换Web内容

你可以直接在 `Sources > Page` 查看 当前页面的 所有资源内容，然后找到你想要修改的资源内容，
右键点击，在菜单中选择 `Override content`。

:::center
![override content](/images/chrome-override/override-content.png){style="width:425px;max-width:100%;"}
:::

开发者工具将会跳转到 `Sources > Overrides` 面板，并建立 该资源内容的 Mock 副本，
你可以直接对其进行修改， `Command /Ctrl + S` 保存文件，然后刷新页面。

---

---
url: /article/hsgdhlah/index.md
---
在 NPM 安装 Electron, Puppeteer 等包时，他们会通过 `postinstall` 脚本下载对应的二进制文件。
因为一些不得而知的原因这个过程在某些网络下可能会很慢或不可用。
你可以复制以下配置至 `.bashrc` 或 `.zshrc` 中，使用 [npmmirror.com](https://npmmirror.com) 提供的二进制镜像。

数据来源于 `binary-mirror-config`。

```sh
# === NPM BINRAY CHINA ===
# https://github.com/cnpm/binary-mirror-config/blob/main/package.json#L48
export NODEJS_ORG_MIRROR="https://cdn.npmmirror.com/binaries/node"
export NVM_NODEJS_ORG_MIRROR="https://cdn.npmmirror.com/binaries/node"
export PHANTOMJS_CDNURL="https://cdn.npmmirror.com/binaries/phantomjs"
export CHROMEDRIVER_CDNURL="https://cdn.npmmirror.com/binaries/chromedriver"
export OPERADRIVER_CDNURL="https://cdn.npmmirror.com/binaries/operadriver"
export ELECTRON_MIRROR="https://cdn.npmmirror.com/binaries/electron/"
export ELECTRON_BUILDER_BINARIES_MIRROR="https://cdn.npmmirror.com/binaries/electron-builder-binaries/"
export SASS_BINARY_SITE="https://cdn.npmmirror.com/binaries/node-sass"
export SWC_BINARY_SITE="https://cdn.npmmirror.com/binaries/node-swc"
export NWJS_URLBASE="https://cdn.npmmirror.com/binaries/nwjs/v"
export PUPPETEER_DOWNLOAD_HOST="https://cdn.npmmirror.com/binaries"
export SENTRYCLI_CDNURL="https://cdn.npmmirror.com/binaries/sentry-cli"
export SAUCECTL_INSTALL_BINARY_MIRROR="https://cdn.npmmirror.com/binaries/saucectl"
export npm_config_sharp_binary_host="https://cdn.npmmirror.com/binaries/sharp"
export npm_config_sharp_libvips_binary_host="https://cdn.npmmirror.com/binaries/sharp-libvips"
export npm_config_robotjs_binary_host="https://cdn.npmmirror.com/binaries/robotj"
```

---

---
url: /article/hw3zwayv/index.md
---
# tree-shaking，“摇” 掉没用的代码
## 什么是 Tree-Shaking？

Tree-Shaking 是一个现代 JavaScript 打包工具中广泛使用的术语，它指的是在打包过程中**移除未使用的代码**的技术。这个名称非常形象——就像摇动一棵树，让枯叶（无用代码）落下，只保留健康的枝叶（有用代码）。

## 为什么需要 Tree-Shaking？

在传统的前端开发中，我们经常引入整个库或模块，但实际上只使用了其中一小部分功能。比如：

```javascript
import { filter, map, reduce } from 'lodash'

// 只使用了 map 和 filter
const result = array.map(x => x * 2).filter(x => x > 10)
```

上面的例子中，`reduce` 函数被导入但从未使用，Tree-Shaking 可以将其从最终打包文件中移除。

## Tree-Shaking 的工作原理

### 1. 静态分析

Tree-Shaking 依赖于 ES6 模块的**静态结构**特性：

```javascript
// ES6 模块 - 支持 Tree-Shaking
import { functionA } from './moduleA'
export { functionB } from './moduleB'

// CommonJS - 不支持 Tree-Shaking
const moduleA = require('./moduleA')
module.exports = { functionB }
```

ES6 模块在编译时就能确定导入导出的关系，而 CommonJS 在运行时才能确定。

### 2. 依赖图构建

打包工具会构建模块依赖图：

```
Entry → Module A → Module B → Module C
                → Module D (未使用)
```

### 3. 标记和清除

工具会标记所有从入口点可达的代码，然后清除未被标记的代码。

## 实际配置示例

### Webpack 配置

```javascript
// webpack.config.js
module.exports = {
  mode: 'production', // 生产模式自动开启 Tree-Shaking
  optimization: {
    usedExports: true,
    minimize: true,
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              ['@babel/preset-env', { modules: false }] // 重要：不转换 ES6 模块
            ]
          }
        }
      }
    ]
  }
}
```

### Rollup 配置

```javascript
// rollup.config.js
export default {
  input: 'src/main.js',
  output: {
    file: 'dist/bundle.js',
    format: 'esm' // 输出 ES 模块格式
  },
  plugins: [
    // Rollup 默认支持 Tree-Shaking
  ]
}
```

## 最佳实践指南

### 1. 使用 ES6 模块语法

```javascript
// ✅ 推荐 - 支持 Tree-Shaking
import { specificFunction } from 'library'
export function util1() {}
export function util2() {}

// ❌ 避免 - 不支持 Tree-Shaking
const _ = require('lodash')
module.exports = everything
```

### 2. 配置 Babel 正确

```json
// .babelrc
{
  "presets": [
    ["@babel/preset-env", {
      "modules": false // 保持 ES6 模块不变
    }]
  ]
}
```

### 3. 使用支持 Tree-Shaking 的库

选择提供 ES 模块版本的库：

```json
{
  "dependencies": {
    "lodash-es": "^4.17.21", // lodash 的 ES 模块版本
    "date-fns": "^2.29.3" // 天然支持 Tree-Shaking
  }
}
```

### 4. 避免副作用

标记纯模块：

```json
// package.json
{
  "name": "your-package",
  "sideEffects": false
}
```

```json
// package.json
{
  "name": "your-package",
  "sideEffects": [
    "*.css",
    "*.scss"
  ]
}
```

## 常见陷阱和解决方案

### 1. 动态导入问题

```javascript
// ❌ 无法 Tree-Shaking
const moduleName = 'utils'
import(moduleName).then((module) => {
  module.dynamicFunction()
})

// ✅ 明确的静态导入
import { specificUtil } from './utils'
```

### 2. 类的方法移除

```javascript
class Calculator {
  add(a, b) { return a + b }
  multiply(a, b) { return a * b } // 如果未使用会被移除
}

// 只使用 add 方法
const calc = new Calculator()
calc.add(1, 2)
```

### 3. 第三方库的副作用

```javascript
// 某些库可能有副作用，阻止 Tree-Shaking
import 'polyfill-library' // 可能包含副作用
```

## 性能对比示例

让我们看一个实际的 Tree-Shaking 效果对比：

**Tree-Shaking 前：**

```javascript
import _ from 'lodash'

// 只使用一个函数
const result = _.chunk([1, 2, 3, 4], 2)
// 打包大小：~70KB（整个 lodash）
```

**Tree-Shaking 后：**

```javascript
import { chunk } from 'lodash-es'

const result = chunk([1, 2, 3, 4], 2)
// 打包大小：~2KB（仅 chunk 函数）
```

## 调试 Tree-Shaking

### Webpack Bundle Analyzer

```bash
npm install --save-dev webpack-bundle-analyzer
```

```javascript
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
}
```

## 总结

Tree-Shaking 是现代前端优化的关键技术，要充分发挥其作用需要：

1. **使用 ES6 模块**作为项目标准
2. **正确配置构建工具**，避免意外转换模块语法
3. **选择支持 Tree-Shaking 的第三方库**
4. **合理标记副作用**，帮助打包工具识别
5. **定期分析打包结果**，持续优化

通过合理运用 Tree-Shaking，可以显著减少最终打包文件的大小，提升应用加载性能，为用户提供更好的体验。

## 参考

* [Webpack Tree-Shaking 文档](https://webpack.js.org/guides/tree-shaking/)
* [Rollup Tree-Shaking 原理](https://rollupjs.org/guide/en/#tree-shaking)
* [ES6 模块与 CommonJS 差异](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/)

---

---
url: /article/hx3h2vvj/index.md
---
# JavaScript 进阶 七： 原型到原型链
## 引言

在JavaScript的世界里，原型（Prototype）和原型链（Prototype Chain）是理解这门语言面向对象特性的核心基石。无论你是初学者还是有一定经验的开发者，深入理解原型机制都能让你写出更优雅、更高效的代码。本文将带你从基础概念出发，逐步深入原型链的运作机制，并探讨其在现代JavaScript开发中的实际应用。

:::info 为什么需要理解原型？
JavaScript的继承机制与其他面向对象语言（如Java、C++）不同，它基于原型而非类。理解原型链能帮助你：

* 更好地理解JavaScript的继承机制
* 避免常见的陷阱和错误
* 写出更高效的代码
* 深入理解现代框架的底层原理
  :::

## 一、基础概念：理解原型三要素

### 1.1 构造函数（Constructor）

构造函数是用来创建对象的函数，通过`new`关键字调用：

```javascript title="构造函数示例"
function Person(name) {
  this.name = name
}

const person1 = new Person('Alice')
const person2 = new Person('Bob')
```

### 1.2 原型对象（Prototype）

每个函数都有一个`prototype`属性，指向一个原型对象：

```javascript title="原型对象示例"
Person.prototype.sayHello = function () {
  console.log(`Hello, I'm ${this.name}`)
}

person1.sayHello() // "Hello, I'm Alice"
person2.sayHello() // "Hello, I'm Bob"
```

### 1.3 实例对象（Instance）

通过`new`关键字创建的对象称为实例：

```javascript
console.log(person1 instanceof Person) // true
console.log(person2 instanceof Person) // true
```

## 二、原型链的核心机制

### 2.1 `__proto__`与原型链

每个对象都有一个`__proto__`属性（在现代JavaScript中建议使用`Object.getPrototypeOf()`），指向其原型对象：

```javascript title="原型链示例"
function Animal(type) {
  this.type = type
}

Animal.prototype.speak = function () {
  console.log(`This ${this.type} makes a sound`)
}

function Dog(name) {
  Animal.call(this, 'dog')
  this.name = name
}

// 设置原型链
Dog.prototype = Object.create(Animal.prototype)
Dog.prototype.constructor = Dog

Dog.prototype.bark = function () {
  console.log(`${this.name} barks`)
}

const buddy = new Dog('Buddy')
```

:::warning 注意
虽然`__proto__`被广泛使用，但在生产环境中建议使用`Object.getPrototypeOf()`和`Object.setPrototypeOf()`来操作原型链。
:::

### 2.2 属性查找机制

当访问一个对象的属性时，JavaScript引擎会按照以下顺序查找：

:::steps

* 在对象自身属性中查找
* 如果未找到，沿着`__proto__`在原型对象中查找
* 继续沿着原型链向上查找，直到找到属性或到达`null`
* 如果最终未找到，返回`undefined`

:::

```javascript title="属性查找示例"
function hasOwnProperty(target, key) {
  return Object.prototype.hasOwnProperty.call(target, key)
}

console.log(hasOwnProperty(buddy, 'name')) // true
console.log(hasOwnProperty(buddy, 'bark')) // false
console.log(hasOwnProperty(buddy, 'speak')) // false

buddy.bark() // 在Dog.prototype中找到
buddy.speak() // 在Animal.prototype中找到
buddy.toString() // 在Object.prototype中找到
```

## 三、原型链的完整图谱

让我们通过代码来构建完整的原型链图谱：

```javascript title="完整原型链分析"
function Foo() {}

const f = new Foo()

// 原型链关系
console.log(f.__proto__ === Foo.prototype) // true
console.log(Foo.prototype.__proto__ === Object.prototype) // true
console.log(Object.prototype.__proto__ === null) // true

// 构造函数关系
console.log(Foo.__proto__ === Function.prototype) // true
console.log(Function.prototype.__proto__ === Object.prototype) // true
console.log(Function.__proto__ === Function.prototype) // true (特殊!)
```

:::info 原型链终点
所有原型链的最终终点都是`null`，这是JavaScript设计中的一个重要特性。
:::

## 四、基于原型链的继承实现

### 4.1 组合继承（最常用）

```javascript title="组合继承实现"
function Parent(name) {
  this.name = name
  this.colors = ['red', 'blue', 'green']
}

Parent.prototype.sayName = function () {
  console.log(this.name)
}

function Child(name, age) {
  Parent.call(this, name) // 继承实例属性
  this.age = age
}

// 继承原型方法
Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child

Child.prototype.sayAge = function () {
  console.log(this.age)
}

const child1 = new Child('Alice', 10)
const child2 = new Child('Bob', 20)

child1.colors.push('yellow')
console.log(child1.colors) // ['red', 'blue', 'green', 'yellow']
console.log(child2.colors) // ['red', 'blue', 'green'] (独立!)
```

### 4.2 寄生组合式继承（最佳实践）

```javascript title="寄生组合式继承"
function inheritPrototype(child, parent) {
  const prototype = Object.create(parent.prototype)
  prototype.constructor = child
  child.prototype = prototype
}

function Parent(name) {
  this.name = name
}

Parent.prototype.sayName = function () {
  console.log(this.name)
}

function Child(name, age) {
  Parent.call(this, name)
  this.age = age
}

inheritPrototype(Child, Parent)

Child.prototype.sayAge = function () {
  console.log(this.age)
}
```

## 五、ES6 Class与原型链

ES6的`class`语法是原型继承的语法糖，底层仍然基于原型链：

```javascript title="ES6 Class继承"
class Animal {
  constructor(type) {
    this.type = type
  }

  speak() {
    console.log(`This ${this.type} makes a sound`)
  }
}

class Dog extends Animal {
  constructor(name) {
    super('dog')
    this.name = name
  }

  bark() {
    console.log(`${this.name} barks`)
  }
}

const buddy = new Dog('Buddy')

// 原型链关系仍然存在
console.log(buddy instanceof Dog) // true
console.log(buddy instanceof Animal) // true
console.log(buddy instanceof Object) // true
```

:::tip 现代开发建议
在现代JavaScript开发中，推荐使用`class`语法，它更清晰、更符合直觉，同时底层仍然基于健壮的原型继承机制。
:::

## 六、实际应用场景

### 6.1 方法复用与性能优化

```javascript title="方法复用示例"
function User(name) {
  this.name = name
  this.id = Math.random()
}

// 方法定义在原型上，所有实例共享
User.prototype.getInfo = function () {
  return `User: ${this.name}, ID: ${this.id}`
}

// 对比：方法定义在构造函数内（不推荐）
function BadUser(name) {
  this.name = name
  this.id = Math.random()
  this.getInfo = function () { // 每个实例都会创建新函数
    return `User: ${this.name}, ID: ${this.id}`
  }
}
```

### 6.2 扩展内置对象

```javascript title="扩展内置对象（谨慎使用）"
// 为数组添加自定义方法
// eslint-disable-next-line no-extend-native
Array.prototype.last = function () {
  return this[this.length - 1]
}

const arr = [1, 2, 3]
console.log(arr.last()) // 3
```

:::caution 扩展内置对象
扩展内置对象的原型可能会引发兼容性问题，在生产环境中需要谨慎使用。
:::

## 七、常见陷阱与最佳实践

### 7.1 避免的原型陷阱

```javascript title="常见陷阱示例"
function MyArray() {}
MyArray.prototype = []

const arr1 = new MyArray()
arr1.push(1)
console.log(arr1.length) // 1

const arr2 = new MyArray()
console.log(arr2.length) // 1 (!) 引用类型共享问题
```

### 7.2 最佳实践总结

:::important 原型使用最佳实践

* 使用`Object.create()`而不是直接修改`__proto__`
* 在修改原型后记得修复`constructor`指向
* 优先使用ES6 `class`语法
* 避免扩展内置对象的原型
* 使用方法时注意`this`的指向
  :::

## 八、总结

通过本文的学习，我们深入理解了JavaScript原型到原型链的完整机制：

1. **原型是JavaScript实现继承的核心机制**，所有对象都通过原型链连接
2. **`prototype`是函数属性**，用于定义由该函数创建的对象所继承的属性和方法
3. **`__proto__`是对象属性**，指向该对象的原型
4. **属性查找遵循原型链**，从自身属性开始，沿着原型链向上查找
5. **现代JavaScript开发**中，`class`语法提供了更清晰的继承方式

理解原型链不仅有助于写出更好的JavaScript代码，更是深入理解现代前端框架（如React、Vue）的基础。希望本文能帮助你在JavaScript进阶之路上迈出坚实的一步！

***

## 参考

* [MDN: 继承与原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)
* [JavaScript高级程序设计（第4版）](https://book.douban.com/subject/35175321/)
* [ECMAScript规范](https://tc39.es/ecma262/)

---

---
url: /article/i0fxxwpn/index.md
---
# Web指标
## 概览

Web 指标是 Google 开创的一项新计划，旨在为网络质量信号提供统一指导，这些信号对于提供出色的网络用户体验至关重要。

多年来，Google 提供了许多性能测量和性能报告工具。一些开发者对这些工具的使用十分在行，而另一些开发者则发现大量的工具和指标令人应接不暇。

网站所有者要想了解他们提供给用户的体验质量，并非需要成为性能专家。 Web 指标计划旨在简化场景，帮助网站专注于最重要的指标，即 **核心 Web 指标** 。

## 核心 Web 指标

核心 Web 指标是适用于所有网页的 Web 指标子集，每位网站所有者都应该测量这些指标，
并且这些指标还将显示在所有 Google 工具中。每项核心 Web 指标代表用户体验的一个不同方面，
能够进行 [实际](https://web.dev/user-centric-performance-metrics/#how-metrics-are-measured) 测量，
并且反映出 [以用户为中心](https://web.dev/user-centric-performance-metrics/#how-metrics-are-measured) 的关键结果的真实体验。

核心 Web 指标的构成指标会随着时间的推移而[发展](https://web.dev/vitals/#evolving-web-vitals) 。当前针对 2020 年的指标构成侧重于用户体验的三个方面——加载性能、交互性和视觉稳定性——并包括以下指标（及各指标相应的阈值）：

* [Largest Contentful Paint (LCP)](https://web.dev/lcp/) ：最大内容绘制，测量加载性能。为了提供良好的用户体验，LCP 应在页面首次开始加载后的2.5 秒内发生。
* [First Input Delay (FID)](https://web.dev/fid/) ：首次输入延迟，测量交互性。为了提供良好的用户体验，页面的 FID 应为100 毫秒或更短。
* [Cumulative Layout Shift (CLS)](https://web.dev/cls/) ：累积布局偏移，测量视觉稳定性。为了提供良好的用户体验，页面的 CLS 应保持在 0.1. 或更少。

为了确保您能够在大部分用户的访问期间达成建议目标值，对于上述每项指标，一个良好的测量阈值为页面加载的第 75 个百分位数，且该阈值同时适用于移动和桌面设备。

如果一个页面满足上述全部三项指标建议目标值的第 75 个百分位数，那么评估核心 Web 指标合规性的工具应评判该页面为通过。

::: info
要想详细了解这些建议值背后的研究和方法论，请参阅：[定义核心 Web 指标的指标阈值](https://web.dev/defining-core-web-vitals-thresholds/)
:::

## 测量和报告核心 Web 指标的工具

Google 认为核心 Web 指标对一切网络体验都至关重要。因此，Google 致力于 [在其所有热门工具中](https://web.dev/vitals-tools/) 显示这些指标。以下部分详细介绍了支持核心 Web 指标的工具。

### 核心 Web 指标的实测工具

[Chrome 用户体验报告](https://developer.chrome.com/docs/crux/) 为每项核心 Web 指标收集匿名的真实用户测量数据。
这些数据既能使网站所有者快速进行性能评估，而无需在页面上进行手动检测分析，
也能同时为 [PageSpeed Insights 网页速度测量工具](https://pagespeed.web.dev/) 和
搜索控制台的 [核心 Web 指标报告](https://support.google.com/webmasters/answer/9205520) 等工具提供支持。

|                                                                           | LCP | FID | CLS |
| ------------------------------------------------------------------------- | --- | --- | --- |
| [Chrome 用户体验报告](https://developer.chrome.com/docs/crux/)            | ✔  | ✔  | ✔  |
| [PageSpeed Insights 网页速度测量工具](https://pagespeed.web.dev/)         | ✔  | ✔  | ✔  |
| [核心 Web 指标报告](https://support.google.com/webmasters/answer/9205520) | ✔  | ✔  | ✔  |

::: info
关于这些工具的使用方法以及适合您用例的工具选择指南，请参阅：[测量 Web 指标入门指南](https://web.dev/vitals-measurement-getting-started/)
:::

Chrome 用户体验报告提供的数据带来了一种快速评估网站性能的方法，但这些数据没有提供详细的、对应每页浏览量的遥测数据，而这些通常是对回归进行准确诊断、监控，以及做出迅速反应的必要数据。因此，我们强烈建议网站搭建自己的真实用户监控。

### 在 JavaScript 中测量核心 Web 指标

每项核心 Web 指标都可以通过使用标准网页 API 在 JavaScript 中进行测量。

测量所有核心 Web 指标，最简单的方法是使用[web-vitals](https://github.com/GoogleChrome/web-vitals)
JavaScript 库，这是一个围绕底层网页 API 的小型的、生产就绪的封装器，
通过准确匹配每项指标在上方列出的所有 Google 工具中的报告方式来进行指标测量。

通过使用 [web-vitals](https://github.com/GoogleChrome/web-vitals) 库，测量每项指标就像调用单个函数一样简单（有关完整[用法](https://github.com/GoogleChrome/web-vitals#usage)和[API](https://github.com/GoogleChrome/web-vitals#api)详情，请参阅文档）：

```js
import { onCLS, onFID, onLCP } from 'web-vitals'

function sendToAnalytics(metric) {
  const body = JSON.stringify(metric)
  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.
  ;(navigator.sendBeacon && navigator.sendBeacon('/analytics', body))
  || fetch('/analytics', { body, method: 'POST', keepalive: true })
}

onCLS(sendToAnalytics)
onFID(sendToAnalytics)
onLCP(sendToAnalytics)
```

当您将网站配置为使用 [web-vitals](https://github.com/GoogleChrome/web-vitals) 库来测量您的核心 Web 指标数据并将其发送到分析端后，下一步是对数据进行汇总和报告，从而查看您的页面是否在至少 75% 的页面访问中都满足建议阈值。

一些分析工具供应商已经内置了核心 Web 指标支持，但即使是那些没有内置支持的供应商也应该包含基本的自定义指标功能，让您能够使用他们的工具来测量核心 Web 指标。

[Web 指标报告](https://github.com/GoogleChromeLabs/web-vitals-report) 就是其中一个例子，
它使网站所有者能够使用 Google 分析来测量他们的核心 Web 指标。
了解使用其他分析工具测量核心 Web 指标的相关指南，请参阅 [实测 Web 指标的最佳实践](https://web.dev/vitals-field-measurement-best-practices/)。

您还可以使用 [Web 指标 Chrome 扩展程序](https://github.com/GoogleChrome/web-vitals-extension)
来报告每项核心 Web 指标，且无需编写任何代码。
该扩展程序使用 [web-vitals](https://github.com/GoogleChrome/web-vitals) 库来测量每一项指标，并在用户浏览网页时呈现给用户。

此扩展程序有助于您了解自己的网站、竞争对手的网站和整个网络的性能。

|                                                                                  | LCP | FID | CLS |
| -------------------------------------------------------------------------------- | --- | --- | --- |
| [Web 指标报告](https://github.com/GoogleChromeLabs/web-vitals-report)            | ✔  | ✔  | ✔  |
| [Web 指标 Chrome 扩展程序](https://github.com/GoogleChrome/web-vitals-extension) | ✔  | ✔  | ✔  |

此外，倾向于直接通过底层网页 API 来测量这些指标的开发者可以参考这些指标指南，从而了解执行详情：

* [在 JavaScript 中测量 LCP](https://web.dev/lcp/#measure-lcp-in-javascript)
* [在 JavaScript 中测量 FID](https://web.dev/fid/#measure-fid-in-javascript)
* [在 JavaScript 中测量 CLS](https://web.dev/fid/#measure-fid-in-javascript)

::: info
关于如何使用热门分析服务（或您自己的内部分析工具）来测量这些指标的更多指导，请参阅：[实测 Web 指标的最佳实践](https://web.dev/vitals-field-measurement-best-practices/)
:::

### 核心 Web 指标的实验室测量工具

虽然所有的核心 Web 指标首先都是实测指标，但其中的许多指标也可以在实验室中进行测量。

实验室测量是在开发过程中（功能发布给用户之前）测试功能性能的最佳方式，也是在性能回归发生之前及时捕获的最佳方式。

以下工具可用于在实验室环境中测量核心 Web 指标：

|                                                                  | LCP | FID                                        | CLS |
| ---------------------------------------------------------------- | --- | ------------------------------------------ | --- |
| [Chrome 开发者工具](https://developer.chrome.com/docs/devtools/) | ✔  | ✘（使用 [TBT](https://web.dev/tbt/) 代替） | ✔  |
| [灯塔](https://developer.chrome.com/docs/lighthouse/overview/)   | ✔  | ✘（使用 [TBT](https://web.dev/tbt/) 代替） | ✔  |

::: info
灯塔这类在没有用户的模拟环境中加载页面的工具无法测量 FID（没有用户输入）。但是，Total Blocking Time 总阻塞时间 (TBT) 指标不仅可以进行实验室测量，而且还是 FID 的出色代理。在实验室中改进 TBT 的性能优化应该能够改进实际的 FID（请参阅下方的性能建议）。
:::

虽然实验室测量对于提供出色的体验至关重要，但它不能替代实际测量。

根据用户设备功能、网络状况、设备上可能正在运行的其他进程以及与页面交互方式的差别，网站性能也可能会有很大差异。事实上，每项核心 Web 指标的得分都会受到用户交互的影响。只有通过实际测量才能准确获取全貌。

### 提高分数的建议

当您测量了核心 Web 指标并确定了需要改进的领域后，下一步就是优化。以下指南提供了如何针对每项核心 Web 指标优化页面的具体建议：

* [优化 LCP](https://web.dev/optimize-lcp/)
* [优化 FID](https://web.dev/optimize-fid/)
* [优化 CLS](https://web.dev/optimize-cls/)

## 其他 Web 指标

虽然核心 Web 指标是理解并提供出色用户体验的关键指标，但还有其他的一些重要指标。

其他 Web 指标通常用作核心 Web 指标的代理或补充指标，有助于获取范围更广的体验或帮助诊断特定的问题。

例如，[Time to First Byte 首字节时间 (TTFB)](https://web.dev/ttfb/)
和 [First Contentful Paint 首次内容绘制 (FCP)](https://web.dev/fcp/)指标都是加载体验的重要方面，
并且在诊断 LCP 问题方面（分别为[服务器响应时间](https://web.dev/overloaded-server/)
过长或[阻塞渲染资源](https://developer.chrome.com/docs/lighthouse/performance/render-blocking-resources/)）都十分有用。

同样，[总阻塞时间 (TBT)](https://web.dev/tbt/) 和
[Time to Interactive 可交互时间 (TTI)](https://web.dev/tti/)等指标是实验室指标，
对于捕获和诊断会对 FID 产生影响的潜在交互性问题至关重要。
然而，这些指标不是核心 Web 指标的一部分，因为它们无法进行实际测量，
也不反映以[用户为中心](https://web.dev/user-centric-performance-metrics/#how-metrics-are-measured)的结果。

## 不断发展的 Web 指标

Web 指标和核心 Web 指标代表了当今开发者用来测量网络体验质量的最佳可用信号，但这些信号并不完美，并且会在未来不断进行改进或补充。

**核心 Web 指标**与所有网页都息息相关，并且已经显示在相关的 Google 工具中。这些指标的变化将产生广泛的影响，因此，开发者应当认为核心 Web 指标的定义和阈值是稳定的，并且会以可预测的、每年一次的更新节奏提前发布更新通知。

其他 Web 指标通常适用于特定情景或工具，并且可能比核心 Web 指标更具实验性。因此，这些指标的定义和阈值可能会有更频繁的更改。

针对所有 Web 指标的更改都将清楚地记录在这份公开的[更新日志](http://bit.ly/chrome-speed-metrics-changelog)中。

---

---
url: /article/i0tp9eou/index.md
---
# JavaScript 进阶 十三：函数式编程
为什么 React 选择逐步告别 Class 组件，拥抱函数组件？为什么 Redux 的 Reducer 必须是纯函数？函数式思想正在以前所未有的速度渗透前端生态。本文将带你深入理解函数式编程的核心思想与实践方法。

## 什么是函数式编程？

函数式编程（Functional Programming，简称 FP）是一种编程范式，它将计算机运算视为数学函数的计算，并且避免使用程序状态以及易变对象。与命令式编程关注"如何做"不同，函数式编程更关注"做什么"。

:::tip 核心特征

* **一等公民的函数**：函数可以作为参数传递、可以作为返回值、可以赋值给变量
* **纯函数**：相同的输入永远得到相同的输出，没有副作用
* **不可变性**：数据一旦创建就不能被修改
* **声明式编程**：描述要做什么，而不是如何做
  :::

## 纯函数：函数式编程的基石

### 纯函数的定义

```javascript title="纯函数示例"
// 纯函数 - 相同的输入永远得到相同的输出
const add = (a, b) => a + b
const multiply = (x, y) => x * y

// 非纯函数 - 依赖外部状态，结果不确定
let counter = 0
function impureAdd(a, b) {
  counter++ // 副作用
  return a + b
}

// 非纯函数 - 修改了输入参数
function impureUpdateUser(user, newName) {
  user.name = newName // 副作用
  return user
}
```

### 纯函数的优势

:::steps

* **可预测性**：相同的输入永远得到相同的输出，便于测试和调试
* **可缓存性**：可以轻松实现记忆化（memoization）
* **并行安全**：没有共享状态，天然适合并发编程
* **组合性**：纯函数可以轻松组合成更复杂的函数

:::

## 高阶函数：函数的函数

高阶函数是指接收函数作为参数或返回函数作为结果的函数。

```javascript title="高阶函数实践"
// 接收函数作为参数
const calculate = (operation, a, b) => operation(a, b)
const result = calculate((x, y) => x * y, 5, 3) // 15

// 返回函数作为结果
const createMultiplier = factor => number => number * factor
const double = createMultiplier(2)
const triple = createMultiplier(3)

console.log(double(5)) // 10
console.log(triple(5)) // 15

// 数组的高阶函数方法
const numbers = [1, 2, 3, 4, 5]

// map - 转换每个元素
const doubled = numbers.map(x => x * 2)

// filter - 过滤元素
const evens = numbers.filter(x => x % 2 === 0)

// reduce - 累积计算
const sum = numbers.reduce((acc, curr) => acc + curr, 0)
```

## 柯里化与函数组合

### 柯里化（Currying）

柯里化是将多参数函数转换为一系列单参数函数的技术。

```javascript title="柯里化实现与应用"
// 手动柯里化
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args)
    }
    else {
      return function (...args2) {
        return curried.apply(this, args.concat(args2))
      }
    }
  }
}

// 使用柯里化
const addThree = (a, b, c) => a + b + c
const curriedAdd = curry(addThree)

console.log(curriedAdd(1)(2)(3)) // 6
console.log(curriedAdd(1, 2)(3)) // 6

// 实际应用：创建特定功能的函数
function createLogger(level) {
  return message =>
    console.log(`[${level.toUpperCase()}] ${message}`)
}

const infoLog = createLogger('info')
const errorLog = createLogger('error')

infoLog('Application started') // [INFO] Application started
errorLog('Something went wrong') // [ERROR] Something went wrong
```

### 函数组合（Compose）

函数组合是将多个函数组合成一个新函数的过程。

```javascript title="函数组合实践"
// 简单的 compose 函数
function compose(...fns) {
  return x =>
    fns.reduceRight((acc, fn) => fn(acc), x)
}

// 实用的工具函数
const toUpperCase = str => str.toUpperCase()
const exclaim = str => `${str}!`
const repeat = str => `${str} ${str}`

// 组合使用
const shout = compose(exclaim, toUpperCase)
const dramaticShout = compose(repeat, exclaim, toUpperCase)

console.log(shout('hello')) // HELLO!
console.log(dramaticShout('hello')) // HELLO! HELLO!

// 数据处理管道
const users = [
  { name: 'Alice', age: 25, active: true },
  { name: 'Bob', age: 30, active: false },
  { name: 'Charlie', age: 35, active: true }
]

const processUsers = compose(
  users => users.map(user => user.name),
  users => users.filter(user => user.active),
  users => users.filter(user => user.age > 25)
)

console.log(processUsers(users)) // ['Charlie']
```

## 不可变数据与持久化数据结构

### 不可变性的重要性

:::warning 为什么需要不可变性？
在 JavaScript 中，对象和数组是引用类型，直接修改会导致意外的副作用和难以追踪的 bug。
:::

```javascript title="不可变数据操作"
// 错误的做法 - 直接修改
const user = { name: 'Alice', age: 25 }
user.age = 26 // 直接修改，可能产生副作用

// 正确的做法 - 创建新对象
const updatedUser = { ...user, age: 26 }

// 深层嵌套对象的不可变更新
const state = {
  user: {
    profile: {
      name: 'Alice',
      preferences: {
        theme: 'dark',
        language: 'en'
      }
    }
  }
}

// 使用展开运算符进行深层更新
const newState = {
  ...state,
  user: {
    ...state.user,
    profile: {
      ...state.user.profile,
      preferences: {
        ...state.user.profile.preferences,
        theme: 'light'
      }
    }
  }
}

// 使用库简化不可变操作（如 Immer）
// import { produce } from 'immer';
// const newState = produce(state, draft => {
//   draft.user.profile.preferences.theme = 'light';
// });
```

## 函子（Functor）与单子（Monad）

### 函子：带 map 方法的容器

```javascript title="函子实现"
// 简单的 Box 函子
class Box {
  constructor(value) {
    this.value = value
  }

  map(fn) {
    return new Box(fn(this.value))
  }

  fold(fn) {
    return fn(this.value)
  }
}

// 使用示例
const result = new Box(5)
  .map(x => x * 2)
  .map(x => x + 1)
  .fold(x => x)

console.log(result) // 11
```

### Maybe 单子：优雅处理空值

```javascript title="Maybe 单子"
class Maybe {
  constructor(value) {
    this.value = value
  }

  static of(value) {
    return new Maybe(value)
  }

  isNothing() {
    return this.value === null || this.value === undefined
  }

  map(fn) {
    return this.isNothing()
      ? Maybe.of(null)
      : Maybe.of(fn(this.value))
  }

  chain(fn) {
    return this.map(fn).fold()
  }

  fold() {
    return this.value
  }
}

// 使用示例
const getUser = id => Maybe.of(users.find(user => user.id === id))
const getEmail = user => Maybe.of(user.email)
const formatEmail = email => email.toUpperCase()

const email = getUser(1)
  .chain(getEmail)
  .chain(formatEmail)
  .fold()

console.log(email) // 安全地处理可能的空值
```

## 实际应用场景

### React 中的函数式编程

```javascript title="React 函数组件与 Hooks"
import React, { useCallback, useMemo, useState } from 'react'

// 纯函数组件
function UserList({ users, onUserClick }) {
  // 使用 useMemo 记忆化计算
  const activeUsers = useMemo(
    () => users.filter(user => user.active),
    [users]
  )

  // 使用 useCallback 记忆化函数
  const handleClick = useCallback(
    (userId) => {
      onUserClick(userId)
    },
    [onUserClick]
  )

  return (
    <div>
      {activeUsers.map(user => (
        <div key={user.id} onClick={() => handleClick(user.id)}>
          {user.name}
        </div>
      ))}
    </div>
  )
}

// 自定义 Hook - 函数组合的体现
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    }
    catch (error) {
      return initialValue
    }
  })

  const setValue = useCallback((value) => {
    setStoredValue(value)
    window.localStorage.setItem(key, JSON.stringify(value))
  }, [key])

  return [storedValue, setValue]
}
```

### Redux 中的纯函数

```javascript title="Redux Reducer"
// 纯函数 reducer
const initialState = {
  users: [],
  loading: false,
  error: null
}

function userReducer(state = initialState, action) {
  switch (action.type) {
    case 'FETCH_USERS_START':
      return {
        ...state,
        loading: true,
        error: null
      }

    case 'FETCH_USERS_SUCCESS':
      return {
        ...state,
        loading: false,
        users: action.payload
      }

    case 'FETCH_USERS_FAILURE':
      return {
        ...state,
        loading: false,
        error: action.payload
      }

    default:
      return state
  }
}

// Action creators - 纯函数
const fetchUsersStart = () => ({ type: 'FETCH_USERS_START' })
function fetchUsersSuccess(users) {
  return {
    type: 'FETCH_USERS_SUCCESS',
    payload: users
  }
}
```

## 性能优化技巧

### 记忆化（Memoization）

```javascript title="记忆化实现"
// 简单的记忆化函数
function memoize(fn) {
  const cache = new Map()
  return (...args) => {
    const key = JSON.stringify(args)
    if (cache.has(key)) {
      return cache.get(key)
    }
    const result = fn(...args)
    cache.set(key, result)
    return result
  }
}

// 使用示例
const expensiveCalculation = memoize((a, b) => {
  console.log('Calculating...')
  return a * b + Math.sqrt(a) + Math.sqrt(b)
})

console.log(expensiveCalculation(4, 9)) // Calculating... 然后输出结果
console.log(expensiveCalculation(4, 9)) // 直接从缓存输出结果
```

### 惰性求值

```javascript title="惰性求值模式"
// 惰性序列
class LazySequence {
  constructor(generator) {
    this.generator = generator
    this.cache = []
  }

  take(n) {
    while (this.cache.length < n) {
      const next = this.generator.next()
      if (next.done)
        break
      this.cache.push(next.value)
    }
    return this.cache.slice(0, n)
  }

  map(fn) {
    const originalGenerator = this.generator
    return new LazySequence(function* () {
      for (const value of originalGenerator) {
        yield fn(value)
      }
    }())
  }
}
```

## 最佳实践与常见陷阱

:::important 函数式编程最佳实践

* **优先使用纯函数**：尽量减少副作用
* **拥抱不可变性**：使用展开运算符或不可变库
* **善用高阶函数**：map、filter、reduce 是你的好朋友
* **合理使用柯里化**：但不要过度使用
* **保持函数简洁**：单一职责原则
  :::

:::caution 常见陷阱

* **过度抽象**：不要为了函数式而函数式
* **性能问题**：大量创建新对象可能影响性能
* **学习曲线**：一些概念（如 Monad）需要时间理解
* **团队协作**：确保团队成员都能理解函数式代码
  :::

## 总结

函数式编程不是银弹，但它提供了一种强大而优雅的解决问题的方式。通过拥抱纯函数、不可变数据和高阶函数，我们可以编写出更可预测、更易测试、更易维护的代码。

## 参考

* [《JavaScript 函数式编程指南》](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/)
* [《Eloquent JavaScript》函数式编程章节](https://eloquent.javascript.ac.cn/)
* [Ramda.js](https://ramdajs.com/) - 实用的函数式编程库
* [Immer](https://immerjs.github.io/immer/) - 不可变状态管理

---

---
url: /article/i1wc1uld/index.md
---
::: center
![lerna](https://user-images.githubusercontent.com/645641/79596653-38f81200-80e1-11ea-98cd-1c6a3bb5de51.png){ style="width: 50%" }
:::

## 概述

`lerna` 是一个多包管理工具，针对使用 git 和 npm/yarn 等管理多软件包的代码仓库的工作流程进行优化。

在开发一个大型项目时，往往会将整个项目拆分为多个代码仓库，进行独立版本化的软件包管理，这对于代码共享非常有用。

比如开源项目 `babel`，整个项目被拆分为了`@babel/core`, `@babel/parser`, `@babel/traverse`等多个软件包。

但是这也会导致如果某些更改跨越了多个代码仓库的话，会变得麻烦且难以跟踪。
`lerna`可以帮助优化对多个代码仓库的依赖、版本管理、工作流等。

## 安装

lerna 可以全局安装，也可以在项目中安装（以下内容使用项目中安装的方式）

```sh
# npm
npm install lerna
# yarn
yarn add lerna
```

## 简单入门

创建一个项目，并使用lerna进行项目环境初始化

```sh
mkdir lerna-demo && cd $_
yarn init -y
yarn add lerna
npx lerna init
```

你将会得到一个包含以下内容的项目文件夹：

```sh
lerna-demo
  packages/
  lerna.json
  package.json
```

其中，`packages/` 目录用于存放所有的软件包。`lerna.json`是lerna的配置文件。

## 配置说明

```json
// lerna.json
{
  "useWorkspaces": true,
  "npmClient": "npm", // npm | yarn
  "packages": ["packages/*"],
  "version": "0.0.0",
  "command": {
    "bootstrap": {
      // more...
    }
    // more
  }
}
```

* `npmClient`：设置当前使用的包管理器， 默认是npm， 可以设置为yarn；
* `version`：软件包版本号，根据 semver版本号规范命名；
* `packages`：软件包所在的目录，可以使用golb做模式匹配；
* `useWorkspaces`：使用工作空间，这个选项可以更好的跟yarn配合使用；
* `command`：对lerna的各个command进行配置。

## 命令行说明

### lerna init

初始化一个lerna项目，默认将会在目录中新建 packages/ 和 lerna.json。

`--independent`: 使用分包独立版本管理模式，各个软件包使用独立的版本号。

### lerna create pkgName \[location]

在项目中新建一个子包， pkgName设置包名。 location制定包所在目录，默认是 packages配置的第一个元素。

### lerna add \<package>\[@version] \[--dev] \[--exact] \[--peer]

类似于 `yarn add` 或`npm install`，在一个lerna repo中往dependency中添加依赖包。

* `--dev`: 表示将包添加到 devDependencies
* `--exact`: 添加一个确定版本的包（如1.0.1），而不是一个版本范围的包如（^1.0.1）
* `--peer`: 添加一个前置依赖包。

### lerna bootstrap

为当前 lerna repo 中的所有包安装 依赖库，并 link所有 同域依赖。

### lerna run \<script>

在当前 lerna repo 中的所有包中执行 script 命令。

```sh
packages/
  package1/
  package2/
```

```sh
lerna run build # 相当于在 package1、package2 中执行 npm run build
```

* \--scope 过滤符合条件的包

  ```sh
  lerna run build --scope test component
  ```

* \--stream 使用报名作为前缀，交叉输出所有包的控制台信息流。

  ```sh
  lerna run build --stream
  ```

* \--parallel 类似于 stream。

  ```sh
  lerna run build --parallel
  ```

### lerna clean

删除所有包的node\_modules

---

---
url: /article/i7qzj0bt/index.md
---
# CSS 中的计数器
> 让网页元素自动编号，告别手动维护的烦恼！

你是否曾经遇到过这样的场景：需要为页面上的多个元素添加连续的编号，比如商品列表、步骤说明、或者法律条款？传统做法可能是手动输入数字，但这样既繁琐又容易出错。今天，就让我们一起来探索 CSS 计数器的神奇世界！

## 什么是 CSS 计数器？

CSS 计数器本质上是一种 **由 CSS 维护的变量**，它可以自动递增，让我们能够实现各种复杂的编号效果。想象一下，你有一个魔法笔记本，每当你写下新的条目时，页码会自动更新——CSS 计数器就是这样的存在。

## 基础用法：从零开始

让我们通过一个简单的例子来理解计数器的工作原理：

:::: demo normal expanded
::: code-tabs

@tab HTML

```html
<div class="container">
  <p>CSS 入门</p>
  <p>选择器详解</p>
  <p>布局技巧</p>
</div>
```

@tab:active CSS

```css
.container {
  counter-reset: chapter;  /* 初始化计数器 */
}

.container p::before {
  counter-increment: chapter;  /* 递增计数器 */
  content: "第" counter(chapter) "章：";  /* 显示计数器值 */
}
```

:::
::::

### 核心概念解析

让我们拆解一下这个例子中的三个关键属性：

#### 1. `counter-reset` - 计数器初始化

```css
counter-reset: chapter;
```

这行代码创建了一个名为 `chapter` 的计数器，并将其初始值设为 0。你可以把它想象成给计数器"上发条"。

:::info
`counter-reset` 的默认初始值是 0，你也可以显式指定：

```css
counter-reset: chapter 5; /* 从第5章开始 */
```

:::

#### 2. `counter-increment` - 计数器递增

```css
counter-increment: chapter;
```

每次遇到 `h3` 元素时，`chapter` 计数器的值就会增加 1。这是计数器的"心跳"。

#### 3. `counter()` / `counters()` - 显示计数器值

```css
content: "第" counter(chapter) "章：";
```

`counter()` 函数用于在 `content` 属性中显示当前的计数器值。

## 进阶技巧：多级嵌套计数器

现实中的文档往往需要多级编号，比如：

```
1. 前端技术
  1.1 HTML
  1.2 CSS
    1.2.1 选择器
    1.2.2 布局
  1.3 JavaScript
2. 后端技术
```

使用嵌套计数器可以轻松实现：

:::: demo normal expanded title="多级嵌套示例"

::: code-tabs

@tab HTML

```html
<div class="outline">
  <div class="section">
    <h4>前端技术</h4>
    <div class="subsection">
      <h5>HTML</h5>
    </div>
    <div class="subsection">
      <h5>CSS</h5>
      <div class="subsubsection">
        <h6>选择器</h6>
      </div>
      <div class="subsubsection">
        <h6>布局</h6>
      </div>
    </div>
    <div class="subsection">
      <h5>JavaScript</h5>
    </div>
  </div>
  <div class="section">
    <h4>后端技术</h4>
  </div>
</div>
```

@tab:active CSS

```css
.outline {
  counter-reset: section;
}

.section,.subsection, .subsubsection {
  padding-left: 1em;
}

.section h4::before {
  counter-increment: section;
  content: counter(section) ". ";
  counter-reset: subsection; /* 重置下级计数器 */
}

.subsection h5::before {
  counter-increment: subsection;
  content: counter(section) "." counter(subsection) " ";
  counter-reset: subsubsection;
}

.subsubsection h6::before {
  counter-increment: subsubsection;
  content: counter(section) "." counter(subsection) "." counter(subsubsection) " ";
}
```

:::
::::

:::warning 注意层次关系
嵌套计数器的关键在于：**在父级元素中重置子级计数器**。这样每当开始新的父级章节时，子级编号都会重新开始。
:::

## 实用场景示例

### 1. 步骤说明列表

```css title="步骤计数器"
.steps {
  counter-reset: step;
  list-style: none;
  padding: 0;
}

.steps li::before {
  counter-increment: step;
  content: "步骤" counter(step) ": ";
  background: #4CAF50;
  color: white;
  border-radius: 50%;
  width: 30px;
  height: 30px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  margin-right: 10px;
}
```

### 2. 自定义列表样式

```css title="个性化列表编号"
.custom-list {
  counter-reset: custom;
}

.custom-list li {
  margin-bottom: 10px;
}

.custom-list li::before {
  counter-increment: custom;
  content: "[" counter(custom, lower-roman) "] ";
  font-weight: bold;
  color: #ff6b6b;
}
```

:::tip 数字格式选项
`counter()` 函数的第二个参数可以指定数字格式：

* `decimal` - 十进制数字（默认）
* `lower-roman` - 小写罗马数字
* `upper-roman` - 大写罗马数字
* `lower-alpha` - 小写字母
* `upper-alpha` - 大写字母
* 等等...
  :::

## 常见问题与解决方案

### 问题1：计数器不工作？

:::steps

* **检查计数器作用域**：确保 `counter-reset` 在正确的父元素上声明
* **验证选择器**：确认 `counter-increment` 和 `content` 的选择器能够匹配到目标元素
* **查看继承关系**：计数器值不会自动继承，需要在每个层级单独管理

:::

### 问题2：编号顺序错误？

\==记住这个顺序很重要=={.important}：**重置 → 递增 → 显示**。确保你的 CSS 规则按这个逻辑顺序应用。

## 浏览器兼容性

好消息！CSS 计数器在现代浏览器中得到了很好的支持：

@[caniuse](css-counters)

:::info
即使在不支持计数器的老旧浏览器中，你的内容仍然可以正常显示，只是缺少了自动编号——这就是渐进增强的魅力！
:::

## 总结

CSS 计数器是一个强大而实用的工具，它让我们能够：

* ✅ **自动管理编号**，减少手动维护
* ✅ **实现复杂嵌套**，支持多级目录结构
* ✅ **自定义显示格式**，满足不同设计需求
* ✅ **保持语义化**，不污染 HTML 结构

下次当你需要为元素添加序号时，不妨试试 CSS 计数器。它可能不会让你的网站变得"高大上"，但绝对能让你的开发工作变得更加优雅和高效！

## 延伸学习

想要深入了解？推荐阅读：

* [MDN Web Docs: Using CSS Counters](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Counter_Styles/Using_CSS_counters)
* [CSS Tricks: Automatic Numbering with CSS Counters](https://css-tricks.com/numbering-in-style/)

希望这篇文章能帮助你掌握 CSS 计数器的使用技巧！如果有任何问题，欢迎在评论区讨论～

---

---
url: /article/iezlvhvg/index.md
---
# Vue组件间通信
在我们在进行基于[Vue](https://cn.vuejs.org/)的项目开发时，组件间的数据通信，是我们必须考虑的。

> **注：**
>
> 本文所实现的方式，是在不考虑`vuex`下所做的实现，
> 且仅限于 `vue@2` ，在 `vue@3` 中，有其他的更好的实现方案。

我把组件间的关系，大致分为三种：

1. 父子组件

   ```html
   <parent>
     <child></child>
   </parent>
   ```

   拥有类似结构，`parent`组件包含`child`组件，则`child`组件是`parent`的子组件，`parent`组件是`child`组件的父组件。

2. 兄弟组件

   ```html
   <item></item> <item></item>
   ```

   两个`item`组件在结构上同级，我们称之互为兄弟组件。

3. 跨多级组件

   ```html
   <list>
       <item>
           <message><message>
       </item>
   </list>
   <dialog>
       <content></content>
   </dialog>
   ```

   在这个结构中，`<list>`和`<message>`并不是直接的父子组件，中间还跨了一个级，在实际场景中，还会有跨更多层级的组件关系。`<message>` 和 `<content>` 组件两个既不是兄弟组件，又不是父子组件，而是跨了兄弟，父子的多级关系，实际场景中也会有发生交互。

那么这三种关系的组件，我们应该如何进行组件通信？

### 父子组件通信

要讲父子组件的通信，首先，我们需要了解 `vue` 组件的 特性。

1. 单向数据流，数据自上而下。

   > Prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为
   > 了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。

2. 事件自下而上。

   组件内部状态的变化，通过事件往上冒泡，通知上一级组件，由上一级组件监听事件，并触发相应回调。

基于以上，父子组件通信推荐的方式是：

父组件通过`props`将状态传到子组件，子组件通过事件将状态冒泡到父组件，由父组件监听触发回调改变状态。

`parent.vue`

```html
<template>
  <div class="parent">
    <child :name="name" @name-change="nameChange"> </child>
  </div>
</template>
<script>
  import Child from './child';
  export default {
      name: 'parent',
      data () {
          return {
              name: 'Jack'
          };
      }
      methods: {
          nameChange(name) {
              this.name = name;
          }
      },
      components: {
          Child
      }
  }
</script>
```

`child.vue`

```html
<template>
  <div class="child">
    <span>{{name}}</span>
    <button @click="onClick">change name</button>
  </div>
</template>
<script>
  export default {
    name: 'child',
    props: {
      name: {
        type: String,
        defualt() {
          return ''
        },
      },
    },
    methods: {
      onClick() {
        this.$emit('name-change', 'John')
      },
    },
  }
</script>
```

在某些例子或个人项目中，经常有发现到在子组件中使用 `this.$parent` 直接改变父组件的状态，诚然这种方式能够简化两个深耦合的组件的数据通信，在一些简单的场景中也会比较方便，但其实并不推荐采用这种方式实现父子组件通信，这样做的后果就是导致了数据流的不明确性，牺牲了单项数据流的简洁性，数据的变化流动变得不易于理解。

### 兄弟组件通信、跨多级组件通信

这两种组件关系，并没有直接的联系。

如兄弟组件，我们会很自然的想到使用他们的父级组件作为中转，将 `子组件1` 的状态通信到父组件，再由父组件通过 `props` 流向 `子组件2` ，反之亦然，但是如果兄弟组件间的交互复杂，但又与父组件没有存在直接的交互关联，父组件在这个过程当中，承担了多余的职责。

又如跨多级组件，上述例子中，`<list>`和`<message>`之间间隔了多层，如果我们继续使用父子组件通信`prop`和事件冒泡，中间的层需要重复的定义`prop`和事件，这显然也导致了它们承担了多余的职责。 `<message>` 和 `<content>` 组件之间，更是在结构上没有关联，`prop`和事件冒泡显得十分乏力，无法直接完成通信。

那么这两种组件关系，该如何完成通信，又不对它们中间层级组件，或者父级组件造成多余的干扰？

由于两种组件关系没有直接的关联，所以我们需要有一个桥梁，能够直接连接它们，使它们变得有关联。即，我们需要一个`中间件`。

官方给我们的解决方案是`vuex`，但我认为它更多是的作为全局状态的管理，使用它作为某两个组件的通信中间件，显得大材小用，所以我这里不做讨论。

我所采取的方案是使用 自定义事件 完成组件通信。

**实例化Vue：**

`vue`已实现了一套事件系统，可以很方便的使用它来完成我们的组件通信。

```javascript
const middleware = new Vue()
export default middleware
```

`message.vue`

```javascript
export default {
  name: 'message',
  data() {
    return {
      info: 'hello',
    }
  },
  methods: {
    sayHello() {
      middleware.$emit('say-hello', this.info)
    },
  },
}
```

`content.vue`

```javascript
export default {
  name: 'content',
  data() {
    return {
      info: ''
    }
  },
  created() {
    middleware.$on('say-hello', (info) => {
      this.info = info
    })
  }
}
```

我们通过 `middleware`， 在`content.vue`注册了`say-hello`事件，当`message.vue`触发该事件时，`content.vue`监听到事件触发回调，从而实现了状态传导。

组件数据传导不再是通过`props`传导，而是通过事件进行通信。

**如果不使用实例化Vue的方式去完成，我们也可以自己实现一套自定义事件。** 这可以做更加个性化的自定义事件，满足项目中的多样的使用场景。

```javascript
class Event {
  constructor(options) {
    // some props
    this.options = options
  }

  on() {
    // do something
  }

  emit() {
    // do something
  }

  off() {
    // do somethig
  }
}
```

### 总结

复杂结构的组件通信，实现它们的通信，关键是实现中间件作为桥梁连接它们，无论是使用自定义事件，还是其他的方案。

---

---
url: /article/javascript-modules/index.md
---
# javascript模块化 发展历程
javascript模块化的发展，距今已有10个年头左右。

## 无模块化

在早期，javascript作为一门脚本语言，仅为协助表单校验等界面辅助增强，那时候的前端也比较简单， javascript不需要模块化。

## 命名空间

后来随着 javascript 需要承担更多的功能，代码量开始上升，为了避免全局命名冲突等问题，提出了使用命名空间的方案，将符合某种规则或者约定的代码，放到同一个命名空间下。 这算是 javascript模块化最早期的雏形。

```js
YAHOO.util.Event.stopPropagation(e)
```

## 基本的模块化

在这个时期，出现了比较清晰的模块定义，通过闭包来做模块运行空间

```js
// 定义模块
YUI.add('hello', (Y) => {
  Y.sayHello = function () {
    Y.DOM.set(el, 'innerHTML', 'hello!')
  }
}, '1.0.0', { requires: ['dom'] })

// ...
// 使用模块
YUI().use('hello', (Y) => {
  Y.sayHello('entry') // <div id="entry">hello!</div>
})
```

## CommonJs

CommonJs 其实是一个项目，其目标是为 JavaScript 在网页浏览器之外创建模块约定， 在当年 javascript 的模块化思想还在官方的讨论中， 缺乏普遍可接受形式的javascript脚本模块单元。

CommonJs规范和当时出现的NodeJs相得益彰，共同走入了开发者的实现。

但 CommonJs 其实是面向网页浏览器之外的（如NodeJs，即面向服务端的模块化规范），并不适用于浏览器端。

### CommonJs 规范简介

在CommonJs 规范中， 每个文件都是一个模块，有自己的作用域，在文件中定义的变量、函数、类等，都是私有的，对其他文件不可见。

在每个模块中，有两个内部变量可以使用， `require` 和 `module`

* `require` 用于加载某个模块。
* `module` 表示当前模块，是一个对象。这个对象中保存了当前模块的信息。`exports` 是 `module` 上的一个属性，保存了当前模块要导出的接口或者变量，使用 `require` 加载的某个模块获取到的值就是那个模块使用 `exports` 导出的值。

::: code-tabs

@tab a.js

```js
let name = 'Mark'
let age = 18

module.exports.name = name
module.exports.getAge = function () {
  return age
}
```

@tab:active b.js

```js
let moduleA = require('./a.js')
console.log(moduleA.a) // Mark
// 使用了未导出的变量，获取不到值
console.log(moduleA.age) // undefined
console.log(moduleA.getAge()) // 18
```

:::

在NodeJs环境中，CommonJs的模块由于在服务器环境下，可以从本地进行加载，即 同步加载。

## AMD、CMD

::: note 注释
在我的印象中， CommonJs规范 和 AMD规范 出现的时间点 相差不远。

*AMD 早于 CommonJs。*

按我个人理解，CMD 在当年算是从 AMD 衍生出来的一个方案。
:::
::: warning 注意
CommonJs 和 CMD 是两种方案！不是一样的！
:::

### AMD规范

AMD规范，即 异步模块定义([Asynchronous Module Definition](https://github.com/amdjs/amdjs-api/wiki/AMD))。

AMD 采用 **异步加载模块** 的方式。

AMD规范仅定义了一个 `define` 函数，它是一个全局变量：

```
define(id?, dependencies?, factory);
```

* `id` 描述的是当前模块的标识符;
* `dependencies` 则是当前模块的依赖数组， 它们会在 factory工厂方法被调用前被加载并执行，
  并且执行的结果必须以依赖数组定义的顺序，依此顺序作为参数传入 factory工厂方法。
* `factory`为模块初始化要执行的函数或者对象。如果函数返回一个值，则该值应该设置为该模块的输出值。

### CMD规范

CMD规范，即 公共模块定义([Common Module Definition](https://github.com/cmdjs/specification/blob/master/draft/module.md))

CMD规范 定义了 一个 `define` 函数，它是一个全局变量：

```
define(id?, dependencies?, factory);
```

* `id` 描述的是当前模块的标识符;
* `dependencies` 是当前模块的依赖数组， 他们会在 factory 工厂方法被调用前完成加载，但并不立即执行。
* `factory`为模块初始化要执行的函数或者对象。

  * 如果是一个函数，则函数接受三个参数：

    ```js
    define((require, exports, module) => {

    })
    ```

    `require` 用于同步加载并执行已经定义好的其他模块；获取模块的输出值，
    `exports`是`module.exports`的别名，用于导出当前模块的输出值；`module`存储了当前模块的信息。

  * 如果是一个对象，则直接作为当前模块的输出值。

::: tip 两者的差异

AMD规范 和 CMD规范 从规范定义上来看，主要的差异为：

* AMD 的模块在加载后是立即执行的，并且会按照依赖顺序依次传入 factory，
  而 CMD的模块在加载后并不立即执行，而是在 factory方法中，通过 `require` 方法调用执行模块获取结果；

:::

### 规范的实现

* AMD流行的实现库是 [require.js](https://github.com/requirejs/requirejs);
* CMD流行的实现库是 [sea.js](https://github.com/seajs/seajs);

::: warning 提示
由于在当下已经越来越少会去选择使用 `require.js` 以及 `sea.js`， 这里就不多对这两个库做介绍说明。
:::

## NodeJs前端工具链

得益于 NodeJs 的能力，开源社区在模块化方面又再次向前继续迈进。 特别是在推出了 `NPM` 包管理工具后，前端的工具、模块化出现了井喷式发展。

### grunt gulp

既然 CommonJs 不适用于 浏览器端的一个主要原因是同步加载和异步加载之间的问题，那么借助于 `grunt` 或 `gulp` 提供的前端工具，在开发时，还是以文件一模块，然后构建时，将模块文件打包在一起，那么由于都是在同一个文件中，则模块之间的加载则可以是同步的。

在这个时期，`grunt`、`gulp` 并没有提供直接的模块化打包能力，但是在其基础上，通过插件实现了文件合并，从而能够在开发时，以 某种模块规范进行项目架构和管理，再进行打包构建。

### webpack NPM

真正让 前端模块化得到质的飞跃的，是 NPM的推出，内置到了 NodeJS 中。

而 webpack 的出现，这块 真正意义上的 模块打包工具，配合 NPM， 让模块化越来越得以更方便的运用于应用开发中。

webpack 作为一个 模块打包器， 在内部根据 CommonJs规范实现了 模块加载器，使得应用于浏览器端的javascript代码，也能够像 Node端的 javascript代码，拥有类似甚至相同的文件组织结构。

实现了一文件一模块，模块之间通过 `require` 函数进行 访问。

而 NPM的推出与流行，在前端引入了 `package` 包的概念，模块以包的形式进行管理， 让越来越多的开发者，能够共享各自开发的模块，开发者可以通过 NPM 安装其他开发者已开发好的模块，然后通过 `webpack` 实现开发时加载这些模块。

webpack 内部实现了 不同的 模块化规范，包括 匿名函数闭包`iife`, `AMD`, `CMD`,`CommonJs`等。

`webpack` 不仅将 javascript 作为模块，而是将一切资源都作为模块进行处理。

### 其他的模块打包工具

* [rollup](https://github.com/rollup/rollup) 轻量且快速的模块打包工具
* [parcel](https://github.com/parcel-bundler/parcel) 零配置的开箱即用的模块打包工具
* [vite](https://github.com/vitejs/vite) 基于rollup的前端工具
* more...

### 其他包管理工具

* [yarn](https://classic.yarnpkg.com/lang/en/)
* [pnpm](https://pnpm.io/)
* more...

::: info 说明
与`npm` 对比，都是社区对于 包管理 的不同理念、不同实践 下所产生的工具。
三者互相发展，并都有各自的特色。
:::

## ES Modules

[ES Modules](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules)

随着 javascript的发展，ECMAScript将模块加载添加到了标准之中，浏览器也开始支持 模块加载。

使用 Javascript 模块依赖于 `import` 和 `export` 进行导入和导出。

在 `html` 导入 javascript模块脚本是，需要在 `<script>` 标签中添加 `type="module"` 的属性声明

```html
<script type="module" src="/moduleA.js"></script>
```

::: code-tabs

@tab moduleA.js

```js
import { getAge, name } from './moduleB.js'

console.log(name)
console.log(getAge())
```

@tab moduleB.js

```js
export const name = 'Mark'

const age = 18

export function getAge() {
  return age
}
```

:::

## Deno模块加载

Deno与 Node在模块加载上最大的差别， 就是 放弃了 项目中的`node_modules` 作为第三方包的存放目录，也抛弃了 类似于 NPM 的中心化管理的 模块管理工具。

Deno 推荐使用的是 去中心化的模块加载管理，支持直接从远程的任意站点加载提供的模块。

如从 官方的 [deno.lang](https://deno.land/)，或者从 [unpkg.com](https://unpkg.com/) 加载第三方模块。

::: info 说明
这种去中心化模块管理的模块加载方案，相对来说会比较依赖于网络环境，虽然远程的模块首次加载后也会被缓存，但进行生产部署时，往往生产服务器跟公网是隔离的，在这种情况下，就需要自建一个内部服务器作为代理，托管第三方的模块包。
:::

---

---
url: /article/jxbtp9xg/index.md
---
::: center
::logos:pm2 =200px::
:::

## 什么是 PM2？

PM2 是一款功能强大的 Node.js 进程管理器，专门用于管理和守护 Node.js 应用程序。无论是在开发环境还是生产环境中，它都能确保你的 Node 应用稳定运行，并提供丰富的监控与管理功能。

简单来说，PM2 就像是 Node.js 应用的“贴身管家”，负责启动、停止、重启应用，并在应用意外崩溃时自动恢复，从而保障服务的高可用性。

## 安装 PM2

### 全局安装（推荐）

```bash
npm install pm2 -g
# 或使用 yarn
yarn global add pm2
```

### 本地项目安装

```bash
npm install pm2 --save-dev
# 在项目中使用
npx pm2 start app.js
```

### 验证安装

```bash
pm2 --version
# 输出示例：5.3.0
```

## 主要用途

1. **进程守护**：保障 Node.js 应用持续运行，崩溃时自动重启
2. **负载均衡**：利用 Node.js 集群模式充分发挥多核 CPU 性能
3. **零停机部署**：实现应用无缝更新与部署
4. **性能监控**：实时监控应用性能及资源使用情况
5. **日志管理**：集中管理应用日志输出

## 核心功能

### 1. 进程管理

```bash
# 启动应用
pm2 start app.js

# 启动并指定应用名称
pm2 start app.js --name "my-api"

# 启动多个实例（集群模式）
pm2 start app.js -i 4

# 重启应用
pm2 restart app.js

# 停止应用
pm2 stop app.js

# 删除应用
pm2 delete app.js
```

### 2. 配置文件

创建 `ecosystem.config.js` 文件：

```javascript
module.exports = {
  apps: [{
    name: 'my-app',
    script: './app.js',
    instances: 'max', // 使用所有 CPU 核心
    exec_mode: 'cluster', // 集群模式
    env: {
      NODE_ENV: 'development',
      PORT: 3000
    },
    env_production: {
      NODE_ENV: 'production',
      PORT: 80
    },
    watch: true, // 开发时监听文件变化
    ignore_watch: ['node_modules', 'logs'],
    max_memory_restart: '1G', // 内存超过 1G 自动重启
    error_file: './logs/err.log',
    out_file: './logs/out.log',
    log_file: './logs/combined.log',
    time: true
  }],

  // 部署配置
  deploy: {
    production: {
      'user': 'node',
      'host': ['server1.com', 'server2.com'],
      'ref': 'origin/main',
      'repo': 'git@github.com:user/repo.git',
      'path': '/var/www/my-app',
      'post-deploy': 'npm install && pm2 reload ecosystem.config.js --env production'
    }
  }
}
```

使用配置文件启动应用：

```bash
pm2 start ecosystem.config.js --env production
```

### 3. 监控和日志

```bash
# 查看所有进程状态
pm2 list

# 监控所有进程
pm2 monit

# 查看应用日志
pm2 logs
pm2 logs my-app --lines 100  # 查看最近 100 行

# 查看特定应用的监控信息
pm2 show my-app

# 生成启动脚本（服务器重启后 PM2 自动启动）
pm2 startup
pm2 save
```

## 常用命令速查表

| 命令          | 描述               | 示例               |
| ------------- | ------------------ | ------------------ |
| `pm2 start`   | 启动应用           | `pm2 start app.js` |
| `pm2 list`    | 列出所有应用       | `pm2 list`         |
| `pm2 stop`    | 停止应用           | `pm2 stop all`     |
| `pm2 restart` | 重启应用           | `pm2 restart app`  |
| `pm2 delete`  | 删除应用           | `pm2 delete app`   |
| `pm2 logs`    | 查看日志           | `pm2 logs app`     |
| `pm2 monit`   | 监控面板           | `pm2 monit`        |
| `pm2 reload`  | 重载应用（零停机） | `pm2 reload app`   |
| `pm2 scale`   | 扩展实例           | `pm2 scale app +1` |
| `pm2 startup` | 生成启动脚本       | `pm2 startup`      |

## PM2 的优缺点

### 优点

1. **强大的进程管理**：自动重启、集群模式、负载均衡
2. **零停机部署**：支持热重载，更新应用无需停机
3. **丰富的生态系统**：内置监控、日志管理、性能分析
4. **易于使用**：命令行接口简洁，学习成本低
5. **跨平台支持**：兼容 Linux、Windows、macOS
6. **活跃的社区**：持续更新，文档完善
7. **免费开源**：大部分功能免费使用

### 缺点

1. **内存占用**：相比简单方案，PM2 本身会占用额外内存
2. **配置复杂**：高级功能需较复杂配置
3. **Windows 支持有限**：部分功能在 Windows 上表现不如 Linux
4. **依赖 Node.js**：必须安装 Node.js 环境

## 替代品及对比

### 1. Forever

```bash
npm install forever -g
forever start app.js
```

**与 PM2 对比：**

* ✅ 更轻量，内存占用少
* ❌ 功能较少，不支持集群模式
* ❌ 监控和日志功能有限
* ❌ 社区活跃度较低

### 2. Docker + 进程管理

```dockerfile
FROM node:18
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
CMD ["node", "app.js"]
```

**与 PM2 对比：**

* ✅ 更好的隔离性和可移植性
* ✅ 标准化部署流程
* ❌ 学习曲线更陡峭
* ❌ 资源消耗更大

### 3. Systemd (Linux)

```ini
# /etc/systemd/system/myapp.service
[Unit]
Description=My Node.js App
After=network.target

[Service]
Type=simple
User=node
WorkingDirectory=/var/www/myapp
ExecStart=/usr/bin/node app.js
Restart=on-failure

[Install]
WantedBy=multi-user.target
```

**与 PM2 对比：**

* ✅ 系统级集成
* ✅ 无需额外依赖
* ❌ 配置复杂
* ❌ 功能有限

### 4. Kubernetes

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nodejs-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nodejs
  template:
    metadata:
      labels:
        app: nodejs
    spec:
      containers:
        - name: nodejs
          image: my-nodejs-app:latest
          ports:
            - containerPort: 3000
```

**与 PM2 对比：**

* ✅ 企业级容器编排
* ✅ 自动扩展和自愈能力
* ❌ 架构复杂，运维成本高
* ❌ 小型项目可能过度设计

## 选择建议

| 场景                | 推荐工具         | 理由                   |
| ------------------- | ---------------- | ---------------------- |
| 中小型 Node.js 项目 | **PM2**          | 功能全面，易于使用     |
| 需要容器化部署      | **Docker + PM2** | 结合容器优势和进程管理 |
| 企业级微服务        | **Kubernetes**   | 完善的容器编排能力     |
| 简单守护需求        | **Forever**      | 轻量级解决方案         |
| Linux 系统服务      | **Systemd**      | 系统原生集成           |

## 最佳实践

### 1. 生产环境配置

```javascript
// ecosystem.config.js
module.exports = {
  apps: [{
    name: 'api-prod',
    script: './dist/server.js',
    instances: 'max',
    exec_mode: 'cluster',
    node_args: '--max-old-space-size=1024',
    env: {
      NODE_ENV: 'production',
      PORT: 8080
    },
    max_memory_restart: '800M',
    error_file: '/var/log/pm2/api-error.log',
    out_file: '/var/log/pm2/api-out.log',
    combine_logs: true,
    time: true,
    wait_ready: true,
    listen_timeout: 3000
  }]
}
```

### 2. 部署脚本示例

```bash
#!/bin/bash
# deploy.sh

echo "开始部署..."

# 拉取最新代码
git pull origin main

# 安装依赖
npm install --production

# 构建应用
npm run build

# 使用 PM2 重载应用（零停机）
pm2 reload ecosystem.config.js --env production

echo "部署完成！"
```

## 总结

PM2 是 Node.js 开发者的得力助手，特别适用于需要高可用性和易维护性的生产环境。它提供从开发到部署的全套解决方案，虽然在特定场景下可能有更专业的替代方案，但对于大多数 Node.js 项目而言，PM2 仍是最实用、最全面的选择。

**核心价值：**

* 🚀 简化部署和维护流程
* 🔄 确保应用高可用性
* 📊 提供完善的监控能力
* ⚡ 支持性能优化和扩展

无论你是独立开发者还是团队协作，掌握 PM2 都能显著提升 Node.js 应用的管理与运维效率。

## 延伸资源

[PM2 官方文档](https://pm2.io/docs/){.read-more}
[PM2 GitHub 仓库](https://github.com/Unitech/pm2){.read-more}
[Node.js 最佳实践](https://github.com/goldbergyoni/nodebestpractices){.read-more}

---

---
url: /article/k39mhbxp/index.md
---
# JavaScript 进阶 六：this 绑定机制
在JavaScript开发中，`this`关键字可能是最令人困惑但又至关重要的概念之一。很多开发者对`this`的理解停留在"谁调用就指向谁"的浅层认知，但在实际开发中，这种理解往往会导致意想不到的bug。本文将带你深入理解JavaScript中的`this`绑定机制，掌握其在不同场景下的行为规律。

## 什么是this？

简单来说，`this`是一个在函数执行时动态绑定的特殊变量，它指向当前执行上下文中的某个对象。但`this`的具体指向并不是在函数定义时确定的，而是在**函数调用时**根据调用方式动态决定的。

## this的四种绑定规则

### 1. 默认绑定

当函数独立调用时，`this`会指向全局对象（浏览器中为`window`，Node.js中为`global`）。

```javascript title="默认绑定示例"
function showThis() {
  console.log(this)
}

showThis() // 在浏览器中输出: Window对象
```

:::warning 严格模式下的变化
在严格模式(`'use strict'`)下，默认绑定的`this`会是`undefined`，而不是全局对象：

```javascript title="严格模式下的默认绑定"
'use strict'

function strictShowThis() {
  console.log(this)
}

strictShowThis() // 输出: undefined
```

:::

### 2. 隐式绑定

当函数作为对象的方法调用时，`this`指向调用该方法的对象。

```javascript title="隐式绑定示例"
const user = {
  name: '张三',
  greet() {
    console.log(`你好，我是${this.name}`)
  }
}

user.greet() // 输出: "你好，我是张三"
```

:::caution 隐式丢失问题
一个常见的陷阱是隐式绑定的丢失：

```javascript title="隐式绑定丢失"
const user = {
  name: '李四',
  sayName() {
    console.log(this.name)
  }
}

const sayName = user.sayName
sayName() // 输出: undefined (this指向全局对象)
```

:::

### 3. 显式绑定

使用`call()`、`apply()`或`bind()`方法可以显式地指定`this`的指向。

```javascript title="显式绑定示例"
function introduce(language, framework) {
  console.log(`我是${this.name}，擅长${language}和${framework}`)
}

const developer = { name: '王五' }

// 使用call - 参数逐个传递
introduce.call(developer, 'JavaScript', 'React')

// 使用apply - 参数以数组形式传递
introduce.apply(developer, ['TypeScript', 'Vue'])

// 使用bind - 返回一个新函数
const boundIntroduce = introduce.bind(developer, 'Python')
boundIntroduce('Django') // 输出: "我是王五，擅长Python和Django"
```

### 4. new绑定

使用`new`关键字调用构造函数时，`this`会指向新创建的对象实例。

```javascript title="new绑定示例"
function Person(name, age) {
  this.name = name
  this.age = age
  this.introduce = function () {
    console.log(`我叫${this.name}，今年${this.age}岁`)
  }
}

const person1 = new Person('赵六', 25)
person1.introduce() // 输出: "我叫赵六，今年25岁"
```

## this绑定的优先级

理解绑定规则的优先级对于预测`this`的行为至关重要：

:::important 绑定规则优先级
**new绑定 > 显式绑定 > 隐式绑定 > 默认绑定**

```javascript title="绑定优先级验证"
function test() {
  console.log(this.value)
}

const obj1 = { value: 'obj1', test }
const obj2 = { value: 'obj2' }

// 隐式绑定
obj1.test() // 输出: "obj1"

// 显式绑定优先于隐式绑定
obj1.test.call(obj2) // 输出: "obj2"

// new绑定优先于显式绑定
const boundTest = test.bind(obj1)
// eslint-disable-next-line new-cap
const instance = new boundTest() // 输出: undefined (new绑定覆盖了bind)
```

:::

## 特殊场景下的this

### 箭头函数中的this

箭头函数没有自己的`this`，它会继承外层作用域的`this`值。

```javascript title="箭头函数的this"
const obj = {
  value: 'outer',
  regularFunc() {
    console.log('普通函数:', this.value)

    const arrowFunc = () => {
      console.log('箭头函数:', this.value)
    }

    arrowFunc()
  }
}

obj.regularFunc()
// 输出:
// 普通函数: outer
// 箭头函数: outer
```

### 事件处理函数中的this

在DOM事件处理函数中，`this`通常指向触发事件的元素。

```javascript title="事件处理函数中的this"
// 假设有HTML: <button id="myButton">点击我</button>
document.getElementById('myButton').addEventListener('click', function () {
  console.log(this) // 输出: <button id="myButton">点击我</button>
})
```

### 定时器中的this

在`setTimeout`和`setInterval`中，回调函数的`this`默认指向全局对象。

```javascript title="定时器中的this"
const timerObj = {
  value: 'timer object',
  startTimer() {
    setTimeout(function () {
      console.log(this.value) // 输出: undefined
    }, 1000)

    // 解决方案：使用箭头函数或bind
    setTimeout(() => {
      console.log(this.value) // 输出: "timer object"
    }, 1000)
  }
}

timerObj.startTimer()
```

## 实战应用技巧

### 1. 使用bind避免this丢失

:::steps

* 在React类组件中绑定事件处理函数：

  ```javascript title="React类组件中的this绑定"
  class MyComponent extends React.Component {
    constructor(props) {
      super(props)
      this.handleClick = this.handleClick.bind(this)
    }

    handleClick() {
      console.log(this) // 正确指向组件实例
    }

    render() {
      return <button onClick={this.handleClick}>点击</button>
    }
  }
  ```

* 在Vue 2的选项式API中：

  ```javascript title="Vue选项式API中的方法绑定"
  export default {
    methods: {
      handleClick() {
        console.log(this) // 指向Vue实例
      }
    }
  }
  ```

:::

### 2. 使用箭头函数简化绑定

```javascript title="使用箭头函数简化this绑定"
class ModernComponent extends React.Component {
  // 使用类属性 + 箭头函数自动绑定this
  handleClick = () => {
    console.log(this) // 自动绑定到组件实例
  }

  render() {
    return <button onClick={this.handleClick}>点击</button>
  }
}
```

### 3. 函数柯里化与this

```javascript title="函数柯里化中的this处理"
function createLogger(prefix) {
  return function (message) {
    console.log(`[${prefix}] ${this.name}: ${message}`)
  }
}

const userLogger = createLogger('USER').bind({ name: '张三' })
userLogger('登录成功') // 输出: "[USER] 张三: 登录成功"
```

## 常见陷阱与解决方案

:::warning

* **回调函数中的this丢失**：使用箭头函数或显式绑定
* **方法赋值导致的this丢失**：使用bind或在调用时确保正确的上下文
* **嵌套函数中的this混乱**：使用箭头函数或在外部保存this引用

:::

```javascript title="this相关陷阱解决方案"
const problematicObj = {
  data: 'important data',

  // 陷阱：嵌套函数中的this丢失
  problematicMethod() {
    setTimeout(function () {
      console.log(this.data) // undefined
    }, 100)
  },

  // 解决方案1：使用箭头函数
  solution1() {
    setTimeout(() => {
      console.log(this.data) // "important data"
    }, 100)
  },

  // 解决方案2：保存this引用
  solution2() {
    const self = this
    setTimeout(() => {
      console.log(self.data) // "important data"
    }, 100)
  },

  // 解决方案3：使用bind
  solution3() {
    setTimeout(() => {
      console.log(this.data) // "important data"
    }, 100)
  }
}
```

## 总结

深入理解JavaScript的`this`绑定机制是成为高级前端开发者的重要一步。记住这些关键点：

1. **`this`的指向在函数调用时确定**，而非定义时
2. **四种绑定规则**：默认、隐式、显式、new绑定
3. **优先级顺序**：new > 显式 > 隐式 > 默认
4. **箭头函数**没有自己的`this`，继承外层作用域
5. 在**回调函数和事件处理**中特别注意`this`的指向

掌握这些知识后，你将能够更加自信地处理各种复杂的`this`相关场景，写出更加健壮和可维护的JavaScript代码。

## 参考

* [MDN - this](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this)
* [You Don't Know JS: this & Object Prototypes](https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/this%20%26%20object%20prototypes/README.md)
* [JavaScript.info - 对象方法，"this"](https://zh.javascript.info/object-methods)

---

---
url: /article/kflidi22/index.md
---
# Vue 响应式系统
响应式编程从提出至今，大约有几十年的历史了，它时而兴起，时而沉寂。而在前端，它在这几年来，有开始迸发出了新的活力。
特别是在当下流行的如 `vue` 、 `react`、`svelte` 和 `solid` 之类的前端框架中，响应式编程的发展迅速。

然而，它并不是那么容易理解。

* 在不同的响应式编程实现方式中，某些术语或者概念可能会有所不同，对于不同的人来说，也有不同的理解。
* 其次，它看起来像是一个魔法，虽然事实并非如此，人们在理解响应式编程是什么之前，常常会被 **“怎么做到的”** 分散注意力，从而导致理解难度的增加。这使得很难通过一些实际的例子，完全理解响应式编程。

本文不完全解释响应式编程，但是希望能够帮助你理解响应式编程。并帮助理解 `vue` 的响应式系统。

## 响应性

响应式编程，一个重要的特点是 **响应性**。

那么如何理解响应性？一种很口语化的表达是，两个物体之间存在某种关联，当其中一个发生变化时，另一个也会随之发生变化。

一个常见的例子，如我们常用的 Excel 表格：

|     | A   | B   | C   |
| --- | --- | --- | --- |
| 0   | 2   |     |     |
| 1   | 3   |     |     |
| 2   | 5   |     |     |

`A2` 单元格的值 是根据 `A0` 和 `A1` 两个单元格的值，进行求和后的结果，
通常我们会在 `A2` 的单元格上写 `=SUM(A0:A1)` 的公式。
当 `A0` 和 `A1` 两个单元格的值发生变化时，`A2` 单元格的值也会随之发生变化。

这种`A2` 与 `A0``A1`的关系，我们可以称之为 **响应性**。公式 `=SUM(A0:A1)` 则声明并建立了这种关系。

所以，**响应性** 是一种可以使我们声明式地处理变化的编程范式。

## JavaScript 中实现响应性

我们把 这个 Excel 表格 编写为 `javascript` 的逻辑：

```ts
let A0 = 2
let A1 = 3
let A2 = A0 + A1

console.log(A2) // 5

A0 = 5
console.log(A2) // 仍然是 5
```

即使`A0`的值发生了变化，但`A2`的值仍然是 5。可见在 `javascript` 中，默认并不具有 响应性 的。
那么，要如何在 javascript 中建立响应性呢？

通常在 `javascript` 的代码中，我们使用一个函数来包装计算`A2`的逻辑，
并在其他值发生改变时，调用这个函数来更新`A2`的值。

```ts
let A0 = 2
let A1 = 3
let A2

function update() {
  A2 = A0 + A1
}
console.log(A2) // 5

A0 = 5
update()
console.log(A2) // 8
```

但是，每次修改 `A0` 或 `A1` 时，都需要主动调用 `update()` 来更新`A2`的值，这显然没有 `响应性`。
需要找到一种，修改 `A0` 或 `A1` 时，自动调用 `update()` 来更新`A2`的值的方法。

通常，我们很容易就会联想到通过 `订阅者模式`，来实现这种功能。
`A2` 订阅 `A0`和`A1` 两个变量，当它们发生变化时，自动调用 `update()` 来更新`A2`的值。

```ts
// 仅表示伪代码，方便理解
A2.subscribe(A0, A1, update)
```

然而，在 `javascript` 中，要实现对 变量的变更的监听，并不那么容易。
`javascript` 并没有提供一种方式，帮助我们实现对基本数据类型的变更监听。

### 轮询检查

我们还是可以通过 **轮询检查** 来实现对变量的变更的监听。每隔一段时间，扫描`A0`和`A1`两个变量的值，如果发生了变化，就调用 `update()` 来更新`A2`的值。

```ts
let A0 = 2
let A1 = 3
let A2
let OA0 = A0
let OA1 = A1

setInterval(() => {
  if (OA0 !== A0 || OA1 !== A1) {
    A2 = A0 + A1
    console.log('A2:', A2)
  }
}, 10)

A0 = 5
// A2: 8
```

**缺陷**：

```mermaid
graph TD
    A[轮询机制] --> B[高频CPU消耗]
    A --> C[状态同步延迟]
    A --> D[无效检查浪费]
```

### 输入检查

然而定期检查 会带来不必要的开销，在稍微复杂的场景中，会导致严重的性能问题，
因此最好能够在 `A0 = 5` 时，再检查是否发生变更，自动更新`A2`的值。

```ts
let A0 = 2
let A1 = 3
let A2
function updateValue(update) {
  let OA1 = A1
  let OA0 = A0

  update()

  if (OA0 !== A0 || OA1 !== A1) {
    A2 = A0 + A1
    console.log('A2:', A2)
  }
}
updateValue(() => {
  A0 = 5
})
// A2: 8
```

这种方式的好处是，只有在 重新输入 `A0` 或 `A1` 时，才会检查变更。
但这种代码，把 检查的代码、响应变更的代码都放在一起，会导致代码的复杂度增加。
我们期望的是，将它们分开，从而降低代码的复杂度。

```ts
let A0 = 2
let A1 = 3
let A2

const { onUpdate, updateValue } = createReactive(A0, A1) // 创建响应式

// 监听变更
onUpdate(() => {
  A2 = A0 + A1
})

// 更新变量
updateValue(() => {
  A0 = 5
})
```

### 状态机

在上面的代码中，我们很容易产生一个困惑，
`A0` 和 `A1` 作为外部变量，`createReactive` 函数内部如何知道它们是否有变化呢？

答案是，确实不知道。`A0` 和 `A1` 仅是 基本数据类型，即使传入`createReactive`，
函数内部也不知道它们何时发生变化。

因此，我们需要引入 `状态机`的概念，来解决这个问题。将 `A0` 和 `A1` 、`A2` 作为状态变量，而不是基本数据类型，
托管给 状态机。

```ts
const { subscribe, setState } = createReactive({
  A0: 2,
  A1: 3,
  A2: 5,
}) // 创建响应式

// 侦听变更
subscribe((state) => {
  state.A2 = state.A0 + state.A1
})

setState((state) => {
  return { A0: 5 }
})
```

我们可以很轻松的实现 一个简单的 `createReactive`：

```ts
function createReactive(initialState) {
  let state = initialState
  const listeners = new Set()

  // 添加订阅者
  const subscribe = (callback) => {
    listeners.add(callback)
  }

  const checkUpdate = (newState, oldState) => {
    // 实际情况需要对比 state 每个 key 的值，
    return newState !== oldState
  }

  const setState = (callback) => {
    const oldState = state
    const newState = { ...state, ...callback(state) }
    if (checkUpdate(newState, oldState)) {
      listeners.forEach(callback => callback(newState))
      state = newState
    }
  }
  return { state, subscribe, setState }
}
```

当然，实际情况远比这复杂的多，但至少是可以理解的，已经初具雏形。

在 `createReactive` 的帮助下，通过 `setState()` 更新 `A0` 和 `A1` 两个状态的值时，在函数内部
检查状态变更，然后在内部调用 侦听器，实现对 `A2` 状态的响应更新。

### 响应视图更新

到这里，你或许已经想到，这好像与 `React` 类似，然后想到，那么如何使视图更新呢?

其实 视图 也是一个 订阅者，在 `React` 组件中，我们通过 `render()` 方法来定义视图：

```tsx
class Counter extends React.Component {
  state = { count: 0 }
  render() {
    return (
      <div>
        <h1>{this.state.count}</h1>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>+</button>
      </div>
    )
  }
}
```

同样的，通过 `subscribe()` 方法来添加订阅者。

```ts
subscribe((state) => {
  render()
})
```

当调用 `setState()` 更新状态时， `render()` 也会被重新调用，从而更新视图。

## Vue2 的响应式系统

在有了以上的 基础了解后，你已经对 响应式编程 有了一个 基本的认识，和 对如何实现响应式编程 有了一定的了解。

接下来，我们来看看 `vue` 的响应式系统。

在 `vue2` 中，我们 仅 需要写 `this.count += 1` 就能触发视图更新。并没有看到 如 `setState()` 这样的方法帮助我们
检查状态变更和调用侦听者。 这看起来像是一个 “魔法” 。

事实上，`vue2` 通过 `Object.defineProperty`, 把 `count` 属性改成了 `getter/setter` ,
`getter/setter` 对用户而言，是不可见的。 当我们对 `this.count += 1` 时，实际上调用的是 `setter` 方法。

```ts
Object.defineProperty(this, 'count', {
  set(val) {
    this.count = val
  },
  get() {
    return this.count
  }
})
```

这样就有机会在 `setter` 方法中，进行状态变更检查，并调用侦听器。

```ts
Object.defineProperty(this, 'count', {
  set(val) {
    const oldValue = this.count
    this.count = val
    listeners.forEach(callback => callback(val, oldValue))
  },
  get() {
    return this.count
  }
})
```

---

---
url: /article/knagbtgd/index.md
---
# webpack模块热替换（HMR）
**模块热替换（Hot Module Replacement）** 是 webpack 的一个 十分有用且强大的 特性。
当我们对 文件代码进行修改并保存后，webpack 会重新编译打包文件代码，并将新的模块代码发送给客户端，
浏览器通过将旧模块替换为新模块，实现在浏览器不刷新的情况下，对应用进行更新。

## 前言

在还没有 HMR 之前，我们对文件代码进行更新保存后，想要查看更新后的内容，常常需要手动刷新浏览器。

但还好的是，也有一些 **live reload** 的工具库，这些库能够监听文件的变化，通知浏览器刷新页面，
从而帮助我们减少了重复的操作。

但是为什么还需要 HMR 呢？

当浏览器刷新，也意味着当前页面的状态丢失了。
比如，我们打开了一个弹窗，然后我们对弹窗的代码逻辑进行了修改并保存，浏览器刷新后，弹窗被关闭了，
我们需要重新进行交互打开弹窗。
这无疑会增加非常多的重复且无意义工作量、时间。

HMR 的作用，就是不仅帮助我们在无刷新的情况下更新了应用代码，同时还保留了应用的状态，让我们能避免了
大量重复操作，从而提高开发效率。

## 模块热替换

模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。

### 启用

启用 HMR 的方式很简单，[查看官方文档](https://www.webpackjs.com/guides/hot-module-replacement/)

### 特性

HMR有几个特性：

* 保留在完全重新加载页面时丢失的应用程序状态。
* 只更新变更内容，以节省宝贵的开发时间。
* 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。

## HMR基本流程

* **Step 1:**

  webpack watch 模式下，监听文件系统中的某个文件是否发生修改。当监听到文件发生变更时，
  根据配置文件**对模块进行重新编译打包**，并将打包后的代码 通过 JavaScript 对象保存在内存中。

* **Step 2:**

  webpack-dev-middleware 调用 webpack 的API 对代码的变化进行监控，并通知webpack，将代码打包到内存中。

* **Step 3:**

  webpack-dev-server 监听文件变化，不同于第一步的是，这一步不监听代码变化进行重新编译打包。
  当配置文件中配置了 `devServer.watchContentBase` 为 `true` 时，
  Server会监听配置的文件夹中静态文件的变化，如果发生变化，通知浏览器进行 `live reload`,即刷新页面。

* **Step 4:**

  webpack-dev-server 通过 sockjs 在浏览器和服务器端之间建立一个 websocket 长连接，
  将webpack编译打包的各个阶段的状态信息告知浏览器端，也包括第三步中 Server 监听静态文件变化的信息。
  浏览器端根据这些socket消息进行不同的操作。
  其中，服务器传递的最主要的信息，是新模块的 hash 值，后续步骤根据 hash值 进行模块的替换。

* **Step 5:**

  webpack-dev-server 虽然会告知浏览器打包状态，但在 webpack-dev-server/client 端并不会去请求更新的代码，
  也不会执行热模块替换的操作，这些工作会交回给 webpack/hot/dev-server。
  webpack/hot/dev-server 根据 webpack-dev-server/client 传给它的信息，以及 dev-server 的配置信息，
  来决定是刷新浏览器，还是执行 热模块替换。

* **Step 6:**

  在客户端中，HotModuleReplacement.runtime 接受到 上一步传递给它的新模块的 hash 值，
  通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，server 端返回一个 json。
  该 json 包含了所有要更新的模块的 hash 值，获取到需要更新的模块列表后，再发送一个 jsonp 请求，
  获取最新的模块代码。

* **Step 7:**

  HotModulePlugin 会对新旧模块进行对比，决定是否更新模块。
  在决定更新模块后，检查模块之间的依赖关系，更新模块的同时，也更新模块间的依赖引用。
  这个步骤也决定了 HMR 是否成功。

* **Step 8:**

  如果 HMR 失败，则回退到 live reload 操作，通过刷新浏览器来获取最新打包的代码。

---

---
url: /article/l9mhrvdi/index.md
---
# JavaScript 进阶 九：错误处理与异常捕获
在 JavaScript 开发中，错误处理是构建健壮应用的关键技能。本文将深入探讨 JavaScript 错误处理机制，从基础语法到高级实践，帮助您写出更可靠的代码。

## 为什么需要错误处理？

:::warning 错误不可避免
在真实的软件环境中，错误是不可避免的。好的代码不仅在一切顺利时能够正常工作，而且在出现问题时也能保持可预测性和安全性。
:::

JavaScript 中的错误主要分为几类：

* **语法错误**：代码编写不规范，在解析阶段就会报错
* **运行时错误**：代码执行过程中出现的错误
* **逻辑错误**：代码逻辑有误，但不会抛出异常

```javascript title="常见错误示例"
// 1. 引用错误
console.log(undefinedVariable) // ReferenceError

// 2. 类型错误
null.function() // TypeError

// 3. 语法错误（无法通过 try...catch 捕获）
// console.log("hello; // SyntaxError
```

## Error 对象详解

当错误发生时，JavaScript 会创建一个 Error 对象，包含以下重要属性：

```javascript
try {
  let user = undefinedUser
}
catch (error) {
  console.log('错误名称:', error.name) // ReferenceError
  console.log('错误信息:', error.message) // undefinedUser is not defined
  console.log('调用栈:', error.stack) // 详细的调用栈信息
}
```

:::info Error 对象属性

* `name`：错误类型名称
* `message`：错误描述信息
* `stack`：调用栈信息（调试用）
  :::

## try...catch 基础

### 基本语法

```javascript
try {
  // 可能出错的代码
  riskyOperation()
}
catch (error) {
  // 错误处理逻辑
  console.error('操作失败:', error.message)
}
```

### 实际应用示例

:::: demo normal title="JSON 解析错误处理" desc="处理可能格式错误的 JSON 数据"
::: code-tabs
@tab HTML

```html
<div id="result"></div>
<button onclick="parseJSON()">解析 JSON</button>
```

@tab JavaScript

```javascript
function parseJSON() {
  const jsonString = '{"name": "Alice", "age": 25}' // 有效的 JSON
  // const jsonString = '{"name": Alice}'; // 无效的 JSON

  try {
    const user = JSON.parse(jsonString)
    document.getElementById('result').innerHTML
      = `姓名: ${user.name}, 年龄: ${user.age}`
  }
  catch (error) {
    document.getElementById('result').innerHTML
      = `JSON 解析失败: ${error.message}`
  }
}
```

:::
::::

### try...catch 的限制

:::caution 重要限制

1. **仅对运行时错误有效**：语法错误无法捕获
2. **同步工作**：无法直接捕获异步操作中的错误
   :::

```javascript title="异步错误无法直接捕获"
try {
  setTimeout(() => {
    throw new Error('异步错误') // 这个错误无法被外部的 catch 捕获
  }, 1000)
}
catch (error) {
  console.log('这行代码不会执行')
}
```

## throw 操作符与自定义错误

### 基本用法

`throw` 语句允许您创建自定义错误：

```javascript
function validateAge(age) {
  if (age < 0) {
    throw new Error('年龄不能为负数')
  }
  if (age > 150) {
    throw new Error('年龄超出合理范围')
  }
  return true
}

try {
  validateAge(-5)
}
catch (error) {
  console.error('验证失败:', error.message)
}
```

### 自定义错误类型

通过继承 Error 类创建更具体的错误类型：

```javascript title="自定义验证错误"
class ValidationError extends Error {
  constructor(field, message) {
    super(`${field} 验证失败: ${message}`)
    this.name = 'ValidationError'
    this.field = field
    this.timestamp = new Date().toISOString()
  }
}

class NetworkError extends Error {
  constructor(url, status) {
    super(`请求 ${url} 失败，状态码: ${status}`)
    this.name = 'NetworkError'
    this.status = status
  }
}

// 使用示例
function registerUser(userData) {
  if (!userData.username) {
    throw new ValidationError('username', '用户名不能为空')
  }
  if (userData.password.length < 8) {
    throw new ValidationError('password', '密码至少8位')
  }

  // 模拟网络请求
  throw new NetworkError('/api/register', 500)
}

try {
  registerUser({ username: 'john', password: '123' })
}
catch (error) {
  if (error instanceof ValidationError) {
    console.error('输入验证错误:', error.message)
  }
  else if (error instanceof NetworkError) {
    console.error('网络错误:', error.message)
  }
  else {
    console.error('未知错误:', error.message)
  }
}
```

## finally 块的作用

`finally` 块中的代码==总是会执行=={.important}，无论是否发生错误：

```javascript
function processFile(filename) {
  let fileHandle = null

  try {
    console.log(`开始处理文件: ${filename}`)
    fileHandle = `handle_${filename}` // 模拟文件打开
    // 模拟文件处理可能出错
    if (Math.random() > 0.5) {
      throw new Error('文件处理失败')
    }
    console.log('文件处理成功')
  }
  catch (error) {
    console.error('处理过程中出错:', error.message)
    throw error // 重新抛出错误
  }
  finally {
    // 无论成功还是失败，都要关闭文件
    console.log(`关闭文件句柄: ${fileHandle}`)
    fileHandle = null
  }
}

try {
  processFile('data.txt')
}
catch (error) {
  console.log('外部捕获:', error.message)
}
```

## 异步错误处理

### Promise 错误处理

```javascript
// .catch() 方法
fetch('/api/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('请求失败:', error.message))

// 或者使用 async/await
async function fetchData() {
  try {
    const response = await fetch('/api/data')
    if (!response.ok) {
      throw new Error(`HTTP错误! 状态码: ${response.status}`)
    }
    const data = await response.json()
    return data
  }
  catch (error) {
    console.error('获取数据失败:', error.message)
    throw error // 可以选择重新抛出
  }
}
```

### 异步函数中的错误处理模式

```javascript title="健壮的异步错误处理"
class ApiService {
  async request(url, options = {}) {
    try {
      const response = await fetch(url, {
        timeout: 5000,
        ...options
      })

      if (!response.ok) {
        throw new Error(`请求失败: ${response.status}`)
      }

      return await response.json()
    }
    catch (error) {
      // 记录错误日志
      console.error(`API请求错误 [${url}]:`, error.message)

      // 根据错误类型提供友好的错误信息
      if (error.name === 'TypeError' && error.message.includes('fetch')) {
        throw new Error('网络连接失败，请检查网络设置')
      }

      throw error
    }
  }
}

// 使用示例
const api = new ApiService()

async function loadUserData(userId) {
  try {
    const user = await api.request(`/api/users/${userId}`)
    const posts = await api.request(`/api/users/${userId}/posts`)

    return { user, posts }
  }
  catch (error) {
    console.error('加载用户数据失败:', error.message)
    // 可以在这里显示用户友好的错误信息
    return null
  }
}
```

## 最佳实践与设计模式

### 1. 错误传播与重新抛出

:::tip 重新抛出原则
只处理你能处理的错误，将其他错误传递给上层调用者。
:::

```javascript
function processUserData(userData) {
  try {
    // 数据验证
    if (!userData.email.includes('@')) {
      throw new ValidationError('email', '邮箱格式不正确')
    }

    // 业务逻辑处理
    const result = complexBusinessLogic(userData)
    return result
  }
  catch (error) {
    // 只处理验证错误，其他错误重新抛出
    if (error instanceof ValidationError) {
      console.warn('输入验证警告:', error.message)
      return { success: false, error: error.message }
    }

    // 重新抛出未知错误
    throw error
  }
}

// 上层调用
try {
  const result = processUserData({ email: 'invalid-email' })
  console.log(result)
}
catch (error) {
  // 这里会捕获到除 ValidationError 外的所有错误
  console.error('严重错误:', error.message)
}
```

### 2. 全局错误处理

```javascript
// 全局错误捕获
window.addEventListener('error', (event) => {
  console.error('全局错误:', event.error)
  // 可以在这里发送错误报告到服务器
  sendErrorReport(event.error)
})

// 未处理的 Promise 拒绝
window.addEventListener('unhandledrejection', (event) => {
  console.error('未处理的 Promise 拒绝:', event.reason)
  event.preventDefault() // 防止默认的错误输出
})

// 错误报告函数
async function sendErrorReport(error) {
  const report = {
    message: error.message,
    stack: error.stack,
    url: window.location.href,
    userAgent: navigator.userAgent,
    timestamp: new Date().toISOString()
  }

  try {
    await fetch('/api/error-report', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(report)
    })
  }
  catch (reportError) {
    console.warn('错误报告发送失败:', reportError.message)
  }
}
```

### 3. 防御性编程模式

```javascript title="防御性函数设计"
class DataProcessor {
  // 带有完整错误处理的处理函数
  async processWithRetry(operation, maxRetries = 3) {
    let lastError

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`尝试第 ${attempt} 次执行...`)
        const result = await operation()
        console.log('操作成功')
        return result
      }
      catch (error) {
        lastError = error
        console.warn(`第 ${attempt} 次尝试失败:`, error.message)

        if (attempt < maxRetries) {
          // 指数退避
          const delay = Math.min(1000 * 2 ** (attempt - 1), 30000)
          console.log(`等待 ${delay}ms 后重试...`)
          await new Promise(resolve => setTimeout(resolve, delay))
        }
      }
    }

    throw new Error(`操作在 ${maxRetries} 次尝试后失败，最后错误: ${lastError.message}`)
  }

  // 安全的数据访问
  getSafe(obj, path, defaultValue = null) {
    try {
      const value = path.split('.').reduce((current, key) => {
        return current && current[key] !== undefined ? current[key] : undefined
      }, obj)

      return value !== undefined ? value : defaultValue
    }
    catch (error) {
      console.warn(`安全访问路径 ${path} 失败:`, error.message)
      return defaultValue
    }
  }
}

// 使用示例
const processor = new DataProcessor()

// 带重试的操作
processor.processWithRetry(async () => {
  const response = await fetch('/api/unstable-endpoint')
  if (!response.ok)
    throw new Error(`HTTP ${response.status}`)
  return response.json()
}).then(data => console.log('最终结果:', data)).catch(error => console.error('所有重试都失败了:', error.message))

// 安全数据访问
const user = { profile: { address: { city: '北京' } } }
const city = processor.getSafe(user, 'profile.address.city', '未知')
const zipCode = processor.getSafe(user, 'profile.address.zipCode', '000000')
```

## 总结

1. **==始终处理可预见的错误=={.success}**：不要忽略你知道可能发生的错误
2. **==使用适当的错误类型=={.info}**：创建有意义的自定义错误类
3. **==异步错误特殊处理=={.warning}**：Promise 和 async/await 需要专门的错误处理
4. **==合理使用 finally=={.tip}**：确保资源清理和状态重置
5. **==实现全局错误处理=={.important}**：捕获未处理的错误并提供用户友好的反馈

通过掌握这些错误处理技术，您将能够构建更加健壮、可靠的 JavaScript 应用程序。记住，好的错误处理不仅能防止应用崩溃，还能提供更好的用户体验和更快的故障排查。

## 参考

* [MDN Error 文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error)
* [Promise 错误处理最佳实践](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises)
* [Node.js 错误处理模式](https://nodejs.org/api/errors.html)

---

---
url: /article/lasuemgv/index.md
---
# unknown 类型应用场景
`unknown` 类型 表示 不可预先定义的类型，在很多场景下，它可以代替 `any` 类型的功能
的同时，保留静态检查的能力。

## 类型转换

```ts twoslash
const num: number = 10
;(num as unknown as string).split('')
//                           ^?

// @log: 这里可以和 any 一样通过静态检查
```

这个例子可以看出， `unknown` 类型的作用和 `any` 类型的作用非常相似，你可以把它转换为任何类型。
区别在于，**`any` 在静态编译时可以调用任何方法，但 `unknown` 类型在静态编译时是不可以调用任何方法的** 。

```ts twoslash
// @errors: 18046
const foo: unknown = 'string'
foo.substr(1) // 静态检查不通过报错
const bar: any = 10
bar.substr(1)
```

## 替代 `any`

大多数情况下，我们可以选择使用 `unknown` 替代 `any`，从而避免由于使用 `any` 而带来的 静态类型
检查的失效。

如，避免使用 `any` 作为 函数参数类型，使用 `unknown` 替代。

**使用 any，静态检查失效：**

```ts twoslash
function test(input: any): number {
  if (Array.isArray(input)) {
    return input.length
  }
  return input.length
}
```

**使用 unknown，静态检查正确推断：**

```ts twoslash
// @errors: 18046
function test(input: unknown): number {
  if (Array.isArray(input)) {
    // 类型守卫将input识别为array类型
    return input.length
  }
  // input是unknown类型，静态检查报错
  return input.length
}
```

---

---
url: /article/ldvuv37p/index.md
---
# React组件渲染性能优化
在大型 React 应用中，组件渲染性能直接影响用户体验。

## 渲染机制与优化

当父组件状态变化时，React 默认会重新渲染该组件及其所有子组件，即使子组件的 props 未改变。

这种机制可能导致不必要的渲染开销：

```mermaid
graph TD
    A[父组件状态更新] --> B[父组件重新渲染]
    B --> C[子组件1重新渲染]
    B --> D[子组件2重新渲染]
    B --> E[子组件3重新渲染]
```

因此，优化核心策略是 阻断不必要的渲染链，我们可以通过 **浅比较(shallow comparison)** 来实现这一目标。

## 类组件渲染性能优化

::: warning
`shouldComponentUpdate` 和 `PureComponent` 主要用于 类组件，虽然 ==React 更推荐使用函数式组件=={.warning}，
但了解其渲染优化策略是有必要的。
不仅仅是因为对于维护旧的类组件代码有帮助，而且在优化策略上是相通的。
:::

我们先来看一个简单的 类组件 例子：

```tsx
class Child extends React.Component {
  render() {
    console.log('Child rendered')
    return (
      <div>
        <h1>
          Child Count:
          {this.props.count}
        </h1>
      </div>
    )
  }
}

class App extends React.Component {
  state = {
    count: 0,
    otherValue: 'Hello',
  }

  increment = () => {
    this.setState(prevState => ({ count: prevState.count + 1 }))
  }

  changeOtherValue = () => {
    this.setState(prevState => ({ otherValue: prevState.otherValue === 'Hello' ? 'World' : 'Hello' }))
  }

  render() {
    console.log('Parent rendered')
    return (
      <div>
        <h1>
          otherValue:
          {this.state.otherValue}
        </h1>
        <Child count={this.state.count} />
        <button onClick={this.increment}>Increment Count</button>
        <button onClick={this.changeOtherValue}>Change Other Value</button>
      </div>
    )
  }
}

export default App
```

在这个应用中，`Child` 组件的 Props `count` 是 `App` 的 `State` 的一部分。

当我们点击 `Increment Count` 按钮时，`App` 的 `count` 会增加，
此时，`App` 会重新渲染，`Child` 也会重新渲染。

::: center
![render-1](/images/react/optimize/rendered-1.png){style="max-width:640px"}
:::

当我们点击 `Change Other Value` 按钮时，`otherValue` 发生了改变，`App` 会重新渲染。
虽然 `Child` 组件没有用到 `otherValue`, 但 `Child` 依然重新渲染了。

::: center
![render-2](/images/react/optimize/rendered-2.png){style="max-width:640px"}
:::

这是因为当 Parent 组件的 `state` 或 `props` 发生变化时，React 会默认重新渲染该组件及其所有 Child 组件。

在这种情况下，我们可以通过 `shouldComponentUpdate` 来进行优化，来阻断不必要的渲染。

### shouldComponentUpdate

[**React** -> Component -> shouldComponentUpdate](https://zh-hans.react.dev/reference/react/Component#shouldcomponentupdate){.read-more}

`shouldComponentUpdate` 是 类组件 的生命周期。它用于决定组件是否需要更新。当返回 `true` 时，表示组件可以更新，
返回 `false` 时，表示组件不需要更新。

我们对 `Child` 组件进行优化：

```tsx
class Child extends React.Component {
  shouldComponentUpdate(nextProps) { // [!code ++:4]
    // 仅当count变化时更新
    return this.props.count !== nextProps.count
  }

  render() {
    console.log('Child rendered')
    // ...
  }
}
```

我们重新分别点击 `Increment Count` 和 `Change Other Value` 按钮，可以看到:

::: center
![render](/images/react/optimize/rendered-3.png){style="max-width:640px"}
:::

### PureComponent

[**React** -> PureComponent](https://zh-hans.react.dev/reference/react/PureComponent){.read-more}

除了使用 `shouldComponentUpdate` 进行优化外，React 还提供了一个更加简便的方法：使用 `PureComponent`。

`PureComponent` 类似于 `Component`，但是当 `props` 和 `state` 与之前保持一致时会跳过重新渲染。

我们使用 `PureComponent` 重写 `Child` 组件:

```tsx
class Child extends React.PureComponent {
  render() {
    console.log('Child rendered')
    return (
      <div>
        <h1>
          Child Count:
          {this.props.count}
        </h1>
      </div>
    )
  }
}
```

当 `count` 一致时，`Child` 会跳过重新渲染。

需要注意的是，`PureComponent` 只对 `Props` 和 `State` 进行浅比较，
如果 props 或 state 中包含复杂的数据结构（如对象或数组），浅比较可能无法正确判断数据是否发生变化。
在这种情况下，可以使用深比较或手动实现 `shouldComponentUpdate` 来确保组件正确地更新。

**浅比较的注意事项**：

```mermaid
graph LR
    A[原始数据] --> B[浅比较]
    C[对象/数组] --> D[引用地址比较]
    E[基本类型] --> F[值比较]
    B --> D
    B --> F
```

:::important 重要提示
当 props 包含嵌套对象时，需返回新引用（如 `[...list]` 或 `{...obj}`）才能触发更新。
:::

## 函数组件渲染性能优化

我们来看下面的 函数组件 例子：

::: tip 这是 React 推荐的函数组件写法
它实现了与上面的 类组件实现的 应用完全相同的功能。
:::

```tsx
import { useState } from 'react'

function Child({ count }) {
  console.log('Child rendered')
  return (
    <div>
      <h1>
        Child Count:
        {count}
      </h1>
    </div>
  )
}

function App() {
  const [count, setCount] = useState(0)
  const [otherValue, setOtherValue] = useState('Hello')

  const increment = () => {
    setCount(prevCount => prevCount + 1)
  }

  const changeOtherValue = () => {
    setOtherValue(prevValue => prevValue === 'Hello' ? 'World' : 'Hello')
  }

  console.log('Parent rendered')
  return (
    <div>
      <h1>
        otherValue:
        {otherValue}
      </h1>
      <Child count={count} />
      <button onClick={increment}>Increment Count</button>
      <button onClick={changeOtherValue}>Change Other Value</button>
    </div>
  )
}

export default App
```

当我们点击 `Increment Count` 按钮时，`App` 的 `count` 会增加，
此时，`App` 会重新渲染，`Child` 也会重新渲染。

::: center
![render-1](/images/react/optimize/rendered-1.png){style="max-width:640px"}
:::

当我们点击 `Change Other Value` 按钮时，`otherValue` 发生了改变，`App` 会重新渲染。
虽然 `Child` 组件没有用到 `otherValue`, 但 `Child` 依然重新渲染了。

::: center
![render-2](/images/react/optimize/rendered-2.png){style="max-width:640px"}
:::

### React.memo

[**React** -> memo](https://zh-hans.react.dev/reference/react/memo){.read-more}

`React.memo` 是一个高阶组件，使用 `memo` 将组件包装起来，以获得该组件的一个 记忆化 版本。
通常情况下，只要该组件的 props 没有改变，这个记忆化版本就不会在其父组件重新渲染时重新渲染。

我们使用 `React.memo` 重写 `Child` 组件:

```tsx
const Child = React.memo(({ count }) => { // [!code ++]
  console.log('Child rendered')
  return (
    <div>
      <h1>
        Child Count:
        {count}
      </h1>
    </div>
  )
})
```

我们重新分别点击 `Increment Count` 和 `Change Other Value` 按钮，可以看到:

::: center
![render](/images/react/optimize/rendered-3.png){style="max-width:640px"}
:::

::: tip 可以把 `React.memo` 看做是 `PureComponent` 的等价实现
`Rect.memo` 只对 `props` 进行浅比较
:::

对于 `props` 为比较复杂的数据结构时，我们可以在需要更新时返回一个新的对象或数组，以避免浅比较的问题。

还可以使用 `React.memo` 的第二个参数，自定义 `props` 的比较逻辑。

**React.memo 语法**：

```tsx
const Child = React.memo(
  props => <div>{/* ... */}</div>,
  (prevProps, nextProps) => {
    // 自定义比较逻辑
    // 如果返回true，表示新旧props相等，不渲染 与shouldComponentUpdate相反
    // 如果返回false，表示新旧props不等，重新渲染
  }
)
```

### useCallback

[**React** -> useCallback](https://zh-hans.react.dev/reference/react/useCallback){.read-more}

`useCallback` 是 React 提供的 `hook`，它用于在多次渲染中 ==缓存函数==。

我们重新调整下 `App` 的代码，将 `increment` 作为 `Child` 的 `props`，将按钮置于 `Child` 中：

```tsx
import React, { useState } from 'react'

const Child = React.memo(({ count, increment }: { count: number, increment: () => void }) => {
  console.log('Child rendered')
  return (
    <div>
      <h1>
        Child Count:
        {count}
      </h1>
      <button onClick={increment}>Increment Count</button>
    </div>
  )
})

function App() {
  const [count, setCount] = useState(0)
  const [otherValue, setOtherValue] = useState('Hello')

  const increment = () => {
    setCount(prevCount => prevCount + 1)
  }

  const changeOtherValue = () => {
    setOtherValue(prevValue => prevValue === 'Hello' ? 'World' : 'Hello')
  }

  console.log('Parent rendered')
  return (
    <div>
      <h1>
        otherValue:
        {otherValue}
      </h1>
      <button onClick={changeOtherValue}>Change Other Value</button>
      <Child count={count} increment={increment} />
    </div>
  )
}

export default App
```

分别点击 `Increment Count` 和 `Change Other Value` 按钮，可以看到:

::: center
![useCallback-1](/images/react/optimize/use-callback-1.png){style="max-width:640px"}
:::

当 `otherValue` 变化时，`App` 和 `Child` 都重新渲染了， `Child` 组件并没有使用 `otherValue` 。

实际问题是由于 `App` **每次重新渲染时，都创建了新的 `increment` 函数**，这对于 `Child` 来说，
`props` 发生了变化，所以重新渲染。

这显然是不必要的，可以使用 `useCallback` 来缓存 `increment` 函数:

```tsx
function App() {
  // ...
  const increment = useCallback(() => {
    setCount(prevCount => prevCount + 1)
  }, [])
  // ...
}
```

`useCallback` 接收两个参数，第一个参数是要缓存的函数，第二个参数是一个依赖项数组，如果依赖项发生变化，缓存的函数会重新创建。

在本示例中，由于 `increment` 比较简单，它不需要依赖项，所以只需要传入一个空数组即可。

分别点击 `Increment Count` 和 `Change Other Value` 按钮，可以看到:

::: center
![useCallback-2](/images/react/optimize/use-callback-2.png){style="max-width:640px"}
:::

可以看到，当 `otherValue` 变化时，`Child` 没有重新渲染了，这符合我们的预期。

::: important 实际开发中， `React.memo` 和 `useCallback` 通常会一起使用，以减少不必要的组件渲染，从而提高性能。
:::

::: warning 注意
在某些文章中会提到 `useCallback` 可以避免不必要的 **函数创建** 。这种说法是 ==错误的=={.danger} ！！！

函数组件在每次执行时，都会创建新的执行上下文，在函数作用域内，传入 `useCallback` 的函数，每次都是一个新的函数。

`useCallback` 的核心并不是在阻止函数的创建，而是 ==控制函数引用的更新时机=={.important} 。从而避免与其相关的组件
由于引用发生变化，导致不必要的重新渲染，从而提高性能。
:::

### useMemo

[**React** -> useMemo](https://zh-hans.react.dev/reference/react/useMemo){.read-more}

`useMemo` 用于缓存计算结果，避免在每次渲染时重新计算。

它适合在一些计算代价比较大的操作中使用。

::: info 说明
`useMemo` 有些类似于 `Vue` 的 `computed` 计算属性。

它缓存了当前计算结果，在下次渲染时，只要依赖项没有发生变化，则跳过计算，直接返回缓存的结果。
:::

举个例子，当我们在实现一个购物车功能时，总价需要根据当前购物车中的商品进行计算，
如果每次重新渲染时都需要重新计算总价，可能产生的代价是高昂的，浪费了性能。

我们可以使用 `useMemo` 来缓存计算结果，避免在每次渲染时重新计算:

```tsx
function ShoppingCart({ items }) {
  const total = useMemo(() => {
    console.log('计算总价...')
    return items.reduce((sum, item) =>
      sum + item.price * item.quantity, 0)
  }, [items]) // 仅当items变化时重新计算

  return (
    <div>
      总价:
      {total}
    </div>
  )
}
```

我们回到最开始的 `App` 应用，增加一个 `doubleCount` ，它需要根据 `count` 进行计算:

```tsx
function App() {
  // ...
  // 处于演示目的，使用一个简单的函数，实际可以直接写为 doubleCount = count * 2
  const doubleCount = () => { // [!code ++:4]
    console.log('doubleCount called')
    return count * 2
  }
  // ...
  console.log('App rendered')
  return (
    <div>
      {/* ... */}
      <p>
        Double Count:
        {doubleCount()}
      </p>
    </div>
  )
}
```

::: center
![useMemo-1](/images/react/optimize/use-memo-1.png){style="max-width:640px"}
:::

可以看到，不管是更新 `count` 还是更新 `otherValue` ， `doubleCount` 都会重新计算。
但 `doubleCount` 仅需要在 `count` 发生变化时才会重新计算，而 `otherValue` 变化时没必要重新计算。

此时我们可以使用 `useMemo` 来缓存计算结果，避免在每次渲染时重新计算:

```tsx
function App() {
  // ...
  const doubleCount = useMemo(() => { // [!code ++:4]
    console.log('doubleCount called')
    return count * 2
  }, [count])
  // ...
  console.log('App rendered')
  return (
    <div>
      {/* ... */}
      <p>
        Double Count:
        {doubleCount}
      </p>
    </div>
  )
}
```

::: center
![useMemo-2](/images/react/optimize/use-memo-2.png){style="max-width:640px"}
:::

可以看到， 当 `count` 变化时，`doubleCount` 重新计算，但 `otherValue` 变化时，`doubleCount` 没有重新计算，这符合我们的预期。

### 对比

| 特性       | React.memo                                  | useCallback                        | useMemo                            |
| :--------: | ------------------------------------------- | ---------------------------------- | ---------------------------------- |
| 主要功能   | 缓存组件                                    | 缓存函数                           | 缓存计算结果                       |
| 使用场景   | 当传入的 props 没有变化时，避免组件重新渲染 | 当函数没有变化时，避免函数重新执行 | 当计算结果没有变化时，避免重新计算 |
| 依赖项     | props                                       | 依赖数组                           | 依赖数组                           |
| 缓存目标   | 组件实例                                    | 函数引用                           | 计算结果                           |
| 返回值类型 | 组件                                        | 函数                               | 任意值                             |

## 总结

React 渲染优化核心在于 **精确控制组件更新时机** 。

特别需要注意的是：

* 所有优化都基于浅比较原理
* 函数组件优化需要 hooks 的配合使用
* 复杂数据结构需保证引用更新可预测性

::: important 性能优化第一原则
只有在性能监测工具（如 React DevTools Profiler）确认存在性能问题后才进行优化，避免过早优化带来的代码复杂度。
:::

---

---
url: /article/m0kwurpc/index.md
---
# React 原理解析——优先级调度
::: warning 🚧 施工中...
:::

React 的并发渲染能力依赖于其精细的优先级调度系统，==Lanes 模型== 是这一系统的基石。

## Lanes 模型

它使用 ==31 位二进制掩码== 表示不同优先级的更新任务，每个位称为一个 "Lane"（优先级通道）。

```txt
> 0b 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
                                                                 ^
                                                                最高优先级
> 0b 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0
                                                               ^
                                                               第二优先级
> 0b 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1
                                                         ^     ^ ^
                                                         优先级组合
```

* 每个 Lane 对应一个二进制位，共 31 个
* 优先级从右向左递减（SyncLane 在 bit 2）
* 相同类型任务复用 lane 组（如 TransitionLanes 含 14 个 lane）

## Lanes 类型

1. **同步优先级**
   * `SyncHydrationLane`
   * `SyncLane`
2. **连续输入优先级**
   * `InputContinuousHydrationLane`
   * `InputContinuousLane`
3. **默认优先级**
   * `DefaultHydrationLane`
   * `DefaultLane`
4. **过渡优先级**
   * `TransitionHydrationLane`
   * `TransitionLane`, `TransitionLane1` ~ `TransitionLane14`
5. **重试优先级**
   * `RetryLanes`
   * `RetryLane1` ~ `RetryLane4`
6. **空闲优先级**
   * `IdleHydrationLane`
   * `IdleLane`
   * `OffscreenLane`
   * `DeferredLane`

[源码位置：**facebook/react** / **react-reconciler/src/ReactFiberLane.js#L39**](https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberLane.js#L36-L105){.read-more}

```ts :collapsed-lines
export const TotalLanes = 31

export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000
export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000

export const SyncHydrationLane: Lane = /*               */ 0b0000000000000000000000000000001
export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000010
export const SyncLaneIndex: number = 1

export const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000100
export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000001000

export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000010000
export const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000100000

export const SyncUpdateLanes: Lane
  = SyncLane | InputContinuousLane | DefaultLane

export const GestureLane: Lane = /*                     */ 0b0000000000000000000000001000000

const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000010000000
const TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111100000000
const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000100000000
const TransitionLane2: Lane = /*                        */ 0b0000000000000000000001000000000
const TransitionLane3: Lane = /*                        */ 0b0000000000000000000010000000000
const TransitionLane4: Lane = /*                        */ 0b0000000000000000000100000000000
const TransitionLane5: Lane = /*                        */ 0b0000000000000000001000000000000
const TransitionLane6: Lane = /*                        */ 0b0000000000000000010000000000000
const TransitionLane7: Lane = /*                        */ 0b0000000000000000100000000000000
const TransitionLane8: Lane = /*                        */ 0b0000000000000001000000000000000
const TransitionLane9: Lane = /*                        */ 0b0000000000000010000000000000000
const TransitionLane10: Lane = /*                       */ 0b0000000000000100000000000000000
const TransitionLane11: Lane = /*                       */ 0b0000000000001000000000000000000
const TransitionLane12: Lane = /*                       */ 0b0000000000010000000000000000000
const TransitionLane13: Lane = /*                       */ 0b0000000000100000000000000000000
const TransitionLane14: Lane = /*                       */ 0b0000000001000000000000000000000

const RetryLanes: Lanes = /*                            */ 0b0000011110000000000000000000000
const RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000
const RetryLane2: Lane = /*                             */ 0b0000000100000000000000000000000
const RetryLane3: Lane = /*                             */ 0b0000001000000000000000000000000
const RetryLane4: Lane = /*                             */ 0b0000010000000000000000000000000

export const SomeRetryLane: Lane = RetryLane1

export const SelectiveHydrationLane: Lane = /*          */ 0b0000100000000000000000000000000

const NonIdleLanes: Lanes = /*                          */ 0b0000111111111111111111111111111

export const IdleHydrationLane: Lane = /*               */ 0b0001000000000000000000000000000
export const IdleLane: Lane = /*                        */ 0b0010000000000000000000000000000

export const OffscreenLane: Lane = /*                   */ 0b0100000000000000000000000000000
export const DeferredLane: Lane = /*                    */ 0b1000000000000000000000000000000

// Any lane that might schedule an update. This is used to detect infinite
// update loops, so it doesn't include hydration lanes or retries.
export const UpdateLanes: Lanes
  = SyncLane | InputContinuousLane | DefaultLane | TransitionLanes

export const HydrationLanes
  = SyncHydrationLane
    | InputContinuousHydrationLane
    | DefaultHydrationLane
    | TransitionHydrationLane
    | SelectiveHydrationLane
    | IdleHydrationLane
```

## Lanes 操作机制

### 优先级计算

React 使用位运算实现高效优先级管理：

```ts
// 获取最高优先级Lane（最右侧的1）
export function getHighestPriorityLane(lanes: Lanes): Lane {
  return lanes & -lanes // 补码技巧：-lanes = ~lanes + 1
}

// 获取等或更高优先级的Lanes集合
function getLanesOfEqualOrHigherPriority(lanes: Lanes): Lanes {
  const lowestIndex = 31 - clz32(lanes) // 计算前导零
  return (1 << (lowestIndex + 1)) - 1 // 生成掩码
}
```

**位运算优势：**

* $O(1)$ 时间复杂度完成优先级查询
* 单次操作处理多个Lane（批量更新）
* 内存紧凑（单数字存储完整状态）

### 调度状态机

React 使用三状态模型管理任务生命周期：

```mermaid
stateDiagram-v2
    [*] --> Pending： 更新产生
    Pending --> Suspended： 数据未就绪
    Suspended --> Pinged： 数据到达
    Pinged --> Pending： 重试渲染
    Pending --> Committed： 渲染完成
    Suspended --> Expired： 超时处理
```

对应代码实现：

```ts
// 标记挂起任务
export function markRootSuspended(root: FiberRoot, suspendedLanes: Lanes) {
  root.suspendedLanes |= suspendedLanes
  root.pingedLanes &= ~suspendedLanes
}

// 标记数据到达
export function markRootPinged(root: FiberRoot, pingedLanes: Lanes) {
  root.pingedLanes |= root.suspendedLanes & pingedLanes
}

// 检测过期任务
export function markStarvedLanesAsExpired(root, currentTime) {
  let lanes = root.pendingLanes
  while (lanes) {
    const index = 31 - clz32(lanes)
    const lane = 1 << index
    if (root.expirationTimes[index] <= currentTime) {
      root.expiredLanes |= lane // 标记过期
    }
    lanes &= ~lane
  }
}
```

## 任务调度算法

### 调度决策流程

```mermaid
graph TD
    Start[开始] --> CheckPending{有pending任务?}
    CheckPending -->|无| ReturnNoLanes[返回NoLanes]

    CheckPending -->|有| CheckNonIdle{非空闲任务?}
    CheckNonIdle -->|是| CheckUnblocked{未阻塞任务?}
    CheckUnblocked -->|是| GetHighest[获取最高优先级]
    CheckUnblocked -->|否| CheckPinged{被ping任务?}
    CheckPinged -->|是| GetHighest
    CheckPinged -->|否| CheckPrewarm{需预热任务?}
    CheckPrewarm -->|是| GetHighest

    CheckNonIdle -->|否| CheckIdleUnblocked{空闲未阻塞?}
    CheckIdleUnblocked -->|是| GetHighest
    CheckIdleUnblocked -->|否| CheckIdlePinged{空闲被ping?}

    GetHighest --> CheckInterrupt{可中断当前渲染?}
    CheckInterrupt -->|否| ReturnWIP[返回进行中任务]
    CheckInterrupt -->|是| ReturnNew[返回新任务]
```

### 关键调度逻辑

```ts
export function getNextLanes(root, wipLanes, rootHasPendingCommit) {
  const pendingLanes = root.pendingLanes

  // 分层处理策略
  const nonIdlePendingLanes = pendingLanes & NonIdleLanes
  if (nonIdlePendingLanes !== NoLanes) {
    // 优先级1：未阻塞任务
    const unblocked = nonIdlePendingLanes & ~root.suspendedLanes
    if (unblocked !== NoLanes)
      return getHighestPriorityLanes(unblocked)

    // 优先级2：被ping任务
    const pinged = nonIdlePendingLanes & root.pingedLanes
    if (pinged !== NoLanes)
      return getHighestPriorityLanes(pinged)

    // 优先级3：需预热任务
    if (!rootHasPendingCommit) {
      const toPrewarm = nonIdlePendingLanes & ~root.warmLanes
      if (toPrewarm !== NoLanes)
        return getHighestPriorityLanes(toPrewarm)
    }
  }

  // 中断保护机制
  if (wipLanes !== NoLanes && wipLanes !== nextLanes) {
    const nextLane = getHighestPriorityLane(nextLanes)
    const wipLane = getHighestPriorityLane(wipLanes)
    if (nextLane >= wipLane)
      return wipLanes // 不中断当前渲染
  }
}
```

**调度策略**：

* **非空闲任务优先**：确保用户交互及时响应
* **状态分层处理**：未阻塞任务 > 被ping任务 > 需预热任务
* **渲染连续性保护**：避免高优先级任务中断进行中的低优先级渲染

### 嵌套更新处理

React 通过纠缠（Entanglement）机制处理关联更新：

```ts
export function markRootEntangled(root, entangledLanes) {
  root.entangledLanes |= entangledLanes
  const entanglements = root.entanglements

  let lanes = root.entangledLanes
  while (lanes) {
    const index = 31 - clz32(lanes)
    const lane = 1 << index
    // 传播纠缠关系
    entanglements[index] |= entangledLanes
    lanes &= ~lane
  }
}
```

**纠缠场景**：

* 同一事件触发的多个更新
* 父组件更新触发的子组件更新
* `useDeferredValue` 关联更新

### 过期时间计算

```ts
function computeExpirationTime(lane, currentTime) {
  switch (lane) {
    case SyncLane: return currentTime + 250 // 250ms超时
    case DefaultLane: return currentTime + 5000 // 5s超时
    case TransitionLane1: return currentTime + 5000 // 5s超时
    case IdleLane: return NoTimestamp // 永不过期
  }
}
```

### 批量更新处理

```ts
export function upgradePendingLanesToSync(root, lanesToUpgrade) {
  root.pendingLanes |= SyncLane
  root.entangledLanes |= SyncLane

  let lanes = lanesToUpgrade
  while (lanes) {
    const index = 31 - clz32(lanes)
    const lane = 1 << index
    // 将多个Lane关联到SyncLane
    root.entanglements[SyncLaneIndex] |= lane
    lanes &= ~lane
  }
}
```

## 与Scheduler的协同

```mermaid
graph TD
    A[用户交互/网络响应] --> B[React 渲染器]
    B --> C{Lanes 模型}
    C --> D[分配Lane和优先级]
    D --> E[React Scheduler]
    E --> F[执行高优先级任务]
    E --> G[暂停低优先级任务]
    F --> H[DOM 更新]
    G --> I[等待空闲时段]
```

---

---
url: /article/m4a92nl5/index.md
---
# JavaScript 函数参数按值传递
我们知道，在 `ECMAScrip` 中， 函数的参数是 **按值传递** 的。

那么怎么理解 **按值传递** ？

简单来说， **把函数外部的值复制给函数内部的参数**，即 **把值从一个变量复制到另一个变量**。

那么也就是说，在函数内部，修改函数参数的值，不会改变外部变量的值。

我们来看一个例子：2

**示例1：**

```js
let a = 1
function foo(arg) {
  arg = 2
  console.log(arg)
}
foo(a) // 2
console.log(a) // 1
```

可以看出，外部变量`a`作为 函数 `foo` 的执行时参数值， 在函数内部修改传入的参数值进行修改，
函数执行后，并不会对外部变量`a` 发生修改。

这个例子确实说明了函数参数是按值传递的。

但是再来看另一个例子：

**示例2：**

```js
let obj1 = {
  a: 1,
}
function foo(arg) {
  arg.a = 2
  console.log(arg)
}
foo(obj1) // { a: 2 }
console.log(obj1) // { a: 2 }

let obj2 = {
  a: 1,
}
function bar(arg) {
  arg = 2
  console.log(arg)
}
bar(obj2) // 2
console.log(obj2) // { a: 1 }
```

在这个例子中， 函数`foo` 执行完后， 打印的 `obj1` 值发生了变化，说明函数`foo` 内部修改了外部变量`obj1`，
为什么会发生修改？而在 函数`bar` 执行后，`obj2` 值保持不变，这又是为什么？ 函数参数是否真的是 **按值传递**？

那么该如何理解 `函数参数是按值传递的`?

在理解这个之前，我们首先需要知道，`JavaScript` 的数据类型，以及不同数据类型的存储方式。

## 数据类型及其存储方式

我们知道， 在 `JavaScript` 中， 有两种 数据类型，分别是：**(1)基本数据类型**和 **(2)引用数据类型**，

* 基本数据类型：值 直接保存在 **栈（stack）** 中。

  ```js
  let a = 1
  let b = a
  a = 2
  console.log(a, b) // 2 1
  ```

  基本类型在 **栈** 中的赋值变动如下：
  ::: center
  ![function-value-stack](/images/func-value-stack.png){ style=width:500px; }
  :::

* 引用数据类型：值 保存在 **堆（heap）** 中， 并在 **栈（stack）** 中保存 值 在 **堆（heap）** 中的内存地址。

  ```js
  let a = { name: 'Mark' }
  let b = a
  b.name = 'John'
  console.log(a) // { name: 'John' }
  ```

  引用类型在 **栈** 和 **堆** 中的复制变动如下：
  ::: center
  ![function-value-stack](/images/func-value-heap.png){ style=width:680px; }
  :::

## 按值传递

我们从 数据类型来理解 `按值传递`, 那么可以发现， **传递** 的值， 是指在 **栈（stack）** 中保存的值。

即， 无论 **参数值** 是 基本数据类型还是引用数据类型， **传递** 的是 **栈（stack）** 中的值。

* 对于基本数据类型， 函数内部修改参数的值，实际上是修改的是 函数参数重新在 **栈（stack）** 中的内存片段保存的值。

* 对于引用数据类型， 函数参数 传递是的 引用类型在 **栈（stack）** 中的内存地址：
  * 如果直接修改参数的值，函数参数在 **栈（stack）** 中的内存片段保存的内存地址被覆盖。
  * 如果修改 参数对象的属性值，修改的是根据 函数参数在 **栈（stack）** 中的内存片段保存的内存地址对应的在 **堆（heap）** 中的值。

所以回头重新看 **示例1** 和 **示例2**， 均正确表述了 函数的参数是 **按值传递** 的。

---

---
url: /article/m63fd7lf/index.md
---
# WebComponent——custom elements
在我们的web应用开发中，HTML标签为我们提供了基础的应用和交互，我们使用HTML标签构建了各种各样丰富的web应用。

然而在我们开发web应用的过程中，html标签提供的语义化并不能完全满足我们的场景。
虽然在HTML5标准中，也增加了不少包括`<header>`、`<section>`、`<article>`、`<nav>`、`<container>`、`<footer>`
等语义化标签，但它们主要是为内容或布局添加的通用语义化标签，在实际的场景中，
我们还需要使用 `class` 等一些属性或者辅助说明，声明该标签的具体语义。

```html
<div class="login-wrapper"></div>
```

如果可以这么做呢：

```html
<login></login>
```

使用更加语义化的标签，满足我们各种场景，甚至是扩展已有标签的特性。那么我们该怎么做呢？

接下来是我们的主角： **[自定义元素（custom Elements）](http://w3c.github.io/webcomponents/spec/custom/)**

### 自定义元素

> 自定义元素能够帮助web开发者创建拥有自身特性的自定义标签。

### 创建自定义元素

*创建自定义元素有两种方式，这里只讨论 **DOM LEVEL 3** 提供的 `customElements`，在 **DOM LEVEL 2** 中的 `document.registerElement` 将作为补充内容在本文最后补充。*

[Custom Element API 规范](http://w3c.github.io/webcomponents/spec/custom/) 定义了`customElements`作为统一的对象管理自定义元素，并对ES6 class提供了更完善的支持。

> 规范还定义了 `CustomElementRegistry`, 并且 `customElements instanceof CustomElementRegistry`。

我们可以通过 `customElements.define()` 方法来注册一个custom element，该方法接受以下参数：
`customElements.define(tarName, class[, option])`

* `tarName`: `DOMString`，用于表示所创建的元素名称。名称必须是小写字母开头，且必须包含至少一个`-`，任何不含`-`的自定义标签都会导致错误。例如`my-tag`,`my-list-item`为合法标签，`my_tag`,`myTag`都是非法的自定义标签名称；
* `class`: 类对象，用于定义元素行为.
* `option`: 包含 `extends` 属性的配置对象，可以指定所创建的元素继承自那个内置元素，可以继承任何内置元素；

`customElements`的类对象可以通过 ES 2015的类语法定义：

```javascript
class MyTag extends HTMLElement {
  constructor(options) {
    super()
  }
}
customElements.define('my-tag', MyTag)
```

### 使用自定义元素的生命周期回调函数

在`customElements`的构造函数中，我们可以指定多个不同的回调函数，他们会在不同的声明周期被触发。

* `connectedCallback`: 元素首次插入到文档DOM时回调；
* `discannectedCallback`: 元素从文档DOM中删除时回调；
* `attributeChangedCallback`： 元素增加、删除、修改自身属性时回调；
* `adoptedCallback`：元素被移动到新的文档时回调；

```javascript
class MyCustom extends HTMLElement {
  // 自定义元素开始提升时调用
  // 元素提升并不说明元素已插入到文档中
  // 在此阶段尽量避免进行DOM操作
  constructor(options) {
    super()
  }

  // 元素插入到文档时回调
  connectedCallback() {
    // do something...
  }

  // 元素从文档中删除时回调
  discannectedCallback() {
    // do something...
  }

  /*
   * 元素属性变化回调
   * @param name {string} 变化的属性名
   * @param oldValue {any} 变化前的值
   * @param newVlalue {any} 变化后的值
   */
  attributeChangedCallback(name, oldValue, newValue) {
    // do something...
  }

  // 元素被移动到新的文档中时调用
  // （When it is adopted into a new document, its adoptedCallback is run.）
  // 具体场景示例：通过document.adoptNode方法修改元素ownerDocument属性时可以触发
  adoptedCallback() {
    // do something...
  }
}
```

如果需要在元素属性发生变化后触发 `attributeChangedCallback`，就必须监听这些属性。 我们可以通过定义静态属性`observedAttributed`的 get函数来添加需要监听的属性：

```js
class MyCustom extends HTMLElement {
  static get observedAttributed() {
    return ['name']
  }
}
```

### 使用自定义元素

我们可以在文档的任何地方使用`customElements.define`注册的自定义元素，即使是在自定义元素注册之前。

```html
<my-tag></my-tag>
```

或者：

```js
class MyTag extends HTMLElement {
  constructor(options) {
    super()
  }
}
customElements.define('my-tag', MyTag)

// 方式一：
let tag1 = document.createElement('my-tag')
document.appendChild(tag1)
// 方式二：
let tag2 = new MyTag()
document.appendChild(tag2)
```

### 元素提升

浏览器是如何解析非标准的标签的？为什么对非标准的标签，浏览器不会报错？

> HTML规范：
> 非规范定义的元素必须使用 *HTMLUnknownElement* 接口。

我们在页面中声明一个 `<myTag>`标签，由于它是非标准标签，所以会继承 `HTMLUnknownElement`。

对于自定义元素，情况有所不同。 拥有合法元素名称的自定义元素继承自`HTMLElement`。
对于不支持自定义元素的浏览器，拥有合法元素名称的标签，仍然继承`HTMLUnknownElement`。

### 扩展内置元素特性

在创建自定义元素时，置顶所需的扩展的元素，使用时，在内置元素上声明`is`属性指定自定义元素名称：

```js
class CustomButton extends HTMLButtonElement {
  constructor(options) {
    super()
  }
}
customElements.define('custom-button', CustomButton, {
  extends: 'button',
})
```

```html
<button is="custom-button"></button>
```

### 自定义元素样式

自定义元素和内置元素一样，可以使用CSS各类选择器定义样式。

自定义元素规范还提出了一个新的CSS伪类`:unresolved`。在浏览器调用你的`createdCallback()` 之前，这个伪类可以匹配到未完成元素提升的自定义元素。

```css
custom-button {
  opacity: 1;
  transition: opacity 300ms;
}
custom-button:unresolved {
  opacity: 0;
}
```

> :unresolved 不能用于继承自HTMLUnkownElement的元素。

### 浏览器支持

`Chrome`和`Opera`默认支持custom elements。`Firefox`计划在60/61的版本中默认支持自定义元素。`Safair`目前不支持自定义元素对内置元素的扩展。`Edge`在实现中。

### 补充内容：`document.registerElement`

使用`document.registerElement()` 创建自定义元素

```javascript
let MyTag = document.registerElement('my-tag')
```

添加自定义元素特性：

```javascript
let proto = Object.create(HTMLElement.prototype)
proto.hello = 'hello'
proto.sayHello = function () {
  alert(this.hello)
}
let MyTag = document.registerElement('my-tag', {
  prototype: proto,
})
```

扩展原生元素特性

`document.registerElement()` 的第二个参数还允许我们为扩展原生素的特性。

```javascript
let MyButton = document.registerElement('my-button', {
  extend: 'button',
  prototpye: Object.create(HTMLButtonElement.prototype),
})
```

```html
<button is="my-button"><button></button></button>
```

生命周期以及回调方法

1. createdCallback(): 元素创建后回调。
2. attachCallback(): 元素附加到文档后调用。
3. detachCallback(): 元素从文档移除后调用。
4. attributeChangedCallback(): 元素任意属性变化后调用。

```javascript
let myTagProto = Object.create(HTMLElement.prototype)

myTagProto.createdCallback = function () {
  // 元素创建后回调。
  this.textContent = '我被创建了'
}

let MyTag = document.registerElement('my-tag', {
  prototype: myTagProto,
})
```

### 结语

自定义元素作为 `webComponent` 规范中的一部分，为web应用开发提供了更多的可能性，配合`webComponent` 规范的其他内容，可以为web开发者提供更强大的能力。

---

---
url: /article/mj6buh4l/index.md
---
# JavaScript 进阶 五：事件循环
## 引言

想象一下你经营着一家网红奶茶店（主线程），柜台后只有你一位店员。客人下单（代码执行）时你会快速制作当前订单（同步任务），遇到需要等待的操作（比如要煮珍珠），你会先把这单暂时搁置（挂起异步任务），继续处理下一个订单（执行后续代码）。
等计时器响起（异步任务完成），再把完成的订单交给顾客（回调执行）。这种高效的排队处理机制，就是 JavaScript 事件循环的核心逻辑。

:::info 为什么需要事件循环？
JavaScript 是单线程语言，意味着它一次只能执行一个任务。如果没有事件循环，任何耗时操作都会阻塞整个程序的执行。事件循环通过异步处理机制，让 JavaScript 能够"同时"处理多个任务，保持应用的响应性。
:::

## 一、浏览器的事件循环机制

### 1.1 核心架构模型

浏览器的事件循环基于三层处理机制：

```javascript
// 浏览器环境示例（技术栈：ES6+）
console.log('开始准备珍珠') // 同步任务1

setTimeout(() => {
  console.log('定时器煮好了珍珠') // 宏任务回调
}, 1000)

new Promise((resolve) => {
  console.log('正在煮波霸珍珠') // 同步任务2
  resolve()
}).then(() => {
  console.log('波霸准备完成') // 微任务回调
})

console.log('开始制作奶茶基底') // 同步任务3

/* 执行顺序：
1. 开始准备珍珠
2. 正在煮波霸珍珠
3. 开始制作奶茶基底
4. 波霸准备完成
5. 定时器煮好了珍珠（约1秒后）
*/
```

::: card

* 浏览器运行时环境
  * 执行栈（Call Stack）
    * 同步代码
  * 微任务队列（Microtask Queue）
    * Promise.then
    * MutationObserver
    * queueMicrotask
  * 宏任务队列（Macrotask Queue）
    * setTimeout
    * setInterval
    * I/O 操作
    * UI 渲染
      :::

### 1.2 事件循环完整流程

事件循环按照以下顺序处理任务：

:::steps

* **步骤1**：执行当前执行栈中的所有同步代码
* **步骤2**：检查微任务队列，执行所有微任务直到队列清空
* **步骤3**：执行一个宏任务
* **步骤4**：再次检查并执行所有微任务
* **步骤5**：进行 UI 渲染（如果需要）
* **步骤6**：开始下一轮事件循环

:::

### 1.3 复杂场景分析

```javascript
function complexExample() {
  console.log('开始冲泡奶茶')

  setTimeout(() => {
    console.log('定时器1完成')
    Promise.resolve().then(() => console.log('定时器1的微任务'))
  }, 0)

  new Promise((resolve) => {
    console.log('正在称量茶叶')
    resolve()
  }).then(() => {
    console.log('茶叶称量完成')
    setTimeout(() => console.log('微任务中的定时器'), 0)
  })

  requestAnimationFrame(() => {
    console.log('动画帧回调')
  })
}

complexExample()

/* 典型输出顺序：
1. 开始冲泡奶茶
2. 正在称量茶叶
3. 茶叶称量完成
4. 动画帧回调
5. 定时器1完成
6. 定时器1的微任务
7. 微任务中的定时器
*/
```

## 二、Node.js 的事件循环机制

### 2.1 libuv 引擎的六层处理结构

Node.js 采用更复杂的事件循环阶段轮询机制：

```mermaid
graph LR
A[Timers] --> B[Pending I/O]
B --> C[Idle/Prepare]
C --> D[Poll]
D --> E[Check]
E --> F[Close]
F --> A
```

### 2.2 各阶段详解

:::code-tabs
@tab Timers 阶段

```javascript
// 处理 setTimeout 和 setInterval 回调
setTimeout(() => {
  console.log('计时器回调')
}, 0)
```

@tab Poll 阶段

```javascript
// 执行 I/O 回调，检索新事件
fs.readFile('file.txt', (err, data) => {
  if (err)
    throw err
  console.log('文件读取完成')
})
```

@tab Check 阶段

```javascript
// 专门处理 setImmediate 回调
setImmediate(() => {
  console.log('setImmediate 回调')
})
```

:::

### 2.3 Node.js 特殊 API

```javascript
// Node.js 环境示例（技术栈：Node 14+）
console.log('阶段1: 启动程序')

setImmediate(() => {
  console.log('阶段5: setImmediate回调')
})

setTimeout(() => {
  console.log('阶段1: 计时器回调')
}, 0)

Promise.resolve().then(() => {
  console.log('微任务队列')
})

process.nextTick(() => {
  console.log('nextTick队列')
})

/* 执行顺序：
1. 阶段1: 启动程序
2. nextTick队列
3. 微任务队列
4. 阶段1: 计时器回调
5. 阶段5: setImmediate回调
*/
```

:::warning 注意
`process.nextTick` 拥有独立最高优先级，在每个阶段切换时都会优先处理，甚至比 Promise 微任务还要早执行。
:::

## 三、浏览器与 Node.js 的关键差异

### 3.1 架构对比表

| 特性 | 浏览器环境 | Node.js 环境 |
|------|------------|--------------|
| **任务队列架构** | 两层队列体系 | 六阶段轮询机制 |
| **微任务执行时机** | 每个宏任务结束后 | 各阶段切换时 |
| **nextTick** | 不存在 | 拥有独立最高优先级 |
| **渲染时机** | 每个循环周期可能渲染 | 不涉及 DOM 渲染 |
| **setImmediate** | 不支持 | 支持并用于阶段控制 |
| **文件 I/O 处理** | XMLHttpRequest 等 | fs 模块异步 API |

### 3.2 执行顺序差异深度解析

```javascript
// 复杂执行顺序示例
console.log('Main')

setTimeout(() => {
  console.log('Timeout 1')
  process.nextTick(() => console.log('nextTick in Timeout'))
}, 0)

setImmediate(() => {
  console.log('Immediate 1')
  Promise.resolve().then(() => console.log('Promise in Immediate'))
})

Promise.resolve().then(() => console.log('Promise 1'))
process.nextTick(() => console.log('nextTick 1'))

/* Node.js 输出顺序：
Main → nextTick 1 → Promise 1 → Timeout 1 → nextTick in Timeout → Immediate 1 → Promise in Immediate
*/
```

## 四、任务类型详解

### 4.1 宏任务（MacroTasks）

宏任务是 JavaScript 事件循环中较大的任务单元：

:::code-tabs
@tab 定时器任务

```javascript
setTimeout(() => {
  console.log('setTimeout 宏任务')
}, 0)

setInterval(() => {
  console.log('setInterval 宏任务')
}, 1000)
```

@tab I/O 操作

```javascript
// 浏览器
fetch('/api/data')
  .then(response => response.json())
  .then(data => console.log(data))

// Node.js
fs.readFile('file.txt', (err, data) => {
  if (err)
    throw err
  console.log('文件读取完成')
})
```

@tab UI 渲染

```javascript
// 浏览器专用
requestAnimationFrame(() => {
  // 动画更新逻辑
  element.style.transform = 'translateX(100px)'
})
```

:::

### 4.2 微任务（MicroTasks）

微任务在当前宏任务执行完毕后立即执行：

:::code-tabs
@tab Promise

```javascript
Promise.resolve()
  .then(() => console.log('Promise.then 微任务'))
  .then(() => console.log('链式微任务'))
```

@tab async/await

```javascript
async function asyncExample() {
  console.log('1') // 同步
  await console.log('2') // 同步
  console.log('3') // 微任务
}
```

@tab queueMicrotask

```javascript
queueMicrotask(() => {
  console.log('queueMicrotask 微任务')
})
```

:::

## 五、实战应用与性能优化

### 5.1 浏览器环境优化实践

**浏览器阻塞示例：**

```javascript
// 危险操作：同步阻塞
document.querySelector('#load-btn').addEventListener('click', () => {
  const data = JSON.parse(largeJsonString) // 假设这是很大的 JSON
  renderList(data) // 复杂 DOM 操作

  // 正确做法应该是：
  // 1. 使用 Web Worker 处理数据解析
  // 2. 分帧渲染列表项
})
```

**优化方案：**

```javascript
// 使用微任务优化用户交互
function debounce(func, wait) {
  let timeout
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout)
      func(...args)
    }
    clearTimeout(timeout)
    timeout = setTimeout(later, wait)
  }
}

// 使用 requestAnimationFrame 优化动画
function smoothAnimation(element) {
  let start = null

  function step(timestamp) {
    if (!start)
      start = timestamp
    const progress = timestamp - start

    element.style.transform = `translateX(${Math.min(progress / 10, 200)}px)`

    if (progress < 2000) {
      requestAnimationFrame(step)
    }
  }

  requestAnimationFrame(step)
}
```

### 5.2 Node.js 服务端优化要点

```javascript
// Node.js 优化示例
function processData(data) {
  // 低效的同步处理
  // return cpuIntensiveTask(data);

  // 优化方案：使用 setImmediate 释放事件循环
  return new Promise((resolve, reject) => {
    setImmediate(() => {
      try {
        const result = cpuIntensiveTask(data)
        resolve(result)
      }
      catch (err) {
        reject(err)
      }
    })
  })
}

// 使用工作线程处理 CPU 密集型任务
const { Worker } = require('node:worker_threads')

function heavyComputation(data) {
  return new Promise((resolve, reject) => {
    const worker = new Worker('./computation-worker.js', {
      workerData: data
    })

    worker.on('message', resolve)
    worker.on('error', reject)
    worker.on('exit', (code) => {
      if (code !== 0) {
        reject(new Error(`Worker stopped with exit code ${code}`))
      }
    })
  })
}
```

## 六、常见陷阱与规避策略

### 6.1 微任务递归导致的饥饿问题

```javascript
// 危险示例：微任务递归导致宏任务饥饿
function microtaskLoop() {
  Promise.resolve().then(() => {
    console.log('Microtask executed')
    microtaskLoop() // 递归调用
  })
}

// 浏览器：会强制中断无限微任务链（如 Chrome 的 100 万次限制）
// Node.js：无此保护机制，可能导致事件循环完全阻塞
```

**解决方案：**

```javascript
// 使用宏任务分解长任务
function processInChunks(data, chunkSize = 1000) {
  let index = 0

  function processChunk() {
    const chunk = data.slice(index, index + chunkSize)
    // 处理数据块...
    index += chunkSize

    if (index < data.length) {
      // 使用 setImmediate 或 setTimeout 让出控制权
      setImmediate(processChunk)
    }
  }

  processChunk()
}
```

### 6.2 定时器精度与销毁

:::code-tabs
@tab Vue 中销毁定时器

```javascript
export default {
  mounted() {
    this.timer = setInterval(() => {
      console.log('Interval triggered')
    }, 1000)
  },
  beforeDestroy() { // Vue 2.x
    clearInterval(this.timer)
  },
  beforeUnmount() { // Vue 3.x
    clearInterval(this.timer)
  }
}
```

@tab React 中销毁定时器

```javascript
import React, { useEffect } from 'react'

function MyComponent() {
  useEffect(() => {
    const timer = setInterval(() => {
      console.log('Interval triggered')
    }, 1000)

    // 清理函数
    return () => clearInterval(timer)
  }, []) // 空依赖数组表示这个 effect 只在组件挂载时运行一次

  return <div>Check the console.</div>
}
```

:::

## 七、现代异步编程实践

### 7.1 Promise 进阶应用

```javascript
// Promise 组合使用
async function complexAsyncOperation() {
  try {
    const [user, settings] = await Promise.all([
      fetchUser(),
      fetchUserSettings()
    ])

    const processedData = await processUserData(user, settings)

    return await saveProcessedData(processedData)
  }
  catch (error) {
    console.error('操作失败:', error)
    throw error
  }
}

// 自定义 Promise 工具函数
class AsyncUtils {
  static delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms))
  }

  static timeout(promise, ms) {
    return Promise.race([
      promise,
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error('操作超时')), ms)
      )
    ])
  }

  static retry(operation, maxRetries = 3) {
    return new Promise((resolve, reject) => {
      const attempt = (retryCount) => {
        operation()
          .then(resolve)
          .catch((error) => {
            if (retryCount < maxRetries) {
              console.log(`重试 ${retryCount + 1}/${maxRetries}`)
              attempt(retryCount + 1)
            }
            else {
              reject(error)
            }
          })
      }
      attempt(0)
    })
  }
}
```

### 7.2 async/await 最佳实践

```javascript
// 错误处理模式
async function robustAsyncFunction() {
  try {
    const result = await potentiallyFailingOperation()
    return { success: true, data: result }
  }
  catch (error) {
    console.error('操作失败:', error)
    return { success: false, error: error.message }
  }
}

// 并行执行优化
async function parallelOperations() {
  // 错误的串行执行
  // const a = await operationA();
  // const b = await operationB();
  // const c = await operationC();

  // 正确的并行执行
  const [a, b, c] = await Promise.all([
    operationA(),
    operationB(),
    operationC()
  ])

  return { a, b, c }
}

// 流式处理大数据集
async function processLargeDataset(dataset) {
  const results = []

  for (const item of dataset) {
    // 使用 await 确保顺序但让出控制权
    const result = await processItem(item)
    results.push(result)

    // 定期让出控制权避免阻塞
    if (results.length % 100 === 0) {
      await AsyncUtils.delay(0)
    }
  }

  return results
}
```

## 八、总结与最佳实践

### 8.1 核心原则总结

:::important 浏览器开发要做到

* 优先使用微任务优化交互响应
* 合理分配不同优先级任务
* 关注长任务对用户体验的影响
* 动画处理优先使用 `requestAnimationFrame`
  :::

:::important Node.js 开发要注意

* 充分利用各阶段的特性
* 避免阻塞事件循环的误操作
* 正确处理不同优先级的回调
* 警惕 CPU 密集型任务阻塞
  :::

### 8.2 通用最佳实践

1. **始终牢记 JavaScript 的单线程本质**

2. **优先采用异步编程模式**

3. **合理使用任务类型**：
   * <50ms 的任务优先使用微任务
   * I/O 密集型操作使用宏任务分解
   * 动画更新使用 `requestAnimationFrame`

4. **内存管理**：
   * 及时移除事件监听器
   * 避免在微任务中创建大型对象
   * 使用 `WeakMap` 管理 DOM 引用

5. **错误处理**：
   * 保持异步操作的错误处理链路完整
   * 使用适当的超时机制
   * 实现重试逻辑处理临时故障

理解事件循环机制是成为高级 JavaScript 开发者的关键一步。
通过掌握浏览器和 Node.js 环境的不同实现，你能够编写出更高效、更可靠的异步代码，为用户提供更好的体验。

:::tip 实战建议
在实际项目中，多使用浏览器开发者工具的 Performance 面板和 Node.js 的 `--trace-event-categories` 标志来分析和优化你的事件循环性能。
:::

## 参考

* [MDN Web Docs: 并发模型与事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop)
* [Node.js 官方文档：事件循环](https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/)
* [Philip Roberts: 到底什么是事件循环？](https://www.youtube.com/watch?v=8aGhZQkoFbQ)（经典演讲）

---

---
url: /article/mlm6wnvq/index.md
---
# Vue 原理解析 —— diff 算法
[源码位置：**vuejs/core —— runtime-core/src/renderer.ts**](https://github.com/vuejs/core/blob/main/packages/runtime-core/src/renderer.ts){.read-more}

在 Vue 中，**虚拟 DOM（Virtual DOM）** 与 **`diff` 算法** 一直是高性能渲染的核心引擎。

Vue 3 对 `diff` 算法进行了革命性的重构，其性能提升远超 Vue 2，秘密就在于 **编译时优化** 与 **运行时靶向更新** 的完美结合。今天，我们就深入剖析 Vue 3 的 `diff` 算法，揭示其如何将 DOM 操作降至最低。

## 虚拟 DOM 和 Diff 算法的必要性

### 什么是虚拟 DOM

虚拟 DOM（Virtual DOM）是一个轻量级的 JavaScript 对象，它是对真实 DOM 结构的抽象表示。

当应用状态变化时，Vue 会创建一个新的虚拟 DOM 树，然后将其与上一次渲染的旧虚拟 DOM 树进行比较，计算出最小的变更集，最后将这些变更应用到真实 DOM 上。

```ts
// 简化的虚拟 DOM 节点表示
const vnode = {
  type: 'div',
  props: {
    id: 'app',
    class: 'container'
  },
  children: [
    { type: 'p', children: 'Hello Vue 3' },
    { type: 'button', children: 'Click me' }
  ]
}
```

### 为什么需要虚拟 DOM ？

频繁的直接操作真实 DOM 的成本极高：

* 浏览器渲染引擎工作流程复杂（解析、布局、绘制）
* 频繁的 DOM 操作会导致性能瓶颈
* 跨平台渲染的统一抽象层

虚拟 DOM 的核心价值在于：

* **抽象层**：提供与平台无关的UI描述，便于跨平台渲染。
* **批处理与优化**：将多次DOM操作合并为单次执行，减少昂贵操作。
* **差异最小化**：通过智能算法找出状态变更所需的最小DOM操作集。

### diff 算法的必要性

每次状态变更都完全替换 DOM 显然不可行：

```ts
// 低效的 DOM 替换
document.body.innerHTML = newHTML
```

diff 算法通过智能比较新旧虚拟 DOM 树，找出两者之间的差异，并仅更新必要的部分：

```ts
// 高效的差异更新
patch(oldVNode, newVNode)
```

**Diff 算法** 的核心任务就是高效地比较新旧两棵虚拟DOM树的差异，
并计算出应用于真实DOM的最小操作集合（如创建、移动、更新、删除节点）。
算法的效率直接决定了框架在复杂视图更新时的性能表现。

## 回顾 Vue 2 的 diff 算法

Vue2 采用的是一种双端比较（Two-Pointers Diff） 算法，主要策略包括：

* **同层比较**：只比较同一层级的节点，不跨层级移动节点。
* **双端四指针**：使用四个指针（oldStartIdx, oldEndIdx, newStartIdx, newEndIdx）同时从新旧子节点列表的两端向中间移动比较。
* **Key的重要性**：依赖key标识节点身份，识别可复用的节点。
* **就地复用**：尝试移动节点位置而非销毁重建。

### 典型流程

```ts
function updateChildren(oldCh, newCh) {
  let oldStartIdx = 0
  let newStartIdx = 0
  let oldEndIdx = oldCh.length - 1
  let newEndIdx = newCh.length - 1
  let oldStartVnode = oldCh[0]
  let newStartVnode = newCh[0]
  let oldEndVnode = oldCh[oldEndIdx]
  let newEndVnode = newCh[newEndIdx]

  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    // 四种比较情况：头头、尾尾、头尾、尾头
    if (isSameVnode(oldStartVnode, newStartVnode)) {
      patchVnode(oldStartVnode, newStartVnode)
      oldStartVnode = oldCh[++oldStartIdx]
      newStartVnode = newCh[++newStartIdx]
    }
    else if (isSameVnode(oldEndVnode, newEndVnode)) {
      // ...类似处理尾尾
    }
    else if (isSameVnode(oldStartVnode, newEndVnode)) {
      // ...头尾匹配，移动节点
    }
    else if (isSameVnode(oldEndVnode, newStartVnode)) {
      // ...尾头匹配，移动节点
    }
    else {
      // 暴力查找：遍历旧节点寻找匹配的新节点
      const idxInOld = findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
      if (idxInOld) {
        const vnodeToMove = oldCh[idxInOld]
        patchVnode(vnodeToMove, newStartVnode)
        parentElm.insertBefore(vnodeToMove.elm, oldStartVnode.elm)
        oldCh[idxInOld] = undefined // 标记已处理
      }
      else {
        createElm(newStartVnode, parentElm, oldStartVnode.elm)
      }
      newStartVnode = newCh[++newStartIdx]
    }
  }
  // 处理剩余节点...
}
```

[源码位置 - **vuejs/vue - core/vdom/patch.ts**](https://github.com/vuejs/vue/blob/main/src/core/vdom/patch.ts#L413){.read-more}

### 主要瓶颈

* **全量遍历**：即使节点无变化，仍需遍历所有节点进行isSameVnode检查。
* **潜在的高复杂度**：在无法通过双端匹配时（如列表乱序），退化为 $O(n²)$ 的暴力查找。
* **过度移动**：算法有时会产生非必要的DOM移动操作。

## 编译时优化

Vue 3 的核心突破在于编译器（`@vue/compiler-dom`）。
它在编译模板时，进行静态分析并注入优化提示，供运行时 `patch` 算法使用。

### 缓存静态内容

在模板中常常有部分内容是不带任何动态绑定的：

```html
<div>
  <div>foo</div> <!-- [!code hl:2]-->
  <div>bar</div>
  <div>{{ dynamic }}</div>
</div>
```

`foo` 和 `bar` 这两个 div 是完全静态的，没有必要在重新渲染时再次创建和比对它们。

编译器在编译 SFC 或模板字符串时，会识别出纯静态的节点（没有任何动态绑定 `v-bind`, `v-if`, `v-for`, 插值`{{ }}`等）和静态的 props。

**编译结果**：

```js
import { createCommentVNode as _createCommentVNode, createElementBlock as _createElementBlock, createElementVNode as _createElementVNode, openBlock as _openBlock, toDisplayString as _toDisplayString } from 'vue'

export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (_openBlock(), _createElementBlock('div', null, [
    _cache[0] || (_cache[0] = _createElementVNode('div', null, 'foo', -1 /* CACHED */)),
    _createCommentVNode(' cached '),
    _cache[1] || (_cache[1] = _createElementVNode('div', null, 'bar', -1 /* CACHED */)),
    _createCommentVNode(' cached '),
    _createElementVNode('div', null, _toDisplayString(_ctx.dynamic), 1 /* TEXT */)
  ]))
}
```

**作用**：

* **避免重新创建 VNode**： 这些静态节点或 props 对应的 VNode 对象在首次渲染时创建一次后，会被缓存起来。后续每次渲染都直接复用这个缓存的 VNode，而无需重新创建。
* **跳过 Diff**： 在 `patch` 过程中，当遇到这个静态 VNode 时，由于知道它永远不会改变，Vue 会完全跳过对这个节点及其整个子树的 diff 过程。

**收益**：

* 减少了创建 VNode 对象的开销（内存分配、GC 压力）。
* 显著缩小了需要 diff 的树的范围。大型应用中静态部分（如页头、页脚、固定布局元素）占比可能很高，跳过它们能极大提升性能。

当有足够多连续的静态元素时，它们还会再被压缩为一个“静态 vnode”，其中包含的是这些节点相应的纯 HTML 字符串。
这些静态节点会直接通过 innerHTML 来挂载。

::: code-tabs

@tab 源码

```html
<div>
  <div class="foo">foo</div>
  <div class="foo">foo</div>
  <div class="foo">foo</div>
  <div class="foo">foo</div>
  <div class="foo">foo</div>
  <div>{{ dynamic }}</div>
</div>
```

@tab 编译结果

```js
import { createElementBlock as _createElementBlock, createElementVNode as _createElementVNode, createStaticVNode as _createStaticVNode, openBlock as _openBlock, toDisplayString as _toDisplayString } from 'vue'

export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (_openBlock(), _createElementBlock('div', null, [
    _cache[0] || (_cache[0] = _createStaticVNode('<div class="foo">foo</div><div class="foo">foo</div><div class="foo">foo</div><div class="foo">foo</div><div class="foo">foo</div>', 5)),
    _createElementVNode('div', null, _toDisplayString(_ctx.dynamic), 1 /* TEXT */)
  ]))
}
```

:::

### 缓存事件处理函数

对于内联的事件处理函数 (如 `@click="handleClick(param)"` )，编译器会生成代码，在父组件更新时，只有当事件处理函数依赖的 param 真正改变时，才重新创建该函数。否则，复用之前的事件处理函数。

```vue
<script setup>
import { ref } from 'vue'

const dynamic = ref('Hello World!')
function onClick(val) {
  console.log(val)
}
</script>

<template>
  <div>
    <div @click="onClick(dynamic)">
      {{ dynamic }}
    </div>
  </div>
</template>
```

**编译结果**:

```js
import { createElementBlock as _createElementBlock, createElementVNode as _createElementVNode, openBlock as _openBlock, toDisplayString as _toDisplayString } from 'vue'
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (_openBlock(), _createElementBlock('div', null, [
    _createElementVNode('div', {
      onClick: _cache[0] || (_cache[0] = $event => ($setup.onClick($setup.dynamic))) // [!code hl]
    }, _toDisplayString($setup.dynamic), 1 /* TEXT */)
  ]))
}
```

**作用**：

避免在每次父组件渲染时都给子组件传递一个全新的函数引用，从而防止子组件不必要的重新渲染。

**收益**：

减少了不必要的 VNode 创建和子组件渲染。

### Patch Flags / 更新类型标记

编译器分析模板中的动态绑定（`v-bind`, `v-if`, `v-for`, 插值 `{{ }}`, 自定义指令等）。
对于每个包含动态绑定的元素，编译器会在生成的代码中给其 VNode 添加一个 `patchFlag` 属性。
这个标志是一个 **位掩码** ，精确地标记出该 VNode 上哪些类型的属性或内容是动态的、需要被检查更新的。

常见标志位：

```ts
enum PatchFlags {
  TEXT = 1, // 表示一个具有动态文本内容（子元素快速路径）的元素
  CLASS = 1 << 1, // 表示一个具有动态 class 绑定的元素。
  STYLE = 1 << 2, // 表示具有动态样式的元素
  PROPS = 1 << 3, // 表示一个具有非类/样式动态属性的元素。
  FULL_PROPS = 1 << 4, // 表示一个具有动态键属性的元素
  NEED_HYDRATION = 1 << 5, // 表示一个需要进行属性水合的元素（但不一定需要修补）
  STABLE_FRAGMENT = 1 << 6, // 表示一个子节点顺序不变的片段。
  KEYED_FRAGMENT = 1 << 7, // 表示一个带有键控或部分键控子元素的片段
  UNKEYED_FRAGMENT = 1 << 8, // 表示一个包含无键子元素的片段。
  NEED_PATCH = 1 << 9, // 表示一个仅需非属性修补的元素
  DYNAMIC_SLOTS = 1 << 10, // 表示一个具有动态插槽的组件
  DEV_ROOT_FRAGMENT = 1 << 11, // 表示一个仅因用户在模板根层级放置了注释而创建的片段。（仅限开发使用的标记）

  CACHED = -1, // 表示一个缓存的静态虚拟节点(vnode)。
  BAIL = -2, // 一个特殊标志，表示差异比较算法应退出优化模式
}
```

例如，一个 VNode 上有 `class` 和 `style` 两个动态属性，那么这个 VNode 的 `patchFlag` 就会包含 `PatchFlags.CLASS` 和 `PatchFlags.STYLE` ，从而标记出这个 VNode 的更新类型标记：

```ts
// 使用示例
const vnode = {
  type: 'div',
  // 按位或运算，合并上述两个标志
  patchFlag: PatchFlags.CLASS | PatchFlags.STYLE, // [!code hl]
  props: {
    class: dynamicClass, // 动态 class
    style: dynamicStyle, // 动态 style
    id: 'static-id' // 静态属性
  }
}
```

在执行 patch 操作时，根据这个标志，可以知道该 VNode 的更新类型是什么，从而进行相应的更新操作:

```ts
const { patchFlag } = n2 // 从新的虚拟 DOM 中获取 patchFlag

if (patchFlag > 0) {
  // 通过 按位与 运算，判断是否有需要更新的内容
  if (patchFlag & PatchFlags.CLASS) {
    // 更新 class
  }

  if (patchFlag & PatchFlags.STYLE) {
    // 更新 style
  }
  // ...
}
```

**作用**：

根据 `patchFlag` 的值，`patch` 函数可以只执行特定类型的更新检查，而无需遍历 VNode 的所有属性和子节点。

**收益**：

* **大幅减少属性/内容比较次数**： 从全量比较变为只比较真正可能变化的部分。
* **消除不必要的操作**： 避免了大量永远不会变化的属性或内容的冗余检查和 DOM 操作。

### 树结构打平

回顾 [缓存静态内容](#缓存静态内容) 中的 编译结果代码，可以发现所返回的虚拟 DOM 树是经一个特殊的 `createElementBlock()` 调用创建的：

```ts
export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (_openBlock(), _createElementBlock('div', null, [
    /** children */
  ]))
}
```

在 vue 3 的模板编译结果中，引入了一个 **“区块”** 的概念，内部结构是稳定的一个部分可被称之为一个区块。
在这个用例中，整个模板只有一个区块，因为这里没有用到任何结构性指令 (比如 `v-if` 或者 `v-for`)。

每一个块都会追踪其所有带更新类型标记的后代节点 (不只是直接子节点)，举例来说：

```html
<div> <!-- root block -->
  <div>...</div>         <!-- 不会追踪 -->
  <div :id="id"></div>   <!-- 要追踪 --> <!-- [!code hl]-->
  <div>                  <!-- 不会追踪 -->
    <div>{{ bar }}</div> <!-- 要追踪 --> <!-- [!code hl]-->
  </div>
</div>
```

编译的结果会被打平为一个数组，仅包含所有动态的后代节点：

```txt
div (block root)
- div 带有 :id 绑定
- div 带有 {{ bar }} 绑定
```

当这个组件需要重渲染时，只需要遍历这个打平的树而非整棵树。
这也就是我们所说的 **树结构打平**，这大大减少了我们在虚拟 DOM 协调时需要遍历的节点数量。
模板中任何的静态部分都会被高效地略过。

一个 Block 由一个稳定的根节点（通常是带 `v-if` / `v-for` 的元素）和其动态子节点组成。

```html
<div> <!-- 根区块 -->
  <div>
    <div v-if> <!-- if 区块 -->
      ...
    </div>
    <div v-for="item in items"> <!-- for 区块 -->
      ...
    </div>
  </div>
</div>
```

**特性**:

* **稳定结构**：Block根节点自身结构稳定（如 `v-for` 的容器 `<ul>`）。
* **动态子节点数组**：Block 内部维护一个动态子节点数组（ `dynamicChildren` ），只包含可能变化的子节点（如 `v-for` 循环项）。

**收益**：

* 当Block根节点需要更新时（如 `v-for` 的源数据 items 变化），只需 Diff 该 Block 内部的 `dynamicChildren` 数组。
* 完全跳过 Block 内部所有静态节点和兄弟 Block 的 Diff

这是比静态提升更激进的优化。
它彻底改变了传统的树递归 Diff 方式。运行时 diff 的 **复杂度不再与模板整体大小直接相关，而只与动态节点的数量相关**。
即使模板非常庞大，只要动态部分少且集中，更新就非常快。

同时避免了深入遍历大量静态节点，减少了函数调用栈开销。

### 编译时优化的作用

* Vue 3 的编译器不再是简单的 模板->渲染函数转换器 。
  它是一个强大的优化器，在编译阶段就深入分析模板结构，识别出所有静态和动态部分，并生成高度优化的、
  带有丰富提示信息（Patch Flags, Block Tree）的代码。这使得运行时 `diff` 算法（`patch` 过程）能有的放矢。
* 不再进行全量 VNode 属性比较，而是根据编译时标记，只检查和更新真正可能变化的部分（文本、特定 class、特定 props 等）。
  极大减少了属性遍历和比较的开销。
* 通过树结构打平，`diff` 过程 **完全避开了静态子树**，只在一个扁平的动态节点列表 (`dynamicChildren`) 中进行。
  这使得 `diff` 的复杂度从 $O(n^3)$ / $O(n)$ 优化到接近 $O$ (动态节点数量)，尤其是在大型静态模板中效果惊人。
  这是 Vue 3 渲染性能飞跃的关键。
* 复用静态节点和 props 的 VNode，减少内存分配、垃圾回收压力和创建开销。
* 减少副作用 (缓存事件处理函数)， 避免因父组件更新导致的无意义子组件更新。

## Diff 算法

[源码位置：**vuejs/core —— runtime-core/src/renderer.ts**](https://github.com/vuejs/core/blob/v3.5.17/packages/runtime-core/src/renderer.ts){.read-more}

vue3 的 diff 算法，在
[runtime-core/src/renderer.ts](https://github.com/vuejs/core/blob/v3.5.17/packages/runtime-core/src/renderer.ts#342)
的 `baseCreateRenderer` 内部 的 `patch` 函数实现。

先从它的类型定义开始:

```ts
type PatchFn = (
  n1: VNode | null, // 旧的虚拟节点， null 表示这是一个挂载操作
  n2: VNode, // 新的虚拟节点
  container: RendererElement, // 容器元素
  anchor?: RendererNode | null, // 锚点元素
  parentComponent?: ComponentInternalInstance | null, // 父组件实例
  parentSuspense?: SuspenseBoundary | null, // 父 Suspense 边界
  namespace?: ElementNamespace, // 命名空间，主要用于 SVG / Math
  slotScopeIds?: string[] | null, // 插槽作用域 ID
  optimized?: boolean, // 是否启用优化
) => void
```

在这里，我们主要关注的是它的参数 `n1` 、 `n2`、 `container` 和 `anchor` 。

* `n1` 表示旧的虚拟节点，当如接收到的是 `null` ，则表示是一个 挂载 （mount） 操作。
* `n2` 表示新的虚拟节点。它将会与 `n1` 进行比较，以更新或创建新的 DOM 节点。
* `container` 是一个 DOM 元素，用于将新的虚拟节点渲染到容器中。
* `anchor` 表示锚点元素，用于在执行 插入或移动 操作时的参考点。

接下来，我们来看它的实现，`patch` 首先根据 `n1` 和 `n2` 的不同情况进行不同的处理：

1. 如果 `n1` 和 `n2` 相同，则表示是一个无需更新的操作，直接跳过。
2. 如果 `n1` 和 `n2` 节点类型不同，说明它们是两个完全不同的节点，直接卸载旧节点，挂载新的节点。
3. 如果 `n1` 不存在，说明是一个全新的挂载操作，需要进行挂载。
4. 根据 `type` 和 `shapeFlag` 的不同情况，进行不同的处理，包括文本节点、注释节点、静态节点等。

```ts
const patch: PatchFn = (
  n1,
  n2,
  container,
  anchor = null,
) => {
  // 如果新旧节点相同，直接跳过
  if (n1 === n2) {
    return
  }

  // 如果新旧节点类型不同，需要卸载旧节点树
  if (n1 && !isSameVNodeType(n1, n2)) {
    // 卸载旧节点
    unmount(n1, parentComponent, parentSuspense, true)
    // 将旧节点设置为 null，表示这是一个全新的挂载操作
    n1 = null
  }

  const { type, shapeFlag } = n2
  // 取出节点类型，根据类型进行不同的处理
  switch (type) {
    case Text: // 文本节点
      processText(n1, n2, container, anchor)
      break
    case Comment: // 注释节点
      processCommentNode(n1, n2, container, anchor)
      break
    case Static: // 静态节点
      if (n1 == null) {
        mountStaticNode(n2, container, anchor, namespace)
      }
      break
    case Fragment: // 片段节点
      processFragment(n1, n2, container, anchor,)
      break
    default: // 其它节点
      // 根据 shapeFlag 进行不同的处理
      if (shapeFlag & ShapeFlags.ELEMENT) {
        processElement(n1, n2, container, anchor, /* ...args */)
      }
      else if (shapeFlag & ShapeFlags.COMPONENT) {
        processComponent(n1, n2, container, anchor, /* ...args */)
      }
      else if (shapeFlag & ShapeFlags.TELEPORT) {
        ;(type as typeof TeleportImpl).process(n1, n2, container, anchor, /* ...args */)
      }
      else if (shapeFlag & ShapeFlags.SUSPENSE) {
        ;(type as typeof SuspenseImpl).process(n1, n2, container, anchor, /* ...args */)
      }
  }
}
```

### ShapeFlags / 节点类型标记

ShapeFlags 是用于描述虚拟节点（VNode）类型和结构的标志位系统。

[源码位置：**vuejs/core - shared/src/shapeFlags.ts**](https://github.com/vuejs/core/blob/v3.5.17/packages/shared/src/shapeFlags.ts){.read-more}

```ts
export const enum ShapeFlags {
  ELEMENT = 1, // 普通 DOM 元素（如 div）
  FUNCTIONAL_COMPONENT = 1 << 1, // 函数式组件
  STATEFUL_COMPONENT = 1 << 2, // 有状态组件（普通组件）
  TEXT_CHILDREN = 1 << 3, // 子节点是文本（如 vnode.children = "text"）
  ARRAY_CHILDREN = 1 << 4, // 子节点是数组（多个子节点）
  SLOTS_CHILDREN = 1 << 5, // 子节点是插槽（scoped slots）
  TELEPORT = 1 << 6, // Teleport 组件
  SUSPENSE = 1 << 7, // Suspense 组件
  COMPONENT_SHOULD_KEEP_ALIVE = 1 << 8, // 需要被 keep-alive 的组件
  COMPONENT_KEPT_ALIVE = 1 << 9, // 已被 keep-alive 缓存的组件
  COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT // 组件类型（函数式/有状态）
}
```

它在 `createVNode` 和 `normalizeChildren` 阶段被用于标记节点的类型和子节点的类型，以便在 `patch` 阶段进行相应的处理。

[源码位置：**vuejs/core - runtime-core/src/vnode.ts - createVNode**](https://github.com/vuejs/core/blob/v3.5.17/packages/runtime-core/src/vnode.ts#L609){.read-more}

```ts
function createVNode(type, props, children) {
  // ...
  const shapeFlag = isString(type)
    ? ShapeFlags.ELEMENT
    : __FEATURE_SUSPENSE__ && isSuspense(type)
      ? ShapeFlags.SUSPENSE
      : isTeleport(type)
        ? ShapeFlags.TELEPORT
        : isObject(type)
          ? ShapeFlags.STATEFUL_COMPONENT
          : isFunction(type)
            ? ShapeFlags.FUNCTIONAL_COMPONENT
            : 0
  // ...
}
```

[源码位置：**vuejs/core - runtime-core/src/vnode.ts - normalizeChildren**](https://github.com/vuejs/core/blob/v3.5.17/packages/runtime-core/src/vnode.ts#L814){.read-more}

```ts
function normalizeChildren(vnode: VNode, children: unknown): void {
  let type = 0
  const { shapeFlag } = vnode

  if (isArray(children)) {
    type = ShapeFlags.ARRAY_CHILDREN // 标记为数组子节点
  }
  else if (typeof children === 'object') {
    if (shapeFlag & (ShapeFlags.ELEMENT | ShapeFlags.TELEPORT)) {
      // ...
      return
    }
    else {
      type = ShapeFlags.SLOTS_CHILDREN // 标记为插槽
      const slotFlag = (children as RawSlots)._
      if (!slotFlag && !isInternalObject(children)) {
        // ...
      }
      else if (slotFlag === SlotFlags.FORWARDED && currentRenderingInstance) {
        // 子组件接收来自父组件转发的插槽。
        // 其插槽类型由父组件的插槽类型决定。
        if (currentRenderingInstance.slots._ === SlotFlags.STABLE) {
          // ...
        }
        else {
          vnode.patchFlag |= PatchFlags.DYNAMIC_SLOTS // 标记为动态插槽
        }
      }
    }
  }
  else if (isFunction(children)) {
    type = ShapeFlags.SLOTS_CHILDREN // 标记为插槽
  }
  else {
    // 强制将子元素传送到数组以便移动
    if (shapeFlag & ShapeFlags.TELEPORT) {
      type = ShapeFlags.ARRAY_CHILDREN // 标记为数组子节点
    }
    else {
      type = ShapeFlags.TEXT_CHILDREN // 标记为文本子节点
    }
  }
  vnode.shapeFlag |= type
}
```

ShapeFlags 通过 位运算 描述 VNode 的特性，主要用于：

* 快速判断 VNode 类型

  ```ts
  // 判断是否是组件
  const isComponent = vnode.shapeFlag & ShapeFlags.COMPONENT
  ```

* 优化 Diff 算法: 根据 shapeFlag 选择不同的处理逻辑

* 子节点类型优化:

  * 文本子节点 (`TEXT_CHILDREN`)：直接设置 `textContent`
  * 数组子节点 (`ARRAY_CHILDREN`)：递归 `patch` 每个子节点
  * 插槽 (`SLOTS_CHILDREN`)：动态更新插槽内容

`shapeFlag` 结合位运算的高效特性，使用 `|` 组合标志、`&` 检测标志，比字符串比较快得多。
一个 VNode 可同时拥有多个标志（如 `ELEMENT` | `ARRAY_CHILDREN`），同时也便于后期的扩展。

### 处理不同的节点类型

在处理不同的节点类型时，其主要思路大体是类似的：

```ts
function processSomething(n1, n2, container, anchor) {
  // 新节点，进行挂载
  if (n1 === null) {
    mountSomething(n2, container, anchor)
  }
  else {
    // 对比节点差异，进行更新
    patchSomething(n1, n2, container, anchor)
  }
}
```

比如，处理 `Text` 节点，它的处理逻辑大致如下：

```ts
const processText: ProcessTextOrCommentFn = (n1, n2, container, anchor) => {
  if (n1 == null) {
    // 创建一个文本节点，并插入到对应的容器位置中
    hostInsert(
      (n2.el = hostCreateText(n2.children as string)),
      container,
      anchor,
    )
  }
  else {
    // 复用旧节点上的 dom 元素，并更新文本内容
    const el = (n2.el = n1.el!)
    if (n2.children !== n1.children) {
      hostSetText(el, n2.children as string)
    }
  }
}
```

处理静态节点时，由于其内容不会发生变化，因此直接进行挂载即可（不考虑 DEV 模式下的热更新）：

```ts
function mountStaticNode(n2: VNode, container: RendererElement, anchor: RendererNode | null, namespace: ElementNamespace) {
  ;[n2.el, n2.anchor] = hostInsertStaticContent!(
    n2.children as string,
    container,
    anchor,
    namespace,
    n2.el,
    n2.anchor,
  )
}
```

在接下来的其他处理函数中，我们不再关注 `mountSomething` 的实现，主要专注于 `patchSomething` 部分。

### patchFragment

在处理 `Fragment` 节点时，对于 `patchFragment` 处理部分，由于 `Fragment` 包含多个子节点，因此需要重点关注的是：

* [`pathBlockChildren`](#patchblockchildren) 函数，处理 “区块” 内的子节点
* [`patchChildren`](#patchchildren) 函数，处理子节点

```ts
function processFragment(n1: VNode | null, n2: VNode, container: RendererElement, anchor: RendererNode | null) {
  const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''))!
  const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''))!

  let { patchFlag, dynamicChildren } = n2
  // ...
  if (
    patchFlag > 0
    && patchFlag & PatchFlags.STABLE_FRAGMENT
    // 包含动态子节点
    && dynamicChildren
    && n1.dynamicChildren
  ) {
    // 一个稳定的片段（模板根节点或带有`<template v-for>`的模板）不需要
    // 处理子节点顺序，但它可能包含动态子节点。
    patchBlockChildren(n1.dynamicChildren, dynamicChildren, container) // [!code hl]
  }
  else {
    // keyed / unkeyed, 或 手动片段。
    // 对于键控和非键控情况，由于它们是由v-for编译器生成的，
    // 每个子节点都确保是一个区块，因此片段永远不会包含动态子节点。
    patchChildren(n1, n2, container, fragmentEndAnchor) // [!code hl]
  }
  // ...
}
```

[源码位置：**vuejs/core - runtime-core/src/renderer.ts - processElement**](https://github.com/vuejs/core/blob/v3.5.17/packages/runtime-core/src/renderer.ts#L595){.read-more}

:::details 什么是 Fragment 片段 ？

Fragment 不会渲染为真实 DOM 元素，仅作为逻辑容器存在。

组件的 template 中包含多个顶级元素：

```html
<template>
  <span>...</span>
  <span>...</span>
</template>
```

显式 `<template>` 标签，当 `<template>` 标签用于逻辑分组但不需要渲染为 DOM 元素时：

```html
<template>
  <template v-if="isMobile">
    <MobileHeader />
  </template>
  <template v-else>
    <DesktopHeader />
  </template>
</template>
```

在 `setup()` 或渲染函数中直接返回节点数组时：

```ts
export default defineComponent({
  // 返回多个根节点
  setup() {
    return () => [
      h('div', 'Top'),
      h('div', 'Bottom')
    ]
  }
})
```

当插槽内容包含多个节点时：

```html
<!-- Parent.vue -->
<Child>
  <span>Slot 1</span>  <!-- 这些节点会被包裹在 -->
  <span>Slot 2</span>  <!-- Fragment 中传递给子组件 -->
</Child>
```

当 `v-if` / `v-else` 分支包含多个同级节点：

```html
<div>
  <template v-if="condition">
    <p>A</p>
    <p>B</p>  <!-- 这个分支会生成 Fragment -->
  </template>
  <div v-else>C</div>
</div>
```

当 `v-for` 渲染多个节点且无包裹元素

```html
<ul>
  <template v-for="item in list" :key="item.id">
    <li>{{ item.name }}</li>
    <li>{{ item.desc }}</li> <!-- 每组两个 <li> 会被包裹在 Fragment 中 -->
  </template>
</ul>
```

`Teleport/Suspense` 内置组件的内容区域自动成为 Fragment：

```html
<Teleport to="#modal">
  <div>Title</div>  <!-- 这些节点会被包裹在 -->
  <div>Content</div> <!-- Fragment 中传送 -->
</Teleport>
```

函数式组件返回多个根节点时：

```tsx
function FunctionalComp(props, { slots }) {
  return [
    <div>Header</div>,
    slots.default(),
    <div>Footer</div>
  ]
}
```

:::

### patchElement

处理 `Element` 节点时，需要重点关注的是：

* [`pathBlockChildren`](#patchblockchildren) 函数，处理 “区块” 内的子节点
* [`patchChildren`](#patchchildren) 函数，处理子节点
* `patchProps` 函数，处理属性

```ts
function patchElement(n1: VNode, n2: VNode, parentComponent: ComponentInternalInstance | null) {
  const el = (n2.el = n1.el!)
  let { patchFlag, dynamicChildren, dirs } = n2
  patchFlag |= n1.patchFlag & PatchFlags.FULL_PROPS
  const oldProps = n1.props || EMPTY_OBJ
  const newProps = n2.props || EMPTY_OBJ
  if (dynamicChildren) {
    patchBlockChildren(n1.dynamicChildren!, dynamicChildren, el, parentComponent) // [!code hl]
  }
  else if (!optimized) {
    // full diff
    patchChildren(n1, n2, el, null) // [!code hl]
  }
  if (patchFlag > 0) {
    // patchFlag 的存在意味着该元素的渲染代码由编译器生成，可启用快速路径。
    // 在此路径下，新旧节点保证具有相同的结构
    // (即在源模板中的位置完全一致)
    if (patchFlag & PatchFlags.FULL_PROPS) {
      // 元素属性包含动态键，需进行完整差异比对
      patchProps(el, oldProps, newProps, parentComponent, namespace) // [!code hl]
    }
    else {
      // class
      // 当元素具有动态类绑定时，此标志会被匹配。
      if (patchFlag & PatchFlags.CLASS) {
        if (oldProps.class !== newProps.class) {
          hostPatchProp(el, 'class', null, newProps.class, namespace)
        }
      }

      // style
      // 当元素具有动态样式绑定时，此标志会被匹配
      if (patchFlag & PatchFlags.STYLE) {
        hostPatchProp(el, 'style', oldProps.style, newProps.style, namespace)
      }

      // props
      // 当元素具有动态属性/特性绑定时会匹配此标志
      // 不包括 class 和 style。动态属性/特性的键会被保存以便更快迭代
      // 注意像 :[foo]="bar" 这样的动态键会导致此优化失效
      // 转而执行完整差异对比， 因为需要清除旧键
      if (patchFlag & PatchFlags.PROPS) {
        const propsToUpdate = n2.dynamicProps!
        for (let i = 0; i < propsToUpdate.length; i++) {
          const key = propsToUpdate[i]
          const prev = oldProps[key]
          const next = newProps[key]
          if (next !== prev || key === 'value') {
            hostPatchProp(el, key, prev, next, namespace, parentComponent)
          }
        }
      }
    }
    // ...
  }
  else if (!optimized && dynamicChildren == null) {
    patchProps(el, oldProps, newProps, parentComponent, namespace) // [!code hl]
  }
}
```

[源码位置：**vuejs/core - runtime-core/src/renderer.ts - patchElement**](https://github.com/vuejs/core/blob/v3.5.17/packages/runtime-core/src/renderer.ts#L802){.read-more}

### patchBlockChildren

`BlockChildren` 是一个优化路径，专门用于处理 编译优化后的动态子节点更新。

```ts
const patchBlockChildren: PatchBlockChildrenFn = (
  oldChildren,
  newChildren,
  fallbackContainer,
  parentComponent,
  parentSuspense,
  namespace: ElementNamespace,
  slotScopeIds,
) => {
  for (let i = 0; i < newChildren.length; i++) {
    const oldVNode = oldChildren[i]
    const newVNode = newChildren[i]
    // 确定补丁（patch）所在的容器（父元素）。
    const container = oldVNode.el || fallbackContainer // 省略代码...
    patch(
      oldVNode,
      newVNode,
      container,
      null,
      parentComponent,
      parentSuspense,
      namespace,
      slotScopeIds,
      true,
    )
  }
}
```

[源码位置：**vuejs/core - runtime-core/src/renderer.ts - patchBlockChildren**](https://github.com/vuejs/core/blob/v3.5.17/packages/runtime-core/src/renderer.ts#L943){.read-more}

它主要用于优化以下两种场景：

* `v-for` 动态列表的更新：

  ::: code-tabs

  @tab 源码

  ```html
  <!-- 编译后生成的 block -->
  <template v-for="item in list" :key="item.id">
    <div>{{ item.name }}</div>  <!-- 动态节点 -->
    <span>foo</span>        <!-- 静态节点（跳过更新） -->
  </template>
  ```

  @tab 编译结果

  ```ts
  function render(_ctx, _cache, $props, $setup, $data, $options) {
    return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList($setup.list, (item) => {
      return (_openBlock(), _createElementBlock(_Fragment, {
        key: item.id
      }, [
        // 动态节点
        _createElementVNode('div', null, _toDisplayString(item.name), 1 /* TEXT */),
        // 静态节点，复用缓存
        _cache[0] || (_cache[0] = _createElementVNode('span', null, 'foo', -1 /* CACHED */))
      ], 64 /* STABLE_FRAGMENT */))
    }), 128 /* KEYED_FRAGMENT */))
  }
  ```

  :::

  Vue 的编译器会将 `v-for` 包裹的内容标记为 **block**，并记录其中的动态节点（`dynamicChildren`）

  `patchBlockChildren` 直接遍历 `dynamicChildren` 数组，跳过静态节点，仅更新动态节点

* Fragment 多根节点组件的优化更新

  ::: code-tabs

  @tab 源码

  ```html
  <!-- 多根组件（Fragment） -->
  <template>
    <header>{{ dynamicTitle }}</header>  <!-- 动态节点 -->
    <main>静态内容</main>               <!-- 静态节点 -->
    <footer :class="dynamicClass"></footer>  <!-- 动态节点 -->
  </template>
  ```

  @tab 编译结果

  ```ts
  function render(_ctx, _cache, $props, $setup, $data, $options) {
    return (_openBlock(), _createElementBlock(_Fragment, null, [
      _createElementVNode('header', null, _toDisplayString($setup.dynamicTitle), 1 /* TEXT */),
      _cache[0] || (_cache[0] = _createElementVNode('main', null, '静态内容', -1 /* CACHED */)),
      _createElementVNode('footer', {
        class: _normalizeClass($setup.dynamicClass)
      }, null, 2 /* CLASS */)
    ], 64 /* STABLE_FRAGMENT */))
  }
  ```

  :::

  编译器将多根组件标记为 **block**，并提取动态节点到 `dynamicChildren`

  `patchBlockChildren` 仅更新 `dynamicChildren` 中的 `<header>` 和 `<footer>`，跳过静态的 `<main>`

### patchChildren

`patchChildren` 是用于更新子节点的核心函数，负责处理新旧虚拟节点的子节点差异，采用不同的更新策略：

1. 优化路径：

   * 处理带 key 的片段（KEYED\_FRAGMENT）
   * 处理不带 key 的片段（UNKEYED\_FRAGMENT）

2. 常规路径：

   * 处理文本子节点：直接更新文本内容
   * 处理数组子节点：使用 diff 算法比较和更新
   * 处理无子节点的情况

更新策略的选择基于：
`patchFlag` 优化标记，指示更新的具体类型；
`shapeFlag` 节点的形状标记，表明子节点的类型（文本/数组）

在这里，我们需要关注的是：

* `patchKeyedChildren`:处理带 key 的片段
* `patchUnkeyedChildren`:处理不带 key 的片段

```ts
const patchChildren: PatchChildrenFn = (
  n1,
  n2,
  container,
  anchor,
) => {
  const c1 = n1 && n1.children
  const prevShapeFlag = n1 ? n1.shapeFlag : 0
  const c2 = n2.children

  const { patchFlag, shapeFlag } = n2
  // 快速路径
  if (patchFlag > 0) {
    if (patchFlag & PatchFlags.KEYED_FRAGMENT) {
      // 这可能是全 key 的 或混合式的（部分有 key，部分无 key）
      // 存在 patchFlag 意味着子节点保证是数组
      patchKeyedChildren(c1, c2, container, anchor) // [!code hl]
      return
    }
    // 编译器会在没有 key 的情况下标记为 UNKEYED_FRAGMENT
    else if (patchFlag & PatchFlags.UNKEYED_FRAGMENT) {
      // unkeyed
      patchUnkeyedChildren(c1, c2, container, anchor) // [!code hl]
      return
    }
  }

  if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
    // ...
  }
  else {
    if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
      // 先前子级为数组
      if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
        // 两个数组，不做任何假设，进行完整差异比较
        patchKeyedChildren(c1, c2, container, anchor) // [!code hl]
      }
      else {
        // 没有新的子节点，仅卸载旧的子节点
        unmountChildren(c1, parentComponent, parentSuspense, true)
      }
    }
    // ...
  }
}
```

[源码位置：**vuejs/core - runtime-core/src/renderer.ts - patchChildren**](https://github.com/vuejs/core/blob/v3.5.17/packages/runtime-core/src/renderer.ts#L1609){.read-more}

### patchUnkeyedChildren

`patchUnkeyedChildren` 用于更新没有 key 的子节点数组，采用简单的位置对比策略，按顺序更新、移除或添加节点。

**更新流程**：

1. 确保新旧子节点数组至少是空数组
2. 计算新旧数组的公共长度
3. 更新公共长度范围内的节点：
   * 优化模式下克隆已挂载的节点
   * 非优化模式下标准化处理新节点
   * 对相同位置的节点进行 patch 更新
4. 处理长度差异：
   * 如果旧数组更长，移除多余的节点
   * 如果新数组更长，挂载新增的节点

```ts
function patchUnkeyedChildren(
  c1: VNode[],
  c2: VNodeArrayChildren,
  container: RendererElement,
  anchor: RendererNode | null
) {
  c1 = c1 || EMPTY_ARR
  c2 = c2 || EMPTY_ARR
  const oldLength = c1.length
  const newLength = c2.length
  // 计算新旧数组的公共长度
  const commonLength = Math.min(oldLength, newLength)
  let i
  for (i = 0; i < commonLength; i++) {
    const nextChild = (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i]))

    // 对相同位置的节点进行 patch 更新
    patch(c1[i], nextChild, container, null)
  }
  if (oldLength > newLength) {
    // 如果旧数组更长，需要移除多余的节点
    // 从 commonLength 开始移除剩余的旧节点
    unmountChildren(c1, /* ...args, */ commonLength)
  }
  else {
    // 如果新数组更长，需要挂载新增的节点
    // 从 commonLength 开始挂载剩余的新节点
    mountChildren(c2, container, anchor, /* ...args, */ commonLength)
  }
}
```

### patchKeyedChildren

`patchKeyedChildren` 用于更新带 `key` 的子节点数组，它是 Vue Diff 算法最核心的部分。
它专门处理带 `key` 的可复用节点组成的列表。
`key` 是 Vue 识别节点身份、实现高效复用和最小化移动的关键。

它主要有为 5 流程，每一步都针对特定的列表变更模式进行优化：

1. **同步前导节点 (`sync from start`)**:

   * **目标**： 快速处理列表开头未变化的节点。
   * **过程**： 使用指针 i 同时从新旧列表开头遍历。
   * **条件**： `oldVNode[i]` 和 `newVNode[i]` `key` 相同 (即 `sameVnodeType` 判定)。
   * **操作**： 调用 `patch` 递归更新这些相同节点。
   * **终止**： 当遇到第一个 `key` 不同的节点时停止。
   * **优化意义**： 如果只有列表尾部有变化，这一步能快速跳过所有前面未变的节点。

2. **同步后导节点 (`sync from end`)**:

   * **目标**： 快速处理列表末尾未变化的节点。
   * **过程**： 使用指针 `e1` (指向旧列表最后一个节点) 和 `e2` (指向新列表最后一个节点) 从列表末尾开始向前遍历。
   * **条件**： `oldVNode[e1]` 和 `newVNode[e2]` key 相同。
   * **操作**： 调用 `patch` 递归更新这些相同节点。
   * **终止**： 当遇到第一个 `key` 不同的节点时停止。
   * **优化意义**： 如果只有列表开头有变化（如头部插入），这一步能快速跳过所有后面未变的节点。
     结合第 1 步，高效处理了仅在列表两端增删的情况。

3. **处理新增节点 (`common sequence + mount`)**:

   * **场景**： 经过前两步同步后，可能出现：
     * `i > e1` (旧列表已遍历完) 且 `i <= e2` (新列表还有剩余节点)。
     * 这意味着新列表在中间或末尾新增了节点。
   * **操作**：
     * 遍历新列表中剩余的节点 (索引 `i` 到 `e2`)。
     * 找到这些节点应该插入的位置 (`nextPos = e2 + 1`, 如果 `nextPos < newChildren.length` 则参考节点是 `newChildren[nextPos].el`，否则参考节点是 `anchor`，通常是 `null` 表示追加)。
     * 逐个调用 `patch(null, newVNode, container, anchor, ...)` 创建并挂载这些新节点。

4. **处理删除节点 (`common sequence + unmount`)**:

   * **场景**： 经过前两步同步后，可能出现：
     * `i > e2` (新列表已遍历完) 且 `i <= e1` (旧列表还有剩余节点)。
     * 这意味着新列表在中间或开头删除了节点。
   * **操作**：
     * 遍历旧列表中剩余的节点 (索引 `i` 到 `e1`)。
     * 逐个调用 `unmount(oldVNode, parentComponent, parentSuspense, true)` 卸载这些不再需要的节点及其子组件。

5. **处理未知序列 (unknown sequence)**：==最长递增子序列 (LIS)==

   * **场景**： 经过前四步处理后，新旧列表中都还有未处理的节点 (`i <= e1 && i <= e2`)，并且这些节点的顺序发生了复杂的变化（移动、新增、删除混合）。
   * 这是最复杂的情况，需要以最小的 DOM 移动代价，将旧节点序列变成新节点序列。
   * **Vue3 的解决方案**：基于 `key` 映射和 **最长递增子序列 (Longest Increasing Subsequence - LIS)**。

```ts
// 可以是 all-key 的 或 混合的
function patchKeyedChildren(
  c1: VNode[],
  c2: VNodeArrayChildren,
  container: RendererElement,
  parentAnchor: RendererNode | null
) {
  let i = 0 // 当前对比的起始索引
  const l2 = c2.length // 新子节点数组的长度
  let e1 = c1.length - 1 // 旧子节点数组的结束索引
  let e2 = l2 - 1 // 新子节点数组的结束索引

  // 1. 同步前导节点 / sync from start
  // (a b) c
  // (a b) d e
  while (i <= e1 && i <= e2) {
    const n1 = c1[i]
    const n2 = (c2[i] = optimized
      ? cloneIfMounted(c2[i] as VNode)
      : normalizeVNode(c2[i]))
    if (isSameVNodeType(n1, n2)) {
      patch(n1, n2, container, null) // [!code hl]
    }
    else {
      break
    }
    i++
  }

  // 2. 同步后导节点 / sync from end
  // a (b c)
  // d e (b c)
  while (i <= e1 && i <= e2) {
    const n1 = c1[e1]
    const n2 = (c2[e2] = optimized
      ? cloneIfMounted(c2[e2] as VNode)
      : normalizeVNode(c2[e2]))
    if (isSameVNodeType(n1, n2)) {
      patch(n1, n2, container, null) // [!code hl]
    }
    else {
      break
    }
    e1--
    e2--
  }

  // 3. 普通序列 + 挂载 / common sequence + mount
  // (a b)
  // (a b) c
  // i = 2, e1 = 1, e2 = 2
  // (a b)
  // c (a b)
  // i = 0, e1 = -1, e2 = 0
  if (i > e1) {
    if (i <= e2) {
      const nextPos = e2 + 1
      const anchor = nextPos < l2 ? (c2[nextPos] as VNode).el : parentAnchor
      while (i <= e2) {
        patch(
          null,
          (c2[i] = optimized
            ? cloneIfMounted(c2[i] as VNode)
            : normalizeVNode(c2[i])),
          container,
          anchor
        )
        i++
      }
    }
  }

  // 4. 普通序列 + 卸载 / common sequence + unmount
  // (a b) c
  // (a b)
  // i = 2, e1 = 2, e2 = 1
  // a (b c)
  // (b c)
  // i = 0, e1 = 0, e2 = -1
  else if (i > e2) {
    while (i <= e1) {
      unmount(c1[i], parentComponent, parentSuspense, true)
      i++
    }
  }

  // 5. 未知序列 / unknown sequence
  // [i ... e1 + 1]: a b [c d e] f g
  // [i ... e2 + 1]: a b [e d c h] f g
  // i = 2, e1 = 4, e2 = 5
  else {
    // LIS
    // 此部分在下个章节中进行
  }
}
```

[源码位置 - \**vuejs/core - runtime-core/src/renderer.ts - patchKeyedChildren*](https://github.com/vuejs/core/blob/v3.5.17/packages/runtime-core/src/renderer.ts#L1771){.read-more}

### 处理未知序列：最长递增子序列 (Longest Increasing Subsequence - LIS)

对于 未知序列 的处理，Vue3 采用了 [最长递增子序列 -LIS](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) 算法。

**详细步骤**：

1. **构建 Key-Index 映射 (keyToNewIndexMap)**:

   * 创建一个 `Map` (`keyToNewIndexMap = new Map()`)。
   * 遍历新列表中剩余未处理的节点 (索引 `i` 到 `e2`)。
   * 以每个节点的 `key` 为键，其在新列表中的索引位置 (`j`) 为值，存入 `Map`。`keyToNewIndexMap.set(newVNode.key, j)`。
   * **目的**： 后续能通过 `key` 快速查找新节点在新列表中的位置 (索引 `j`)。时间复杂度 $O(1)$。

2. **遍历旧列表剩余节点，寻找复用与记录位置**：

   * 初始化变量：
     * `patched = 0` (已处理的新节点计数)
     * `toBePatched = e2 - i + 1` (新列表剩余待处理的节点总数)
     * `newIndexToOldIndexMap = new Array(toBePatched)` (一个长度等于待处理新节点数的数组)
     * `newIndexToOldIndexMap.fill(0)` (初始化为 0，0 表示该新节点在旧列表中没有对应的可复用节点)
   * 遍历旧列表中剩余未处理的节点 (索引 `i` 到 `e1`)
   * 对于每个旧节点 `oldVNode`：
     * 如果 `patched >= toBePatched`：说明所有新节点都已被处理过，当前旧节点是多余的，直接卸载 `unmount(oldVNode, ...)`。
     * 否则，尝试通过 `oldVNode.key` 在 `keyToNewIndexMap` 中查找其在新列表中的位置 `newIndex`。
     * 如果 `newIndex` 未定义 (`undefined`)：说明该旧节点在新列表中不存在。卸载它 `unmount(oldVNode, ...)`。
   * 如果 `newIndex` 存在：
     * 说明找到了一个可复用的节点（`key` 相同）。
     * 将 `newIndexToOldIndexMap[newIndex - i] = oldIndex + 1`。注意这里 `+1` 是为了区分初始化的 `0`（表示无复用）。`oldIndex` 是当前旧节点的索引（通常就是循环变量，但需要记录实际位置）。
     * 记录移动可能性： 如果 `newIndex` 在遍历过程中不是持续递增的 (即 `newIndex < maxNewIndexSoFar`)，则设置 `moved = true` (表明节点顺序发生了变动，可能需要移动 DOM)。
     * 否则更新 `maxNewIndexSoFar = newIndex` (记录当前遇到的最大新索引)。
     * 调用 `patch(oldVNode, newVNode[newIndex], container, null, ...)` 递归更新这个可复用的节点。

3. 计算最小移动：最长递增子序列 (LIS)

   * 只有在 `moved` 为 `true` (即检测到顺序变动) 时，才需要计算 LIS。
   * `newIndexToOldIndexMap` 数组的含义：它的下标对应 **新列表待处理部分** 的相对索引 (`0` 对应新列表索引 `i`, `1` 对应 `i+1` ...)。它的值表示：该位置的新节点在 **旧列表中的索引值 + 1**  (如果是 0 表示该新节点是新增的)。
   * LIS 的核心目标： 在 `newIndexToOldIndexMap` 中找到一个最长的递增子序列 (Increasing Sequence)。
     这个子序列对应的新节点在新旧列表中的相对顺序没有改变。

4. 处理新增节点： 在步骤 5.2 中，`newIndexToOldIndexMap` 中值为 `0` 的项，对应的就是新列表中的新增节点。
   在移动过程中，当遍历到这些节点时，直接创建并插入到正确位置。

```ts
// 记录两个序列的开始索引
const s1 = i // 旧序列的开始索引
const s2 = i // 新序列的开始索引

// 5.1 为新的子节点构建 key 到索引的映射
// 这个映射用于快速查找新位置
const keyToNewIndexMap: Map<PropertyKey, number> = new Map()
for (i = s2; i <= e2; i++) {
  const nextChild = (c2[i] = optimized
    ? cloneIfMounted(c2[i] as VNode)
    : normalizeVNode(c2[i]))
  if (nextChild.key != null) {
    // 记录 key 到索引的映射
    keyToNewIndexMap.set(nextChild.key, i)
  }
}

// 5.2 遍历剩余的旧子节点，尝试修补匹配的节点并移除不再存在的节点
let j
let patched = 0 // 已经修补的节点数量
const toBePatched = e2 - s2 + 1 // 需要修补的新节点数量
let moved = false
// 用于追踪是否有节点移动
let maxNewIndexSoFar = 0
// 创建一个数组，记录新索引到旧索引的映射关系
// 注意：旧索引会加1，因为索引0是一个特殊值
// 表示新节点在旧节点中没有对应的节点
// 这个数组用于确定最长稳定子序列
const newIndexToOldIndexMap = Array.from({ length: toBePatched })
// eslint-disable-next-line no-unmodified-loop-condition
for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0

// 遍历剩余的旧子节点
for (i = s1; i <= e1; i++) {
  const prevChild = c1[i]
  if (patched >= toBePatched) {
    // 如果已修补的节点数量超过需要修补的数量
    // 说明剩下的旧节点都需要被移除
    unmount(prevChild, parentComponent, parentSuspense, true)
    continue
  }
  // 查找旧节点在新子节点中的位置
  let newIndex
  if (prevChild.key != null) {
    // 如果节点有 key，直接从 Map 中查找新位置
    newIndex = keyToNewIndexMap.get(prevChild.key)
  }
  else {
    // 如果节点没有 key，则需要遍历查找相同类型的无 key 节点
    for (j = s2; j <= e2; j++) {
      // 找到未匹配的相同类型节点
      if (
        newIndexToOldIndexMap[j - s2] === 0
        && isSameVNodeType(prevChild, c2[j] as VNode)
      ) {
        newIndex = j
        break
      }
    }
  }
  // 如果在新子节点中找不到对应位置
  if (newIndex === undefined) {
    // 说明该节点在新的子节点中已经不存在，需要卸载
    unmount(prevChild, parentComponent, parentSuspense, true)
  }
  else {
    // 找到了对应位置，记录新旧索引的映射关系
    // i + 1 是为了避免 i = 0 的特殊情况，因为 0 表示没有对应的旧节点
    newIndexToOldIndexMap[newIndex - s2] = i + 1
    // 如果当前的新索引大于之前遇到的最大索引
    if (newIndex >= maxNewIndexSoFar) {
      maxNewIndexSoFar = newIndex
    }
    else {
      // 如果当前索引小于最大索引，说明节点需要移动
      moved = true
    }
    patch(prevChild, c2[newIndex], container, null)
    patched++
  }
}

// 5.3 移动和挂载节点
// 只有在有节点需要移动的情况下，才需要生成最长递增子序列
const increasingNewIndexSequence = moved
  ? getSequence(newIndexToOldIndexMap) // 获取最长递增子序列
  : EMPTY_ARR
j = increasingNewIndexSequence.length - 1
// 从后向前遍历，这样可以使用最后修补的节点作为锚点
for (i = toBePatched - 1; i >= 0; i--) {
  const nextIndex = s2 + i // 计算当前需要处理的节点索引
  const nextChild = c2[nextIndex] as VNode
  // 确定锚点：如果不是最后一个节点，使用下一个节点的 el 作为锚点
  const anchor = nextIndex + 1 < l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor
  // 如果映射中没有对应的旧节点索引（值为 0）
  if (newIndexToOldIndexMap[i] === 0) {
    // 说明是新节点，需要挂载
    patch(null, nextChild, container, anchor)
  }
  else if (moved) {
    // 如果需要移动节点，则检查：
    // 1. 没有稳定的子序列（例如完全倒序）
    // 2. 当前节点不在稳定子序列中
    if (j < 0 || i !== increasingNewIndexSequence[j]) {
      // 移动节点到正确的位置
      move(nextChild, container, anchor, MoveType.REORDER)
    }
    else {
      j--
    }
  }
}
```

**为什么 LIS 能最小化移动？**

* **LIS 中的节点**： 它们在更新前后保持了原有的相对顺序。这些节点是稳定的，不需要移动。
* **非 LIS 中的节点**： 它们要么是新增的，要么需要被移动到正确的位置。
* **移动策略**： 倒序遍历新列表待处理部分的节点。对于每个节点：
  * 如果它在 LIS 中，并且处于 LIS 的最后一个有效位置，则说明它位置正确，跳过移动。
  * 否则，它需要被移动。通过 `insertBefore` 将它插入到下一个节点（新列表中它的后一个节点）的前面。
    倒序插入保证了移动的 DOM 操作是顺序正确的。

Vue3 使用了一个 **贪心 + 二分查找的算法** (在 `getSequence` 函数中) 来高效计算 LIS。

其时间复杂度是 $O(n log n)$ ，远优于暴力 $O(n²)$。

## 实践建议

Vue3 通过大量的编译时优化和改进运行时的 diff 算法，使得渲染性能大大提升，
它相比于 vue2 有 2~10 倍的性能提升。

但要让其发挥最大效能，需要在开发过程中遵循这些建议：

* **始终使用稳定唯一的key**：尤其在 `v-for` 中，这是高效复用和LIS算法工作的基石。避免使用 `index` 作为 `key`（除非列表绝对静态）。
* **拥抱模板编译**：Vue3的编译时优化是其性能核心，尽量使用SFC单文件组件模板，而非手写渲染函数。
* **利用 `v-once`/`v-memo`**：对于纯静态内容使用 `v-once`。
  对于复杂但依赖特定条件更新的节点，使用 `v-memo` 进行细粒度控制，避免不必要的 Diff。
* **避免不必要的组件抽象**：过度拆分组件会增加 Block 边界和运行时开销。
  在性能敏感路径上权衡可维护性与性能。
* **理解 Block 边界**：`v-if`/ `v-for` 会创建Block边界。
  尽量保持Block内部结构稳定，避免在Block根节点上使用非响应式属性导致Block整体失效。
* **谨慎使用无 `key` 的 `v-for`**：无 `key` 时 Vue3 会退化为更简单的就地复用策略（patchUnkeyedChildren），在列表顺序变化时可能导致状态错乱或性能下降。

---

---
url: /article/nb46t3t0/index.md
---
# CSS at-Rule @supports 和 `CSS.supports()` API
在现代前端开发中，浏览器兼容性是一个永恒的话题。随着 CSS 标准的快速发展，
如何优雅地检测浏览器是否支持某个 CSS 特性变得尤为重要。本文将深入探讨两种强大的特性检测工具：
JavaScript 的 `CSS.supports()` API 和 CSS 的 `@supports` at-rule。

## 引言：为什么需要特性检测

:::info 特性检测的重要性
在过去，开发者通常使用用户代理嗅探（User Agent Sniffing）来判断浏览器能力，但这种方法既不可靠又难以维护。特性检测提供了更准确、更面向未来的解决方案。
:::

随着 CSS 新特性的不断涌现，如 Grid、Flexbox、CSS Variables 等，确保网站在不同浏览器中都能提供良好的用户体验变得至关重要。

## CSS.supports() JavaScript API

`CSS.supports()` 是 CSS 对象模型（CSSOM）的一部分，允许开发者在 JavaScript 中检测浏览器是否支持特定的 CSS 声明或规则。

### 基本语法

```javascript
// 检测属性-值对
CSS.supports(propertyName, value)

// 检测条件字符串
CSS.supports(condition)
```

### 使用示例

:::: code-tabs
@tab 检测属性-值对

```javascript
// 检测浏览器是否支持 CSS Grid
if (CSS.supports('display', 'grid')) {
  console.log('CSS Grid 支持！')
  // 应用 Grid 布局
  document.body.style.display = 'grid'
}
else {
  console.log('CSS Grid 不支持，使用备用布局')
  // 使用传统布局
  document.body.style.display = 'flex'
}
```

@tab 检测条件字符串

```javascript
// 检测多个条件
if (CSS.supports('(display: grid) and (position: sticky)')) {
  console.log('支持 Grid 和 sticky 定位')
}

// 检测 CSS 自定义属性支持
if (CSS.supports('--main-color: red')) {
  console.log('支持 CSS 自定义属性')
}

// 检测新特性
if (CSS.supports('backdrop-filter: blur(10px)')) {
  console.log('支持毛玻璃效果')
}
```

::::

### 实际应用：渐进增强

```javascript title="渐进增强示例"
function applyModernStyles() {
  const container = document.getElementById('main-container')

  // 检测多个现代特性
  const supportsGrid = CSS.supports('display', 'grid')
  const supportsVariables = CSS.supports('--primary-color: #000')
  const supportsBackdrop = CSS.supports('backdrop-filter', 'blur(10px)')

  if (supportsGrid && supportsVariables) {
    container.classList.add('modern-layout')
    console.log('应用现代样式')
  }
  else {
    container.classList.add('fallback-layout')
    console.log('使用回退样式')
  }
}
```

## CSS @supports at-rule

`@supports` at-rule 允许在 CSS 中直接进行特性检测，类似于媒体查询，但针对的是 CSS 特性支持。

### 基本语法

```css
@supports (condition) {
  /* 当条件满足时应用的 CSS 规则 */
}

@supports not (condition) {
  /* 当条件不满足时应用的 CSS 规则 */
}

@supports (condition1) and (condition2) {
  /* 当所有条件都满足时应用的 CSS 规则 */
}

@supports (condition1) or (condition2) {
  /* 当任一条件满足时应用的 CSS 规则 */
}
```

### 使用示例

:::: code-tabs
@tab 基础检测

```css
/* 检测 Grid 支持 */
@supports (display: grid) {
    .container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
    }
}

/* 检测不支持的情况 */
@supports not (display: grid) {
    .container {
        display: flex;
        flex-wrap: wrap;
    }

    .item {
        flex: 1 1 300px;
        margin: 10px;
    }
}
```

@tab 复杂条件

```css
/* 组合条件检测 */
@supports (display: grid) and (position: sticky) {
    .header {
        position: sticky;
        top: 0;
    }

    .main-content {
        display: grid;
        grid-template-areas: "sidebar content";
    }
}

/* 或条件检测 */
@supports (backdrop-filter: blur(10px)) or
          (-webkit-backdrop-filter: blur(10px)) {
    .modal {
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        background: rgba(255, 255, 255, 0.8);
    }
}
```

@tab 实际布局示例

```css
/* 现代布局系统 */
.container {
    display: flex; /* 基础回退 */
}

@supports (display: grid) {
    .container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 1rem;
    }
}

/* CSS 变量支持检测 */
:root {
    --primary-color: #2c3e50; /* 基础值 */
}

@supports (--css-variables: yes) {
    :root {
        --primary-color: #3498db;
        --secondary-color: #e74c3c;
    }

    .button {
        background-color: var(--primary-color);
        color: white;
    }
}
```

::::

## 实际应用场景

### 1. 布局系统的渐进增强

```css title="响应式布局系统"
/* 基础移动端布局 */
.page-layout {
    display: block;
}

/* 中等屏幕 - Flexbox */
@supports (display: flex) and (max-width: 768px) {
    .page-layout {
        display: flex;
        flex-direction: column;
    }
}

/* 大屏幕 - Grid */
@supports (display: grid) and (min-width: 1024px) {
    .page-layout {
        display: grid;
        grid-template-areas:
            "header header"
            "sidebar content"
            "footer footer";
        grid-template-columns: 250px 1fr;
    }
}
```

### 2. 新特性的优雅降级

```css title="毛玻璃效果实现"
.card {
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

@supports (backdrop-filter: blur(10px)) or
          (-webkit-backdrop-filter: blur(10px)) {
    .glass-card {
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
    }
}

@supports not ((backdrop-filter: blur(10px)) or
               (-webkit-backdrop-filter: blur(10px))) {
    .glass-card {
        background: rgba(255, 255, 255, 0.95);
    }
}
```

### 3. JavaScript 中的动态特性检测

```javascript title="动态加载 polyfill"
class FeatureDetector {
  static checkFeatures() {
    const features = {
      cssGrid: CSS.supports('display', 'grid'),
      cssVariables: CSS.supports('--test: value'),
      backdropFilter: CSS.supports('backdrop-filter', 'blur(10px)')
        || CSS.supports('-webkit-backdrop-filter', 'blur(10px)'),
      aspectRatio: CSS.supports('aspect-ratio', '16 / 9')
    }

    return features
  }

  static loadPolyfills() {
    const features = this.checkFeatures()

    if (!features.cssGrid) {
      // 动态加载 Grid polyfill
      this.loadScript('css-grid-polyfill.js')
    }

    if (!features.cssVariables) {
      // 应用 CSS 变量回退方案
      this.applyVariableFallbacks()
    }

    // 更新 HTML 类以便 CSS 使用
    this.updateRootClasses(features)
  }

  static updateRootClasses(features) {
    const root = document.documentElement

    Object.entries(features).forEach(([feature, supported]) => {
      const className = supported
        ? `has-${feature}`
        : `no-${feature}`
      root.classList.add(className)
    })
  }
}

// 页面加载时检测
document.addEventListener('DOMContentLoaded', () => {
  FeatureDetector.loadPolyfills()
})
```

## 最佳实践与注意事项

:::warning 浏览器兼容性
虽然 `@supports` 和 `CSS.supports()` 在现代浏览器中得到良好支持，但在 IE 和旧版浏览器中不可用。==始终提供合理的回退方案=={.warning}。
:::

### 1. 性能考虑

```javascript
// 好的做法：缓存检测结果
class CSSSupportCache {
  constructor() {
    this.cache = new Map()
  }

  check(property, value = null) {
    const key = value ? `${property}:${value}` : property

    if (!this.cache.has(key)) {
      const result = value
        ? CSS.supports(property, value)
        : CSS.supports(property)
      this.cache.set(key, result)
    }

    return this.cache.get(key)
  }
}

const supportCache = new CSSSupportCache()

// 重复使用缓存结果
if (supportCache.check('display', 'grid')) {
  // 应用 Grid 样式
}
```

### 2. 渐进增强策略

:::: steps

* **定义核心体验**
  首先确保在不支持任何现代特性的浏览器中，网站的基本功能仍然可用

* **检测特性支持**
  使用 `@supports` 和 `CSS.supports()` 检测可用特性

* **分层增强**
  根据支持的特性逐步添加更高级的样式和交互

* **提供回退**
  为每个现代特性都准备合适的回退方案
  ::::

### 3. 测试策略

```javascript title="自动化特性检测测试"
describe('CSS 特性检测', () => {
  beforeEach(() => {
    // 重置缓存
    window.CSS._supportCache = null
  })

  test('应该检测 Grid 支持', () => {
    // 模拟不同环境
    const originalSupports = CSS.supports

    // 测试支持的情况
    CSS.supports = jest.fn().mockReturnValue(true)
    expect(CSS.supports('display', 'grid')).toBe(true)

    // 测试不支持的情况
    CSS.supports = jest.fn().mockReturnValue(false)
    expect(CSS.supports('display', 'grid')).toBe(false)

    CSS.supports = originalSupports
  })
})
```

## 总结

`CSS.supports()` JavaScript API 和 CSS `@supports` at-rule 为前端开发者提供了强大的特性检测能力，使得实现渐进增强和优雅降级变得更加简单可靠。

### 关键要点

:::important

* **使用场景**：`CSS.supports()` 适合动态检测，`@supports` 适合静态样式检测
* **渐进增强**：始终从基础体验开始，逐步添加增强功能
* **性能优化**：缓存检测结果，避免重复检测
* **回退方案**：为每个现代特性准备合适的回退方案
* **测试覆盖**：确保在不同浏览器环境下的兼容性

:::

### 参考

[MDN - CSS.supports()](https://developer.mozilla.org/zh-CN/docs/Web/API/CSS/supports){.read-more}
[MDN - @supports](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@supports){.read-more}
[Can I use - CSS Feature Queries](https://caniuse.com/css-featurequeries){.read-more}

通过合理运用这些特性检测工具，你可以构建出既现代化又具有良好兼容性的 Web 应用，为用户提供始终如一的优秀体验。

---

---
url: /article/npm-semantic-versions/index.md
---
# npm 语义化版本管理
## 前言

当我们着手进行项目开发时，为了方便项目管理，需要为项目定义一个版本。
可是，项目的版本号，应该怎么写呢？ 是 `1.0`，还是 `0.1` 还是 `1.0.0` 还是 `0.0.1` 呢？

如果是使用了 `1.0.0` 作为起始，那么下一次版本，应该是 `1.0.1` 还是 `1.1.0` 呢？

我们经常在一些开源的项目中，看到一些项目的版本号，还携带了后缀， 比如 `vue` 的 `3.0.0-beta.0`，
或者 `react` 的 `18.0.0-rc.0`。这些后缀有代表了什么含义呢？

## Semver 规范

使用一种好的版本号管理方案，可以帮助我们快速的了解版本的变化范围。

这并不是一个创新性的想法，实际上，你可能已经在做近似的事情了。问题在于只是“近似”还不够。
如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。
将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。
一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。

在 开源社区中，由 Gravatars 创办者兼 GitHub 共同创办者
[Tom Preston-Werner](http://tom.preston-werner.com/) 建立了 语义化版本控制的规范, `semantic version` 简称 `semver`，即 这个规范称为 `semver 规范`。

你可以在 <https://semver.org/lang/zh-CN/> 了解 `semver` 规范的详细信息。

### 版本号格式

版本格式：**主版本号.次版本号.修订号** ，我们以 `X.Y.Z` 作为 格式别名。

其中 X、Y 和 Z 为非负的整数，且禁止在数字前方补零，X 是主版本号、Y 是次版本号、而 Z 为修订号，
每个元素必须（MUST）以数值来递增。如 `1.9.1 -> 1.10.0 -> 1.11.0`。

### 版本控制规范

1. 标记版本号的软件发行后，**禁止** 改变该版本软件的内容。任何修改都 **必须** 以新版本发行。

2. 主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。

3. 1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。

4. 修订号 Z（x.y.Z | x > 0）**必须** 在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。

5. 次版本号 Y（x.Y.z | x > 0）**必须** 在有向下兼容的新功能出现时递增。
   在任何公共 API 的功能被标记为弃用时也 **必须递增**。
   也 **可以** 在内部程序有大量新功能或改进被加入时递增，其中 **可以** 包括修订级别的改变。
   每当次版本号递增时，修订号 **必须** 归零。

6. 主版本号 X（X.y.z | X > 0）**必须**在有任何不兼容的修改被加入公共 API 时递增。
   其中 **可以** 包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号 **必须** 归零。

7. 先行版本号 **可以** 被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。
   标识符 **必须** 由 ASCII 字母数字和连接号 `[0-9A-Za-z-]` 组成，且 **禁止**留白。
   数字型的标识符 **禁止** 在前方补零。先行版的优先级低于相关联的标准版本。
   被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。
   范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。

8. 版本编译信息 **可以** 被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。
   标识符 **必须** 由 ASCII 字母数字和连接号 `[0-9A-Za-z-]` 组成，且 **禁止** 留白。
   当判断版本的优先层级时，版本编译信息 **可** 被忽略。
   因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。

   范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。

9. 版本的优先层级指的是不同版本在排序时如何比较。

   1. 判断优先层级时，**必须** 把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较
      （版本编译信息不在这份比较的列表中）。

   2. 由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较。

      例如：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。

   3. 当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。

      例如：1.0.0-alpha < 1.0.0。

   4. 有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级 **必须** 透过由左到右的每个被句点
      分隔的标识符来比较，直到找到一个差异值后决定：

      1. 只有数字的标识符以数值高低比较。

      2. 有字母或连接号时则逐字以 ASCII 的排序来比较。

      3. 数字的标识符比非数字的标识符优先层级低。

      4. 若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。

      例如：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。

#### 总结递增规则如下

* 主版本号：当你做了不兼容的 API 修改，
* 次版本号：当你做了向下兼容的功能性新增，
* 修订号：当你做了向下兼容的问题修正。

先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。

## FAQ

### 在 0.y.z 初始开发阶段，我该如何进行版本控制？

最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。

### 如何判断发布 1.0.0 版本的时机？

当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。
如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。

### 语义化版本对于版本的字符串长度是否有限制呢？

没有，请自行做适当的判断。举例来说，长到 255 个字符的版本已过度夸张。
再者，特定的系统对于字符串长度可能会有他们自己的限制。

### “v1.2.3” 是一个语义化版本号吗？

“v1.2.3” 并不是一个语义化的版本号。但是，在语义化版本号之前增加前缀 “v” 是用来表示版本号的常用做法。
在版本控制系统中，将 “version” 缩写为 “v” 是很常见的。
比如：git tag v1.2.3 -m "Release version 1.2.3" 中，“v1.2.3” 表示标签名称，而 “1.2.3” 是语义化版本号。

## alpha、beta、rc

在规范中， 先行版本中 `-` 后的字符是自定义的，我们经常可以看到一些开源库使用的标识符如 `alpha`、`beta`、`rc`。

一般来说，这些 标识符表示以下含义：

* `alpha`: 表示 内部测试版本。主要是提供给内部的开发和测试使用，不建议用户下载。
* `beta`: 表示 公开测试版本。用户可以提前尝试使用一些功能。
* `rc`: 表示预览版本。表示该版本不再增加新的功能，可能还存在一些 bug，修复完成后就到 正式版本了。

## npm 指定版本范围

我们可以在 `package.json` 中看到版本号之前出现如 `^` 或 `~` 等符号，如：

```json
{
  "vuepress": "^1.9.7",
  "vue": "~2.7.11"
}
```

这些符号表示以后该库 安装版本的 允许范围。

通常常见的字符包括： `^`、 `~` 、 `>`、`<`、`<=`、`>=` 等。

`^` 表示 次版本号的更新，比如 `^1.2.3` 就表示以后安装的版本 `>=1.2.3 <2.0.0`。
但是如果 主版本号为 `0`，比如 `^0.2.3` 相当于 `>=0.2.3 <0.3.0`； `^0.0.3` 相当于 `>=0.0.3 <0.0.4`。

`~` 表示 修订号的更新，比如 `~1.2.3` 就表示以后安装的版本 `>=1.2.3 <1.3.0`。

完整版本范围说明，查看 [npm 文档](https://docs.npmjs.com/cli/v8/configuring-npm/package-json#dependencies)

---

---
url: /article/o0trf4ov/index.md
---
# 给 JavaScript 开发者的 Go 语言指南
写这篇文章，其实有些晚了，早在今年的 3 月份（2025 年），
微软宣布 [Typescript 官方编译器将移植到 Go](https://devblogs.microsoft.com/typescript/typescript-native-port/)，并承诺速度比当前编译器要快 10 倍。这引起了 Javascript 社区对 Go 语言的广泛关注。

因此，这篇文章旨在为对 ==Go 语言== 感到好奇或希望进一步了解的 ==JavaScript 开发者=={.info} 提供一个起点。
我将尝试涵盖 Go 的核心基础概念，同时与 `JavaScript/TypeScript` 中的类似概念进行比较，并分享一些我作为 JavaScript 开发者思维需要适应的注意事项。

::: tip 本文并不能完整的作为 Go 语言的入门教程。
:::

JavaScript 拥有多个运行时环境，为避免混淆，示例中的 JavaScript 代码均使用 `Typescript` 编写，并运行在 `Node.js` 环境下。

## 基础概念 {#basic}

### 编译与执行 {#compile-and-run}

首先需要了解的是，`Go` 是一种编译型语言，因此需要先编译成本地机器码二进制文件才能执行；
而 `JavaScript` 则是一种解释型语言，无需编译即可执行。

例如，你可以编写一个 `JavaScript` 文件，然后使用 `node` 命令直接运行它：

```js title="hello.js"
console.log('Hello, world!')
```

然后可以直接执行它：

```sh title="Terminal"
node hello.js
> Hello, world!
```

::: info 开始使用 `Go`
要开始使用Go，你需要从 <https://go.dev/dl/> 下载适用于你的系统的 Go 二进制发行版。
:::

以下是 `Go` 语言的示例：

```go title="hello.go"
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}

```

要运行此程序，你需要先构建它，然后执行生成的二进制文件：

```sh title="Terminal"
go build hello.go

./hello
> Hello, World!
```

或者，你也可以直接使用 `run` 命令，它能够一步完成编译与执行：

```sh title="Terminal"
go run hello.go
> Hello, World!
```

::: info 由于Go编译为本地机器码，若希望代码能在不同平台上运行，就需要为不同架构编译不同的二进制文件。
:::

### Packages - 包 {#packages data-outline="4"}

每个 `Go` 程序都由包构成，并从运行主包开始。
主包中必须包含一个名为 `main` 的函数，该函数作为程序的入口点，当主函数返回时程序结束。

::: go-repl title="main.go"

```go
package main // 声明 main 包
// 导入其他包
import (
  "fmt"
)
// 运行 main 包时， main 函数会默认执行
func main() {
  // 在控制台打印 Hello world
  fmt.Println("Hello world")
}
```

:::

::: tip 可通过代码片段标题右侧的在线运行按钮来执行示例。
:::

`Go` 语言中的包类似于`JavaScript` 中的模块，它们是一组相关的源文件集合。
你可以像在 `JavaScript` 中导入模块一样创建和导入包。
在上面的代码片段中，我们也从 `Go` 的标准库中导入了 `fmt` 包。

::: info
`fmt`（format的缩写）是Go语言的核心包之一。它用于格式化输入输出。
上文中的 `Println` 函数会以默认格式打印参数，并在末尾添加换行符。

:::

#### `go.mod`

类似于 `package.json`，`Go` 程序有一个 `go.mod` 文件，它作为 Go 模块的配置文件，包含了模块及其依赖项的信息。
一个典型的 `Go` 模块文件如下所示：

```go title="go.mod"
module myproject

go 1.16

require (
    github.com/gin-gonic/gin v1.7.4
    golang.org/x/text v0.3.7
)
```

* 第一行声明了模块的导入路径，作为该模块的唯一标识；
* 第二行指定了模块所需的最低 Go 版本；
* 最后列出了所有直接和间接依赖项及其具体版本。

要在 Go 中创建一个包，你需要新建一个目录，目录名即为包名，
然后该目录下的所有 Go 文件通过在文件顶部声明包名来成为该包的一部分。

在Go语言中，从包中导出内容的方式也很有趣。
在 JavaScript 中，如果使用 ES 模块，我们会用 `export` 关键字来使模块内的内容对外可用。
但在 Go 语言中，==如果一个名称以大写字母开头，它就会被导出=={.important}。

以下示例展示了我们之前讨论的所有内容：

::: go-repl

```go
package main

import (
  "fmt"
  "myproject/fib"
)

func main() {
  sequence := fib.FibonacciSequence(10)

  // 这将导致一个错误
  // firstFibonacciNumber := fib.fibonacci(1)

  fmt.Println("Fibonacci sequence of first 10 numbers:")
  fmt.Println(sequence)
}

-- go.mod --
module myproject

-- fib/fib.go --
package fib

// 由于此函数未以大写字母开头，因此它不会被导出。
func fibonacci(n int) int {
    if n <= 0 {
        return 0
    }
    if n == 1 {
        return 1
    }

    return fibonacci(n-1) + fibonacci(n-2)
}

// 该函数导出，因为它以大写字母开头
func FibonacciSequence(n int) []int {
    sequence := make([]int, n)

    for i := 0; i < n; i++ {
        sequence[i] = fibonacci(i)
    }

    return sequence
}
```

[在 **go playground** 中运行](https://goplay.tools/snippet/YGirZs_tEtD){.readmore}

在上述示例中，我们通过创建同名目录生成了另一个名为 `fib` 的包。
此外，如果仔细观察，只有 `FibonacciSequence` 函数被导出，因为它以 **大写字母开头**，因此可以在包外部访问。

### Variables - 变量 {#variables}

Go 是静态类型语言，即你需要声明（或推断）每个变量的类型，这些类型会在编译阶段进行检查。
这与 JavaScript 不同，在 JavaScript 中变量可以持有任意类型的值，且仅在程序运行时才会进行类型评估。

例如，在 JavaScript 中，你可以这样操作：

::: code-tabs
@tab JavaScript

```ts
let x = 5
let y = 2.5
let sum = x + y // 运行正常：7.5
// eslint-disable-next-line prefer-template
let weird = x + '2' // 同样“有效”：“52”（但可能并非你所期望！）
```

:::

但在 Go 语言中，你需要非常明确地指定类型，`var` 相当于现代 JavaScript 中的 `let`：

```go title="GoLang"
var x int = 5
// 或者 x := 5 这是一个简短的赋值语句。
// 可以替代具有隐式类型的变量声明。

var y float64 = 2.5

// 这将无法编译：
sum := x + y  // Error: mismatched types int and float64

// 必须显式转换：
sum := float64(x) + y
```

类似于 JavaScript 中的 `const`，Go 语言也拥有 `const` 关键字用于声明常量。
其声明方式与变量类似，但需使用 `const` 关键字：

```go title="GoLang"
const pi float64 = 3.14

// 或者声明时不指定类型以直接推断
const s = "hello"
```

但与 JavaScript 不同，==Go 语言中的 `const` 仅能用于基本类型（字符、字符串、布尔值或数值）=={.important}，而不能用于其他复杂类型。

::: warning 在 Go 语言中，声明变量却不使用它，并不仅仅是像某些 linter 在 JavaScript 或 TypeScript 中给出的警告那样，而是一个编译错误。
:::

### Structs and Types - 结构体与类型 {#structs-and-types}

正如你可以用 JavaScript 对象来表示一组字段一样，在 Go 中你也可以使用结构体来表示一组字段。

```go title="GoLang"
type Person struct {
  Name string
  Age int
}

p := Person{
  Name: "John",
  Age: 32,
}

// 或创建复合结构体
type User struct {
  Person Person
  ID     string
}

u := User{
  Person: p,
  ID:     "123",
}
```

::: info
在 Go 语言中，结构体字段名必须首字母大写才能被导出（供其他包访问或用于 [JSON序列化](https://pkg.go.dev/encoding/json)）。
小写字母开头的结构体字段是未导出的，仅在包内可见。
:::

乍看之下，你可能会觉得这种语法与 TypeScript 的 `type / interface` 相似，但实际行为却不同：

* 在 TypeScript 中，类型仅规定值的结构，你可以传入任何其他类型的超集，代码仍能正常运行。
* 而在 Go 中，结构体是具体的数据类型，其赋值兼容性是基于名称而非结构。

因此，以下代码在 TypeScript 中可以运行：

```ts twoslash title="TypeScript"
interface Person {
  name: string
  age: number
}

interface User {
  name: string
  age: number
  username: string
}

function helloPerson(p: Person) {
  console.log(p)
}

helloPerson({
  name: 'John',
  age: 32
})

const x: User = {
  name: 'John',
  age: 32,
  username: 'john',
}

helloPerson(x)
```

这在Go语言中行不通：

:::go-repl title="GoLang"

```go
package main

type Person struct {
    Name string
    Age  int
}

type User struct {
    Name     string
    Age      int
    Username string
}

func HelloPerson(p Person) {
    fmt.Println(p)
}

func main() {
    // This works fine
    HelloPerson(Person{
        Name: "John",
        Age:  32,
    })

    // 不能正常工作
    x := User{
        Name:     "John",
        Age:      32,
        Username: "john",
    }

    // Error: cannot use x (variable of struct type User) as Person value in argument to HelloPerson
    HelloPerson(x)

    // 要使其正常工作，你需要明确进行转换：
    // HelloPerson(Person{Name: x.Name, Age: x.Age})
}
```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/icNQx5SCNIx){.readmore}

Go 语言中的类型不仅限于结构体，它们可以定义变量能够持有的任何类型的值：

```go title="GoLang"
type ID int

var i ID
i = 2
```

一个常见的用例是创建基于字符串的枚举：

```go title="GoLang"
type Status string

const (
  StatusPending  Status = "pending"
  StatusApproved Status = "approved"
  StatusRejected Status = "rejected"
)

type Response struct {
  Status Status
  Meta   string
}

res := Response{
  Status: StatusApproved,
  Meta:   "Request successful",
}
```

与TypeScript的联合类型不同，Go 的自定义类型（如 `Status`）仅仅是其基础类型的别名。
编译器不会阻止你将任意字符串赋值给 `Status` 变量：

```go title="GoLang"
var s Status
s = "hello" // 可以正常编译
```

就 TypeScript 而言，它的类型系统是图灵完备的，允许你扩展或操作现有类型来创建新类型，
并完全在类型层面执行复杂计算。这使得高级类型验证和类型安全的抽象成为可能。

```ts title="TypeScript" twoslash
interface Person {
  firstName: string
  lastName: string
  age: number
}

// 扩展类型，包含Person的所有属性，以及额外的属性
type Doctor = Person & {
  speciality: string
}

type Res = { status: 'success', data: Person } | { status: 'error', error: string }

// Res 是一个区分联合类型，允许你根据状态访问不同的属性。
function getData(res: Res) {
  switch (res.status) {
    case 'success':
      console.log(res.data)
      break
    case 'error':
      console.log(res.error)
      break
  }
}

// 所有属性都是可选的类型
type OptionalDoctor = Partial<Doctor>

// 仅包含 firstName 和 speciality 属性的类型
type MinimalDoctor = Pick<Doctor, 'firstName' | 'speciality'>
```

Go 语言中的结构体主要是数据容器，不具备像TypeScript类型那样的操作特性。
最相似的功能是结构体嵌入，这是 Go 实现组合和一种继承形式的方式：

::: go-repl title="GoLang"

```go
package main

import "fmt"

type Person struct {
  FirstName string
  LastName  string
}

type Doctor struct {
  Person
  Speciality string
}

func main() {
  d := Doctor{
    Person: Person{
      FirstName: "Bruce",
      LastName:  "Banner",
    },
    Speciality: "gamma",
  }

  fmt.Println(d.Person.FirstName) // Bruce

  // 嵌入的结构体的键会被提升
  // 所以这也有效
  fmt.Println(d.FirstName) // Bruce
}

```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/llYHWGG0u35){.readmore}

### Zero Values - 零值 {#zero-values}

另一个可能让习惯 JavaScript 的你一开始感到困惑的概念是 Go 中的 ==零值=={.important}。
在 JavaScript 中，你可以定义一个变量，默认情况下它的值会是 `undefined` 。

```ts title="TypeScript" twoslash
let x: number | undefined
console.log(x) // undefined

x = 3
console.log(x) // 3
```

但在 Go 语言中，如果你初始化一个变量而未显式赋值，它会被赋予与类型相应的零值。

以下是一些基本类型的默认值：

```go title="GoLang"
var i int // 0
var f float64 // 0
var b bool // false
var s string // ""

x := i + 7 // 7
y := !b // true
z := s + "string" // string
```

同样地，结构体字段默认也具有零值：

```go title="GoLang"
type Person struct {
  name string  // ""
  age  int     // 0
}

p := Person{} // 创建一个名为空字符串且年龄为0的Person
```

Go语言也有 `nil` ，类似于 JavaScript 中的 `null`，但只有 **引用类型的变量** 才能持有 `nil` 值。
要理解这些概念，我们需要先了解 Go 语言中的指针。

### Pointers - 指针 {#pointers}

Go 语言拥有指针，其概念与 `C` 和 `C++` 等语言类似，指针用于存储指向某个值的内存地址。

您可以使用 `*T` 语法为类型 `T` 声明指针。在 Go 语言中，任何指针的零值都是 `nil`。

```go title="GoLang"
var i *int

i == nil // true
```

`&` 运算符生成指向其操作数的指针，而 `*` 运算符获取指针所指向的底层值，这也被称为 ==解引用指针=={.important}。

::: go-repl title="GoLang"

```go
package main

import "fmt"

func main() {
  x := 42
  i := &x
  fmt.Println(*i) // 42

  *i = 84
  fmt.Println(x) // 84
}
```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/VjT8Pafk3xN){.readmore}

但请记住，如果指针是nil，而你尝试解引用它，就会引发著名的 ==空指针解引用错误=={.warning} ：

```go title="GoLang"
var x *string

fmt.Println(*x)
// panic: runtime error: invalid memory address or nil pointer dereference
```

这引出了 JavaScript 开发者的需要关注的一个关键差异：

* 在 JavaScript 中，除了原始值外，所有内容都是隐式地通过引用传递的；
* 而 Go 则通过指针使其显式化。

例如，JavaScript 中的对象是通过引用传递的，因此如果你在函数内部修改对象，它会修改原始对象：

```ts title="TypeScript" twoslash
let obj = { value: 42 }

function modifyObject(o: any) {
  o.value = 84 // Original object is modified
}

modifyObject(obj)
console.log(obj.value) // 84
```

在 Go语言中，几乎所有内容都是按值传递的（除了切片、映射和通道，我们将在后续章节中介绍），
除非你使用指针，因此以下做法在 Go 中行不通：

::: go-repl title="GoLang"

```go
package main

type Object struct {
  Value int
}

func modifyObject(o Object) {
  o.Value = 84
}

func main() {
  o := Object{Value: 42}
  modifyObject(o) // 原始对象不会被修改
  fmt.Println(o.Value) // 42
}
```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/-nt_ZN68xMx){.readmore}

除非通过指针实现：

::: go-repl title="GoLang"

```go
package main

type Object struct {
  Value int
}

func modifyObjectPtr(o *Object) {
  o.Value = 84  // Go语言允许对结构体使用这种简写形式。
  // 而不是执行 (*o).Value
}

func main() {
  o := Object{Value: 42}
  modifyObjectPtr(&o)
  fmt.Println(o.Value) // 84
}
```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/0rq7_RnlxxV){.readmore}

这是因为当我们传递指针时，实际上传递的是 ==原始对象的内存地址=={.important}，这使得我们能够直接修改其底层值。
而且这不仅限于结构体，你可以为任何类型创建指针，包括基本类型：

::: go-repl title="GoLang"

```go
package main

func modifyValue(x *int) {
    *x = 100
}

func main() {
  y := 42
  modifyValue(&y)
  fmt.Println(y) // 100
}
```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/3jXZoqLjHpe){.readmore}

### Functions - 函数 {#functions}

我们在上一节简要介绍了函数，你可能已经猜到，它们与 JavaScript 中的工作方式非常相似。
除了使用 `func` 关键字而非 `function` 之外，它们的声明语法也与 JavaScript 颇为接近。

```go title="GoLang"
func greet(name string) string {
  if name == "" {
    name = "there"
  }
  return "Hello, " + name
}
```

与 JavaScript 类似，它们也是一等公民，这意味着它们可以被赋值给变量并传递，因此也支持高阶函数和闭包。
例如：

::: go-repl title="GoLang"

```go
package main

import "fmt"

func makeMultiplier(multiplier int) func(int) int {
  return func(x int) int {
    return x * multiplier
  }
}

func main() {
  double := makeMultiplier(2)

  fmt.Println(double(2)) // 4
}
```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/6l3X5QjvjA9){.readmore}

Go 语言同样支持从函数返回多个值。
这一模式在处理错误时尤为实用，我们将在后续章节中详细探讨。

::: go-repl title="GoLang"

```go
package main

import (
  "fmt"
  "strings"
)

func parseName(fullName string) (string, string) {
  parts := strings.Split(fullName, " ")
  if len(parts) < 2 {
    return parts[0], ""
  }
  return parts[0], parts[1]
}

func main() {
  firstName, lastName := parseName("Bruce Banner")

  fmt.Printf("%s, %s", lastName, firstName) // Banner, Bruce
}
```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/iv0rrwHGQgf){.readmore}

### Arrays and Slices - 数组与切片 {#arrays-and-slices}

在 Go 语言中，与 JavaScript 不同，数组具有固定容量，长度是其类型的一部分，因此无法调整大小。
这听起来可能有些局限，但我们马上会介绍一种处理数组的更好方法。

首先，我们来回顾一下 JavaScript 中数组的工作原理：

```ts title="TypeScript" twoslash
let s: Array<number> = [1, 2, 3]

s.push(4)

s[1] = 0

console.log(s) // [1, 0, 3, 4]
```

在 Go 语言中，你可以这样声明一个指定大小的数组：

```go title="GoLang"
var a [3]int
//  ^ 这将创建一个包含三个零值的数组：[0 0 0]

a[1] = 2 // [0 2 0]

// 或者你也可以定义一个带有初始值的数组：
b := [3]int{1,2,3}
```

注意这里没有 `push` 方法，因为在 Go 语言中数组长度是固定的。
而这正是切片发挥作用的地方。切片是对数组的动态大小灵活视图：

```go title="GoLang"
c := [6]int{1,2,3,4,5,6}

d := c[1:4] // [2 3 4]
```

乍一看，这或许像是 JavaScript 中的 `slice` 方法，但请记住：

* JavaScript 的 `slice` 返回的是 ==浅拷贝==，
* \==Go 中的切片则保持对底层数组的引用=={.important}。

因此，在 JavaScript 中可以这样操作：

```ts title="TypeScript" twoslash
let x: Array<number> = [1, 2, 3, 4, 5, 6]
let y = x.slice(1, 4)

y[1] = 0
console.log(x, y) // x = [1, 2, 3, 4, 5, 6] y = [2, 0, 4]
```

现在重点的部分是 ==切片字面量==。你可以通过 ==省略数组中的长度部分=={.important} 来创建切片字面量。

```go title="GoLang"
var a []int
// 或者
b := []int{1,2,3}

a == nil // true
```

对于 `b`，它创建了我们之前看到的相同数组，但 `b` 存储了引用该数组的切片。
另外，如果还记得上节中的 [零值](#zero-values) 概念，切片的零值是 `nil`，
因此在上面的例子中，`a` 将是 `nil`，因为指向底层数组的指针是 `nil` 。

除了底层数组外，切片还拥有 ==长度== 和 ==容量== 两个属性，
其中长度表示切片当前包含的元素数量，容量则代表底层数组的元素总数。
可以通过 `len` 和 `cap` 方法获取切片的长度与容量信息：

:::go-repl title="GoLang"

```go
package main

import "fmt"

func main() {
  s := []int{1,2,3,4,5,6}
  t := s[0:3]

  fmt.Printf("len=%d cap=%d %v\n", len(t), cap(t), t)
  // len=3 cap=6 [1 2 3]
}
```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/a-YG-bMozDz){.readmore}

在上述示例中，切片 `t` 的长度为 `3`，这是因为它从原始数组中被截取的方式所致，但底层数组的剩余容量仍为 `6`。

你也可以使用内置的 `make` 函数来创建一个切片，语法为 `make([]T, len, cap)` 。
它会分配一个初始化为零值的数组，并返回一个引用该数组的切片。

```go title="GoLang"
a := make([]int, 5)  // len(a)=5, cap(a)=5

b := make([]int, 0, 5) // len(b)=0, cap(b)=5
```

[在 **Go Playground** 中运行](https://goplay.tools/snippet/a4ZBuDj0VWn){.readmore}

此外，还有一个内置的 `append` 方法，它允许将项目追加到切片中，而无需担心切片的长度或容量：

```go title="GoLang"
a := []int{1,2,3}

a = append(a,4) // [1 2 3 4]
```

`append` 总是返回一个包含原切片所有元素及所提供值的新切片。
如果底层数组容量不足以容纳新增值，`append` 会创建更大的数组并返回指向该数组的切片。

与 JavaScript 不同，Go 语言没有内置声明式的函数式辅助工具，如 `map`、`reduce`、`filter` 等。
因此，你可以使用传统的 `for` 循环来遍历切片或数组：

```go title="GoLang"
for i, num := range numbers {
  fmt.Println(i, num)
}

// 或者如果你只想要数字的话
// for _, num := range numbers
```

最后，我们知道在 JavaScript 中数组属于非原始类型，因此它们总是通过引用传递：

```ts title="Typescript" twoslash
function modifyArray(arr: number[]) {
  arr.push(4)
  console.log('Inside function:', arr) // Inside function: [1, 2, 3, 4]
}

const myArray: number[] = [1, 2, 3]
modifyArray(myArray)
console.log('Outside function:', myArray) // Outside function: [1, 2, 3, 4]
```

在 Go 语言中，==数组是按值传递的=={.important}，正如我们在前一节所见，
**切片是数组片段的描述符，它包含一个指向数组的指针**，因此传递这个描述符意味着 ==对切片元素的修改会影响底层数组=={.important}。

::: go-repl title="GoLang"

```go
package main

import "fmt"

func modifyArray(arr [3]int) {
    arr[0] = 100
    fmt.Println("Array Inside:", arr) // Array Inside: [100, 2, 3]
}

func modifySlice(slice []int) {
    slice[0] = 100
    fmt.Println("Slice Inside:", slice) // Slice Inside: [100, 2, 3]
}

func main() {
  myArray := [3]int{1, 2, 3}
  mySlice := []int{1, 2, 3}

  modifyArray(myArray)
  fmt.Println("Array After:", myArray) // Array After: [1, 2, 3]

  modifySlice(mySlice)
  fmt.Println("Slice After:", mySlice) // Slice After: [100, 2, 3]
}
```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/EkXXRTBKYzh){.readmore}

### Maps - 映射 {#maps}

Go 中的 `Maps` 实际上更类似于 JavaScript 中的 `Map`，而非 JavaScript 对象（`JSON`），后者在存储键值对时更为常见。

简单回顾一下，JavaScript 中 `Map` 的工作原理如下：

```ts title="Typescript" twoslash
const userScores: Map<string, number> = new Map()

// 添加键值对
userScores.set('Alice', 95)
userScores.set('Bob', 82)
userScores.set('Charlie', 90)

// 定义一个用户年龄对象的 interface
interface UserAgeInfo {
  age: number
}

// 使用 interface 来定义一个映射
const userAges: Map<string, UserAgeInfo> = new Map([
  ['Alice', { age: 28 }],
  ['Bob', { age: 34 }],
  ['Charlie', { age: 22 }]
])

// 访问映射
console.log(userScores.get('Alice')) // 95

// 删除键值对
userScores.delete('Bob')

// 映射大小
console.log(userScores.size) // 2
```

同样地，这也是Go语言中映射（`map`）的工作原理：

::: go-repl title="GoLang"

```go
package main

import "fmt"

func main() {
  // Creating a map
  userScores := map[string]int{
    "Alice":   95,
    "Bob":     82,
    "Charlie": 90,
  }

  type UserAge struct {
    age int
  }

  // Alternative way to create
  userAges := make(map[string]UserAge)
  userAges["Alice"] = UserAge{age: 28}
  userAges["Bob"] = UserAge{age: 34}
  userAges["Charlie"] = UserAge{age: 22}

  // Getting values
  aliceScore := userScores["Alice"]
  fmt.Println(aliceScore) // 95

  // Deleting an entry
  delete(userScores, "Bob")

  // Size of the map
  fmt.Println(len(userScores)) // 2
}

```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/SC0q91MPMrd){.readmore}

需要注意的是，如果你尝试访问映射中不存在的键，你将得到该值类型的零值。
因此，在上面的例子中，这会导致 `davidScore` 被设置为 `0`，而不是像 JavaScript 中的 `undefined`。

```go title="GoLang"
davidScore := userScores["David"] // 0
```

那么，如何判断一个元素是否真的存在于映射中呢？
从映射中检索值会返回两个值：

* 第一个是值本身，也就是我们在上述例子中看到的
* 第二个是一个布尔值，表示该值是否确实存在于映射中。

::: go-repl title="GoLang"

```go
package main

import "fmt"

func main() {
  userScores := map[string]int{
    "Alice":   95,
    "Bob":     82,
    "Charlie": 90,
  }

  davidScore, exists := userScores["David"]
  if !exists {
    fmt.Println("David not found")
  }

  fmt.Println(davidScore)
}

```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/Pr2bOa4ofQi){.readmore}

最后，类似于我们之前看到的切片，映射变量同样是指向底层数据结构的指针，因此它们也像切片一样通过引用传递。

::: go-repl title="GoLang"

```go
package main

import "fmt"

func modifyMap(m map[string]int) {
  m["Zack"] = 100 // 这个更改将对调用者可见
}

func main() {
  scores := map[string]int{
    "Alice": 95,
    "Bob":   82,
  }

  fmt.Println("Before:", scores) // 之前: map[Alice:95 Bob:82]

  modifyMap(scores)

  fmt.Println("After:", scores) // 之后: map[Alice:95 Bob:82 Zack:100]
}
```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/tXlHkIfmLMd){.readmore}

### Comparisons - 比较 {#comparisons}

在 JavaScript中，进行严格相等性检查时，有时会让人感到困惑。
你可以按值比较原始类型，但其他所有类型都是通过引用来比较和传递的。

```ts title="Typescript" twoslash
let a = 5
let b = 5
console.log(a === b) // true - 按值比较

let str1 = 'hello'
let str2 = 'hello'
console.log(str1 === str2) // true - 按值比较

let a1 = { name: 'Hulk' }
let a2 = { name: 'Hulk' }
let a3 = a1

console.log(a1 === a2) // false - 内容相同但引用不同
console.log(a1 === a3) // true - 引用相同
```

但在 Go 语言中情况并非如此，几乎所有内容都 ==按值比较== ，即使是结构体和数组这样的复合类型，
只要它们不包含不可比较的类型（如切片、映射等）。例如

::: go-repl title="GoLang"

```go
package main

import "fmt"

type Person struct {
  Name string
  Age  int
}

func main() {
  p1 := Person{Name: "Alice", Age: 30}
  p2 := Person{Name: "Alice", Age: 30}

  fmt.Println("p1 == p2:", p1 == p2) // true - 相同内容，不同实例

  // 数组按值比较
  arr1 := [3]int{1, 2, 3}
  arr2 := [3]int{1, 2, 3}

  fmt.Println("arr1 == arr2:", arr1 == arr2) // true - 相同内容，不同实例

  // 但切片不能
  tasks := []string{"Task1", "Task2", "Task3"}
  tasks2 := []string{"Task1", "Task2", "Task3"}

  // 这不会编译：
  fmt.Println(tasks == tasks2) // 无效操作: tasks == tasks2

  // 尽管这是允许的
  fmt.Println(tasks == nil) // false

  // 但当一个结构体包含不可比较的类型时，它本身也成为不可比较的
  type Container struct {
    Items []int // 切片是不可比较的
  }

  c1 := Container{Items: []int{1, 2, 3}}
  c2 := Container{Items: []int{1, 2, 3}}

  // 这不会编译：
  fmt.Println("c1 == c2:", c1 == c2) // error: struct containing slice cannot be compared

  // 指针通过引用（地址）进行比较
  pp1 := &Person{Name: "Bob", Age: 25}
  pp2 := &Person{Name: "Bob", Age: 25}
  pp3 := pp1

  fmt.Println("pp1 == pp2:", pp1 == pp2)     // false - 不同实例
  fmt.Println("pp1 == pp3:", pp1 == pp3)     // true - 相同实例
  fmt.Println("*pp1 == *pp2:", *pp1 == *pp2) // true - 解引用比较值
}
```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/t7tOVCutIJ6){.readmore}

### Methods and Interfaces - 方法和接口 {#methods-and-interfaces}

在JavaScript中，我们使用类对象将相关的属性和方法打包成一个实体，以模拟现实世界中的概念。
你可以通过类来创建对象，而类本质上只是JavaScript原型继承系统的语法糖。

```ts title="Typescript" twoslash
class Rectangle {
  length: number
  width: number

  constructor(length: number, width: number) {
    this.length = length
    this.width = width
  }

  area() {
    return this.length * this.width
  }
}

const r = new Rectangle(4, 5)
console.log(r.area()) // 20
```

Go 语言不像许多其他语言那样拥有类，但它允许你直接在类型上定义方法。
方法是一种特殊的函数，它在 `func` 关键字和方法名之间有一个 ==特殊的接收者参数=={.important}。

例如：

::: go-repl title="GoLang"

```go
package main

import "fmt"

type Rectangle struct {
  length float64
  width  float64
}

func (r Rectangle) Area() float64 {
  return r.length * r.width
}

func main() {
  r := Rectangle{
    length: 4,
    width:  5,
  }
  fmt.Println(r.Area()) // 20
}

```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/HWQk6JXotK8){.readmore}

由于方法本质上就是带有接收者参数的函数，上述示例可以在功能完全不变的情况下重写为：

```go title="GoLang"
func Area(r Rectangle) float64 {
  return r.length * r.width
}
```

上述代码片段展示了一个值接收器的例子，其中接收器变量获取的是类型的副本。
尽管在大多数情况下，你会使用指针接收器来声明方法。
带有指针接收器的方法可以修改接收器所指向的值。

::: go-repl title="GoLang"

```go
package main

import "fmt"

type Rectangle struct {
  length float64
  width  float64
}

func (r Rectangle) Area() float64 {
  return r.length * r.width
}

func (r *Rectangle) Double() {
  r.length = r.length * 2
  r.width = r.width * 2
}

func main() {
  r := Rectangle{
    length: 4,
    width:  5,
  }

  r.Double()
  fmt.Println(r.Area()) // 80
}

```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/hoakk7i4sGJ){.readmore}

::: info 为了方便起见，Go 会自动将语句 `r.Double()` 解释为 `(&r).Double()`，因为 `Double()` 方法具有指针接收器。
:::

使用指针接收器的另一个好处是，你可以避免在每次方法调用时复制值，如果它是一个大型结构体，这可能会提高效率。

### Interfaces - 接口 {#interfaces}

正如我们所知，TypeScript 使用 `type` 和 `interface` 来定义对象的签名，
与其他语言类似，它们也可以与类结合使用，通过 `implements` 关键字来定义类的签名变量和方法：

```ts title="TypeScript" twoslash
interface Shape {
  area: () => number
  perimeter: () => number
}

class Circle implements Shape {
  #radius: number

  constructor(radius: number) {
    this.#radius = radius
  }

  area(): number {
    return Math.PI * this.#radius * this.#radius
  }

  perimeter(): number {
    return 2 * Math.PI * this.#radius
  }
}

function printArea(s: Shape) {
  console.log(s.area())
}

let c = new Circle(3)

printArea(c)
```

Go 语言的接口也服务于类似的目的，在 Go 中接口类型同样被定义为一组方法签名，并且它可以持有实现了这些方法的值。

例如

::: go-repl title="GoLang"

```go
package main

import (
  "fmt"
  "math"
)

type Shape interface {
  area() float64
  perimeter() float64
}

type Rectangle struct {
  length float64
  width  float64
}

func (r *Rectangle) area() float64 {
  return r.length * r.width
}

func (r *Rectangle) perimeter() float64 {
  return 2 * (r.length + r.width)
}

type Circle struct {
  radius float64
}

func (c *Circle) area() float64 {
  return math.Pi * c.radius * c.radius
}

func (c *Circle) perimeter() float64 {
  return 2 * math.Pi * c.radius
}

func printArea(s Shape) {
  fmt.Println(s.area())
}

func main() {
  r := &Rectangle{
    length: 4,
    width:  5,
  }

  c := &Circle{
    radius: 3,
  }

  fmt.Println("Rectangle area:")
  printArea(r)

  fmt.Println("Circle area:")
  printArea(c)
}
```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/EjS07cGLbxs){.readmore}

在上述示例中，请注意虽然 `Rectangle` 没有使用 `implements` 关键字，
但我们仍能将其传递给需要 `Shape` 类型参数的函数。
在 Go 语言中，类型通过实现接口的方法来隐式满足该接口，无需任何显式的 `implements` 关键字。

起初这可能看起来有些奇怪，但这是Go设计中的一个非常强大的特性，
它允许我们将接口的定义与其实现解耦，这意味着你可以为现有类型创建接口。

在 Go 语言中，接口的底层实现可以看作是一个包含值和具体类型的元组。以上述示例为例：

```go title="GoLang"
var r Shape

r = &Rectangle{
  length: 4,
  width:  5,
}

fmt.Printf("%v, %T", r, r) // &{4 5}, *main.Rectangle
```

同样地，一个空的接口既没有值也没有具体类型，访问该接口上的属性会导致空指针异常。

```go title="GoLang"
var r Shape

fmt.Printf("(%v, %T)\n", r, r) // <nil>, <nil>

r.Area() // Runtime error: nil pointer exception
```

一个空接口类型的变量可以容纳任何值，它相当于 TypeScript 中的 `any`。

```go title="GoLang"
var r interface{}

r = 42

r = "Bruce Banner"
```

::: info Go 1.18 还引入了一个名为 `any` 的类型，它实际上是空接口的别名，因此在上面的例子中，`var r any` 同样适用。
:::

最后，Go 语言中还有类型断言，可用于获取接口的底层具体值。例如在上述情况中

::: go-repl title="GoLang"

```go
package main

import (
  "fmt"
  "math"
)

type Shape interface {
  area() float64
  perimeter() float64
}

type Rectangle struct {
  length float64
  width  float64
}

func (r *Rectangle) area() float64 {
  return r.length * r.width
}

func (r *Rectangle) perimeter() float64 {
  return 2 * (r.length + r.width)
}

type Circle struct {
  radius float64
}

func (c *Circle) area() float64 {
  return math.Pi * c.radius * c.radius
}

func (c *Circle) perimeter() float64 {
  return 2 * math.Pi * c.radius
}

func printArea(s Shape) {
  fmt.Println(s.area())
}

func main() {
  var s Shape

  s = &Circle{
    radius: 3,
  }

  c, ok := s.(*Circle) // c 的类型是 *Circle
  fmt.Println(c, ok)   // &{3} true

  r, ok := s.(*Rectangle) // r 的类型将是 *Rectangle
  fmt.Println(r, ok)      // <nil> false
}

```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/OMvHoC4ztD7){.readmore}

而且这不仅仅适用于结构体类型，类型断言同样适用于基本类型：

::: go-repl title="GoLang"

```go
package main

import (
  "fmt"
)

func main() {
  var i interface{} = "hello"

  s, ok := i.(string)
  fmt.Println(s, ok)

  f, ok := i.(float64)
  fmt.Println(f, ok)
}
```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/JysEU1GCbiS){.readmore}

### Error Handling - 错误处理 {#error-handling}

这是我喜欢 Go 语言的一点，也是 JavaScript 值得借鉴的地方。
Go 语言处理错误的方式极其明确，而且如果你没有处理错误，还会有 linter 工具发出警告。

在 JavaScript 中处理错误最常见的方法之一是使用 `try catch`，以下是一个典型的函数示例，
该函数读取一些 JSON 文件，处理它们并返回 JSON ：

```ts title="TypeScript" twoslash
import fs from 'node:fs'

async function processFiles(filePaths: string[]): Promise<any[] | null> {
  try {
    const fileContents = await Promise.all(
      filePaths.map(path => fs.promises.readFile(path, 'utf-8'))
    )

    const results = fileContents.map(content => JSON.parse(content))
    return results
  }
  catch (error) {
    // 哪个操作失败了？是文件读取还是JSON解析？
    // 哪个文件导致了问题？
    console.error('Something went wrong:', error)
    return null
  }
}
```

在上述代码中，尽管我们处理了异常，但若没有额外操作（例如将每个文件读取和解析操作都包裹在 `try-catch` 中），
我们仍无法细致了解具体哪个环节可能出错。

但 Go 语言采用了不同的错误处理方式。它不使用异常机制，而是允许函数返回多个值。
按照惯例，最后一个返回值通常是错误类型。因此，上述示例在 Go 中会呈现为类似这样的形式：

```go title="GoLang"
func processFiles(filePaths []string) ([]map[string]string, error) {
  var results []map[string]string

  for _, path := range filePaths {
    // 在源头单独处理每个错误
    data, err := os.ReadFile(path)
    if err != nil {
      return nil, fmt.Errorf("failed to read file %s: %w", path, err)
    }

    var result map[string]string
    err = json.Unmarshal(data, &result)

    if err != nil {
      return nil, fmt.Errorf("failed to parse JSON from file %s: %w", path, err)
    }

    results = append(results, result)
  }

  return results, nil
}
```

在上述 Go 语言的示例中，错误在每一步都得到了显式处理，从而清晰地展示了故障发生的位置和原因。
每个可能失败的操作之后都会立即检查错误值，一旦出现错误，函数便会提前返回并附带详细的错误信息。

这种方法还促使开发者必须明确考虑并处理各种错误情况，而不是让异常在调用栈中未经处理地向上传递。

Go语言中也有一种称为延迟函数（`defer`）的特性，它允许我们在外围函数退出后立即执行某个语句。例如：

::: go-repl title="GoLang"

```go
package main

import "fmt"

func main() {
  defer fmt.Println("World")
  defer fmt.Println("Go")
  fmt.Println("Hello")
}
```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/6aLLD8qxgZo){.readmore}

`defer` 函数遵循后进先出（`LIFO`）的顺序执行，因此 `“World”` 会在最后打印。

`defer` 函数与 Go 语言的错误处理机制配合得天衣无缝，它允许你将清理代码紧邻资源分配的位置编写，
但仅在函数退出时执行。例如：

```go title="GoLang"
package main

import (
  "database/sql"
  "fmt"
  _ "github.com/lib/pq" // PostgreSQL driver
)

func getUsername(userID int) (string, error) {
    // 打开数据库连接
    db, err := sql.Open("postgres", "postgresql://username:password@localhost/mydb?sslmode=disable")
    if err != nil {
        return "", fmt.Errorf("无法连接到数据库: %w", err)
    }
    defer db.Close() // 这确保了函数退出时数据库连接被关闭。

    // 执行查询
    var username string
    err = db.QueryRow("SELECT username FROM users WHERE id = $1", userID).Scan(&username)
    if err != nil {
        return "", fmt.Errorf("获取用户名失败： %w", err)
    }

    return username, nil
}

```

在上面的示例中，用于关闭数据库的 `defer` 语句紧接在打开数据库连接之后，
这确保了只要打开连接时没有错误，无论函数如何退出，连接都会被关闭，
同时将清理代码紧邻资源获取处放置，清晰地展示了需要释放哪些资源。

在 JavaScript 中，我们使用类似 `finally` 代码块来实现类似的目标。
以下是上述示例在 JavaScript 中的方式：

```ts title="TypeScript"
import { Client } from 'pg'

async function getUsername(userId: string) {
  const client = new Client({
    connectionString: 'postgresql://username:password@localhost/mydb'
  })

  try {
    await client.connect()

    // 执行查询
    const result = await client.query('SELECT username FROM users WHERE id = $1', [userId])

    if (result.rows.length === 0) {
      throw new Error('User not found')
    }

    return result.rows[0].username
  }
  catch (error) {
    throw new Error(`Database error: ${error.message}`)
  }
  finally {
    await client.end() // 这相当于 Go 语言中用于清理的 defer 语句。
  }
}
```

延迟函数也可用于从 `panics` 中恢复，`panics` 是 Go 语言中与 JavaScript 运行时错误或异常相对应的概念。
在这两种语言中，当发生 `panics` 或运行时异常时，程序会停止执行当前函数并开始展开调用栈；
如果异常最终未被处理，程序将终止（在Go语言中，展开过程中仍会执行调用栈上的所有延迟函数）。

在 JavaScript 中，你可以使用相同的 `try-catch` 块来优雅地处理运行时错误；

而在 Go 语言中，你需要在 `defer` 函数中使用名为 `recover` 的特殊函数来处理 `panic`。例如：

::: go-repl title="GoLang"

```go
package main

import "fmt"

func riskyOperation() {
  defer func() {
    if r := recover(); r != nil {
      fmt.Println("Recovered from panic:", r)
    }
  }()

  // 这将引发 panic
  var arr []int
  fmt.Println(arr[1]) // 访问越界
}

func main() {
  riskyOperation()
  fmt.Println("Program continues after recovery")
}

```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/NfqH0R3d0rA){.readmore}

在上述示例中，当发生 `panic` 时，会执行延迟函数，该函数调用 `recover` 来捕获 `panic` 并防止程序崩溃。
这使得你能够优雅地处理错误并继续执行。

### Concurrency - 并发 {#concurrency}

这两种语言处理并发的方式是它们最大的不同之处。

JavaScript 本质上是单线程的，但由于其事件驱动的架构，它允许在主线程上通过回调、Promise 等方式执行非阻塞 I/O 操作。
这种事件驱动的架构使 JavaScript 能够在没有多线程的情况下实现并发。

Go通过 `goroutine` 支持真正的并发，这些是由 Go 运行时管理的轻量级线程（每个约 2KB）。
与 JavaScript 的单线程事件循环不同，Go 可以在多个操作系统线程上并行执行代码。
虽然 Go 代码本身是同步的，但 `goroutine` 使得跨 CPU 核心的并行执行成为可能。

以下是创建 `goroutine` 的方法：

::: go-repl title="GoLang"

```go
package main

import (
  "fmt"
  "time"
)

func say(s string) {
  fmt.Println(s)
}

func main() {
  go say("world")
  say("hello")

  // 添加睡眠以防止程序退出
  // 在 goroutine 运行之前，有更好的方式
  // 使用通道和等待组来处理这种情况
  time.Sleep(100 * time.Millisecond)
}

```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/0tQR1874rNG){.readmore}

在上面的示例中，`go` 关键字会在一个新的 `goroutine` 中执行该函数，该 `goroutine` 与当前 `goroutine` 并行运行。

要理解 `goroutine` 与 JavaScript 事件循环的对比，这里有一个示例：

我们并行发起多个 API 调用，并使用 `Promise.all` 等待响应：

```ts title="TypeScript"
async function fetchData() {
  try {
    // 同时发起两个请求, “并行”
    const postPromise = fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then(response => response.json())

    const commentsPromise = fetch('https://jsonplaceholder.typicode.com/posts/1/comments')
      .then(response => response.json())

    // 等待两个 promises 都 resolve
    const [post, comments] = await Promise.all([postPromise, commentsPromise])

    console.log('Post:', post)
    console.log('Comments:', comments)
  }
  catch (error) {
    console.error('Error fetching data:', error)
  }
}

fetchData()
```

以下是在 Go 语言中使用goroutine实现类似功能的示例：

::: go-repl title="GoLang"

```go
package main

import (
  "fmt"
  "io/ioutil"
  "net/http"
  "sync"
)

func main() {
  var wg sync.WaitGroup
  var postJSON, commentsJSON string
  var postErr, commentsErr error

  // Add two items to wait for
  wg.Add(2)

  // Fetch post in a goroutine
  go func() {
    defer wg.Done()
    resp, err := http.Get("https://jsonplaceholder.typicode.com/posts/1")
    if err != nil {
      postErr = err
      return
    }
    defer resp.Body.Close()

    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
      postErr = err
      return
    }

    postJSON = string(body)
  }()

  // Fetch comments in a goroutine
  go func() {
    defer wg.Done()
    resp, err := http.Get("https://jsonplaceholder.typicode.com/posts/1/comments")
    if err != nil {
      commentsErr = err
      return
    }
    defer resp.Body.Close()

    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
      commentsErr = err
      return
    }

    commentsJSON = string(body)
  }()

  // Wait for both goroutines to complete
  wg.Wait()

  // Handle any errors
  if postErr != nil {
    fmt.Println("Error fetching post:", postErr)
    return
  }
  if commentsErr != nil {
    fmt.Println("Error fetching comments:", commentsErr)
    return
  }

  // Print results
  fmt.Println("Post JSON:", postJSON)
  fmt.Println("Comments JSON:", commentsJSON)
}
```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/a36f7R8WqtT){.readmore}

::: important
上述示例使用了 `WaitGroup`，它属于 `sync` 包，为 Go 提供了基本的 `synchronization primitives`。

`Channels` 是 Go 另一个强大的特性，它允许 `goroutine` 之间相互通信，并可用于同步执行。
本文未涵盖 `Channels`，因为它们值得单独撰文探讨，但如果你想深入了解 Go 的并发模型，`Channels` 绝对值得关注。
:::

示例的关键区别在于：

* JavaScript 通过异步 I/O 和事件循环实现并发，将 I/O 操作委托给 浏览器 或 Node.js 在主线程外执行；
* 但对于 CPU 密集型任务，JavaScript 仍会在单主线程上运行，从而阻塞其他操作。
* 而 Go 通过 `goroutine` 实现真正的并行，这些协程可以跨 CPU 核心同时执行。以下是通过协程并行运行 CPU 密集型任务的示例：

::: go-repl title="GoLang"

```go
package main

import (
  "fmt"
  "sync"
)

func sum(s []int, result *int, wg *sync.WaitGroup) {
  defer wg.Done() // 表示此 goroutine 已完成

  sum := 0
  for _, v := range s {
    sum += v
  }
  *result = sum
}

func main() {
  s := []int{7, 2, 8, -9, 4, 0}

  var wg sync.WaitGroup
  var x, y int

  // 向等待组添加 2 个 goroutine
  wg.Add(2)

  // 运行 goroutines
  go sum(s[:len(s)/2], &x, &wg)
  go sum(s[len(s)/2:], &y, &wg)

  // 等待两个 goroutine 都完成
  wg.Wait()

  fmt.Println(x, y, x+y)
}
```

:::

[在 **Go Playground** 中运行](https://goplay.tools/snippet/hVHIuly3-bZ){.readmore}

在上述示例中，我们通过 `goroutine` 并行执行一个 CPU 密集型任务——对切片的两半分别求和，
类似这样的操作在 JavaScript 中除非使用 [Web Workers](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers) 或 [Node.js 的工作线程](https://nodejs.org/api/worker_threads.html)，否则无法原生支持。

### Formatting and Linting - 格式化和检查 {#formatting-and-linting}

Go 在标准库中通过 [Gofmt](https://pkg.go.dev/cmd/gofmt) 包提供了官方格式化工具。

与 JavaScript 生态中不同项目使用 `Prettier` / `Eslint` / `Biome` / `oxlint` 进行个性化配置不同，
`Gofmt` 的可配置性不强，但已被 大多数 Go 项目广泛接受，且多数编辑器默认通过扩展插件支持基于它的自动代码格式化。

在代码检查方面，Go 与 JavaScript 类似，社区构建了一系列检查规则，能够警告或自动修复各类代码质量问题。
[golangci-lint](https://golangci-lint.run/welcome/install/) 是流行的Go检查器运行工具之一，它能并行运行多个检查器，并集成了上百个可配置的检查器。

## 结语

如果你已经读到这里，希望本文为你对 Go 有所启发，并帮助你理解 Go 与 JavaScript 的异同——无论是语言特性还是运行机制。

## 相关资源 {#resources}

* [Go Playground](h**ttps://goplay.tools/)
* [Go 官方文档](https://go.dev/learn/)
* [Go 边学边练](https://go.dev/tour/)
* [Go Examples](https://gobyexample.com/)
* [urfave cli](https://github.com/urfave/cli)

---

---
url: /article/o5g7ggvf/index.md
---
# BFC 块级格式化上下文
## 概念

BFC, Block Formatting Context。是 W3C CSS2.1规范中的一个概念。 是页面中的一块块级渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和作用。

具有BFC特性的元素，可以看做是一个被隔离了的独立容器，容器内的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性。

## 创建BFC的方式

1. 根元素（html）
2. 浮动元素，即 float值不为 none。
3. 绝对定位元素， 元素的 position 为 absolute 或者 fixed
4. 行内块元素， 元素的 display 为 inline-block
5. 表格单元格， 元素的 display 为 table-cell。 （HTML表格单元格默认为该值）
6. 表格标题， 元素的display为table-caption。 （HTML表格标题默认为该值）
7. 匿名表格单元格元素， 元素的display为 table、table-row、table-row-group、table-header-group、table-footer-group 。
   （分别是 HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table。
8. overflow计算值不为visible的块元素
9. display值为 flow-root的元素
10. contain值为 layout、content、paint的元素
11. 弹性元素，display为 flex、inline-flex元素的直接子元素
12. 网格元素， display为gird、inline-gird元素的直接子元素
13. 多列容器，元素的column-count或column-width不为 auto， 包括column-count不为1
14. colum-span为all的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中。

## 作用

1. 同一个BFC的外边距会发生折叠（合并）， 通过将其放在不同的BFC中规避折叠。
2. BFC可以包含浮动元素，即清除浮动。
3. BFC可以阻止元素被浮动元素覆盖。

---

---
url: /article/o95q9n27/index.md
---
# jsdoc参考
[本文翻译自 **官方文档 JSDoc Reference**](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html){.read-more}

***

下面的列表概述了当使用 JSDoc 注释在 JavaScript 文件中提供类型信息时，当前支持哪些结构。

注意，下面没有显式列出的任何标记(例如 `@async` )都不支持。

**Types:**

* [@type](#type)
* [@import](#import)
* [@param](#param-and-returns) (or [@arg](#param-and-returns) or [@argument](#param-and-returns))
* [@returns](#param-and-returns) (or [@return](#param-and-returns))
* [@typedef](#typedef-callback-and-param)
* [@callback](#typedef-callback-and-param)
* [@template](#template)
* [@satisfies](#satisfies)

**Classes:**

* [Property Modifiers](#property-modifiers) `@public`, `@private`, `@protected`, [@readonly](#readonly)
* [@override](#override)
* [@extends](#extends) (or `@augments`)
* [@implements](#implements)
* `@class` (or [@constructor](#constructor))
* [@this](#this)

**Documentation:**

文档标签在TypeScript和JavaScript中都有效。

* [@deprecated](#deprecated)
* [@see](#see)
* [@link](#link)

**Other:**

* [@enum](#enum)
* [@author](#author)
* [Other supported patterns](#other-supported-patterns)
* [Unsupported patterns](#unsupported-patterns)
* [Unsupported tags](#unsupported-tags)

其含义通常与 [jsdoc.app](https://jsdoc.app) 中给出的标签含义相同，或者是超集。
下面的代码描述了不同之处，并给出了每个标记的一些示例用法。

## Types

### `@type`

你可以使用 `@type` 标签来声明类型，类型可以是：

* 原始的，如 `string`、`number` 等。
* 在 typescript 声明文件中声明的，可以是全局的，也可以是导入的。
* 在 [@typedef](#typedef-callback-and-param) 标签中声明的。

您可以使用大多数 JSDoc 类型语法和任何 TypeScript 语法，
从 [最基本的语法string](https://www.typescriptlang.org/docs/handbook/2/basic-types.html) 到 [最高级的语法（例如条件类型）](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)。

```js
/**
 * @type {string}
 */
var s

/** @type {Window} */
var win

/** @type {PromiseLike<string>} */
var promisedString

// 你可以用DOM属性指定一个HTML元素
/** @type {HTMLElement} */
var myElement = document.querySelector(selector)
element.dataset.myData = ''
```

`@type` 可以指定联合类型 - 例如，某些内容可以是字符串或布尔值。

```js
/**
 * @type {string | boolean}
 */
var sOrB
```

可以使用多种语法指定数组类型：

```js
/** @type {number[]} */
var ns
/** @type {Array.<number>} */
var jsdoc
/** @type {Array<number>} */
var nas
```

还可以指定对象文字类型。例如，具有属性“a”（字符串）和“b”（数字）的对象使用以下语法：

```js
/** @type {{ a: string, b: number }} */
var var9
```

可以使用标准 JSDoc 语法或 TypeScript 语法，使用字符串和数字索引签名来指定类 Map 和类 Array 对象。

```js
/**
 * 一个类似map的对象，将任意 `string` 属性映射到 `number`。
 *
 * @type {Object.<string, number>}
 */
var stringToNumber

/** @type {Object.<number, object>} */
var arrayLike
```

前面两种类型相当于 TypeScript 类型 `{ [x: string]: number }` 和 `{ [x: number]: any }` 。
编译器理解这两种语法。

可以使用 TypeScript 或 Google Closure 语法指定函数类型：

```js
/** @type {function(string, boolean): number} Closure syntax */
var sbn
/** @type {(s: string, b: boolean) => number} TypeScript syntax */
var sbn2
```

或者可以只使用未指定的Function类型：

```js
/** @type {Function} */
var fn7
/** @type {function} */
var fn6
```

Closure 中的其他类型也适用：

```js
/**
 * @type {*} - can be 'any' type
 */
var star
/**
 * @type {?} - unknown type (same as 'any')
 */
var question
```

#### Casts

TypeScript 借用了 Google Closure 的强制转换语法。
这允许 `@type` 通过在任何带括号的表达式之前添加标签来将类型转换为其他类型。

```js
/**
 * @type {number | string}
 */
var numberOrString = Math.random() < 0.5 ? 'hello' : 100
var typeAssertedNumber = /** @type {number} */ (numberOrString)
```

`const` 甚至可以像 TypeScript 一样进行转换：

```js
let one = /** @type {const} */ (1)
```

#### Import types

可以使用 类型导入 从其它文件中导入类型声明，此语法是 TypeScript 特定的，与 JSDoc 标准不同：

```js
// @filename: types.d.ts
export type Pet = {
  name: string,
};

// @filename: main.js
/**
 * @param {import("./types").Pet} p
 */
function walk(p) {
  console.log(`Walking ${p.name}...`);
}
```

导入类型可以在类型别名声明中使用：

```js
/**
 * @typedef {import("./types").Pet} Pet
 */

/**
 * @type {Pet}
 */
var myPet
myPet.name
```

如果不知道模块中值的类型，或者模块中的类型较大且难以获取，则可使用导入类型从模块中获取值的类型：

```js
/**
 * @type {typeof import("./accounts").userAccount}
 */
var x = require('./accounts').userAccount
```

### `@import`

`@import` 标签允许我们引用其他文件中的导出内容。

```ts
/**
 * @import {Pet} from "./types"
 */

/**
 * @type {Pet}
 */
var myPet
myPet.name
```

这些标签实际上并不会在运行时导入文件，它们引入的作用域符号仅能用于JSDoc注释中进行类型检查。

```ts
// @filename: dog.js
export class Dog {
  woof() {
    console.log('Woof!')
  }
}

// @filename: main.js
/** @import { Dog } from "./dog.js" */

const d = new Dog() // error!
```

### `@param` and `@returns`

`@param` 的语法使用与 `@type` 的类型语法使用相同，但添加了参数名称。
该参数也可以通过用方括号括住名称来声明为可选：

```js
// 可以用各种语法形式声明参数
/**
 * @param {string}  p1 - string 参数
 * @param {string=} p2 - 可选参数 (Google Closure syntax)
 * @param {string} [p3] - 可选参数 (JSDoc syntax).
 * @param {string} [p4="test"] - 带默认值的可选参数
 * @returns {string} 返回结果
 */
function stringsStringStrings(p1, p2, p3, p4) {
  // TODO
}
```

同样，对于函数的返回类型：

```js
/**
 * @return {PromiseLike<string>}
 */
function ps() {}

/**
 * @returns {{ a: string, b: number }} - 可以使用 '@returns' 或 '@return'
 */
function ab() {}
```

### `@typedef`, `@callback`, and `@param`

可以使用 `@typedef` 定义更加复杂的类型。类似的语法也适用于 `@param`。

```js
/**
 * @typedef {Object} SpecialType - 创建一个名为 'SpecialType' 的类型
 * @property {string} prop1 - SpecialType 上的 string 类型属性
 * @property {number} prop2 - SpecialType 上的 number 类型属性
 * @property {number=} prop3 - SpecialType 上的 一个可选的 number 类型属性
 * @prop {number} [prop4] - SpecialType 上的 一个可选的 number 类型属性
 * @prop {number} [prop5=42] - SpecialType 上的 一个可选的 number 类型属性，默认值为 42
 */

/** @type {SpecialType} */
var specialTypeObject
specialTypeObject.prop3
```

可以在第一行使用 `Object` 或 `object` 。

```js
/**
 * @typedef {object} SpecialType1 - creates a new type named 'SpecialType1'
 * @property {string} prop1 - a string property of SpecialType1
 * @property {number} prop2 - a number property of SpecialType1
 * @property {number=} prop3 - an optional number property of SpecialType1
 */

/** @type {SpecialType1} */
var specialTypeObject1
```

`@param` 允许对一次性类型规范使用类似的语法。
请注意，嵌套属性名称必须以参数名称作为前缀：

```js
/**
 * @param {Object} options - The shape is the same as SpecialType above
 * @param {string} options.prop1
 * @param {number} options.prop2
 * @param {number=} options.prop3
 * @param {number} [options.prop4]
 * @param {number} [options.prop5=42]
 */
function special(options) {
  return (options.prop4 || 1001) + options.prop5
}
```

`@callback` 与 `@typedef` 类似，但它指定函数类型而不是对象类型：

```js
/**
 * @callback Predicate
 * @param {string} data
 * @param {number} [index]
 * @returns {boolean}
 */

/** @type {Predicate} */
const ok = (s) => !(s.length % 2)
```

当然，任何这些类型都可以使用 TypeScript 语法在单行中声明 `@typedef`：

```js
/** @typedef {{ prop1: string, prop2: string, prop3?: number }} SpecialType */
/** @typedef {(data: string, index?: number) => boolean} Predicate */
```

### `@template`

可以使用 `@template` 标签声明类型参数。可以用于创建通用的函数、类或类型：

```js
/**
 * @template T
 * @param {T} x - A generic parameter that flows through to the return type
 * @returns {T}
 */
function id(x) {
  return x
}

const a = id('string')
const b = id(123)
const c = id({})
```

使用逗号或多个标签来声明多个类型参数：

```js
/**
 * @template T,U,V
 * @template W,X
 */
```

还可以在类型参数名称之前指定类型约束。仅列表中的第一个类型参数受到约束：

```js
/**
 * @template {string} K - K must be a string or string literal
 * @template {{ serious(): string }} Seriousalizable - must have a serious method
 * @param {K} key
 * @param {Seriousalizable} object
 */
function seriousalize(key, object) {
  // ????
}
```

最后，可以指定类型参数的默认值：

```js
/** @template [T=object] */
class Cache {
  /** @param {T} initial */
  constructor(initial) {}
}
let c = new Cache()
```

### `@satisfies`

`@satisfies` 提供 [对 TypeScript 中后缀运算符的satisfies](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html) 访问。
Satisfies 用于声明某个值实现了某种类型，但不影响该值的类型。

```js
// @ts-check
/**
 * @typedef {"hello world" | "Hello, world"} WelcomeMessage
 */

/** @satisfies {WelcomeMessage} */
const message = 'hello world' // const message: "hello world"

/** @satisfies {WelcomeMessage} */
const failingMessage = 'Hello world!'
// Type '"Hello world!"' does not satisfy the expected type 'WelcomeMessage'.

/** @type {WelcomeMessage} */
const messageUsingType = 'hello world' // const messageUsingType: WelcomeMessage
```

## Classes

Classes 可以声明 ES6 的 Classes

```js
class C {
  /**
   * @param {number} data
   */
  constructor(data) {
    // property types can be inferred
    this.name = 'foo'

    // or set explicitly
    /** @type {string | null} */
    this.title = null

    // or simply annotated, if they're set elsewhere
    /** @type {number} */
    this.size

    this.initialize(data) // Should error, initializer expects a string
  }
  /**
   * @param {string} s
   */
  initialize = function (s) {
    this.size = s.length
  }
}

var c = new C(0)

// C should only be called with new, but
// because it is JavaScript, this is allowed and
// considered an 'any'.
var result = C(1)
```

它们也可以声明为构造函数; 需要与 `@constructor` 和 `@this` 一起使用。

### Property Modifiers

`@public`、`@private` 和 `@protected` 的工作方式与 TypeScript 中的 `public`、 `private` 、`protected` 完全相同：

```js
// @ts-check

class Car {
  constructor() {
    /** @private */
    this.identifier = 100
  }

  printIdentifier() {
    console.log(this.identifier)
  }
}

const c = new Car()
console.log(c.identifier)
// Property 'identifier' is private and only accessible within class 'Car'.
```

* `@public` 始终是隐含的并且可以省略，但意味着可以从任何地方访问属性。
* `@private` 意味着属性只能在包含类中使用。
* `@protected` 意味着属性只能在包含类和所有派生子类中使用，但不能在包含类的不同实例上使用。

`@public`、`@private`、 和 `@protected` 不适用于构造函数。

### `@readonly`

`@readonly` 修饰符确保属性仅在初始化期间被写入。

```js
// @ts-check

class Car {
  constructor() {
    /** @readonly */
    this.identifier = 100
  }

  printIdentifier() {
    console.log(this.identifier)
  }
}

const c = new Car()
console.log(c.identifier)
```

### `@override`

`@override` 与 TypeScript 的工作方式相同；在重写基类方法的方法上使用它：

```js
export class C {
  m() {}
}
class D extends C {
  /** @override */
  m() {}
}
```

在 tsconfig 中设置 `noImplicitOverride: true` 以检查覆盖。

### `@extends`

当 JavaScript 类扩展通用基类时，没有用于传递类型参数的 JavaScript 语法。该 `@extends` 标签允许这样做：

```js
/**
 * @template T
 * @extends {Set<T>}
 */
class SortableSet extends Set {
  // ...
}
```

请注意，`@extends` 仅适用于类。目前，构造函数无法扩展类。

### `@implements`

同样，也没有用于实现 TypeScript 接口的 JavaScript 语法。该@implements标签的工作方式就像在 TypeScript 中一样：

```js
/** @implements {Print} */
class TextBook {
  print() {
    // TODO
  }
}
```

### `@constructor`

编译器根据 this-property 赋值推断构造函数，但是如果添加 `@constructor` 标签，
可以使检查更严格并提供更好的建议：

```js
/**
 * @constructor
 * @param {number} data
 */
function C(data) {
  // property types can be inferred
  this.name = 'foo'

  // or set explicitly
  /** @type {string | null} */
  this.title = null

  // or simply annotated, if they're set elsewhere
  /** @type {number} */
  this.size

  this.initialize(data)
  // Argument of type 'number' is not assignable to parameter of type 'string'.
  /**
   * @param {string} s
   */
  C.prototype.initialize = function (s) {
    this.size = s.length
  }

  var c = new C(0)
  c.size

  var result = C(1)
  // Value of type 'typeof C' is not callable. Did you mean to include 'new'?
}
```

> 注意：错误消息仅显示在具有 [JSConfig](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)
> 并 [checkJs](https://www.typescriptlang.org/tsconfig#checkJs) 启用的 JS 代码库中。

对于`@constructor`，`this` 是在构造函数 `C` 中检查的，所以你会得到初始化方法的建议，如果你给它传递一个数字就会出现错误。如果调用 `C` 而不是构造它，编辑器也可能显示警告。

不幸的是，这意味着同样可调用的构造函数不能使用 `@constructor`。

### `@this`

`this` 当编译器有一些上下文可以使用时，它通常可以找出类型。如果没有，您可以显式通过 `@this` 标签指定`this`：

```js
/**
 * @this {HTMLElement}
 * @param {*} e
 */
function callbackForLater(e) {
  this.clientHeight = parseInt(e) // should be fine!
}
```

## Documentation

### `@deprecated`

当函数、方法或属性被弃用时，您可以通过使用 `/** @deprecated */` JSDoc 注释对其进行标记来让用户知道。
该信息显示在完成列表中，并作为编辑器可以专门处理的建议诊断。
在 VS Code 等编辑器中，不推荐使用的值通常以删除线样式显示 ~~像这样~~。

```js
/** @deprecated */
const apiV1 = {}
const apiV2 = {}
```

### `@see`

`@see` 允许链接到程序中的其他名称：

```ts
type Box<T> = { t: T }
/** @see Box for implementation details */
type Boxify<T> = { [K in keyof T]: Box<T> }
```

有些编辑器会变成 Box 链接，以便轻松跳转。

### `@link`

@link与 类似@see，只不过它可以在其他标签内使用：

```ts
type Box<T> = { t: T }
/** @returns A {@link Box} containing the parameter. */
function box<U>(u: U): Box<U> {
  return { t: u }
}
```

## Other

### `@enum`

`@enum` 标签允许您创建一个对象字面值，其成员都是指定类型。
与JavaScript中的大多数对象字面量不同，它不允许其他成员。
`@enum` 旨在与Google Closure的 `@enum` 标签兼容。

```js
/** @enum {number} */
const JSDocState = {
  BeginningOfLine: 0,
  SawAsterisk: 1,
  SavingComments: 2,
}

JSDocState.SawAsterisk
```

注意 `@enum` 与TypeScript的 `enum` 完全不同，而且比它简单得多。
但是，与TypeScript的枚举不同，`@enum` 可以是任何类型:

```js
/** @enum {function(number): number} */
const MathFuncs = {
  add1: (n) => n + 1,
  id: (n) => -n,
  sub1: (n) => n - 1,
}

MathFuncs.add1
```

### `@author`

可以使用以下方式指定项目的作者@author：

```js
/**
 * Welcome to awesome.ts
 * @author Ian Awesome <i.am.awesome@example.com>
 */
```

请记住用尖括号将电子邮件地址括起来。否则，`@example` 将被解析为新标签。

### Other supported patterns

```js
var someObj = {
  /**
   * @param {string} param1 - JSDocs on property assignments work
   */
  x: function (param1) {},
}

/**
 * As do jsdocs on variable assignments
 * @return {Window}
 */
let someFunc = function () {}

/**
 * And class methods
 * @param {string} greeting The greeting to use
 */
Foo.prototype.sayHi = (greeting) => console.log('Hi!')

/**
 * And arrow function expressions
 * @param {number} x - A multiplier
 */
let myArrow = (x) => x * x

/**
 * Which means it works for function components in JSX too
 * @param {{a: string, b: number}} props - Some param
 */
var fc = (props) => <div>{props.a.charAt(0)}</div>

/**
 * A parameter can be a class constructor, using Google Closure syntax.
 *
 * @param {{new(...args: any[]): object}} C - The class to register
 */
function registerClass(C) {}

/**
 * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')
 */
function fn10(p1) {}

/**
 * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')
 */
function fn9(p1) {
  return p1.join()
}
```

### Unsupported patterns

对象字面量类型中的属性类型的后缀 equals 不指定可选属性：

```js
/**
 * @type {{ a: string, b: number= }}
 */
var wrong
/**
 * Use postfix question on the property name instead:
 * @type {{ a: string, b?: number }}
 */
var right
```

[strictNullChecks](https://www.typescriptlang.org/tsconfig#strictNullChecks) 可空类型仅在打开时才有意义：

```js
/**
 * @type {?number}
 * With strictNullChecks: true  -- number | null
 * With strictNullChecks: false -- number
 */
var nullable
```

TypeScript 原生语法是联合类型：

```js
/**
 * @type {number | null}
 * With strictNullChecks: true  -- number | null
 * With strictNullChecks: false -- number
 */
var unionNullable
```

不可为 null 的类型没有任何意义，并且被视为其原始类型：

```js
/**
 * @type {!number}
 * Just has type number
 */
var normal
```

与 JSDoc 的类型系统不同，TypeScript 只允许将类型标记为包含 null 或不包含 null。
没有显式的不可为空性 — 如果打开 `strictNullChecks`，则number不可为空。如果它关闭，则可number为空。

### Unsupported tags

TypeScript 会忽略任何不支持的 JSDoc 标签。

以下标签有待解决的问题来支持它们：

* `@const`（[问题＃19672](https://github.com/Microsoft/TypeScript/issues/19672)）
* `@inheritdoc`（[问题＃23215](https://github.com/Microsoft/TypeScript/issues/23215)）
* `@memberof`（[问题＃7237](https://github.com/Microsoft/TypeScript/issues/7237)）
* `@yields`（[问题＃23857](https://github.com/Microsoft/TypeScript/issues/23857)）

### Legacy type synonyms

为兼容旧版JavaScript代码，部分常见类型被赋予了别名。尽管多数别名类型现已罕用，但其中部分与现有类型名称相同。
例如 `String` 被视为 `string` 的别名——虽然在 TypeScript 中 `String` 本身是独立类型，
但旧版JSDoc常将其作为 `string` 使用。此外需注意：TypeScript 中首字母大写的原始类型实为包装器类型
（使用它们几乎总是错误的）。因此编译器会根据旧版JSDoc的使用惯例将这些类型视为同义词：

* `String` -> `string`
* `Number` -> `number`
* `Boolean` -> `boolean`
* `Void` -> `void`
* `Undefined` -> `undefined`
* `Null` -> `null`
* `function` -> `Function`
* `array` -> `Array<any>`
* `promise` -> `Promise<any>`
* `Object` -> `any`
* `object` -> `any`

当`noImplicitAny: true` 时，最后四个别名将被禁用：

* `object` 和 `Object` 是内置类型，不过 `Object` 很少被使用。
* `array` 和 `promise` 并非内置类型，但可能在程序中的某处被声明。

---

---
url: /article/ofdnzflv/index.md
---
# Web Animations API 入门
> 在现代前端开发中，创造流畅、高性能的动画效果已成为提升用户体验的关键。Web Animations API 为我们提供了一种强大而灵活的方式来控制动画，让我们一起来探索它的魅力！

## 什么是 Web Animations API？

Web Animations API (WAAPI) 是一个现代的 JavaScript API，它允许开发者使用 JavaScript 来控制 CSS 动画和过渡。与传统的 CSS 动画相比，WAAPI 提供了更精细的控制能力和更强大的编程接口。

:::info 为什么选择 WAAPI？

* **性能优异**：与 CSS 动画性能相当，但控制更灵活
* **编程友好**：完全使用 JavaScript，便于逻辑控制
* **时间轴控制**：精确的播放控制和时间管理
* **兼容性良好**：现代浏览器广泛支持
  :::

## 基础入门

### 1. 创建第一个动画

让我们从一个简单的动画开始：

```javascript title="基础动画示例"
// 获取要动画的元素
const element = document.getElementById('animatedElement')

// 创建动画
const animation = element.animate(
  [
    // 关键帧：从状态
    { transform: 'translateX(0px)', opacity: 1 },
    // 关键帧：到状态
    { transform: 'translateX(100px)', opacity: 0.5 }
  ],
  {
    // 动画选项
    duration: 1000, // 持续时间：1秒
    easing: 'ease-in-out', // 缓动函数
    fill: 'forwards' // 动画结束后保持最终状态
  }
)
```

### 2. 动画选项详解

WAAPI 提供了丰富的配置选项：

```javascript title="完整动画配置"
const animation = element.animate(
  [
    { transform: 'scale(1)', backgroundColor: 'red' },
    { transform: 'scale(1.5)', backgroundColor: 'blue' },
    { transform: 'scale(1)', backgroundColor: 'green' }
  ],
  {
    duration: 2000, // 动画持续时间（毫秒）
    delay: 500, // 开始前延迟（毫秒）
    iterations: 3, // 重复次数（Infinity 表示无限循环）
    direction: 'alternate', // 播放方向：normal, reverse, alternate, alternate-reverse
    easing: 'cubic-bezier(0.42, 0, 0.58, 1)', // 缓动函数
    fill: 'both', // 填充模式：none, forwards, backwards, both
    composite: 'replace' // 复合操作：replace, add, accumulate
  }
)
```

## 核心概念深入

### 1. 关键帧格式

WAAPI 支持多种关键帧格式：

::: code-tabs
@tab 对象数组格式

```javascript
element.animate(
  [
    { opacity: 0, transform: 'translateY(-100px)' },
    { opacity: 1, transform: 'translateY(0)' }
  ],
  { duration: 1000 }
)
```

@tab 属性数组格式

```javascript
element.animate(
  {
    opacity: [0, 1],
    transform: ['translateY(-100px)', 'translateY(0)']
  },
  { duration: 1000 }
)
```

@tab 偏移指定格式

```javascript
element.animate(
  [
    { opacity: 0, offset: 0 },
    { opacity: 0.5, offset: 0.3 },
    { opacity: 1, offset: 1 }
  ],
  { duration: 1000 }
)
```

:::

### 2. 缓动函数

缓动函数决定了动画的变化速率：

```javascript title="常用缓动函数示例"
const easings = {
  linear: 'linear',
  ease: 'ease',
  easeIn: 'ease-in',
  easeOut: 'ease-out',
  easeInOut: 'ease-in-out',
  customBezier: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)',
  steps: 'steps(5, jump-end)'
}

// 使用不同的缓动函数
Object.entries(easings).forEach(([name, easing]) => {
  element.animate(
    [{ transform: 'translateX(0)' }, { transform: 'translateX(100px)' }],
    { duration: 1000, easing }
  )
})
```

## 动画控制与管理

### 1. 播放控制

WAAPI 提供了完整的播放控制接口：

```javascript title="动画控制方法"
const animation = element.animate(
  [{ opacity: 0 }, { opacity: 1 }],
  { duration: 2000, fill: 'forwards' }
)

// 播放控制
animation.play() // 开始或恢复播放
animation.pause() // 暂停播放
animation.cancel() // 取消动画并重置
animation.finish() // 立即完成动画

// 播放状态查询
console.log(animation.playState) // running, paused, finished, etc.

// 反转播放
animation.reverse()
```

### 2. 时间控制

```javascript title="时间控制示例"
const animation = element.animate(
  [{ transform: 'rotate(0deg)' }, { transform: 'rotate(360deg)' }],
  { duration: 5000, iterations: Infinity }
)

// 时间控制
animation.currentTime = 1000 // 跳转到指定时间（毫秒）
animation.playbackRate = 2 // 2倍速播放
animation.playbackRate = -1 // 反向播放

// 监听时间更新
animation.onframe = () => {
  console.log('当前时间:', animation.currentTime)
}
```

### 3. 事件监听

```javascript title="动画事件监听"
const animation = element.animate(
  [{ opacity: 0 }, { opacity: 1 }],
  { duration: 1000 }
)

// 事件监听
animation.onfinish = () => {
  console.log('动画完成！')
}

animation.oncancel = () => {
  console.log('动画被取消')
}

// 使用 addEventListener
animation.addEventListener('finish', () => {
  console.log('动画完成事件')
})

animation.addEventListener('cancel', () => {
  console.log('动画取消事件')
})
```

## 高级特性

### 1. 组合动画

```javascript title="动画组合示例"
// 创建多个动画
const moveAnimation = element.animate(
  [{ transform: 'translateX(0)' }, { transform: 'translateX(200px)' }],
  { duration: 1000, fill: 'forwards' }
)

const fadeAnimation = element.animate(
  [{ opacity: 1 }, { opacity: 0.3 }],
  { duration: 1000, fill: 'forwards' }
)

const scaleAnimation = element.animate(
  [{ transform: 'scale(1)' }, { transform: 'scale(1.2)' }],
  { duration: 1000, fill: 'forwards' }
)

// 顺序执行动画
moveAnimation.finished.then(() => {
  return fadeAnimation.play()
}).then(() => {
  return scaleAnimation.play()
})
```

### 2. 动画时间轴

```javascript title="时间轴动画"
class AnimationTimeline {
  constructor() {
    this.animations = []
    this.currentTime = 0
  }

  addAnimation(animation, startTime) {
    this.animations.push({ animation, startTime })
  }

  play() {
    this.animations.forEach(({ animation, startTime }) => {
      setTimeout(() => {
        animation.play()
      }, startTime)
    })
  }
}

// 使用时间轴
const timeline = new AnimationTimeline()
timeline.addAnimation(moveAnimation, 0)
timeline.addAnimation(fadeAnimation, 500)
timeline.addAnimation(scaleAnimation, 1000)
timeline.play()
```

### 3. 性能优化技巧

:::warning 性能注意事项

* 使用 `transform` 和 `opacity` 属性进行动画，它们不会触发重排
* 避免在动画中修改会触发重排的属性（如 width、height、left 等）
* 使用 `will-change` 属性提示浏览器进行优化
  :::

```javascript title="性能优化示例"
// 好的做法 - 高性能
element.animate(
  [
    { transform: 'translateX(0) scale(1)' },
    { transform: 'translateX(100px) scale(1.5)' }
  ],
  { duration: 1000 }
)

// 避免的做法 - 性能较差
element.animate(
  [
    { left: '0px', width: '100px' },
    { left: '100px', width: '150px' }
  ],
  { duration: 1000 }
)
```

## 实战案例

### 1. 加载动画

```javascript title="加载动画实现"
function createLoadingAnimation(element) {
  return element.animate(
    [
      { transform: 'rotate(0deg)', opacity: 0.5 },
      { transform: 'rotate(180deg)', opacity: 1 },
      { transform: 'rotate(360deg)', opacity: 0.5 }
    ],
    {
      duration: 1500,
      iterations: Infinity,
      easing: 'ease-in-out'
    }
  )
}

// 使用
const loader = document.querySelector('.loader')
const loadingAnimation = createLoadingAnimation(loader)

// 页面加载完成后停止动画
window.addEventListener('load', () => {
  loadingAnimation.cancel()
})
```

### 2. 交互动画

```javascript title="鼠标交互动画"
class HoverAnimation {
  constructor(element) {
    this.element = element
    this.animation = null

    this.setupEventListeners()
  }

  setupEventListeners() {
    this.element.addEventListener('mouseenter', this.onMouseEnter.bind(this))
    this.element.addEventListener('mouseleave', this.onMouseLeave.bind(this))
  }

  onMouseEnter() {
    if (this.animation) {
      this.animation.cancel()
    }

    this.animation = this.element.animate(
      [
        { transform: 'scale(1)', boxShadow: '0 0 0 rgba(0,0,0,0)' },
        { transform: 'scale(1.05)', boxShadow: '0 5px 15px rgba(0,0,0,0.3)' }
      ],
      {
        duration: 300,
        easing: 'ease-out',
        fill: 'forwards'
      }
    )
  }

  onMouseLeave() {
    if (this.animation) {
      this.animation.cancel()
    }

    this.animation = this.element.animate(
      [
        { transform: 'scale(1.05)', boxShadow: '0 5px 15px rgba(0,0,0,0.3)' },
        { transform: 'scale(1)', boxShadow: '0 0 0 rgba(0,0,0,0)' }
      ],
      {
        duration: 300,
        easing: 'ease-in',
        fill: 'forwards'
      }
    )
  }
}

// 使用
const interactiveElements = document.querySelectorAll('.interactive')
interactiveElements.forEach(el => new HoverAnimation(el))
```

### 3. 页面过渡动画

```javascript title="页面过渡动画"
class PageTransition {
  constructor() {
    this.animations = new Map()
  }

  async fadeIn(element) {
    const animation = element.animate(
      [
        { opacity: 0, transform: 'translateY(20px)' },
        { opacity: 1, transform: 'translateY(0)' }
      ],
      {
        duration: 600,
        easing: 'ease-out',
        fill: 'both'
      }
    )

    this.animations.set(element, animation)
    return animation.finished
  }

  async fadeOut(element) {
    const animation = element.animate(
      [
        { opacity: 1, transform: 'translateY(0)' },
        { opacity: 0, transform: 'translateY(-20px)' }
      ],
      {
        duration: 400,
        easing: 'ease-in',
        fill: 'both'
      }
    )

    this.animations.set(element, animation)
    return animation.finished
  }

  async transition(oldElement, newElement) {
    await this.fadeOut(oldElement)
    oldElement.style.display = 'none'
    newElement.style.display = 'block'
    await this.fadeIn(newElement)
  }
}
```

## 兼容性与降级方案

:::caution 兼容性提示
虽然现代浏览器广泛支持 WAAPI，但为了更好的兼容性，建议提供降级方案。
:::

```javascript title="兼容性处理"
// 特征检测
function supportsWebAnimations() {
  return 'animate' in Element.prototype
}

// 安全的动画创建函数
function safeAnimate(element, keyframes, options) {
  if (supportsWebAnimations()) {
    return element.animate(keyframes, options)
  }
  else {
    // 降级到 CSS 动画
    return fallbackToCSSAnimation(element, keyframes, options)
  }
}

function fallbackToCSSAnimation(element, keyframes, options) {
  const animationName = `anim-${Date.now()}`

  // 创建 CSS 关键帧
  const style = document.createElement('style')
  let css = `@keyframes ${animationName} {`

  keyframes.forEach((frame, index) => {
    const percent = (index / (keyframes.length - 1)) * 100
    css += `${percent}% {`
    Object.entries(frame).forEach(([property, value]) => {
      css += `${property}: ${value};`
    })
    css += '}'
  })

  css += '}'
  style.textContent = css
  document.head.appendChild(style)

  // 应用动画
  element.style.animation = `
    ${animationName}
    ${options.duration}ms
    ${options.easing || 'ease'}
    ${options.delay || 0}ms
    ${options.iterations || 1}
    ${options.direction || 'normal'}
    ${options.fill || 'none'}
  `

  // 返回模拟的动画对象
  return {
    cancel: () => {
      element.style.animation = ''
      document.head.removeChild(style)
    },
    finished: new Promise((resolve) => {
      element.addEventListener('animationend', resolve, { once: true })
    })
  }
}
```

## 调试与最佳实践

### 1. 调试技巧

```javascript title="动画调试工具"
class AnimationDebugger {
  static logAnimation(animation, name = 'Unnamed Animation') {
    console.group(`🎬 ${name}`)
    console.log('状态:', animation.playState)
    console.log('当前时间:', animation.currentTime)
    console.log('播放速率:', animation.playbackRate)
    console.log('总时间:', animation.effect.getComputedTiming().duration)
    console.groupEnd()

    // 定期更新
    const interval = setInterval(() => {
      if (animation.playState === 'finished') {
        clearInterval(interval)
      }
      console.log(`[${name}] 时间:`, animation.currentTime)
    }, 100)
  }
}

// 使用调试工具
const anim = element.animate([
  // ...
], {
  // ...
})
AnimationDebugger.logAnimation(anim, '示例动画')
```

### 2. 最佳实践总结

:::steps

* **性能优先**：始终使用 `transform` 和 `opacity` 进行动画
* **适当使用**：不要过度使用动画，保持用户体验的流畅性
* **可访问性**：为偏好减少动画的用户提供 `prefers-reduced-motion` 支持
* **错误处理**：始终处理动画可能失败的情况
* **资源清理**：及时取消不再需要的动画，释放资源

:::

```javascript title="最佳实践示例"
// 响应式动画 - 尊重用户偏好
const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)')

function createRespectfulAnimation(element, keyframes, options) {
  if (mediaQuery.matches) {
    // 用户偏好减少动画，立即应用最终状态
    const finalFrame = keyframes[keyframes.length - 1]
    Object.entries(finalFrame).forEach(([property, value]) => {
      element.style[property] = value
    })
    return { cancel: () => {}, finished: Promise.resolve() }
  }

  return element.animate(keyframes, options)
}
```

## 总结

Web Animations API 为前端开发者提供了强大而灵活的动画控制能力。

* **基础用法**：创建和控制简单动画
* **核心概念**：关键帧、缓动函数、时间控制
* **高级特性**：动画组合、时间轴、性能优化
* **实战应用**：加载动画、交互动画、页面过渡
* **生产就绪**：兼容性处理、调试技巧、最佳实践

WAAPI 不仅功能强大，而且与现有的 CSS 动画性能相当，是现代 Web 动画的首选方案。随着浏览器的不断更新和完善，WAAPI 将会成为 Web 动画的标准解决方案。

## 参考

* [MDN Web Animations API 文档](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API)
* [WAAPI 规范](https://drafts.csswg.org/web-animations/)
* [动画性能指南](https://web.dev/animations/)
* [缓动函数速查表](https://easings.net/)

---

---
url: /article/ofp08jd8/index.md
---
# VSCode 常用插件推荐
`VS Code` 作为我现在工作中最常用的编辑器，也是我十分喜欢的编辑器。它强大的功能和插件系统，对我的工作提供了很多帮助和支持。将我在工作中经常使用的插件，推荐给大家。

### Code

1. [Code Spell Checker](https://github.com/Jason-Rev/vscode-spell-checker)

   单词拼写检查插件，帮助检查代码中单词是否拼写错误，包括驼峰形式的变量名称检查。可以在一定程度避免一些不必要的单词拼写错误导致的一些低级错误。

2. [ESLint](https://github.com/Microsoft/vscode-eslint)

   javascript ES6 代码规范、语法检查工具，帮助规范团队代码规范。

3. [EditorConfig](https://github.com/editorconfig/editorconfig-vscode)

   编辑器配置，代码格式规范相关，必备。

4. [Prettier](https://github.com/prettier/prettier-vscode)

   帮助格式化`javascript`、`typescript`、`CSS`代码。&#x20;
   `Prettier` 会读取 `.editorconfig`，或根据提供相关配置，格式化代码为符合项目代码规范。

5. [Bracket Pair Colorizer](https://github.com/CoenraadS/BracketPair)

   可以对每一个代码块或者每一层嵌套，以不同的颜色高亮，帮助阅读代码。
   ![Bracket Pair Colorizer](https://github.com/CoenraadS/BracketPair/raw/develop/images/example.png)&#x20;
   主要是针对 `()`，`[]`，`{}` 进行不同嵌套的颜色高亮

6. [Code Runner](https://github.com/formulahendry/vscode-code-runner)

   在`VSCode`中运行各种各样的语言。并将结果输出到输出控制台。
   方便代码调试。

7. [Color Highlight](https://github.com/sergiirocks/vscode-ext-color-highlight)

   颜色高亮插件，读取文件中的 十六进制、RGB、RGBA 等颜色，并以对应的颜色高亮显示。

### theme

1. [Atom One Dark Theme](https://github.com/akamud/vscode-theme-onedark)

   一款 Atom 的 暗色系主题皮肤。 习惯了`Atom`编辑器，转而使用`VSCode`的小伙伴们可以使用这款皮肤。
   颜色对比度适中，不会太过强烈。
   ![Atom One Dark Theme](https://raw.githubusercontent.com/akamud/vscode-theme-onedark/master/screenshots/preview.png)

### GIT

1. [Git Blame](https://marketplace.visualstudio.com/items?itemName=waderyan.gitblame)

   可以帮助查看到文件的每一行的详细修改信息，包括 HASH串、作者、日期等。

2. [Git history](https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory)

   以可视化的界面查看 git log 信息。支持：
   查看所有分支或者某一个分支的log信息；
   查看某一个文件的log信息；
   查看某一个作者的log信息等。

3. [Git Project Manager](https://github.com/felipecaputo/git-project-manager)

   该插件可以帮助你快速在VSCode新窗口打开本地git项目。
   命令：`ctrl+shift+p` / `cmd+shift+p`&#x20;
   或者按下 `F1`，输入 `GPM`

4. [Git Tags](https://github.com/leftstick/vscode-git-tags)

   Git Tag 管理插件

5. [Git Lens](https://gitlens.amod.io/)

   这款插件十分适合在多人协作项目中使用，可以定位到当前文件每一行的最后提交作者、时间等git log，也可以查看到当前文件的所有日志等。
   如果有装这一款插件，`Git Blame`插件就没有必要装了。

6. [git ignore](https://github.com/CodeZombieCH/vscode-gitignore)

### Markdown

1. [Markdown Preview Enhanced](https://shd101wyy.github.io/markdown-preview-enhanced)

   一款功能强大的 markdown 插件。让你在vscode 中拥有更好的 markdown 写作体验。

### Icon

1. [vscode-icons](https://github.com/vscode-icons/vscode-icons)
   文件菜单 icons。 根据文件夹命名、文件后缀等，对文件夹、文件菜单栏添加 对应的`icon`。
   ![vscode-icons](https://raw.githubusercontent.com/vscode-icons/vscode-icons/master/images/screenshot.gif)

2. [VSCode Great Icons](https://marketplace.visualstudio.com/items?itemName=emmanuelbeziat.vscode-great-icons)
   另一款 文件菜单栏 icons，支持 100+的文件类型。
   ![VSCode Great Icons](https://raw.githubusercontent.com/EmmanuelBeziat/vscode-great-icons/icons-test/icons.jpg)

### IDE support

1. [View In Browser](https://github.com/hellopao/view-in-browser)

   快速打开html页面在浏览器中访问。

2. [ftp-simple](https://github.com/humy2833/FTP-Simple)

   FTP 上传/下载插件。

3. [Rest Client](https://github.com/Huachao/vscode-restclient)

   允许你在 `VSCode` 中发送HTTP请求，并查看response的内容。

### Framework support

1. [Vetur](https://github.com/vuejs/vetur)

   Vue 支持。

2. [minapp](https://github.com/wx-minapp/minapp-vscode)

   微信小程序 支持。

---

---
url: /article/or9sfaj3/index.md
---
# 怎么写前端开发的 AI prompt ？
## 前言

早上 10 点，当你准备正式开始今天的开发任务时，发现隔壁的前端同学悠闲的看着屏幕，AI 正在输出着代码，
他看了几眼觉得不错便接受了这份代码，于是你也开始让你的 AI 工具帮你写代码。

::: tip 以下示例来自于 [Trae](https://www.trae.ai/) 生成的结果
:::

你不假思索的告诉 AI ：

```txt
帮我用 Vue 写一个登录页面
```

于是，AI 框框一顿输出：

::: code-tabs

@tab AI Chat

```txt :collapsed-lines

我将创建一个登录页面，首先查看项目结构和依赖。
...

让我查看路由配置文件，以便添加登录页面路由。
...

创建登录页面组件，包含用户名和密码输入框以及登录按钮。
...

添加登录页面路由配置。
...

启动开发服务器以预览登录页面。
...

为用户打开登录页面预览。
...

预览

我已经完成了登录页面的创建，主要完成了以下工作：

1. 创建了登录页面组件 <mcfile name="Login.vue" path="/my-vue-app/src/views/Login.vue"></mcfile>，包含：
   - 用户名和密码输入框
   - 登录按钮
   - 美观的页面样式
   - 基础的登录逻辑

2. 在路由配置 <mcfile name="router.ts" path="/my-vue-app/src/router.ts"></mcfile> 中添加了登录页面路由

3. 启动了开发服务器，你可以通过访问 http://localhost:5174/login 来预览登录页面

登录页面已经具备基本的UI和交互功能，你可以进一步根据需求添加：
- 实际的登录接口调用
- 表单验证
- 记住密码功能
- 更多的样式定制

```

@tab Login.vue

```vue :collapsed-lines
<script setup lang="ts">
import { ref } from 'vue'
import { useRouter } from 'vue-router'

const router = useRouter()
const username = ref('')
const password = ref('')

function handleLogin() {
  // 这里添加登录逻辑
  if (username.value && password.value) {
    // 模拟登录成功
    router.push('/')
  }
}
</script>

<template>
  <div class="login-container">
    <div class="login-box">
      <h2>登录</h2>
      <div class="form-item">
        <input
          v-model="username"
          type="text"
          placeholder="请输入用户名"
        >
      </div>
      <div class="form-item">
        <input
          v-model="password"
          type="password"
          placeholder="请输入密码"
        >
      </div>
      <button
        class="login-button"
        @click="handleLogin"
      >
        登录
      </button>
    </div>
  </div>
</template>

<style scoped>
/** ... */
</style>
```

:::

emmmm，是有个页面了，但是不对，你发现 用户名和密码没有进行校验，于是你告诉 AI：

```txt
对用户名和密码进行校验
```

于是，AI 又框框一顿输出:

::: code-tabs

@tab AI Chat

```txt :collapsed-lines
查看登录页面组件代码，以添加表单验证功能。
...

添加用户名和密码的验证逻辑，包括长度限制和错误提示。
...

我已经为登录表单添加了验证功能，主要包括以下内容：

1. 用户名验证：
   - 不能为空
   - 长度至少3个字符
   - 失去焦点时触发验证

2. 密码验证：
   - 不能为空
   - 长度至少6个字符
   - 失去焦点时触发验证

3. 错误提示：
   - 添加了错误信息显示样式
   - 错误信息显示在输入框下方
   - 使用红色文字突出显示

4. 登录验证：
   - 点击登录按钮时会验证所有字段
   - 只有当所有验证通过后才会执行登录操作

现在你可以在登录页面测试这些验证功能：
1. 尝试输入短于3个字符的用户名
2. 尝试输入短于6个字符的密码
3. 不输入任何内容直接点击登录按钮
```

@tab Login.vue

```vue :collapsed-lines
<script setup lang="ts">
import { ref } from 'vue'

const usernameError = ref('') // [!code ++]
const passwordError = ref('') // [!code ++]

function validateUsername() { // [!code ++:12]
  if (!username.value) {
    usernameError.value = '请输入用户名'
    return false
  }
  if (username.value.length < 3) {
    usernameError.value = '用户名至少3个字符'
    return false
  }
  usernameError.value = ''
  return true
}

function validatePassword() { // [!code ++:12]
  if (!password.value) {
    passwordError.value = '请输入密码'
    return false
  }
  if (password.value.length < 6) {
    passwordError.value = '密码至少6个字符'
    return false
  }
  passwordError.value = ''
  return true
}

function handleLogin() {
  const isUsernameValid = validateUsername() // [!code ++:4]
  const isPasswordValid = validatePassword()

  if (isUsernameValid && isPasswordValid) {
    // 模拟登录成功
    router.push('/')
  }
}
</script>

<template>
  <div class="login-container">
    <div class="login-box">
      <h2>登录</h2>
      <div class="form-item">
        <input
          v-model="username"
          type="text"
          placeholder="请输入用户名"
          @blur="validateUsername"
        >
        <div v-if="usernameError" class="error-message">
          {{ usernameError }}
        </div>
      </div>
      <div class="form-item">
        <input
          v-model="password"
          type="password"
          placeholder="请输入密码"
          @blur="validatePassword"
        >
        <div v-if="passwordError" class="error-message">
          {{ passwordError }}
        </div>
      </div>
      <button
        class="login-button"
        @click="handleLogin"
      >
        登录
      </button>
    </div>
  </div>
</template>

<style scoped>
.error-message { /* [!code ++:5] */
  color: #f56c6c;
  font-size: 0.875rem;
  margin-top: 0.5rem;
}
</style>
```

:::

你心想，还是不对，需要对密码进行格式校验，限制必须包含数字，字母，特殊字符，于是你又告诉 AI：

```txt
对密码进行格式校验，限制必须包含数字，字母，特殊字符
```

于是，AI 又框框一顿输出:

::: code-tabs

@tab AI Chat

```txt :collapsed-lines
添加密码格式校验规则，要求包含数字、字母和特殊字符。
...

我已经添加了密码格式的校验规则，具体包括：

1. 密码格式要求：
   - 必须包含数字（0-9）
   - 必须包含字母（a-z或A-Z）
   - 必须包含特殊字符（!@#$%^&*(),.?":{}|<>中的任意字符）
   - 保留原有的长度至少6个字符的要求

2. 校验逻辑：
   - 使用正则表达式分别检测数字、字母和特殊字符
   - 如果缺少任意一种字符类型，显示错误提示
   - 所有条件满足后才能通过验证

3. 错误提示：
   - 当密码格式不符合要求时，会显示"密码必须包含数字、字母和特殊字符"
   - 错误提示会显示在密码输入框下方

现在你可以测试以下场景：
1. 只输入数字（不通过）
2. 只输入字母和数字（不通过）
3. 输入包含数字、字母和特殊字符的密码（通过）
```

@tab Login.vue

```vue :collapsed-lines
<script setup lang="ts">
// ...
function validatePassword() {
  if (!password.value) {
    passwordError.value = '请输入密码'
    return false
  }
  if (password.value.length < 6) {
    passwordError.value = '密码至少6个字符'
    return false
  }
  const hasNumber = /\d/.test(password.value)
  const hasLetter = /[a-zA-Z]/.test(password.value)
  const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(password.value)

  if (!hasNumber || !hasLetter || !hasSpecial) {
    passwordError.value = '密码必须包含数字、字母和特殊字符'
    return false
  }

  passwordError.value = ''
  return true
}
// ...
</script>

<template>
  <div class="login-container">
    <!-- ... -->
  </div>
</template>

<style scoped>
/* ... */
</style>
```

:::

你觉得还行，但是样式不对，而且还没有对接后端，于是你又告诉 AI ...

你陷入与 AI 的一轮轮对话中...

你不停的重复审查着 AI 的代码...

随着对话内容越来越多，AI 开始忘了你最开始的需求...

你又重新告诉 AI ...

时间不知不觉就到中午了...

你发现，怎么比自己写还花时间 ！

## 不要让 AI 自由发挥

发现了吗，从第一句 `“帮我用 Vue 写一个登录页面”` 开始，AI 都是在自由发挥。

它并不清楚你具体想要的是什么，但是 AI 不会拒绝你，它按照它的 “经验”，猜你想要的可能是这样的。
但你觉得这不是你要的，于是你又一遍遍的片面的补充你的需求，AI 也只能一遍遍的片面的输出代码。

这就像是，你遇到了一个外行，一来就告诉你，“尽快给我做一个登录页” 。一听到这话，你的第一想法是什么？

开始干活？还是火气很大？

登录页？什么登录页？要干什么？没需求文档吗？没设计稿吗？有 API 接口吗？

你开始和这个外行不停的聊具体的需求内容，他甚至可能都不知道他自己想要的是什么，于是你可能直接拒绝。

但 AI 不会拒绝你，你要什么，它就给你什么，它开始自由发挥，即使是胡编乱造。

所以，我们要 **避免让 AI 自由发挥**。你的需求越明确，AI 就越知道它应该怎么做。

## 写个需求文档

作为一个开发人员，我们希望有一个明确的需求文档，不用和产品经理反反复复的交流，不用和其他人争论需求模糊的地方，
可以专注于写代码，对于 AI 而言同样也是如此。当你跟 AI 对话时，你不应该只把自己当做技术开发，还要代入产品经理
的角色，你希望产品经理给你一份什么样的需求文档，你也应该准备一份相同的需求文档给 AI。

::: info 那么如何写一份 AI 能理解的需求文档？
:::

对于这个问题，当然是先问下 AI 啦：

::: chat title="DeepSeek"
{.}
在前端开发中使用 AI 帮助生成相关的代码时，prompt 应该如何编写？

{deepseek}
在前端开发中使用 AI 生成代码时，**清晰、具体、结构化**的 prompt 是关键。以下是编写高效 prompt 的方法和示例：

***

**Prompt 设计原则**:

1. **明确技术栈**
   指定框架（React/Vue/Angular）、语言（TS/JS）、UI 库（Tailwind/MUI/AntD）。
   > ❌ 模糊：*"生成一个按钮"*
   > ✅ 明确：*"用 React + TypeScript + Tailwind CSS 创建一个带悬停动画的蓝色按钮"*

2. **描述功能细节**
   包含交互逻辑、状态处理、API 集成等关键行为。
   > ✅ 示例：
   > \_"创建一个计数器组件：
   >
   > * 显示当前数字，初始值为 0
   > * 有 '+' 和 '-' 按钮，点击后数字增减
   > * 当数字为 0 时，'-' 按钮禁用（灰色）"\_

3. **定义样式要求**
   指定布局、响应式规则、动效等。
   > ✅ 示例：
   > \_"使用 Flexbox 实现响应式导航栏：
   >
   > * 移动端：汉堡菜单（点击展开）
   > * 桌面端：水平排列
   > * 悬停时链接变蓝色，带 300ms 过渡效果"\_

4. **提供输入/输出示例（可选但推荐）**
   帮助 AI 理解数据结构。
   > ✅ 示例：
   > *"根据以下数据生成商品卡片组件：
   > 输入数据格式：{ id: number, name: string, price: number }
   > 输出：卡片包含商品名、价格，并添加 '加入购物车' 按钮"*

5. **约束条件**
   明确禁止或限制项（如性能要求、兼容性）。
   > ✅ 示例：
   > *"避免使用任何第三方库，仅用原生 JavaScript 实现轮播图，支持触摸滑动"*

***

**二、Prompt 模板**:

```markdown
### 技术栈
[框架/库]，[语言]，[样式方案]

### 功能需求
1. 核心功能描述...
2. 交互逻辑（如点击/输入事件）...
3. 状态管理要求...

### 样式要求
- 布局方式...
- 响应式规则...
- 动画/过渡效果...

### 其他约束
- 输入数据格式示例: { key: type }
- 浏览器兼容性...
- 禁止使用...
```

***

**三、实战示例**:

案例 1：API 数据表格

```markdown
### 技术栈
React + TypeScript + Ant Design

### 功能需求
1. 从 API 端点 `https://api.example.com/users` 获取用户数据
2. 显示表格列：ID、姓名、邮箱、注册日期
3. 添加搜索框（按姓名过滤）
4. 分页控制（每页 10 条）

### 样式要求
- 表格行在悬停时高亮显示浅蓝色
- 搜索框位于表格右上角

### 其他约束
- 使用 Axios 请求数据
- 处理加载状态（显示 Loading 动画）
- 处理错误状态（显示错误信息）
```

案例 2：动画交互组件

```markdown
### 技术栈
Vue 3 + CSS Modules

### 功能需求
1. 折叠面板组件（Accordion）
2. 点击标题展开/收起内容区域
3. 展开时内容下滑动画（300ms 缓动效果）

### 样式要求
- 标题背景色：#f5f5f5，悬停时变为 #e0e0e0
- 内容区域内边距：16px
- 移动端适配（宽度 < 768px 时字体缩小）

### 其他约束
- 使用 Vue 的 Transition 实现动画
- 禁止使用任何外部 UI 库
```

***

**四、优化技巧**:

1. **迭代优化**：
   首先生成基础代码，再通过追加 prompt 改进：
   > *"为上述表格添加排序功能（点击表头按字母排序）"*

2. **错误处理**：
   若 AI 输出不符合预期，明确指出问题：
   > ❌ *"代码有错"*
   > ✅ *"提交按钮未做表单验证，请添加邮箱格式校验（正则表达式）"*

3. **要求伪代码**：
   复杂逻辑可先要求设计思路：
   > *"请先提供伪代码：如何用 Redux 管理购物车状态？"*

4. **拆分任务**：
   大型功能拆解为子组件：
   > 先生成 *"Header 组件"* → 再生成 *"侧边栏组件"* → 最后集成

***

**五、避免的常见错误**:

1. **过于宽泛**
   ❌ *"做一个电商网站"*
   ✅ *"生成商品详情页的图片轮播组件"*

2. **忽略边界条件**
   ❌ *"实现登录表单"*
   ✅ *"登录表单需包含：邮箱验证、密码强度提示、错误处理（API 返回 401 时显示错误信息）"*

3. **技术栈冲突**
   ❌ *"用 jQuery 和 React 一起实现..."*
   ✅ 明确技术组合是否合理

***

**最终建议**：将 AI 视为高级协作者，用写「需求文档」的思维编写 prompt。清晰的 prompt 不仅能提升代码质量，还能减少返工迭代次数。
:::

这很清晰，我们按照这份建议，采用它的模板写一份需求文档：

```md
### 技术栈
Vue3 + @vueuse/core + element-plus

### 功能需求
- 登录页面
- 使用 邮箱/手机号码 + 密码 登录
- 校验 邮箱 / 手机号码 格式
- 校验 密码：
  - 长度大于等于 6 小于等于 16
  - 密码由 大小写字母、数字、特殊符号 组成
  - 必须包含 大写字母
  - 根据密码强度显示不同的提示信息
  - 密码强度：弱，中，强
- 在失去焦点时校验，并在错误时显示错误信息，当用户重新输入时，清空错误信息
- 点击登录按钮时，调用 `/api/login` 接口，成功后跳转到首页

### 样式要求
- 不需要进行移动端适配
- 采用左右布局，右侧为登录表单，左侧为背景大图，在中间垂直居中
- 表单内容区域内边距 16px
- 在合适的地方添加过渡动画
```

来看看 AI 输出了什么：

::: code-tabs

@tab AI Chat

```txt :collapsed-lines
让我们先查看项目结构和相关文件，以确定需要创建和修改的内容。

filePath: /src/main.ts
/src/router.ts
/package.json

需要安装 element-plus 和 @vueuse/core 依赖，让我们先查看它们的最新版本和安装方式。
...

首先安装所需的依赖包：element-plus、@vueuse/core 以及自动导入插件。
...

让我们查看 vite.config.ts 文件，以配置 Element Plus 和自动导入插件。
...

配置 vite.config.ts，添加 Element Plus 的自动导入插件。
...

让我们查看 App.vue 和 router.ts 文件，以添加登录页面路由和修改布局。
...

创建登录页面组件，实现登录表单和布局。
...

更新路由配置，添加登录页面路由并设置为默认路由。
...

更新 App.vue，优化布局和样式。
...

让我们打开预览页面查看登录界面效果。

预览

已完成登录页面的开发，主要实现了以下功能：

1. 页面布局
- 采用左右布局设计，左侧为带动画效果的 Logo 展示区
- 右侧为登录表单区域，整体采用卡片式设计
- 添加了页面切换和表单交互动画

2. 登录表单功能
- 支持邮箱/手机号码 + 密码登录
- 实现了完整的表单验证：
  - 邮箱/手机号码格式验证
  - 密码复杂度验证（长度、大小写字母、数字、特殊符号）
  - 密码强度实时显示（弱、中、强）
- 添加了输入框清空功能和密码显示/隐藏功能

3. 路由配置
- 添加了登录页面路由
- 实现了路由守卫，未登录状态自动跳转到登录页

4. 样式优化
- 统一的颜色主题
- 响应式输入框动画
- 页面过渡动画
- 左侧 Logo 悬浮动画

现在可以通过访问 `/login` 路径查看登录页面，表单验证功能已经完整实现，可以直接使用。后续可以根据实际需求接入真实的登录接口。
...

已修复登录页面的问题：

1. 修复了 `ElMessage` 未导入的错误
- 从 `element-plus` 中导入了 `ElMessage` 组件
- 由于使用了自动导入插件，其他 Element Plus 组件（如 `el-form`、`el-input` 等）会自动导入

登录页面现在可以正常工作，包含以下功能：

1. 表单验证
- 邮箱/手机号码格式验证
- 密码复杂度验证
- 实时密码强度显示

2. 用户体验
- 表单项动画效果
- 错误提示信息
- 登录成功提示

3. 页面布局
- 左右分栏设计
- Logo 动画效果
- 响应式交互

可以通过访问 `/login` 路径使用登录功能。
```

@tab Login.vue

```vue :collapsed-lines
<script setup lang="ts">
import { ElMessage } from 'element-plus'
import { computed, ref } from 'vue'
import { useRouter } from 'vue-router'

const router = useRouter()

const form = ref({
  account: '',
  password: ''
})

const rules = {
  account: [
    { required: true, message: '请输入邮箱/手机号码', trigger: 'blur' },
    {
      validator: (_rule: any, value: string, callback: Function) => {
        const emailRegex = /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/
        const phoneRegex = /^1[3-9]\d{9}$/
        if (!emailRegex.test(value) && !phoneRegex.test(value)) {
          callback(new Error('请输入正确的邮箱或手机号码'))
        }
        else {
          callback()
        }
      },
      trigger: 'blur'
    }
  ],
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' },
    { min: 6, max: 16, message: '密码长度在 6 到 16 个字符之间', trigger: 'blur' },
    {
      validator: (_rule: any, value: string, callback: Function) => {
        const hasUpperCase = /[A-Z]/.test(value)
        const hasLowerCase = /[a-z]/.test(value)
        const hasNumber = /\d/.test(value)
        const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(value)

        if (!hasUpperCase) {
          callback(new Error('密码必须包含大写字母'))
          return
        }

        let strength = 0
        if (hasUpperCase)
          strength++
        if (hasLowerCase)
          strength++
        if (hasNumber)
          strength++
        if (hasSpecial)
          strength++

        passwordStrength.value = strength
        callback()
      },
      trigger: 'blur'
    }
  ]
}

const formRef = ref()
const passwordStrength = ref(0)

const strengthText = computed(() => {
  switch (passwordStrength.value) {
    case 1:
      return { text: '弱', color: '#F56C6C' }
    case 2:
      return { text: '中', color: '#E6A23C' }
    case 3:
    case 4:
      return { text: '强', color: '#67C23A' }
    default:
      return { text: '', color: '' }
  }
})

const loading = ref(false)

async function handleLogin() {
  if (!formRef.value)
    return

  try {
    await formRef.value.validate()
    loading.value = true

    // 模拟登录请求
    await new Promise(resolve => setTimeout(resolve, 1000))

    // 实际项目中这里应该调用真实的登录接口
    // const res = await fetch('/api/login', {
    //   method: 'POST',
    //   headers: { 'Content-Type': 'application/json' },
    //   body: JSON.stringify(form.value)
    // })
    // const data = await res.json()

    ElMessage.success('登录成功')
    router.push('/')
  }
  catch (error) {
    console.error('登录失败:', error)
  }
  finally {
    loading.value = false
  }
}
</script>

<template>
  <div class="login-container">
    <div class="login-content">
      <div class="login-banner">
        <img src="@/assets/vue.svg" alt="banner">
      </div>
      <div class="login-form">
        <h2>欢迎登录</h2>
        <el-form
          ref="formRef"
          :model="form"
          :rules="rules"
          label-position="top"
          @keyup.enter="handleLogin"
        >
          <el-form-item label="账号" prop="account">
            <el-input
              v-model="form.account"
              placeholder="请输入邮箱/手机号码"
              clearable
            />
          </el-form-item>

          <el-form-item label="密码" prop="password">
            <el-input
              v-model="form.password"
              type="password"
              placeholder="请输入密码"
              show-password
              clearable
            />
            <div v-if="strengthText.text" class="password-strength">
              密码强度：
              <span :style="{ color: strengthText.color }">
                {{ strengthText.text }}
              </span>
            </div>
          </el-form-item>

          <el-form-item>
            <el-button
              type="primary"
              :loading="loading"
              class="login-button"
              @click="handleLogin"
            >
              登录
            </el-button>
          </el-form-item>
        </el-form>
      </div>
    </div>
  </div>
</template>

<style scoped>
.login-container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #f5f7fa;
}

.login-content {
  display: flex;
  width: 900px;
  height: 500px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

.login-banner {
  flex: 1;
  background-color: #409eff;
  display: flex;
  align-items: center;
  justify-content: center;
}

.login-banner img {
  width: 200px;
  height: 200px;
  animation: float 3s ease-in-out infinite;
}

.login-form {
  flex: 1;
  padding: 16px;
  display: flex;
  flex-direction: column;
}

.login-form h2 {
  text-align: center;
  margin-bottom: 24px;
  color: #303133;
}

.login-button {
  width: 100%;
  margin-top: 16px;
}

.password-strength {
  font-size: 12px;
  margin-top: 4px;
  color: #606266;
}

@keyframes float {
  0%, 100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-20px);
  }
}

/* 过渡动画 */
.el-form-item {
  transition: all 0.3s ease-in-out;
}

.el-input {
  transition: all 0.3s ease-in-out;
}

.el-input:focus-within {
  transform: translateY(-2px);
}
</style>
```

:::

预览：

![how to write a good ai prompt](/images/ai/how-prompt-1.png)

![how to write a good ai prompt](/images/ai/how-prompt-2.png)

看起来不错，基本实现了我们所描述的功能。

正如前面所说，越明确的需求文档，AI 生成的结果就越符合预期。
可以总结下来，编写需求文档，我们应该注意以下几点：

* **明确的技术栈**： 告诉 AI 它能使用的技术栈，划定好范围。
* **功能清单**： 列出你的需求，并描述清楚细节
* **布局和交互**：描述清楚页面布局，每个区域的内容以及排版，最好具体到像素级。
* **边界限制**：告诉 AI 只应该做什么，或者不要去处理哪些内容，或者不要做什么。

## 追加改进

事实上上面生成的代码依然存在不少问题：

* API 接口并没有实现接入
* 需要补充 忘记密码 的跳转链接
* 登录的图形验证码校验
* 密码的强中弱应该的输入过程中实时提示
* ...

为什么 API 接口的接入被注释了？因为 AI 并不知道 接口 应该如何传递参数，也不知道接口返回的数据格式是什么。

我们继续告诉 AI 需求改进的内容：

```txt
- 登录接口为 `/api/login`
  - 请求方法为 POST
  - 入参为 `username` 、 `password`、 `captcha`
  - 响应体格式为 `{ message: string, code: number }`，`code` 为 0 表示成功，为 1 表示失败，`message` 为失败原因
- 需要补充 忘记密码 的跳转链接，路径为 `/forget-password`
- 登录的图形验证码校验
  - 图形验证码的接口为 `/api/captcha`，请求方法为 GET，响应体格式为 `{ code: string, image: string }`，`code` 为图形验证码的 id，`image` 为图形验证码的 base64 编码
- 密码的强中弱应该的输入过程中实时提示
  - 使用三个格子的信号灯作为提示，一个格式时为弱，两个为中，三个为强，并显示为对应的颜色
  - 切换时使用动画
```

AI 会根据这些需求改进，然后再次生成代码：

::: code-tabs

@tab AI Chat

```txt :collapsed-lines
让我们查看登录页面组件，以添加图形验证码、密码强度实时提示和忘记密码链接功能。
...

更新登录页面组件，添加图形验证码、密码强度实时提示和忘记密码链接。
...

修复登录成功消息重复显示的问题。
...

添加验证码相关的表单验证规则，并在组件挂载时获取验证码。
...

让我们查看更新后的登录页面效果。

预览

已完成所有功能的开发和优化，主要更新包括：

1. 登录功能增强
- 添加图形验证码功能
  - 自动获取验证码
  - 点击图片可刷新验证码
  - 验证码校验规则
- 优化密码强度提示
  - 使用三格信号灯样式
  - 实时显示密码强度（弱、中、强）
  - 添加渐变动画效果
- 完善表单验证
  - 邮箱/手机号格式验证
  - 密码复杂度验证
  - 验证码必填验证

2. 新增忘记密码功能
- 创建忘记密码页面
- 邮箱验证码登录
- 倒计时重发验证码
- 表单验证和错误提示
- 优雅的过渡动画

3. 接口对接
- 登录接口（/api/login）
  - 用户名、密码、验证码校验
  - 登录状态保存
  - 成功/失败提示
- 验证码接口（/api/captcha）
  - 自动获取和刷新
  - base64 图片显示

4. 用户体验优化
- 添加路由跳转动画
- 优化表单交互动画
- 统一的错误提示
- 友好的加载状态
- 键盘回车提交支持

现在可以通过访问以下路径使用相关功能：
- 登录页面：`/login`
- 忘记密码：`/forget-password`

```

@tab Login.vue

```vue :collapsed-lines
<script setup lang="ts">
import { ElMessage } from 'element-plus'
import { computed, onMounted, ref } from 'vue'
import { useRouter } from 'vue-router'

const router = useRouter()

const form = ref({
  username: '',
  password: '',
  captcha: ''
})

// 获取验证码
const captchaCode = ref('')
const captchaImage = ref('')

async function refreshCaptcha() {
  try {
    const res = await fetch('/api/captcha')
    const data = await res.json()
    captchaCode.value = data.code
    captchaImage.value = data.image
  }
  catch (error) {
    console.error('获取验证码失败:', error)
  }
}

// 监听密码变化实时更新强度
function updatePasswordStrength(value: string) {
  const hasUpperCase = /[A-Z]/.test(value)
  const hasLowerCase = /[a-z]/.test(value)
  const hasNumber = /\d/.test(value)
  const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(value)

  let strength = 0
  if (hasUpperCase)
    strength++
  if (hasLowerCase)
    strength++
  if (hasNumber)
    strength++
  if (hasSpecial)
    strength++

  passwordStrength.value = strength
}

// 组件挂载时获取验证码
onMounted(() => {
  refreshCaptcha()
})

const rules = {
  username: [
    { required: true, message: '请输入邮箱/手机号码', trigger: 'blur' },
    {
      validator: (_rule: any, value: string, callback: Function) => {
        const emailRegex = /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/
        const phoneRegex = /^1[3-9]\d{9}$/
        if (!emailRegex.test(value) && !phoneRegex.test(value)) {
          callback(new Error('请输入正确的邮箱或手机号码'))
        }
        else {
          callback()
        }
      },
      trigger: 'blur'
    }
  ],
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' },
    { min: 6, max: 16, message: '密码长度在 6 到 16 个字符之间', trigger: 'blur' },
    {
      validator: (_rule: any, value: string, callback: Function) => {
        const hasUpperCase = /[A-Z]/.test(value)
        const hasLowerCase = /[a-z]/.test(value)
        const hasNumber = /\d/.test(value)
        const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(value)

        if (!hasUpperCase) {
          callback(new Error('密码必须包含大写字母'))
          return
        }

        let strength = 0
        if (hasUpperCase)
          strength++
        if (hasLowerCase)
          strength++
        if (hasNumber)
          strength++
        if (hasSpecial)
          strength++

        passwordStrength.value = strength
        callback()
      },
      trigger: 'blur'
    }
  ],
  captcha: [
    { required: true, message: '请输入验证码', trigger: 'blur' },
    { min: 4, max: 4, message: '验证码长度为4位', trigger: 'blur' }
  ]
}

const formRef = ref()
const passwordStrength = ref(0)

const strengthText = computed(() => {
  switch (passwordStrength.value) {
    case 1:
      return { text: '弱', color: '#F56C6C' }
    case 2:
      return { text: '中', color: '#E6A23C' }
    case 3:
    case 4:
      return { text: '强', color: '#67C23A' }
    default:
      return { text: '', color: '' }
  }
})

const loading = ref(false)

async function handleLogin() {
  if (!formRef.value)
    return

  try {
    await formRef.value.validate()
    loading.value = true

    const res = await fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...form.value,
        code: captchaCode.value
      })
    })
    const data = await res.json()

    if (data.code === 0) {
      ElMessage.success('登录成功')
      localStorage.setItem('isLoggedIn', 'true')
      router.push('/')
    }
    else {
      ElMessage.error(data.message)
      refreshCaptcha()
    }
    router.push('/')
  }
  catch (error) {
    console.error('登录失败:', error)
  }
  finally {
    loading.value = false
  }
}
</script>

<template>
  <div class="login-container">
    <div class="login-content">
      <div class="login-banner">
        <img src="@/assets/vue.svg" alt="banner">
      </div>
      <div class="login-form">
        <h2>欢迎登录</h2>
        <el-form
          ref="formRef"
          :model="form"
          :rules="rules"
          label-position="top"
          @keyup.enter="handleLogin"
        >
          <el-form-item label="账号" prop="username">
            <el-input
              v-model="form.username"
              placeholder="请输入邮箱/手机号码"
              clearable
              @keyup.enter="handleLogin"
            />
          </el-form-item>

          <el-form-item label="密码" prop="password">
            <el-input
              v-model="form.password"
              type="password"
              placeholder="请输入密码"
              show-password
              clearable
              @input="updatePasswordStrength"
              @keyup.enter="handleLogin"
            />
            <div class="password-strength-indicator">
              <div
                v-for="n in 3"
                :key="n"
                class="strength-bar"
                :class="{
                  active: passwordStrength >= n,
                  weak: passwordStrength === 1 && n === 1,
                  medium: passwordStrength === 2 && n <= 2,
                  strong: passwordStrength >= 3 && n <= 3,
                }"
              />
              <span v-if="strengthText.text" :style="{ color: strengthText.color }">
                {{ strengthText.text }}
              </span>
            </div>
          </el-form-item>

          <el-form-item label="验证码" prop="captcha">
            <div class="captcha-container">
              <el-input
                v-model="form.captcha"
                placeholder="请输入验证码"
                @keyup.enter="handleLogin"
              />
              <img
                v-if="captchaImage"
                :src="captchaImage"
                class="captcha-image"
                alt="验证码"
                @click="refreshCaptcha"
              >
            </div>
          </el-form-item>

          <el-form-item>
            <el-button
              type="primary"
              :loading="loading"
              class="login-button"
              @click="handleLogin"
            >
              登录
            </el-button>
            <div class="form-footer">
              <router-link to="/forget-password" class="forget-password">
                忘记密码？
              </router-link>
            </div>
          </el-form-item>
        </el-form>
      </div>
    </div>
  </div>
</template>

<style scoped>
.login-container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #f5f7fa;
}

.login-content {
  display: flex;
  width: 900px;
  height: 500px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

.login-banner {
  flex: 1;
  background-color: #409eff;
  display: flex;
  align-items: center;
  justify-content: center;
}

.login-banner img {
  width: 200px;
  height: 200px;
  animation: float 3s ease-in-out infinite;
}

.login-form {
  flex: 1;
  padding: 16px;
  display: flex;
  flex-direction: column;
}

.login-form h2 {
  text-align: center;
  margin-bottom: 24px;
  color: #303133;
}

.login-button {
  width: 100%;
  margin-top: 16px;
}

.password-strength-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
}

.strength-bar {
  flex: 1;
  width: 32px;
  height: 4px;
  background-color: #e4e7ed;
  border-radius: 2px;
  transition: all 0.3s ease;
}

.strength-bar.active {
  background-color: #67C23A;
}

.strength-bar.weak {
  background-color: #F56C6C;
}

.strength-bar.medium {
  background-color: #E6A23C;
}

.strength-bar.strong {
  background-color: #67C23A;
}

.captcha-container {
  display: flex;
  gap: 12px;
}

.captcha-image {
  height: 32px;
  border-radius: 4px;
  cursor: pointer;
}

.form-footer {
  margin-top: 16px;
  text-align: right;
}

.forget-password {
  color: var(--el-color-primary);
  text-decoration: none;
  font-size: 14px;
}

.forget-password:hover {
  color: var(--el-color-primary-light-3);
}

@keyframes float {
  0%, 100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-20px);
  }
}

/* 过渡动画 */
.el-form-item {
  transition: all 0.3s ease-in-out;
}

.el-input {
  transition: all 0.3s ease-in-out;
}

.el-input:focus-within {
  transform: translateY(-2px);
}
</style>
```

:::

效果：

![how-to-write-good-ai-prompt-3](/images/ai/how-prompt-3.png)

喔，又发现了新的问题，密码强度提示应该在密码大于 6 位数之后再提示。先记录下来，验证其他流程，
再统一追加改进。

还有别忘了 `Login.vue` 随着修改，体积已经相对较大，太多功能耦合在一起，需要告诉 AI 进行拆分。

```txt
- 密码强度提示应该在密码大于 6 位数之后再开始提示
- 对 Login.vue 进行合理的拆分
```

AI：

```txt
...
```

最终，我们得到了以下的产物：

::: code-tabs

@tab Login.vue

```vue :collapsed-lines
<script setup lang="ts">
import { ElMessage } from 'element-plus'
import { ref } from 'vue'
import { useRouter } from 'vue-router'
import CaptchaInput from '@/components/CaptchaInput.vue'
import PasswordStrength from '@/components/PasswordStrength.vue'
import { calculatePasswordStrength, loginRules } from '@/utils/validation'

const router = useRouter()

const form = ref({
  username: '',
  password: '',
  captcha: ''
})

const formRef = ref()
const loading = ref(false)
const passwordStrength = ref(0)
const captchaCode = ref('')

function updatePasswordStrength(value: string) {
  passwordStrength.value = calculatePasswordStrength(value)
}

function handleCaptchaRefresh(code: string) {
  captchaCode.value = code
}

async function handleLogin() {
  if (!formRef.value)
    return

  try {
    await formRef.value.validate()
    loading.value = true

    const res = await fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...form.value,
        code: captchaCode.value
      })
    })
    const data = await res.json()

    if (data.code === 0) {
      ElMessage.success('登录成功')
      localStorage.setItem('isLoggedIn', 'true')
      router.push('/')
    }
    else {
      ElMessage.error(data.message)
    }
  }
  catch (error) {
    console.error('登录失败:', error)
  }
  finally {
    loading.value = false
  }
}
</script>

<template>
  <div class="login-container">
    <div class="login-content">
      <div class="login-banner">
        <img src="@/assets/vue.svg" alt="banner">
      </div>
      <div class="login-form">
        <h2>欢迎登录</h2>
        <el-form
          ref="formRef"
          :model="form"
          :rules="loginRules"
          label-position="top"
          @keyup.enter="handleLogin"
        >
          <el-form-item label="账号" prop="username">
            <el-input
              v-model="form.username"
              placeholder="请输入邮箱/手机号码"
              clearable
              @keyup.enter="handleLogin"
            />
          </el-form-item>

          <el-form-item label="密码" prop="password">
            <el-input
              v-model="form.password"
              type="password"
              placeholder="请输入密码"
              show-password
              clearable
              @input="updatePasswordStrength"
              @keyup.enter="handleLogin"
            />
            <PasswordStrength :strength="passwordStrength" :password="form.password" />
          </el-form-item>

          <el-form-item label="验证码" prop="captcha">
            <CaptchaInput
              v-model="form.captcha"
              @refresh="handleCaptchaRefresh"
              @enter="handleLogin"
            />
          </el-form-item>

          <el-form-item>
            <el-button
              type="primary"
              :loading="loading"
              class="login-button"
              @click="handleLogin"
            >
              登录
            </el-button>
            <div class="form-footer">
              <router-link to="/forget-password" class="forget-password">
                忘记密码？
              </router-link>
            </div>
          </el-form-item>
        </el-form>
      </div>
    </div>
  </div>
</template>

<style scoped>
.login-container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #f5f7fa;
}

.login-content {
  display: flex;
  width: 900px;
  height: 500px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

.login-banner {
  flex: 1;
  background-color: #409eff;
  display: flex;
  align-items: center;
  justify-content: center;
}

.login-banner img {
  width: 200px;
  height: 200px;
  animation: float 3s ease-in-out infinite;
}

.login-form {
  flex: 1;
  padding: 16px;
  display: flex;
  flex-direction: column;
}

.login-form h2 {
  text-align: center;
  margin-bottom: 24px;
  color: #303133;
}

.login-button {
  width: 100%;
  margin-top: 16px;
}

.form-footer {
  margin-top: 16px;
  text-align: right;
}

.forget-password {
  color: var(--el-color-primary);
  text-decoration: none;
  font-size: 14px;
}

.forget-password:hover {
  color: var(--el-color-primary-light-3);
}

@keyframes float {
  0%, 100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-20px);
  }
}

/* 过渡动画 */
.el-form-item {
  transition: all 0.3s ease-in-out;
}

.el-input {
  transition: all 0.3s ease-in-out;
}

.el-input:focus-within {
  transform: translateY(-2px);
}
</style>
```

@tab CaptchaInput.vue

```vue :collapsed-lines
<script setup lang="ts">
import { onMounted, ref } from 'vue'

defineProps<{
  modelValue: string
}>()

const emit = defineEmits<{
  'update:modelValue': [value: string]
  'refresh': [code: string]
  'enter': []
}>()

const captchaCode = ref('')
const captchaImage = ref('')

async function refreshCaptcha() {
  try {
    const res = await fetch('/api/captcha')
    const data = await res.json()
    captchaCode.value = data.code
    captchaImage.value = data.image
    emit('refresh', data.code)
  }
  catch (error) {
    console.error('获取验证码失败:', error)
  }
}

onMounted(() => {
  refreshCaptcha()
})
</script>

<template>
  <div class="captcha-container">
    <el-input
      :model-value="modelValue"
      placeholder="请输入验证码"
      @update:model-value="(newValue: string) => emit('update:modelValue', newValue)"
      @keyup.enter="$emit('enter')"
    />
    <img
      v-if="captchaImage"
      :src="captchaImage"
      class="captcha-image"
      alt="验证码"
      @click="refreshCaptcha"
    >
  </div>
</template>

<style scoped>
.captcha-container {
  display: flex;
  gap: 12px;
}

.captcha-image {
  height: 32px;
  border-radius: 4px;
  cursor: pointer;
}
</style>
```

@tab PasswordStrength.vue

```vue :collapsed-lines
<script setup lang="ts">
import { computed } from 'vue'

const props = defineProps<{
  strength: number
  password: string
}>()

const showStrength = computed(() => props.password.length >= 6)

const strengthText = computed(() => {
  switch (props.strength) {
    case 1:
      return { text: '弱', color: '#F56C6C' }
    case 2:
      return { text: '中', color: '#E6A23C' }
    case 3:
    case 4:
      return { text: '强', color: '#67C23A' }
    default:
      return { text: '', color: '' }
  }
})
</script>

<template>
  <div v-if="showStrength" class="password-strength-indicator">
    <div
      v-for="n in 3"
      :key="n"
      class="strength-bar"
      :class="{
        active: strength >= n,
        weak: strength === 1 && n === 1,
        medium: strength === 2 && n <= 2,
        strong: strength >= 3 && n <= 3,
      }"
    />
    <span v-if="strengthText.text" :style="{ color: strengthText.color }">
      {{ strengthText.text }}
    </span>
  </div>
</template>

<style scoped>
.password-strength-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
}

.strength-bar {
  flex: 1;
  width: 32px;
  height: 4px;
  background-color: #e4e7ed;
  border-radius: 2px;
  transition: all 0.3s ease;
}

.strength-bar.active {
  background-color: #67C23A;
}

.strength-bar.weak {
  background-color: #F56C6C;
}

.strength-bar.medium {
  background-color: #E6A23C;
}

.strength-bar.strong {
  background-color: #67C23A;
}
</style>
```

@tab utils/validation.ts

```ts :collapsed-lines
// 密码强度计算
export function calculatePasswordStrength(password: string): number {
  const hasUpperCase = /[A-Z]/.test(password)
  const hasLowerCase = /[a-z]/.test(password)
  const hasNumber = /\d/.test(password)
  const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(password)

  let strength = 0
  if (hasUpperCase)
    strength++
  if (hasLowerCase)
    strength++
  if (hasNumber)
    strength++
  if (hasSpecial)
    strength++

  return strength
}

// 表单验证规则
export const loginRules = {
  username: [
    { required: true, message: '请输入邮箱/手机号码', trigger: 'blur' },
    {
      validator: (_rule: any, value: string, callback: Function) => {
        const emailRegex = /^[\w-]+([\.[\w-]+)*@[\w-]+([\.[\w-]+)+$/
        const phoneRegex = /^1[3-9]\d{9}$/
        if (!emailRegex.test(value) && !phoneRegex.test(value)) {
          callback(new Error('请输入正确的邮箱或手机号码'))
        }
        else {
          callback()
        }
      },
      trigger: 'blur'
    }
  ],
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' },
    { min: 6, max: 16, message: '密码长度在 6 到 16 个字符之间', trigger: 'blur' },
    {
      validator: (_rule: any, value: string, callback: Function) => {
        const hasUpperCase = /[A-Z]/.test(value)
        if (!hasUpperCase) {
          callback(new Error('密码必须包含大写字母'))
          return
        }
        callback()
      },
      trigger: 'blur'
    }
  ],
  captcha: [
    { required: true, message: '请输入验证码', trigger: 'blur' },
    { min: 4, max: 4, message: '验证码长度为4位', trigger: 'blur' }
  ]
}
```

:::

在这次的 登录页的开发过程中，我们向 AI 进行了三轮对话：

* 第一次提出了明确的需求文档；
* 对生成的代码进行审查，验证 UI 和交互，进行第一次的追加改进；
* 对改进结果继续审查，进行第二次追加改进。
* 对结果继续审查，基本满足预期的诉求。

我并不是在说只能进行三轮对话。每一轮对话都是有成本的，你需要对每次生成的内容进行审查和验证，这是时间成本，
AI 需求重新查看文件并进行追加修改，这也是时间成本。

因此，每次追加改进应先整理好新的需求文档，避免发现一个就告诉 AI 修改一个。

## 总结

* **明确的技术栈**： 告诉 AI 它能使用的技术栈，划定好范围。
* **功能清单**： 列出你的需求，并描述清楚细节。
* **布局和交互**：描述清楚页面布局，每个区域的内容以及排版，最好具体到像素级。
* **边界限制**：告诉 AI 只应该做什么，或者不要去处理哪些内容，或者不要做什么。
* **追加改进**：每次改进都应该是一个新的完整的需求文档。

不妨实施这个需求文档模板：

```md
### 技术栈
- ...

### 功能清单
- 功能 1
- 功能 2
- ...

### 布局和交互
- ...

### 边界限制
- ...

### 注意事项
- ...
```

---

---
url: /article/otymkumz/index.md
---
# 什么是 Signals ？
2024年了，Signals 在前端框架中越来越成为主流的底层技术依赖。
大概是从哪个框架开始兴起的，我有些忘记了，我映像中最早推动并流行的是 `SolidJS`，
后来在 `Vue3` 中也引入了该技术，随后，如 `MobX`，`Preact`，`Qwik`，`Svelte`，`Angular` 等
也纷纷引入了该技术。

事实上，`Signals` 的提出比 `SolidJS` 还要早的多，早在 [2010年](https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/)，
[Knockout](https://knockoutjs.com/) 便有了类似的实现。

因此，`Signals` 并不是 “新兴的、前沿的” 前端技术方案。相反，关于它的论证、实践和应用，都已经相当的成熟，
这也是 `Signals` 如今越来越受各种框架青睐的原因。

::: tip 说明
[TC39](https://tc39.es/) 新增了一个 Stage-0 的 [提案](https://github.com/proposal-signals/proposal-signals)，
计划将 `Signals` 整合到 JavaScript 标准中。
并邀请了 [Angular](https://angular.io/), [Bubble](https://bubble.io/), [Ember](https://emberjs.com/),
[FAST](https://www.fast.design/), [MobX](https://mobx.js.org/), [Preact](https://preactjs.com/),
[Qwik](https://qwik.dev/), [RxJS](https://rxjs.dev/), [Solid](https://www.solidjs.com/),
[Starbeam](https://www.starbeamjs.com/), [Svelte](https://svelte.dev/),
[Vue](https://vuejs.org/), [Wiz](https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a)
等多个框架的作者或贡献者 参与讨论，共同推动该提案的实现。

听到这个消息我是挺兴奋的，这意味着当 `Signals` 正式成为 `ECMA` 的标准时，将会给我们的前端开发带来很大的便利。
特别是对于各大框架而言，使用 原生 `Signals` 可能会带来更大的性能提升，甚至有机会在不同的框架之间共享同一个 `Signals`，
带来更多的可能性。
:::

## 为什么是 Signals ?

在一个常见的场景中，我们需要实现一个计数器，并希望将当前计数器的值是奇数还是偶数 渲染到 页面上，
每当 计数器的值 发生改变，我们就会重新渲染页面。

当我们使用 原生 JavaScript 实现时：

```js
let counter = 0

const isEven = () => (counter & 1) === 0
const parity = () => (isEven() ? 'even' : 'odd')
const render = () => (element.textContent = parity())

function setCounter(value) {
  counter = value
  render()
}
// 模拟对计数器的外部更新...
setInterval(() => setCounter(counter + 1), 1000)
```

这看起来实现了需求，然而，这里面有存在很多问题：

* `counter` 状态与 渲染系统 紧密耦合；
* 如果 `counter` 发生了变化，但是 `parity` 没有变化（比如 `counter` 从 2 变化为 4），
  那么就会对 奇偶校验进行不必要的计算和不必要的渲染；
* 如果 UI 的另一个部分只想在 `counter` 变化时重新渲染该如何处理？
* 如果 UI 的另一个部分只依赖 `isEven` 或 `parity`，那么该如何处理？

即使在这种相对简单的情况下，很快就会出现许多问题。
我们可以尝试通过引入 **发布/订阅** 来解决这些问题。
这将允许 `counter` 的其他使用者可以订阅添加他们自己对状态更改的反应。

但是，我们仍然可能遇到更多的问题：

* 渲染函数 `render` 只依赖于 `parity`，然而实际上它需要订阅 `counter`。
* 如果不直接与 `counter` 交互，则无法仅基于 `isEven` 和 `parity` 更新 UI。
* 引入了 **发布/订阅** ，问题不再仅仅是调用函数和读取变量，而是 订阅 和在哪里进行更新，
  如何管理退订的问题也变得复杂。

我们通过添加 `发布/订阅` 来解决包括 `counter`、`isEven` 和 `parity` 在内的几个问题。
我们必须将 `isEven` 订阅到 `counter`, 将 `parity` 订阅到 `isEven`，将 `render` 订阅到 `parity`。
然后，这个示例代码的体积越来越大，我们深陷在大量的 订阅 中，如果我们没有正确的方式清理内容，这
可能将导致发生内存灾难。我们虽然解决了一些问题，却编写了大量的代码，引入了更多的问题。

### 引入 Signals

::: info
为便于理解，以下示例 使用 [solid-js](https://www.solidjs.com/docs/latest/api) API，其中：

* `[getter, setter] = createSignal(initial)`: 创建信号，返回一个包含 getter 和 setter 的数组。
* `createMemo(getter)`: 创建一个与给定函数的返回值相等的只读响应值。
* `createEffect(effect)`: 创建一个在其依赖关系发生变化时执行的副作用。

:::

为了理解 `Signals` ，让我们首先对上面的例子进行一些改造：

```ts
const [counter, setCounter] = createSignal(0)
const isEven = createMemo(() => counter() & (1 == 0))
const parity = createMemo(() => (isEven() ? 'even' : 'odd'))

createEffect(() => (element.textContent = parity()))

setInterval(() => setCounter(counter() + 1), 1000)
```

我们可以立即看到：

* 我们消除了 `counter` 不必要的耦合
* 使用统一的 API 来 处理值，计算 和 副作用
* `counter` 和 `render` 之间没有循环引用的问题
* 没有手动订阅，不需要记录依赖关系
* 可以控制副作用的调用时机

同时，Signals 带给我们的，不仅仅是表面看到的：

* **自动依赖跟踪**：计算出来的 Signal 会自动发现它所依赖的其它任何 Signal ，无论这些 Signal 是 简单值 还是其他 计算值。
* **延迟评估**：计算在声明时不会立即评估，也不会在依赖更新时立即重新评估。仅当显式请求该值时，才会评估他们。
* **记忆**：计算信号缓存其最后一个值，以便无论访问多少次，都不需要重新评估其依赖项中没有更改的计算。

## 什么是 Signals ?

`Signals`，即 信号，信号表示可能随时间变化的数据单元。
信号可以是“State”（只是一个手动设置的值）或“Computed”（基于其他信号的公式）。
它 通常被称为 `Signals`，也可以被称为 Observables，Atoms，Subjects 和 Refs 。

`Signals` 通常由 `getter`，`setter`，`value` 组成：

::: code-tabs
@tab solid-js

```ts
const [count, setCount] = createSignal(0)

// 读取 value
console.log(count()) // 0

// 设置 value
setCount(5)
console.log(count()) // 5
```

:::

这看起来好像没有什么特别的地方，只是一个可以存储任意类型值的包装器。
但它的重点在于 `getter` 和 `setter` 可以运行在任意代码中，这对于更新的发布与订阅有很大的帮助。

也许你已经知道，在 Vue 中，它是使用 Object getter 或 Proxies 来实现：

::: code-tabs
@tab vue

```ts
const count = ref(0)

// 读取 value
console.log(count.value) // 0

// 设置 value
count.value = 5
console.log(count.value) // 5
```

:::

或者，像 Svelte 那样，隐藏在编译器后面：

::: code-tabs
@tab svelte

```ts
let count = 0
// 读取 value
console.log(count) // 0

// 设置 value
count = 5
```

:::

**从本质上讲，信号是事件发射器。但主要区别在于订阅的管理方式。**

### Reactive

如果缺少其它与之相关的 Reactive, 单看 `Signals` 好像并没有什么特别。
`Reactive`，也可以被称为 `Effects` 、`Autoruns`、 `Watches` 或 `Computed` 。
`Reactive` 通过观察 `Signals`，在其发生更新时重新运行。

```ts
console.log('1. Create Signal')
const [count, setCount] = createSignal(0)

console.log('2. Create Reaction')
createEffect(() => console.log('The count is', count()))

console.log('3. Set count to 5')
setCount(5)

console.log('4. Set count to 10')
setCount(10)
```

**输出：**

```txt
1. Create Signal

2. Create Reaction
The count is 0

3. Set count to 5
The count is 5

4. Set count to 10
The count is 10
```

这看起来有点神奇，在 `setCount()` 后 立即执行了 `createEffect` 的回调函数。
这看起来并没有直接关联的地方，实际上，在 `createEffect` 回调函数中， 执行 `count()` 时自动
订阅了 `createEffect` 回调函数，每当 `count` 发生变化时，都会重新运行 `createEffect` 回调函数。

## 如何实现 Signals ?

理解了 Signals 的核心概念后，让我们深入探讨其实现机制。Signals 的核心在于**依赖跟踪**和**更新传播**系统，这通过两个关键组件实现：**订阅机制**和**全局执行上下文**。

### 核心实现原理

1. **依赖跟踪**：当计算或副作用访问信号值时，系统自动记录当前上下文对该信号的依赖
2. **更新传播**：当信号值改变时，系统自动通知所有依赖项进行更新
3. **惰性求值**：计算值仅在需要时重新计算，避免不必要的计算
4. **变更批处理**：将多个更新合并为单一批处理，减少重复计算

以下是 Signals 核心机制的简化实现：

```typescript
// 当前正在执行的 effect 上下文
let currentEffect: (() => void) | null = null

// 信号类实现
class Signal<T> {
  private value: T
  private subscribers: Set<() => void> = new Set()

  constructor(initialValue: T) {
    this.value = initialValue
  }

  // 获取信号值并跟踪依赖
  get(): T {
    if (currentEffect) {
      this.subscribers.add(currentEffect)
    }
    return this.value
  }

  // 设置新值并触发更新
  set(newValue: T) {
    if (Object.is(this.value, newValue))
      return
    this.value = newValue
    this.notify()
  }

  // 通知所有订阅者
  private notify() {
    for (const sub of [...this.subscribers]) {
      sub()
    }
  }
}

// 创建副作用
function createEffect(effect: () => void) {
  const execute = () => {
    currentEffect = execute
    try {
      effect()
    }
    finally {
      currentEffect = null
    }
  }
  execute()
}

// 创建计算值
function createMemo<T>(fn: () => T): () => T {
  const [get, set] = createSignal(fn())
  createEffect(() => set(fn()))
  return get
}
```

### 依赖关系可视化

信号与计算值/副作用之间的依赖关系可以表示为有向图：

```mermaid
graph LR
  A[State Signal] --> B[Computed Signal 1]
  A --> C[Computed Signal 2]
  B --> D[Effect 1]
  C --> D
  C --> E[Effect 2]
```

当状态信号更新时，更新会沿着依赖链传播：

```mermaid
sequenceDiagram
  participant StateSignal
  participant ComputedSignal
  participant Effect

  StateSignal->>ComputedSignal: 值变更通知
  ComputedSignal->>ComputedSignal: 重新计算值
  ComputedSignal->>Effect: 值变更通知
  Effect->>Effect: 执行副作用
```

### 关键优化技术

#### 1. 惰性求值 (Lazy Evaluation)

计算值不会立即重新计算，而是在被访问时才计算：

```typescript
class Computed<T> {
  private value!: T
  private dirty = true
  private computeFn: () => T
  private dependencies = new Set<Signal<any>>()

  constructor(fn: () => T) {
    this.computeFn = fn
    this.update()
  }

  get(): T {
    if (this.dirty) {
      this.update()
    }
    return this.value
  }

  private update() {
    // 清除旧依赖
    for (const dep of this.dependencies) {
      dep.unsubscribe(this.markDirty)
    }
    this.dependencies.clear()

    // 设置当前计算上下文
    const prevEffect = currentEffect
    currentEffect = this.markDirty.bind(this)

    // 计算新值并收集依赖
    this.value = this.computeFn()
    this.dirty = false

    // 恢复上下文
    currentEffect = prevEffect
  }

  private markDirty = () => {
    if (!this.dirty) {
      this.dirty = true
      // 通知自己的订阅者
    }
  }
}
```

#### 2. 变更批处理 (Batching Updates)

将多个连续更新合并为单一批处理：

```typescript
let batchedUpdates: (() => void)[] = []
let isBatching = false

function batch(callback: () => void) {
  if (isBatching) {
    callback()
    return
  }

  isBatching = true
  try {
    callback()
    flushUpdates()
  }
  finally {
    isBatching = false
  }
}

function scheduleUpdate(updateFn: () => void) {
  if (isBatching) {
    batchedUpdates.push(updateFn)
  }
  else {
    updateFn()
  }
}

function flushUpdates() {
  while (batchedUpdates.length) {
    const updates = batchedUpdates
    batchedUpdates = []
    updates.forEach(fn => fn())
  }
}
```

### 内存管理优化

为防止内存泄漏，Signal 实现需要包含自动清理机制：

```typescript
class EffectCleanup {
  private cleanupFns: (() => void)[] = []

  add(fn: () => void) {
    this.cleanupFns.push(fn)
  }

  run() {
    for (const fn of this.cleanupFns) {
      fn()
    }
    this.cleanupFns = []
  }
}

function createEffect(effectFn: (cleanup: EffectCleanup) => void) {
  const cleanup = new EffectCleanup()

  const effect = () => {
    cleanup.run()
    currentEffect = effect
    try {
      effectFn(cleanup)
    }
    finally {
      currentEffect = null
    }
  }

  effect()
}
```

### 框架集成策略

不同框架集成 Signals 的方式各有不同：

1. **编译时集成**（如 Svelte）：

   ```mermaid
   graph LR
     A[Svelte Component] --> B[Compiler]
     B --> C[Optimized JS with Signals]
     C --> D[Runtime]
   ```

2. **运行时集成**（如 SolidJS）：

   ```mermaid
   graph LR
     A[Component Render] --> B[Create Signals]
     B --> C[Create Effects]
     C --> D[DOM Updates]
   ```

3. **混合策略**（如 Vue）：

   ```mermaid
   graph LR
     A[Template] --> B[Compiler]
     B --> C[Render Function]
     C --> D[Reactivity System]
     D --> E[Signals]
   ```

### 性能优化对比

下表展示了不同更新策略的性能影响：

| 更新策略       | 计算次数 | DOM 操作次数 | 内存使用 |
|----------------|----------|--------------|----------|
| 传统方式       | O(N)     | O(N)         | 低       |
| 手动优化       | O(logN)  | O(logN)      | 中       |
| Signals 系统   | O(1)     | O(1)         | 中高     |
| 编译时优化     | O(1)     | O(1)         | 低       |

> 注：N 表示依赖项数量

## 未来展望：原生 Signals 支持

TC39 的 Signals 提案目前处于 Stage 0，其核心目标是提供：

1. **标准化 API**：

   ```js
   const count = new Signal.State(0)
   const isEven = new Signal.Computed(() => count.get() % 2 === 0)

   Signal.subtle.watch(() => {
     console.log(`Count is ${count.get()} (${isEven.get() ? 'even' : 'odd'})`)
   })
   ```

2. **跨框架互操作性**：

   ```mermaid
   graph LR
     A[Framework A] --> C[Shared Signals]
     B[Framework B] --> C
     C --> D[DOM Updates]
   ```

3. **底层优化能力**：
   * 直接内存访问
   * 硬件级优化
   * 跨线程同步

### 潜在优势

1. **性能提升**：浏览器可直接优化信号更新路径
2. **内存优化**：共享信号减少框架开销
3. **框架互操作**：不同框架组件可共享状态
4. **开发者体验**：统一响应式编程模型

## 结论

Signals 作为前端响应式编程的核心抽象，经历了十余年的发展和验证，已成为现代前端框架不可或缺的基础设施。其核心价值在于：

1. **精确更新**：最小化计算和渲染范围
2. **自动依赖跟踪**：解放开发者手动管理依赖
3. **声明式编程**：提升代码可维护性和可读性
4. **性能优化**：通过惰性求值和变更批处理减少开销

随着 TC39 标准化进程的推进，我们有望看到：

* 浏览器原生支持的 Signals API
* 跨框架共享的状态管理方案
* 更高效的响应式系统实现
* 更简洁的前端状态管理范式

对于前端开发者而言，深入理解 Signals 不仅有助于更好地使用现代框架，更能把握前端架构的未来发展方向。Signals 代表的细粒度响应式编程范式，正在重塑我们构建复杂用户界面的方式，为下一代 Web 应用奠定坚实基础。

---

---
url: /article/ou7gebop/index.md
---
# Typescript 内置类型
TypeScript 提供了许多内置的类型方法和工具类型，用于处理和操作类型。以下是其中一些常用的内置类型方法：

## 分类

### Utility Types（工具类型）

* `Partial<T>` : 将类型 T 的所有属性变为可选。
* `Required<T>` : 将类型 T 的所有属性变为必选。
* `Readonly<T>` : 将类型 T 的所有属性变为只读。
* `Record<K, T>` : 创建一个具有指定键类型 K 和值类型 T 的新对象类型。
* `Pick<T, K>` : 从类型 T 中选择指定属性 K 形成新类型。
* `Omit<T, K>` : 从类型 T 中排除指定属性 K 形成新类型。
* `Exclude<T, U>` : 从类型 T 中排除可以赋值给类型 U 的类型。
* `Extract<T, U>` : 从类型 T 中提取可以赋值给类型 U 的类型。
* `NonNullable<T>` : 从类型 T 中排除 null 和 undefined 类型。
* `ReturnType<T>` : 获取函数类型 T 的返回类型。
* `Parameters<T>` : 获取函数类型 T 的参数类型组成的元组类型。
* `Awaited<T>`: 模拟 `async` 函数中的 `await` 操作，或者 `promise` 上的 `.then()` 方法。
* `ConstructorParameters<T>`: 获取构造函数类型 T 的参数类型组成的元组类型。
* `InstanceType<T>`: 获取构造函数类型 T 的实例类型。
* `ThisParameterType<T>`: 获取函数类型 T 的 `this` 类型。
* `OmitThisParameter<T>`: 从函数类型 T 中移除 `this` 类型。
* `ThisType<T>`: 获取函数类型 T 的 `this` 类型。

### 条件判定类型

* `Conditional Types（条件类型）`: 根据类型关系进行条件判断生成不同的类型。
* `Distribute Conditional Types（分布式条件类型）`: 分发条件类型，允许条件类型在联合类型上进行分发。

### Mapped Types（映射类型）

根据已有类型创建新类型，通过映射类型可以生成新的类型结构。

### Template Literal Types（模板文字类型）

使用字符串模板创建新类型。

### 类型推断关键字

* `typeof`: 关键字允许在条件类型中推断类型变量。
* `keyof`：关键字允许在泛型条件类型中推断类型变量。
* `instanceof`：运算符用于检查对象是否是特定类的实例。
* `in`：用于检查对象是否具有特定属性。
* `type guard`：类型守卫是自定义的函数或条件语句，用于在代码块内缩小变量的类型范围。
* `as`：用于类型断言，允许将一个变量断言为特定的类型。

## Utility Types

### Partial\<T>

构造一个将 `T` 的所有属性设置为可选的类型。

```ts twoslash
interface Todo {
  title: string
  description: string
}

function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {
  return { ...todo, ...fieldsToUpdate }
}

const todo1 = {
  title: 'organize desk',
  description: 'clear clutter',
}

const todo2 = updateTodo(todo1, {
  description: 'throw out trash',
})

//
```

### Required\<T>

该类型将类型 `T` 的所有属性变为必选。

```ts twoslash
// @errors: 2741
interface Props {
  a?: number
  b?: string
}
const obj: Props = { a: 5 }
const obj2: Required<Props> = { a: 5 }
```

### Readonly\<T>

将类型 `T` 的所有属性变为只读。

```ts twoslash
// @errors: 2540
interface Todo {
  title: string
}
const todo: Readonly<Todo> = {
  title: 'Delete inactive users',
}
todo.title = 'Hello'
```

### Record\<K, T>

创建一个具有指定键类型 K 和值类型 T 的新对象类型。

```ts twoslash
interface CatInfo {
  age: number
  breed: string
}
type CatName = 'miffy' | 'boris' | 'mordred'

const cats: Record<CatName, CatInfo> = {
  miffy: { age: 10, breed: 'Persian' },
  boris: { age: 5, breed: 'Maine Coon' },
  mordred: { age: 16, breed: 'British Shorthair' },
}

cats.boris
//    ^?
//
```

### Pick\<T, K>

从类型 T 中选择指定属性 K 形成新类型。

```ts twoslash
interface Todo {
  title: string
  description: string
  completed: boolean
}

type TodoPreview = Pick<Todo, 'title' | 'completed'>

const todo: TodoPreview = {
  title: 'Clean room',
  completed: false,
}

todo
// ^?
//
```

### Omit\<T, K>

与 Pick 相反，该类型从类型 T 中排除指定属性 K 形成新类型。

```ts twoslash
interface Todo {
  title: string
  description: string
  completed: boolean
  createdAt: number
}

type TodoPreview = Omit<Todo, 'description'>

const todo: TodoPreview = {
  title: 'Clean room',
  completed: false,
  createdAt: 1615544252770,
}

todo
// ^?

type TodoInfo = Omit<Todo, 'completed' | 'createdAt'>

const todoInfo: TodoInfo = {
  title: 'Pick up kids',
  description: 'Kindergarten closes at 5pm',
}

todoInfo
// ^?
//
```

### Exclude\<T, U>

从类型 T 中排除可以赋值给类型 U 的类型。

```ts twoslash
type T0 = Exclude<'a' | 'b' | 'c', 'a'>
//   ^?

type T1 = Exclude<'a' | 'b' | 'c', 'a' | 'b'>
//   ^?

type T2 = Exclude<string | number | (() => void), Function>
//   ^?

type Shape
  = | { kind: 'circle', radius: number }
    | { kind: 'square', x: number }
    | { kind: 'triangle', x: number, y: number }

type T3 = Exclude<Shape, { kind: 'circle' }>
//   ^?

//
```

### Extract\<T, U>

从类型 T 中提取可以赋值给类型 U 的类型。

```ts twoslash
type T0 = Extract<'a' | 'b' | 'c', 'a' | 'f'>
//   ^?

type T1 = Extract<string | number | (() => void), Function>
//   ^?

type Shape
  = | { kind: 'circle', radius: number }
    | { kind: 'square', x: number }
    | { kind: 'triangle', x: number, y: number }

type T2 = Extract<Shape, { kind: 'circle' }>
//   ^?

//
```

### NonNullable\<T>

从类型 T 中排除 null 和 undefined 类型。

```ts twoslash
type T0 = NonNullable<string | number | undefined>
//   ^?

type T1 = NonNullable<string[] | null | undefined>
//   ^?

//
```

### ReturnType\<T>

获取函数类型 T 的返回类型。

```ts twoslash
// @errors: 2344
declare function f1(): { a: number, b: string }

type T0 = ReturnType<() => string>
//   ^?

type T1 = ReturnType<(s: string) => void>
//   ^?

type T2 = ReturnType<<T>() => T>
//   ^?

type T3 = ReturnType<<T extends U, U extends number[]>() => T>
//   ^?

type T4 = ReturnType<typeof f1>
//   ^?

type T5 = ReturnType<any>
//   ^?

type T6 = ReturnType<never>
//   ^?

type T7 = ReturnType<string>

type T8 = ReturnType<Function>
```

### Parameters\<T>

获取函数类型 T 的参数类型组成的元组类型。

```ts twoslash
// @errors: 2344
declare function f1(arg: { a: number, b: string }): void

type T0 = Parameters<() => string>
//   ^?

type T1 = Parameters<(s: string) => void>
//   ^?

type T2 = Parameters<<T>(arg: T) => T>
//   ^?

type T3 = Parameters<typeof f1>
//   ^?

type T4 = Parameters<any>
//   ^?

type T5 = Parameters<never>
//   ^?

type T6 = Parameters<string>

type T7 = Parameters<Function>
```

### Awaited\<T>

模拟 `async` 函数中的 `await` 操作，或者 `promise` 上的 `.then()` 方法。

```ts twoslash
type A = Awaited<Promise<string>>
//   ^?

type B = Awaited<Promise<Promise<number>>>
//   ^?

type C = Awaited<boolean | Promise<number>>
//   ^?

//
```

### ConstructorParameters\<T>

获取构造函数类型 T 的参数类型组成的元组类型。

```ts twoslash
// @errors: 2344
type T0 = ConstructorParameters<ErrorConstructor>
//   ^?

type T1 = ConstructorParameters<FunctionConstructor>
//   ^?

type T2 = ConstructorParameters<RegExpConstructor>
//   ^?

class C {
  constructor(a: number, b: string) {}
}
type T3 = ConstructorParameters<typeof C>
//   ^?

type T4 = ConstructorParameters<any>
//   ^?

type T5 = ConstructorParameters<Function>
```

### InstanceType\<T>

获取构造函数类型 T 的实例类型。

```ts twoslash
// @errors: 2344
class C {
  x = 0
  y = 0
}

type T0 = InstanceType<typeof C>
//   ^?

type T1 = InstanceType<any>
//   ^?

type T2 = InstanceType<never>
//   ^?

type T3 = InstanceType<string>

type T4 = InstanceType<Function>
```

### ThisParameterType\<T>

获取函数类型 T 的 `this` 类型。

```ts twoslash
function toHex(this: number) {
  return this.toString(16)
}

function numberToString(n: ThisParameterType<typeof toHex>) {
  return toHex.apply(n)
}
```

### OmitThisParameter\<T>

从函数类型 T 中移除 `this` 类型。

```ts twoslash
function toHex(this: number) {
  return this.toString(16)
}

const fiveToHex: OmitThisParameter<typeof toHex> = toHex.bind(5)

console.log(fiveToHex())

//
```

### ThisType\<T>

获取函数类型 T 的 `this` 类型。

```ts twoslash
interface ObjectDescriptor<D, M> {
  data?: D
  methods?: M & ThisType<D & M> // Type of 'this' in methods is D & M
}

function makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {
  let data: object = desc.data || {}
  let methods: object = desc.methods || {}
  return { ...data, ...methods } as D & M
}

let obj = makeObject({
  data: { x: 0, y: 0 },
  methods: {
    moveBy(dx: number, dy: number) {
      this.x += dx // Strongly typed this
      this.y += dy // Strongly typed this
    },
  },
})

obj.x = 10
obj.y = 20
obj.moveBy(5, 5)

//
```

## 条件判定类型

条件类型是 `TypeScript` 中强大且灵活的类型构造方式，它允许根据类型关系进行条件判断生成不同的类型。
分布式条件类型是条件类型的一种特殊形式，它允许条件类型在联合类型上进行分发，以便更精确地推断和处理类型。

### Conditional Types（条件类型）

条件类型基于输入的类型关系来确定最终的类型。它使用 `infer` 关键字来推断和定义类型。
条件类型通常结合了 `TypeScript` 中的 `extends` 关键字，这样就可以根据条件来确定最终的类型。

#### 根据输入类型选择不同的类型

条件类型基于输入的类型关系来确定最终的类型。它使用 `infer` 关键字来推断和定义类型。
条件类型通常结合了 `TypeScript` 中的 `extends` 关键字，这样就可以根据条件来确定最终的类型。

示例：

```ts twoslash
type TypeName<T> = T extends string ? 'string' : T extends number ? 'number' : T extends boolean ? 'boolean' : 'other'

type A = TypeName<string>
//   ^?

type B = TypeName<number>
//   ^?

type C = TypeName<boolean>
//   ^?

type D = TypeName<object>
//   ^?

type E = TypeName<string | number>
//   ^?

//
```

在这个例子中，`TypeName<T>` 条件类型根据传入的类型 T 来确定最终返回的类型字符串。如果 T 是 `string`、`number` 或 `boolean` 类型，则返回对应的类型字符串，否则返回 `'other'`。

### 条件类型中使用 `infer` 关键字

`infer` 关键字通常与extends结合使用，用于在条件类型内部声明一个类型变量，并从中提取或推断出一个类型。
它允许我们在泛型条件类型中推断出待推断类型的部分。

具体左右有以下两点：

1. TypeScript 支持 infer 来提取类型的一部分，通过模式匹配的方式。

示例：

```ts twoslash
type ExtractReturnType<T> = T extends (...args: any[]) => infer R ? R : never

function greet(): string {
  return 'Hello!'
}

type GreetReturnType = ExtractReturnType<typeof greet>
//     ^?
//
```

这个例子中的 `ExtractReturnType<T>` 条件类型获取函数类型 `T` 的返回类型。它使用了 `infer` 关键字来推断函数的返回类型，如果 `T` 是一个函数类型，则返回其返回类型，否则返回 `never`。

2. `infer extends` 用来做类型转换，比如 `string` 转 `number`、转 `boolean` 等；

```ts twoslash
enum Code {
  a = 111,
  b = 222,
  c = 'ccc',
}

type StrToNum<Str> = Str extends `${infer Num extends number}` ? Num : Str

type res = StrToNum<`${Code}`>
//    ^?
//
```

3. 条件类型配合泛型使用

```ts twoslash
type Diff<T, U> = T extends U ? never : T

type FilterOut<T, U> = T extends any ? Diff<T, U> : never

type Result = FilterOut<'a' | 'b' | 'c' | 'd', 'a' | 'c'>
//    ^?
//
```

在这个例子中，`FilterOut<T, U>` 条件类型根据传入的两个联合类型 T 和 U，从 T 中过滤掉属于 U 类型的成员，
返回剩余的类型。通过 `Diff<T, U>` 辅助实现了这个操作。这种方式可以在处理类型时非常有用，比如过滤掉某些特定类型。

### Distributive Conditional Types（分布式条件类型）

分布式条件类型是条件类型的一种特殊形式，它在联合类型上进行推断和分发，并返回联合类型中每个成员的条件类型。

```ts twoslash
type ToArray<T> = T extends any ? T[] : never

type StrArray = ToArray<string>
//    ^?

type NumArray = ToArray<number>
//    ^?

type UnionArray = ToArray<string | number>
//    ^?
//
```

在这个例子中，`ToArray<T>` 条件类型以联合类型 T 为输入，并将其分发到联合类型的每个成员上，返回一个数组类型。
这种分布式行为使得条件类型在处理联合类型时更加灵活和强大。

条件类型和分布式条件类型为 TypeScript 中的类型系统增加了极大的灵活性和表达能力，
允许开发者根据复杂的类型关系来定义和推断类型。

## Mapped Types（映射类型）

`映射类型（Mapped Types）` 是 TypeScript 中一种强大的类型操作，它允许你通过已有类型来创建新类型，
通常通过映射现有类型的属性、方法或者创建新的属性来实现。

常见的映射类型是利用 `keyof` 关键字配合索引类型来生成新的类型。一个经典的例子是 `Partial<T>` 类型。它接受一个类型 T 并将所有属性设置为可选的：

```ts twoslash
type MyPartial<T> = {
  [P in keyof T]?: T[P]
}

interface User {
  name: string
  age: number
}

type PartialUser = MyPartial<User>
//    ^?

//
```

在这个例子中，`Partial<T>` 使用了映射类型，通过遍历 T 类型的所有属性（由 `keyof T` 获取），
创建了一个新类型，该类型包含了原类型 T 的所有属性，并将它们设为可选的。

除了 `Partial`，还有一些其他常见的映射类型：

* `Readonly<T>`：将类型 T 中所有属性设置为只读。
* `Pick<T, K>`：选择类型 T 中的特定属性 K。
* `Record<K, T>`：根据键类型 K 创建一个新类型，其属性为类型 T。
* `Exclude<T, U>` 和 `Extract<T, U>`：从类型 T 中排除或提取符合类型 U 的部分。

映射类型可以使类型操作更加灵活，能够根据现有类型创建出符合特定需求的新类型。
这种功能特别适用于工具类型（Utility Types）的定义，使得类型系统更具表现力和可维护性。

## Template Literal Types（模板文字类型）

Template Literal Types（模板文字类型）是 TypeScript 4.1 引入的一项新特性，它允许在类型系统中对字符串文本进行操作和转换。这项功能利用了模板字符串的灵活性，使得可以在类型声明中使用类似于模板字符串的语法。

在模板文字类型中，可以使用模板字符串的 `${}` 语法来动态地创建字符串字面量类型。
这使得类型系统更具表现力，能够进行更复杂的字符串类型操作。

举个例子，假设有一个类型 WelcomeMessage，用于根据用户类型生成不同的欢迎消息：

```ts twoslash
type User = 'admin' | 'user'

type WelcomeMessage<T extends User> = `Welcome, ${Capitalize<T>}!`

type AdminWelcome = WelcomeMessage<'admin'>
//     ^?

type UserWelcome = WelcomeMessage<'user'>
//    ^?
//
```

在这个例子中，`WelcomeMessage` 是一个模板文字类型，利用了模板字符串中的 `${}` 语法。
它动态地根据传入的用户类型（"admin" 或 "user"）生成相应的欢迎消息。
这里使用了 `Capitalize<T>` 来确保用户名的首字母大写。

模板文字类型在类型定义中能够进行字符串的拼接、转换等操作，使得在类型层面上能够更灵活地处理和操作字符串类型。

## 类型推断关键字

在 TypeScript 中，有几个关键字和操作符用于类型判定。
这些关键字和操作符帮助你在代码中进行类型检查、类型判断和类型转换。

### typeof

`typeof` 是一个类型查询操作符，用于获取变量或表达式的类型。它可以返回该值的类型字符串表示。
比如 `typeof variable` 返回变量的类型，如 'number'、'string'、'object' 等。

```ts twoslash
const numberVar = 10

type NumberType = typeof numberVar
//     ^?
//
```

### instanceof

`instanceof` 运算符用于检查对象是否是特定类的实例。它返回一个布尔值表示检查结果。

```ts
class Animal {}
class Dog extends Animal {}

const dog = new Dog()
if (dog instanceof Dog) {
  console.log('It is a dog!')
}
```

### in

`in` 关键字用于检查对象是否具有特定属性。它在条件语句中常用于判断对象是否包含某个属性。

```ts
interface Person {
  name: string
  age: number
}

const person: Person = { name: 'Alice', age: 30 }
if ('age' in person) {
  console.log('Person has age property.')
}
```

### type guards

类型守卫是自定义的函数或条件语句，用于在代码块内缩小变量的类型范围。
它们可以是 `typeof`、`instanceof` 或者其他自定义条件的组合。

```ts twoslash
function isNumber(value: any): value is number {
  return typeof value === 'number'
}

function process(value: any) {
  if (isNumber(value)) {
    //           ^?

    // value 在此处被缩小为 number 类型
    console.log(value.toFixed(2))
    //            ^?
  }
  else {
    console.log('Value is not a number')
  }
}
```

### as

`as` 关键字用于类型断言，允许将一个变量断言为特定的类型。

```ts
const someValue: any = 'hello'
const length = (someValue as string).length
```

这些关键字和操作符能够在 TypeScript 中进行类型判断、类型检查和类型转换，有助于确保代码的类型安全性和正确性。

---

---
url: /article/q40nq4hv/index.md
---
# 详解 Promise
## 概述

`Promise` 是一个构造函数，用于创建一个新的 Promise 对象。该构造函数主要用于包装还没有添加 promise 支持的函数。

```txt
Promise(resolver : (resolve, reject) => void)
```

`Promise` 接受一个函数`resolver`作为参数，包装需要执行的处理程序，当处理结果为成功时，将成功的返回值作为参数调用`resolve` 方法，
如果失败，则将失败原因作为参数调用`reject`方法。

### 示例

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    // do something
    if (Math.random() * 10 > 5) {
      resolve({ status: 'success', data: '' })
    }
    else {
      reject(new Error('error'))
    }
  }, 500)
})
```

### Promise状态

Promise 创建后，必然处于以下几种状态

* `pending` : 待定状态，既没有被兑现，也没有被拒绝
* `fulfilled` : 操作成功。
* `rejected` : 操作失败。

当状态从 `pending` 更新为`fulfilled`或`rejected` 后，就再也不能变更为其他状态。

### Promise 实例方法

#### `.then(onFulfilled, onRejected)`

*then()* 接收两个函数参数（也可以仅接收一个函数参数 onFulfilled）。

* onFulfilled 函数参数，表示当 promise的状态从 `pending` 更新为`fulfilled` 时触发，并将成功的结果 value 作为`onFulfilled`函数的参数。
* onRejected 函数参数，表示当promise的状态从 `pending` 更新为`rejected` 时触发，并将失败的原因 reason 作为 `onRejected`函数的参数。

  *then()* 方法返回的结果会被包装为一个新的promise实例。

#### `.catch(onRejected)`

*catch()* 可以相当于 *.then(null, onRejected)*，即仅处理当promise的状态从 `pending` 更新为`rejected` 时触发。

#### `.finally(onFinally)`

表示promise的状态无论是从`pengding`更新为`fulfilled`或`rejected`，当所有的 then() 和 catch() 执行完成后，最后会执行 finally() 的回调。

由于无法知道promise的最终状态，`onFinally` 回调函数不接收任何参数，它仅用于无论最终结果如何都要执行的情况。

```js
promise
  .then((res) => {
    console.log(res) // { status: 'success', data: '' }
  })
  .catch((reason) => {
    console.log(reason) // error: error
  })
  .finally(() => {
    // do something
  })
```

### 链式调用

使用Promise的一个优势是，可以链式调用的方式，执行多个`then()`/`catch()`方法。
且回调函数允许我们返回任何值，返回的值将会被包装为一个 promise实例，将值传给下一个`then()`/`catch()`方法。

```js
promise
  .then((res) => {
    res.data = { a: 2 }
    return res
  })
  .then((res) => {
    console.log(res) // { status: 'success', data: { a: 2 } }
    throw new Error('cath error')
  })
  .catch((reason) => {
    console.log(reason) // error: cath error
  })
```

## Promise代码实现

```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
const microtask = globalThis.queueMicrotask || (cb => setTimeout(cb, 0))

function LikePromise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError(`Promise resolver ${resolver} is not a function`)
  }
  this.state = PENDING
  this.value = undefined
  this.reason = undefined
  this.fulfillQueue = []
  this.rejectQueue = []

  const that = this

  function reject(reason) {
    if (that.state === PENDING) {
      that.state = REJECTED
      that.reason = reason
      that.rejectQueue.forEach(cb => cb(reason))
    }
  }

  function resolve(value) {
    if (that.state === PENDING) {
      that.state = FULFILLED
      that.value = value
      that.fulfillQueue.forEach(cb => cb(value))
    }
  }

  try {
    resolver(resolve, reject)
  }
  catch (e) {
    reject(e)
  }
}

function resolvePromise(promise, x, resolve, reject) {
  if (promise === x) {
    reject(new TypeError('chaining cycle'))
  }
  else if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
    let used = false
    try {
      const then = x.then
      if (typeof then === 'function') {
        then.call(
          x,
          (y) => {
            if (used)
              return
            used = true
            resolvePromise(promise, y, resolve, reject)
          },
          (r) => {
            if (used)
              return
            used = true
            reject(r)
          },
        )
      }
      else {
        if (used)
          return
        used = true
        resolve(x)
      }
    }
    catch (e) {
      if (used)
        return
      used = true
      reject(e)
    }
  }
  else {
    resolve(x)
  }
}

LikePromise.prototype.then = function (onFulfilled, onRejected) {
  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value
  onRejected
    = typeof onRejected === 'function'
      ? onRejected
      : (reason) => {
          throw reason
        }
  const that = this
  const promise = new LikePromise((resolve, reject) => {
    if (that.state === FULFILLED) {
      microtask(() => {
        try {
          const x = onFulfilled(that.value)
          resolvePromise(promise, x, resolve, reject)
        }
        catch (e) {
          reject(e)
        }
      })
    }
    else if (that.state === REJECTED) {
      microtask(() => {
        try {
          const x = onRejected(that.reason)
          resolvePromise(promise, x, resolve, reject)
        }
        catch (e) {
          reject(e)
        }
      })
    }
    else {
      that.fulfillQueue.push(() => {
        microtask(() => {
          try {
            const x = onFulfilled(that.value)
            resolvePromise(promise, x, resolve, reject)
          }
          catch (e) {
            reject(e)
          }
        })
      })
      that.rejectQueue.push(() => {
        microtask(() => {
          try {
            const x = onRejected(that.reason)
            resolvePromise(promise, x, resolve, reject)
          }
          catch (e) {
            reject(e)
          }
        })
      })
    }
  })
  return promise
}

LikePromise.prototype.catch = function (onRejected) {
  return this.then(null, onRejected)
}

LikePromise.prototype.finally = function (onFinally) {
  return this.then(
    value => LikePromise.resolve(onFinally()).then(() => value),
    reason =>
      LikePromise.resolve(onFinally()).then(() => {
        throw reason
      }),
  )
}

LikePromise.resolve = function (value) {
  return new LikePromise(resolve => resolve(value))
}

LikePromise.reject = function (reason) {
  return new LikePromise((_, reject) => reject(reason))
}
```

## `Promise` 静态方法

### Promise.resolve(value)

返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，
返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),
返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。
通常而言，如果您不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,
这样就能将该value以Promise对象形式使用。

### Promise.reject(reason)

返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法

### Promise.all(promises)

`all()` 允许传入一组promise实例，并返回一个新的promise实例。

promises并发执行，并且当这组promises的最终状态均更新为`fulfilled`时，才触发返回的promise实例的`onFulfilled`，
并将这组promises的执行结果，已promises的定义顺序，以数组的形式传给`onFulfilled`。
如果其中某个promise的最终状态更新为`rejected`，则立即触发返回的promise实例的`onRejected`。

#### 示例

```js
const promises = [
  Promise.resolve({ a: 1 }),
  new Promise((resolve) => {
    setTimeout(() => {
      resolve({ b: 1 })
    }, 0)
  }),
]
Promise.all(promises).then((res) => {
  console.log(res) // [ { a: 1}, { b: 1 } ]
})
```

#### 手写Promise.all 实现代码

```js
function promiseAll(promises) {
  promises = promises || []
  let length = promises.length
  if (length === 0)
    return Promise.resolve([])
  let count = 0
  const list = []
  return new Promise((resolve, reject) => {
    const resolveFn = (res, index) => {
      list[index] = res
      count++
      if (count >= length) {
        resolve(list)
      }
    }
    promises.forEach((item, i) => {
      if (item instanceof Promise) {
        item.then(res => resolveFn(res, i), reject)
      }
      else {
        resolveFn(item, i)
      }
    })
  })
}
```

### Promise.allSettled

`allSettled(promises)` 允许传入一组promise实例，并返回一个新的promise对象。

当这组promises的状态从`pending` 都更新到最终状态、无论最终状态是 `fulfilled` 或`rejected`时，触发返回的promise的`onfulfilled`。

`onfulfilled` 回调函数，根据promises定义的顺序，将执行结果以 `{ status: string, [value|reason]: any }[]` 的形式作为参数传入。

#### 示例

```js
const promises = [Promise.resolve({ a: 1 }), Promise.reject(new Error('reason'))]
Promise.allSettled(promises).then((res) => {
  console.log(res) // [ { status: 'fulfilled’, value: { a: 1 } }, { status: 'rejected', reason: 'reason' }  ]
})
```

#### 手写Promise.allSettled 实现代码

```js
function promiseAllSettled(promises) {
  promises = promises || []
  let length = promises.length
  if (length === 0)
    return Promise.resolve([])
  let count = 0
  const list = []
  return new Promise((resolve) => {
    const resolveFn = (res, index, status) => {
      list[index] = { status }
      if (status === 'fulfilled') {
        list[index].value = res
      }
      else {
        list[index].reason = res
      }
      count++
      if (count >= length) {
        resolve(list)
      }
    }
    promises.forEach((item, i) => {
      if (item instanceof Promise) {
        item.then(
          res => resolveFn(res, i, 'fulfilled'),
          reason => resolveFn(reason, i, 'rejected'),
        )
      }
      else {
        resolveFn(item, i, 'fulfilled')
      }
    })
  })
}
```

### Promise.race

`Promise.race(promises)` 接收一组promise实例作为参数，并返回一个新的promise对象。

当这组promises中的任意一个promise的状态从`pending`更新为`fulfilled`或`rejected`时，返回的promise对象将会把该promise的成功返回值或者失败原因
作为参数调用返回的promise的`onFulfilled`或`onRejected`

#### 示例

```js
const promises = [
  new Promise((resolve) => {
    setTimeout(() => {
      resolve('timeout')
    }, 500)
  }),
  Promise.resolve('resolve'),
]

Promise.race(promises).then((res) => {
  console.log(res) // resolve
})
```

#### 手写Promise.race 实现代码

```js
function promiseRace(array) {
  array = array || []
  return new Promise((resolve, reject) => {
    array.forEach((item) => {
      if (item instanceof Promise) {
        item.then(resolve, reject)
      }
      else {
        resolve(item)
      }
    })
  })
}
```

## 参考资料

> [Promise A+ 规范](https://malcolmyu.github.io/2015/06/12/Promises-A-Plus/)
>
> [MDN Promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)
>
> [MDN 使用Promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises)

---

---
url: /article/qrfeqp1q/index.md
---
# 小徽章制作
用于制作 小徽章的在线网站 或项目

* <https://shields.io/>
* <https://badgen.net/>
* <https://forthebadge.com/>
* <https://badge.fury.io/>
* <https://github.com/boennemann/badges>

## example

```md
![npm version](https://badge.fury.io/js/@vuepress-plume%2Fvuepress-theme-plume.svg)

![npm version](https://badge.fury.io/js/@vuepress-plume%2Fvuepress-theme-plume.svg)

![github version](https://badge.fury.io/gh/pengzhanbo%2Fvuepress-theme-plume.svg)

![release](https://badgen.net/github/release/pengzhanbo/vuepress-theme-plume/)

![npm](https://img.shields.io/npm/dw/@vuepress-plume/vuepress-theme-plume?style=plastic)
```

![npm version](https://badge.fury.io/js/@vuepress-plume%2Fvuepress-theme-plume.svg)

![github version](https://badge.fury.io/gh/pengzhanbo%2Fvuepress-theme-plume.svg)

![release](https://badgen.net/github/release/pengzhanbo/vuepress-theme-plume/)

![npm](https://img.shields.io/npm/dw/@vuepress-plume/vuepress-theme-plume?style=plastic)

---

---
url: /article/qv8ce43o/index.md
---
# CSS @container：组件级响应式设计
在传统响应式设计中，我们依赖媒体查询（`@media`）来根据视口尺寸调整样式。但随着组件化开发的普及，这种方法显得力不从心。CSS `@container` 规则的到来，标志着我们进入了**组件级响应式设计**的新时代！

## 什么是容器查询？

容器查询（Container Queries）允许元素根据其**父容器**的尺寸变化进行样式调整，而不是依赖视口大小。这意味着组件可以自主响应其所在容器的环境，实现真正的模块化和可复用性。

:::tip 核心优势

* **组件级响应**：组件自主响应容器尺寸，不依赖视口
* **上下文感知**：组件可感知不同容器环境自动适配
* **高复用性**：同一组件在不同容器中呈现不同布局
  :::

## 快速入门：三步实现容器查询

:::steps

* **步骤1**：定义容器上下文
* **步骤2**：编写容器查询规则
* **步骤3**：应用响应式样式

:::

### 1. 定义容器上下文

```css title="定义容器"
.component-container {
  container-type: inline-size; /* 监控内联方向尺寸（宽度） */
  container-name: main-container; /* 可选命名 */
}
```

或者使用简写形式：

```css title="简写语法"
.component-container {
  container: main-container / inline-size;
}
```

### 2. 编写容器查询

```css title="容器查询示例"
@container main-container (min-width: 400px) {
  .card {
    grid-template-columns: 1fr 2fr;
    gap: 2rem;
  }
  .card__title {
    font-size: clamp(1.25rem, 3vw, 1.5rem);
  }
}
```

## 实战案例：智能卡片组件

让我们通过一个完整的示例来理解容器查询的强大之处：

:::: demo normal title="响应式卡片演示" desc="根据容器宽度自动调整布局的卡片组件"
::: code-tabs
@tab HTML

```html
<div class="card-container">
  <div class="card">
    <img src="/images/defensive-css/ratio.png" alt="示例图片">
    <div class="content">
      <h3>智能响应式卡片</h3>
      <p>这个卡片会根据父容器的宽度自动调整布局，实现真正的组件级响应式设计。</p>
      <button>了解更多</button>
    </div>
  </div>
</div>
```

@tab CSS

```css
.card-container {
  container: card-container / inline-size;
  resize: horizontal; /* 仅用于演示，允许手动调整宽度 */
  overflow: auto;
  border: 1px solid #e0e0e0;
  padding: 1rem;
  max-width: 800px;
}

/* 默认样式 - 移动端优先 */
.card {
  display: block;
  background: white;
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  overflow: hidden;
}

.card img {
  width: 100%;
  height: 200px;
  object-fit: cover;
}

.card .content {
  padding: 1.5rem;
}

.card h3 {
  font-size: 1.25rem;
  margin-bottom: 0.5rem;
  color: #333;
}

.card p {
  color: #666;
  line-height: 1.6;
  margin-bottom: 1rem;
}

.card button {
  background: #007bff;
  color: white;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.9rem;
}

/* 容器宽度 ≥ 400px 时切换为并排布局 */
@container card-container (min-width: 400px) {
  .card {
    display: grid;
    grid-template-columns: 150px 1fr;
    align-items: start;
    gap: 1.5rem;
  }

  .card img {
    height: 120px;
    border-radius: 8px;
  }
}

/* 容器宽度 ≥ 600px 时优化排版 */
@container card-container (min-width: 600px) {
  .card {
    grid-template-columns: 200px 1fr;
    gap: 2rem;
    padding: 1.5rem;
  }

  .card img {
    height: 150px;
  }

  .card h3 {
    font-size: 1.5rem;
    margin-bottom: 0.75rem;
  }

  .card button {
    padding: 1rem 2rem;
    font-size: 1rem;
  }
}

/* 容器宽度 ≥ 800px 时大屏优化 */
@container card-container (min-width: 800px) {
  .card {
    grid-template-columns: 250px 1fr;
    padding: 2rem;
  }

  .card img {
    height: 180px;
  }

  .card h3 {
    font-size: 1.75rem;
  }
}
```

:::
::::

## 容器类型详解

`container-type` 属性定义了容器的监控维度：

| 类型 | 描述 | 适用场景 |
|------|------|----------|
| `inline-size` | 监控内联方向尺寸（通常是宽度） | ==最常用=={.success}，性能最佳 |
| `size` | 监控宽高两个维度 | 需要高度响应的特殊情况 |
| `normal` | 不监控尺寸，仅用于样式查询 | 样式查询场景 |

:::warning 重要提醒
使用 `container-type: size` 时要特别小心，因为它会阻止容器根据内容调整大小，可能导致布局问题。==大多数情况下推荐使用 `inline-size`=={.tip}。
:::

## 容器查询长度单位

容器查询引入了一套新的相对单位，专门用于容器上下文：

```css title="容器查询单位使用"
@container (min-width: 400px) {
  .responsive-element {
    /* 使用容器宽度百分比 */
    font-size: calc(1rem + 1cqw);
    padding: 2cqi; /* 内联方向的2% */
    margin: 1cqb;  /* 块级方向的1% */
  }
}
```

可用的容器查询单位：

* `cqw` - 容器宽度的1%
* `cqh` - 容器高度的1%
* `cqi` - 内联尺寸的1%
* `cqb` - 块级尺寸的1%
* `cqmin` - 较小尺寸的1%
* `cqmax` - 较大尺寸的1%

## 高级特性

### 1. 多容器嵌套查询

```css title="多容器查询"
/* 查询最近的父级容器 */
@container (min-width: 300px) {
  .component {
    /* 样式 */
  }
}

/* 查询特定命名容器 */
@container sidebar (min-width: 500px) {
  .widget {
    /* 样式 */
  }
}

/* 组合查询 */
@container (min-width: 400px) and (max-width: 800px) {
  .component {
    /* 中等尺寸样式 */
  }
}
```

### 2. 样式查询（实验性功能）

样式查询允许基于容器的样式值（目前主要是自定义属性）进行条件渲染：

```css title="样式查询示例"
.product-card-container {
  container-type: inline-size;
}

/* 基于自定义属性的样式查询 */
@container style(--status: new) {
  .product-badge::after {
    content: "新品";
    background: #28a745;
  }
}

@container style(--status: low-stock) {
  .product-badge::after {
    content: "库存紧张";
    background: #ffc107;
  }
}
```

## 浏览器兼容性与降级方案

### 浏览器支持情况

@[caniuse](mdn-css_at-rules_container)

### 渐进增强策略

```css title="兼容性处理"
/* 基础样式（所有浏览器） */
.card {
  display: block;
  padding: 1rem;
  margin: 1rem 0;
}

/* 容器查询增强（仅支持浏览器生效） */
@supports (container-type: inline-size) {
  .card-container {
    container-type: inline-size;
  }

  @container (min-width: 400px) {
    .card {
      display: grid;
      grid-template-columns: 1fr 2fr;
    }
  }
}

/* 备用媒体查询方案 */
@media (min-width: 768px) {
  .card {
    display: grid;
    grid-template-columns: 1fr 2fr;
  }
}
```

## 性能优化建议

:::important 性能提示

* **优先使用 `inline-size`**：比 `size` 性能更好
* **避免深层嵌套**：建议容器查询嵌套不超过3层
* **使用 CSS Containment**：优化渲染性能
* **限制查询触发频率**：避免过于频繁的布局重计算
  :::

```css title="性能优化示例"
.optimized-container {
  container-type: inline-size;
  contain: layout style; /* 启用布局和样式 containment */
}
```

## 实际应用场景

容器查询特别适合以下场景：

1. **自适应侧边栏组件**
2. **动态网格布局系统**
3. **响应式数据表格**
4. **自适应导航菜单**
5. **卡片组件的多形态展示**
6. **仪表盘小部件**
7. **多列布局内容流**

## 最佳实践总结

1. **移动端优先**：从最小尺寸开始设计，逐步增强
2. **语义化命名**：为容器使用有意义的名称
3. **渐进增强**：确保不支持时的基本功能
4. **性能意识**：避免不必要的复杂查询
5. **测试驱动**：在不同容器尺寸下全面测试

容器查询标志着 CSS 响应式设计的重大进步，它为组件化开发提供了前所未有的灵活性。虽然需要一些时间来适应新的思维模式，但一旦掌握，你将能够创建出真正智能、自适应的用户界面。

## 参考

* [MDN 容器查询文档](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_containment/Container_queries)
* [Chrome 开发者文档：样式查询](https://developer.chrome.com/docs/css-ui/style-queries?hl=zh-cn)
* [Container Queries 规范](https://www.w3.org/TR/css-contain-3/)

---

---
url: /article/rdx1yx85/index.md
---
如果你和大模型聊过天（比如 GPT-4），你可能特别佩服它那种信手拈来的知识和妙语连珠的能力。但说实话，你可能也坑过——它会正儿八经地瞎扯（我们叫它“幻觉”），或压根不知道昨天发生了啥新闻。

这就像是你有个极其博学的“神经病最强大脑”，但他的记忆最后更新时间定格在好几年前。

那么问题来了，有没有办法让这颗脑袋不仅能查内存，还能实时联网查外部资料？特别是能访问我们自己的私人数据？

有没有这么一把钥匙？有，它就是 **RAG**，全名 **Retrieval-Augmented Generation**，翻译过来就是“检索增强生成”。

## 一、说人话，RAG 到底是啥？为啥这么重要？

你可以把 RAG 理解成给大模型配了个 “贴身外挂+图书馆管理员”：

> 它让 LLM（也就是那些大模型）不再只能靠自己的静态知识输出内容，而是允许它去一个“指定的知识库”里开卷考试！

比如你问：

```txt
“AI 最近出啥新鲜事了？”
```

普通 LLM 会说：

```txt
“抱歉啦，我学到的知识截止到 2024 年秋天，实在不清楚你讲的是不是今天的新闻。”
```

人家是真的不知道。

**RAG 的出现，就是来解决两个痛点：**

1. **知识会过期**：LLM 学的知识一旦训练完就“封印”了。
2. **你私人的东西它看不到**：公司内部文档、个人笔记它无从知晓。

而 RAG 是这么做的：

```txt
“你问，等一下，我去查手册。”
```

这就意味着你的 AI 不再只是个背书的学霸，而是一个可以现场翻资料的“活字典+智能分析师”。

## 二、RAG 的核心原理：三步走，不复杂

用一句话总结 RAG 就是：

:::tip 先查资料，再生成答案。
:::

整个流程拆开一看其实非常清晰：

### 🧾 第一步：索引阶段（Indexing）——先准备好你的资料库

这部分是在回答用户提问前就已经搞好的。

想象你要做个《哈利波特》问答机器人：

1. **加载文档**：把整本书或者网页资源读进来。
2. **切割文档**：太大了不好处理，要分成一段一段的“chunks”。
3. **向量化处理**：每段都被转换为数学向量（这就是所谓的 Embedding）。
4. **存进数据库**：用这些向量建立一张“知识地图”，保存到类似 FAISS、Chroma 这样的向量数据库中。

这步做完，你的“图书室 + 搜索引擎”就已经建好了。

### 🔍 第二步：检索阶段（Retrieval）——用户问问题时去快速查找

假设你现在问 AI：

```txt
“火焰杯大赛里魔法部派谁来看哈利？”
```

系统这时候会：

1. 把你这句话向量化；
2. 在刚才打造的那个“知识地图”中搜索最匹配的几个段落；
3. 把这些相关段落抓出来作为“参考资料”。

于是你在这一阶段已经拿到了和问题最贴切的内容。

### 💬 第三步：增强与生成阶段（Augmented Generation）——带着参考资料一起来生成结果

最后一步，才是真正的“创作”：

1. 把你原始问题和刚查到的数据打包成一段提示（Prompt）；
2. 交给大模型（如 GPT、Llama 等）进行“打分并整合生成”。

比如：

```bash
请根据以下内容做出解释：
【背景信息】
- 在火焰杯期间，魔法部派遣了一支强制执行队维持赛场秩序，由巴格曼担任总指挥。
【用户问题】
火焰杯比赛中魔法部支持了哪些措施？
```

最终输出就会告诉你：魔法部安排了强制执行队、任命巴格曼为负责人……

这就像是做了场高质量的“开卷考试”。

## 三、动手实战一下？教你怎么搭个 RAG 应用玩一玩

我们用 [LangChain](https://python.langchain.com/docs/get_started/introduction) 搭一个小型的“网页情报助手”。

### 🔧 准备工作——先安装工具

```bash
pip install langchain langchain-openai langchain-community faiss-cpu beautifulsoup4
```

几个组件它们分别干嘛你知道就行：

* LangChain：串联流程
* WebBaseLoader：抓网页 ↓ 页面 → 文本
* recursiveCharacterTextSplitter：自动分句+切块
* OpenAIEmbeddings + FAISS：生成 + 保存向量库
* ChatOpenAI：驱动聊天的 guy

然后设好 API KEY，通常这样：

```bash
export OPENAI_API_KEY='xxx'
```

### 🧾 Step 1：加载网页并切块

```python
from langchain_community.document_loaders import WebBaseLoader
from langchain_text_splitters import RecursiveCharacterTextSplitter

loader = WebBaseLoader("https://your-target-page.com")
docs = loader.load()

text_splitter = RecursiveCharacterTextSplitter(chunk_size=500, chunk_overlap=0)
splits = text_splitter.split_documents(docs)
print(f"已切出 {len(splits)} 个小块。")
```

### 📦 Step 2：向量化存储

```python
from langchain_openai import OpenAIEmbeddings
from langchain_community.vectorstores import FAISS

embedding = OpenAIEmbeddings()
vectorstore = FAISS.from_documents(documents=splits, embedding=embedding)
print("✅ 向量库创建成功")
```

### ⚡️ Step 3：构建问答链

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain.chains import create_retrieval_chain
from langchain.chains.combine_documents import create_stuff_documents_chain

llm = ChatOpenAI(model="gpt-3.5-turbo")
retriever = vectorstore.as_retriever()

prompt = ChatPromptTemplate.from_template("""
Answer the question using only the provided context:
<context>
{context}
</context>
Question: {input}
""")

document_chain = create_stuff_documents_chain(llm, prompt)
retrieval_chain = create_retrieval_chain(retriever, document_chain)

# 最后调用一下看看
response = retrieval_chain.invoke({"input": "What did the article say about RAG?"})
print("\n---Answer---\n", response["answer"])
```

这样你就做出了一个小小的基于实时网页内容的 QA bot！

## 四、RAG 的优势和小烦恼

### ✅ 它的好处太明显了

* **能防幻觉你知道吧？**
  答案基于真的信息，而不是大模型随便编。
* **旧数据也能“续命”**
  你不需要反复训练模型，只要更新外部数据库就行。
* **私密内容用得上**
  公司机密？内部 Wiki？它就只从这里头查，其他人谁也看不见。
* **成本可控**
  不用继续烧 GPU 微调模型，维护个知识库快多了。

### ⚠️ 当然也有挑战

* **查得准才是关键**
  查错了或者查不到，直接 GG。
* **多文档整合麻烦**
  文档彼此矛盾怎么办？AI 怎么知道谁说的是真的？
* **大库检索太慢？**
  如果文档有百万数量级，光查也要几秒……太影响体验。

## 五、未来：更高阶玩法在哪？

其实今天我们聊的算是“标准版 RAG”，现在已经有不少进化版本，比如：

| 类型                    | 核心升级点                                |
| ----------------------- | ----------------------------------------- |
| Hybrid RAG              | 结合关键词检索 + 语义相似度（提升查准率） |
| Query Rewriting/Routing | 先改写问题，再分发给不同类型的知识集合    |
| MemoRAG                 | 加上了长期记忆，记住以前对话中的信息      |
| GraphRAG                | 把知识结构图化处理，适合逻辑推理          |

::: tip 提一句
现在很多头部企业在搭建的所谓的 AI Agent 系统背后，基本都藏着一套定制化的 RAG 流程。你以为它秒回那么专业？它其实只是查书太快了 😄
:::

## 六、结语

总而言之，**RAG 是目前把 LLM 变得实际可落地的重要桥梁之一**。

它不仅让机器“看得见真实世界的数据”，还允许它在生成响应的过程中灵活调用它们——不再瞎猜，而是有理有据、即插即用。

未来不管你是做客服系统、法律助手、写作助理，还是你想训练自己专属的知识库，RAG 都是一个绕不开的技术选择。

**推荐你动手试试，别光看文章，代码敲起来才能掌握真本领～**

## 参考资料

* [LangChain 官网文档](https://python.langchain.com/docs/get_started/introduction)
* [FAISS 官网介绍](https://github.com/facebookresearch/faiss)
* [OpenAI API 文档](https://platform.openai.com/docs/introduction)
* [HuggingFace RAG 介绍](https://huggingface.co/docs/transformers/model_doc/rag)
* [原始论文：Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks](https://arxiv.org/abs/2005.11401)

---

---
url: /article/s8udp6vp/index.md
---
# <!DOCTYPE> 文档类型声明
Web世界中，随着历史的发展，技术的迭代，发展出了许多不同的文档，只有了解文档的类型，浏览器才能正确的解析渲染文档。

HTML也有多个不同的版本，只有完全明白页面使用的是哪个确切的HTML版本，浏览器才能完全正确的显示出HTML页面。

## 定义

`<!DOCTYPE>` 标签是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器，它应该使用什么样的文档类型定义（DTD）来解析文档。

## 作用

声明文档的解析类型 （document.compatMode），避免浏览器的怪异模式。

**document.compatMode:**

* `BackCompat`: 怪异模式，浏览器使用自己的怪异模式解析渲染页面。
* `CSS1Compat`: 标准模式，浏览器使用W3C的标准解析渲染页面。

## 使用

在文档的首行进行声明。必须位于 html标签之前。

`<!DOCTYPE>` 声明不是HTML标签，它是指示浏览器关于页面使用哪个HTML版本的指令。

> 如果页面没有 DOCTYPE 声明，那么默认是 怪异模式，为了确保浏览器按预期渲染页面，必须进行DOCTYPE声明。

### 常用的DOCTYPE声明

一般情况下，默认使用以下声明即可。

```html
<!doctype html>
<html></html>
```

## 一般DOCTYPE声明列表

### html5

```html
<!doctype html>
```

### HTML 4.01 Strict

该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
```

### HTML 4.01 Transitional

该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
```

### HTML 4.01 Frameset

该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">
```

### XHTML 1.0 Strict

该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
```

### XHTML 1.0 Transitional

该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" " http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
```

### XHTML 1.0 Frameset

该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
```

### XHTML 1.1

该 DTD 等同于 XHTML 1.0 Strict，但允许添加模型（例如提供对东亚语系的 ruby 支持）。

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
```

---

---
url: /article/snkdmwsz/index.md
---
# 内容安全策略(CSP)
内容安全策略（`Content-Security-Policy`），简称 `CSP`。是一种 计算机安全标准。

主要目标是 减少和报告XSS攻击、数据注入攻击等。这些攻击手段的主要目的是盗取网站数据、网站内容污染、散发恶意软件等。

几乎所有现在浏览器都支持 `CSP`， 对于不支持的浏览器，则会忽略 `CSP`。

## XSS攻击

XSS攻击是一种常见的、危害极大的网络攻击手段。它利用浏览器对从服务器获取的内容的信任，
通过站点的 `script` 脚本、内联脚本、外部导入资源等方式进行注入攻击。
恶意脚本在受害者浏览器中执行，以达成其目的。

## CSP

`CSP` 通过 **有效域名**，即 **浏览器认可的可执行脚本的有效来源** ，使 服务器管理者有能力消除或减少 XSS 攻击所以来的载体。
支持 `CSP` 的浏览器，仅会执行从白名单域名加载的脚本文件，忽略其他所有脚本，包括内联脚本和 HTML 事件处理属性。

## 制定策略

`CSP` 通过 声明 HTTP 头部字段 `Content-Security-Policy` 来启用和配置策略：

```
Content-Security-Policy: policy;
Content-Security-Policy: policy; policy;
```

参数 `[policy]` 是一个包含了描述 各种CSP策略指令的字符串。

## 策略指令

### default-src

为其他CSP指令提供备选项，如果其他指令不存在，用户代理会查找并应用该值，如果其他指令有配置值，那么则不会应用 default-src的值。

default-src 策略允许指定一个或多个值：

```
Content-Security-Policy: default-src <source>;
Content-Security-Policy: default-src <source> <source>;
```

### script-src

脚本内容安全策略指令，包括限制 外部资源、内联脚本、eval函数。

```
Content-Security-Policy: script-src <source>
```

### style-src

CSS文件内容安全策略指令，包括限制 内联样式表、通过`<link>` 引入的css文件、样式中通过 `@import` 导入的css文件、
元素的 `style` 属性、 `style.cssText` 属性、以及 `el.setAttribute('style', '')`

```
Content-Security-Policy: style-src <source>
```

### img-src

图片资源内容安全策略指令， 限制通过 `<img>` 加载的图片资源

```
Content-Security-Policy: img-src <source>
```

### media-src

媒体资源内容安全策略指令，限制通过 `<audio>`、`<video>`、`<track>` 加载的媒体资源

```
Content-Security-Policy: media-src <source>
```

### frame-src

iframe内容安全策略指令，限制`<iframe>` 加载的页面资源

### 其他指令

* `manifest-src` 限制 manifest 资源（通过`<link>`引入的 manifest文件）
* `worker-src` 限制 `worker`资源，包括 `Worker`、`SharedWorker` 、`ServiceWorker`
* `child-src` 限制 `web worker`、`<frame>` 、`<iframe>`
* `connect-src` 限制允许通过脚本接口加载的链接地址，包括：`<a>`、`Fetch`、`XMLHttpRequest`、`WebSocket`、`EventSource`
* `font-src` 限制 `@font-face` 加载字体的有效源规则。
* `object-src` 限制 `<object>`、`<embed>`、`<applet>`

### 指令`<source>`有效值

* `<host-source>`

  以域名或者 IP 地址表示的主机名，外加可选的 URL 协议名（URL scheme）以及端口号。
  支持前置通配符（星号 '\*'），可以将通配符应用于站点地址、端口中，如应用于端口，则表示允许使用该域名下的所有端口。

  * **example.com:443** 匹配 example.com 上 443 端口访问
  * **<https://example.com>** 匹配使用了 http: 的 example.com 的访问
  * **\*.example.com** 匹配 example.com 下的所有子域名的访问

* `<scheme-source>`

  协议名如'http:' 或者 'https:'。必须带有冒号，不要有单引号。

* `'self'`

  指向与要保护的文件所在的源，包括相同的 URL scheme 与端口号。必须有单引号。

* `'unsafe-inline'`

  允许使用内联资源，例如内联 `<script>` 元素（javascript: URL）、内联事件处理器以及内联 `<style>` 元素。必须有单引号。

* `'unsafe-eval'`

  允许使用 eval() 以及相似的函数来从字符串创建代码。必须有单引号。

* `'none'`

  不允许任何内容。 必须有单引号。

* `'nonce-<base64 值>'`

  特定使用一次性加密内联脚本的白名单。服务器必须在每一次传输政策时生成唯一的一次性值。否则将存在绕过资源政策的可能。

* `<hash-source>`

  使用 sha256、sha384 或 sha512 编码过的内联脚本或样式。其由用短划线分隔的两部分组成：用于创建哈希的加密算法，以及脚本或样式 base64 编码的哈希值。当生成哈希值的时候，不要包含 `<script>` 或 `<style>` 标签，同时注意字母大小写与空格——包括首尾空格——都是会影响生成的结果的。

  ```
  Content-Security-Policy: default-src sha256-abcdef;
  ```

* `'strict-dynamic'`

  strict-dynamic 指定对于含有标记脚本 (通过附加一个随机数或散列) 的信任，应该传播到由该脚本加载的所有脚本。与此同时，任何白名单以及源表达式例如 'self' 或者 'unsafe-inline' 都会被忽略。

## 启用CSP

启用CSP，可以在 HTTP服务器中，新增 Header 字段：
如，在nginx中：

```nginx
http {
  # ...more
  server {
    # ...more
    location / {
      index index.html;
      Content-Security-Policy default-src 'self';
      # ...more
    }
  }
}
```

也可以在 html 文件中 添加 `<meta>` 标签

```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self';" />
```

## 示例

### 示例1

默认只允许加载本站资源

```
Content-Security-Policy: default-src 'self';
```

### 示例2

默认只允许加载本站资源，但允许任意来源图片资源

```
Content-Security-Policy: default-src 'self'; img-src *;
```

### 示例3

默认只允许加载本站资源，允许 script资源、css资源、图片资源从指定cdn域名加载

```
Content-Security-Policy: default-src 'self'; script-src 'self' https://cdn.example.com; style-src  'self' https://cdn.example.com; img-src 'self' https://cdn.example.com;
```

### 示例4

阻止所有 iframe 窗口，允许本站加载其他资源

```
Content-Security-Policy: default-src 'self'; frame-src 'none';
```

### 示例5

执行特定 nonce 的内联脚本：

```
Content-Security-Policy: script-src 'nonce-abcdef' 'self';
```

只有在`<script>`标签内带有特定 `nonce` 值的脚本才允许执行：

```html
<script nonce="abcdef" src="example.js"></script>
```

### 示例6

Hash 值相符的脚本才能执行：

```
Content-Security-Policy: script-src 'sha256-qznLcsROx4GACP2dm0UCKCzCG+HiZ1guq6ZZDob/Tng='
```

该hash值必须是 script 标签内容的 sha256 值，代码才能执行：

```html
<script>
  alert('Hello, world.')
</script>
```

## 违例报告

启用 CSP 后，默认情况下，违例报告不会发送。我们可以通过配置 `report-uri` 策略指令，并提供至少一个URI地址去递交报告。

```
Content-Security-Policy: default-src 'self'; report-uri http://report.example.com/csp;
```

### 违例报告示例

违例报告将以 JSON 对象的数据结构进行递交：

```json
{
  "csp-report": {
    "document-uri": "http://example.com/index.html", // 发生违规的文档的 URI
    "referrer": "", // 违规发生处的文档引用（地址）
    "blocked-uri": "http://example.com/css/style.css", // 被 CSP 阻止的资源 URI。
    "violated-directive": "style-src cdn.example.com", // 违反的策略名称。
    // 在 Content-Security-Policy HTTP 头部中指明的原始策略。
    "original-policy": "default-src 'none'; style-src cdn.example.com; report-uri /_/csp-reports"
  }
}
```

当服务器接收到 违例报告，可以通过分析报告内容，来进行自定义的处理。

---

---
url: /article/tz7ncicn/index.md
---
# 1px解决方案
在日常移动端前端应用开发中，经常遇到一个问题就是 1px的线在移动端 Retina屏下的渲染并未达到预期。以下总几种不同场景下的 1px解决方案。

## 背景及原因

首先，需要明确的一个概念是， CSS的 `pixels` 并不完全等价于 设备的 `pixels`。
当我们假定设备的 `pixels` 为标准的`pixels` 宽度。这些pixels决定了设备的分辨率。
在默认情况下， PC设备上用户未进行缩放操作（即zoom缩放为100%时）, CSS的`pixels`与设备的`pixels`重叠，
当用户进行了缩放操作时，假设用户缩放了200%，那么 124px的CSS`pixels`实际占用了248设备`pixels`。

但我们开发时，通常设备的`pixels`对我们毫无用处，前端只需要关注CSS的`pixels`，浏览器会根据用户缩放自动处理CSS的pixels是被伸展还是收缩。

但在移动端设备中，由于设备的宽度较小，导致了可显示的内容要少得多。浏览器或者缩放变小，导致内容无法阅读，或者通过拖动来浏览未被显示的内容。这导致了原本适合于PC设备的CSS布局，放到了移动端，变得十分丑陋。

为了解决这个问题，移动端设备的厂商的通常做法是，让viewport更宽（这里的viewport指的是设备的视窗，它决定了HTML标签的宽度表现，继而影响其他的元素）。

移动端的 viewport 被分为了 虚拟的 viewport 和 布局的 viewport：

* `visual viewport`： 虚拟viewport
* `layout viewport`： 布局viewport

![viewport](/images/viewport.jpg)

两者的概念， 可以想象 `layout viewport` 为一张不可改变大小和角度的图片，但它被一层蒙板挡住了， `visual viewport` 是一个蒙板上我们可以观察到 这张图片的窗口。我们可以通过这个窗口观察到 图片的部分内容。并且可以对这个窗口进行拖动或缩放，进而观察到图片的完整内容。

在这里，`visual viewport` 相当于 移动端设备的屏幕，用户的 缩放和拖动操作，反馈到 `layout viewport` ,则是相对的变成 `layout viewport` 被 拖动和缩放。

而通常我们关注的 CSS`pixels`，通常是按照 `layout viewport`来定义的，所以会比`visual viewport` 宽很多。而 `<html>`元素的宽度继承于`layout viewport`。这可以保证你的网站的UI可以在移动端设备和桌面设备表现一致。

但是 `layout viewport`的宽度有多宽，不同的设备，不同的浏览器各有不同。如 iPhone 的Safari 使用的是 980px。

但是在移动端的交互中，我们并不期望 网站的内容是被缩放的，需要让用户进行缩放和拖动。 所以通常我们会在 html文件的head中，进行一个 meta声明。

```html
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
```

即强制设置了`layout viewport` 等于 设备宽度， 设置了缩放为100%，并且用户无法进行缩放操作。这样做的好处是我们可以以一种期望的方式进行设计UI和交互。

但在前面，我们介绍了， CSS的`pixels`并不等价于设备的`pixels`。
通常在移动端设备，我们可以通过 `window.devicePixelRatio` 查看当前设备的CSS`pixels`和设备`pixels`的比例，
如 `window.devicePixelRatio` 值为 2时， 表示 1个CSS`pixels`的宽度占用2个设备`pixels`，即实际占用了 2x2 的设备`pixels`。

这也是导致了 `1px`的线，在移动设备上的渲染，看起来会比实际上的 `1px`更粗的原因。

知道了问题的背景，和产生的原因，那么只需要让 `1px`的 CSS`pixels`的表现，接近于或者贴合 `1px`的设备`pixels`, 那么就可以解决这个问题了。

## 解决方案

如何让 `1px`的 CSS`pixels`的表现，接近于或者贴合 `1px`的设备`pixels`。这个问题需要具体场景具体分析。

### border-width: 0.5px

一种最简单的，且适合各种场景的方案，就是使用 `0.5px` 的值代替 `1px` 的值。 但这个方案有一个兼容问题，现代浏览器并不全都支持该值的。

可以先检查是否支持 `0.5px`，然后在 根元素上添加一个 类，进行使用。

```js
if (window.devicePixelRatio && devicePixelRatio >= 2) {
  let testElem = document.createElement('div')
  testElem.style.border = '.5px solid transparent'
  document.body.appendChild(testElem)
  if (testElem.offsetHeight === 1) {
    document.querySelector('html').classList.add('hairlines')
  }
  document.body.removeChild(testElem)
}
```

```css
div {
  border: 1px solid #bbb;
}

.hairlines div {
  border-width: 0.5px;
}
```

这种方案的好处是简单，能够适配所有场景，但是从兼容性上看，iOS7及之前的版本、Android设备等，均不支持`0.5px`的渲染。

### 伪类 + transform缩放

该方法是是利用 元素的伪类进行线的渲染。

比如 利用 `::before` 或者 `::after`, 画一条上边框的线

```css
.hairlines {
  position: relative;
}
.hairlines::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  display: block;
  width: 100%;
  height: 1px;
  background-color: #000;
  transform: scaleY(0.5);
  transform-origin: 0 0;
}
```

比如，利用 `::before` 或者 `::after`, 画一个线框：

```css
.hairlines {
  position: relative;
}
.hairlines::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  box-sizing: border-box;
  display: block;
  width: 200%;
  height: 200%;
  border: 1px solid #000;
  transform: scale(0.5);
  transform-origin: 0 0;
}
```

该方案的好处同样能都适配多数场景，并且支持圆角的情况。
但缺点在于由于对元素本身设置了`position`，以及使用了伪类，但另一个交互需要使用到被占用的属性时，需要分情况处理问题。

### border-image 图片

使用 border-image-slice 对边框图片进行偏移。

该方案的方法，比如处理 x轴方向的线时， 需要准备 一张2px高的图片，根据显示是上边框，还是下边框，如上边框，则该图片的 上一半1px为对应的颜色的先，下一半为透明。

*line.png* ![1px-lines.png](/images/1px-lines.png)

```css
div {
  border-top: 1px transparent;
  border-image: url(line.png) 2 0 0 0 repeat;
}
```

同理，处理其他方向的边框类似方法。

该方法的缺点是 如果改变颜色，或者有不同颜色的线，需要准备多张图片。

优先是适合多数的场景，且不对元素本身做出影响文档流的改动。

### SVG

由于CSS也支持 SVG 作为 image 资源使用，且SVG是矢量图片，能够相比于使用jpg、png格式的图片获得更好的保真。
可以配合 CSS 的 `background-image` 或者 `border-image` 满足不同场景的需要。

建议此方案配合 CSS 预渲染，如`stylus/sass/less` 进行使用， 也可使用`postcss` 相关插件使用。

如在 stylus中：

```stylus
// 画一个元素的线框
borderXY(color = #eee, radius = 8px) {
    $r = unit(radius/ 2, '');
    border-radius radius /*px*/
    background-image url(s("data:image/svg+xml;charset=utf-8,<svg xmlns='http://www.w3.org/2000/svg' width='100%' height='100%' viewBox='0 0 200% 200%' preserveAspectRatio='xMidYMid meet'><rect fill='rgba(0,0,0,0)' width='100%' height='100%' stroke-width='1' stroke='%s' rx='%s' ry='%s'/></svg>", color, $r, $r))
    background-repeat no-repeat
    background-position 0 0
    background-size 100% 100%
}

// 画一个元素的 上下边框
borderX(color = #eee) {
    border 0
    border-top: 1px solid color; /*no*/
    border-bottom: 1px solid color; /*no*/
    border-image: url(s("data:image/svg+xml;charset=utf-8,<svg xmlns='http://www.w3.org/2000/svg' height='200' width='100'><line x1='0' y1='25' x2='100' y2='25' stroke='%s' style='stroke-width:50'/><line x1='0' y1='75' x2='100' y2='75' style='stroke:transparent;stroke-width:50'/><line x1='0' y1='125' x2='100' y2='125' style='stroke:transparent;stroke-width:50'/><line x1='0' y1='175' x2='100' y2='175' stroke='%s' style='stroke-width:50'/></svg>", color, color)) 100 0 100 0 stretch;
}

// 画一个元素的 左右边框
borderY(color = #eee) {
    border 0
    border-left: 1px solid color; /*no*/
    border-right: 1px solid color; /*no*/
    border-image: url(s("data:image/svg+xml;charset=utf-8,<svg xmlns='http://www.w3.org/2000/svg' height='100' width='200'><line x1='25' y1='0' x2='25' y2='100' stroke='%s' style='stroke-width:50'/><line x1='75' y1='0' x2='75' y2='100' style='stroke:transparent;stroke-width:50'/><line x1='125' y1='0' x2='125' y2='100' style='stroke:transparent;stroke-width:50'/><line x1='175' y1='0' x2='175' y2='100' stroke='%s' style='stroke-width:50'/></svg>", color, color)) 0 100 0 100 stretch;
}

// 画一个元素的上边框
borderTop(color = #eee) {
    border 0
    border-top: 1px solid color; /*no*/
    border-image: url(s("data:image/svg+xml;charset=utf-8,<svg xmlns='http://www.w3.org/2000/svg' height='100' width='100'><line x1='0' y1='25' x2='100' y2='25' stroke='%s' style='stroke-width:50'/><line x1='0' y1='75' x2='100' y2='75' style='stroke:transparent;stroke-width:50'/></svg>", color)) 100 0 0 0 stretch;
}

// 画一个元素的下边框
borderBottom(color = #eee) {
    border 0
    border-bottom: 1px solid color; /*no*/ // 设置border 0后，如果color设置为transparent，则该边框会变成透明
    border-image: url(s("data:image/svg+xml;charset=utf-8,<svg xmlns='http://www.w3.org/2000/svg' height='100' width='100'><line x1='0' y1='25' x2='100' y2='25' style='stroke:transparent;stroke-width:50'/><line x1='0' y1='75' x2='100' y2='75' stroke='%s' style='stroke-width:50'/></svg>", color)) 0 0 100 0 stretch;
}

// 画一个元素的左边框
borderLeft(color = #eee) {
    border 0
    border-left: 1px solid color; /*no*/
    border-image: url(s("data:image/svg+xml;charset=utf-8,<svg xmlns='http://www.w3.org/2000/svg' height='100' width='100'><line x1='25' y1='0' x2='25' y2='100' stroke='%s' style='stroke-width:50'/><line x1='75' y1='0' x2='75' y2='100' style='stroke:transparent;stroke-width:50'/></svg>", color)) 0 0 0 100 stretch;
}
// 画一个元素的右边框
borderRight(color = #eee) {
    border 0
    border-right: 1px solid color; /*no*/
    border-image: url(s("data:image/svg+xml;charset=utf-8,<svg xmlns='http://www.w3.org/2000/svg' height='100' width='100'><line x1='25' y1='0' x2='25' y2='100' style='stroke:transparent;stroke-width:50'/><line x1='75' y1='0' x2='75' y2='100' stroke='%s' style='stroke-width:50'/></svg>", color)) 0 100 0 0 stretch;
}

div {
    borderXY()
}
```

如果是使用 `postcss` ，可以使用安装插件 [postcss-write-svg](https://github.com/csstools/postcss-write-svg)，配合使用

```css
@svg square {
  @rect {
    fill: var(--color, black);
    width: var(--size);
    height: var(--size);
  }
}

.example {
  background: svg(square param(--color green) param(--size 100%)) center / cover;
}
```

使用SVG的优点是，支持调整线的颜色，支持设置圆角，可以根据场景不同，选择 `background-image` 或者 `border-image` 满足绝大多数的场景。

### background-image + jpg/png 图片

该做法是使用一张该元素的多倍的背景图，进行线的渲染。

该做法一般不推荐。

### 背景渐变

该方案不推荐

### box-shadow

该方案不推荐

---

---
url: /article/uocv0xza/index.md
---
# React 架构演进探析 —— 从栈式协调到Fiber架构
## 前言

在探讨 React 内部机制时，经常提及一个关键转折点：**React 16 引入了Fiber架构**。这引发了一系列核心问题：何为 Fiber 架构？它所取代的原有架构是什么？React 团队引入 Fiber 架构的根本动因何在？

本文旨在系统解析Fiber架构的核心概念与设计思想，揭示其如何解决历史架构的瓶颈。深入的技术细节（如具体调度算法、优先级机制）将在后续专题文章中探讨。

**前置知识：** 深入理解 **Virtual DOM (虚拟DOM)** 是掌握React协调（Reconciliation）机制的基础。

## 栈式协调器（Stack Reconciler）

在Fiber架构诞生前，React的核心更新机制依赖于 **栈式协调器（Stack Reconciler）** 。

其核心在于通过 **递归深度优先遍历** 的方式对比新旧虚拟DOM树（Virtual DOM Tree），并计算最小更新操作（diff算法）。

```mermaid
graph LR
    A[更新开始] --> B[递归遍历VDOM]
    B --> C[深度优先遍历]
    C --> D[同步执行diff]
    D --> E[阻塞主线程]
    E --> F[页面卡顿]
    F --> G[更新结束]
```

以下是一个简化的虚拟DOM树结构示例，栈式协调器正是递归遍历此类结构：

```js
const tree = {
  type: 'div',
  props: {
    id: 'list',
    children: [
      {
        type: 'ul',
        props: {
          children: [
            {
              type: 'li',
              props: {
                children: 'apple'
              }
            },
            // ... 其他子节点
          ]
        }
      }
    ]
  }
}
```

### 主要特性与局限性

1. **同步不可中断（Synchronous & Uninterruptible）**：
   * 更新流程一旦启动（即开始递归遍历与 diff 计算），必须 **连续执行直至完成** 。
   * 无法将庞大的更新任务拆分为小单元，也无法在执行过程中响应更高优先级的任务。

2. **性能瓶颈（Performance Bottlenecks）**：
   * 虽然 Virtual DOM 操作在 JavaScript 层面执行，相比直接操作真实 DOM 已是显著优化，但在处理**大型应用、深层嵌套组件树或复杂数据结构**时，递归遍历和 diff 计算仍可能消耗大量主线程（Main Thread）时间。
   * 长时间占用主线程会导致 **页面渲染卡顿（Jank）**、**交互响应延迟（Input Lag）**，严重损害用户体验（User Experience, UX）。

3. **缺乏任务优先级（Absence of Task Prioritization）**：
   * 所有更新任务均按生成顺序 **同步、无差别执行** 。
   * 当低优先级任务（如后台数据拉取后的UI更新）正在进行时，高优先级任务（如用户输入、动画）必须等待，导致 **高优先级交互无法得到即时响应** （例如，用户输入框输入时，毫秒级的延迟即可被感知为卡顿，而数据加载指示器更新延迟几秒可能尚可接受）。

### 核心瓶颈

栈式协调器主要面临两类影响UX的核心瓶颈：

1. **CPU瓶颈**：
   * **本质**：应用的计算复杂度（Virtual DOM diff、组件渲染逻辑）超出了单次事件循环（Event Loop）中主线程的处理能力上限。
   * **表现**：长时间、同步的JavaScript执行阻塞主线程，导致UI渲染与用户交互停滞。这是栈式架构最直接的性能痛点。

2. **I/O瓶颈**：
   * **本质**：网络请求延迟等I/O操作耗时是客观存在的物理限制。
   * **前端优化目标**：在I/O等待期间，主线程应保持响应能力，优先处理用户可感知的交互；同时，需根据任务来源（用户交互 vs. 后台数据）**区分更新优先级**，确保高优先级任务不被低优先级任务阻塞。栈式架构对此无能为力。

## Fiber架构

Fiber 架构是 React 为解决栈式协调器瓶颈而设计的全新协调引擎。

其核心思想是将 **同步不可中断的更新过程** 重构为 **异步可中断、可恢复且具备优先级调度能力** 的机制。

以下阐述其关键概念：

### Fiber节点（Fiber Node）

```mermaid
graph LR
    A[Fiber节点] --> B[child]
    A --> C[sibling]
    A --> D[return]
    B --> E[子节点]
    C --> F[兄弟节点]
    D --> G[父节点]

    style A fill:#f9f,stroke:#333
    style B fill:#bbf,stroke:#333
    style C fill:#bfb,stroke:#333
    style D fill:#fbb,stroke:#333
```

* **本质**：Fiber节点是Fiber架构下 **工作单元（Work Unit）** 的抽象，也是虚拟DOM节点在Fiber架构中的具体实现形式。

* **核心创新：链表数据结构**：与栈式协调器基于递归树不同，Fiber 节点通过 **显式链表指针** （`child`, `sibling`, `return`）组织成一颗**Fiber树**。这种结构赋予了遍历过程 **可暂停、可恢复、可回溯** 的能力。

* **结构示意**：

  * `child`: 指向当前节点的 **第一个子Fiber节点**。
  * `sibling`: 指向当前节点的 **下一个兄弟Fiber节点**。
  * `return`: 指向当前节点的 **父Fiber节点** （完成当前节点工作后需返回的节点）。

* **Fiber节点对象（源码简化版，附关键注释）**：

  ```ts
  function FiberNode(
    tag: WorkTag, // 节点类型标识：FunctionComponent, ClassComponent, HostRoot(根), HostComponent(DOM元素)等
    pendingProps: mixed, // 从新更新中接收到的、待处理的props
    key: null | string, // React元素的key，用于列表diff优化
    mode: TypeOfMode, // 渲染模式标志位（如ConcurrentMode, StrictMode）
  ) {
    // 实例标识与关联
    this.tag = tag
    this.key = key
    this.elementType = null // 创建该元素的函数/类或DOM标签名 (e.g., 'div', MyComponent)
    this.type = null // 与elementType类似，但对于懒加载组件可能不同
    this.stateNode = null // 关联的类组件实例、Host组件(DOM节点) 或 FiberRoot

    // Fiber树链表指针 (核心数据结构)
    this.return = null // 指向父Fiber节点
    this.child = null // 指向第一个子Fiber节点
    this.sibling = null // 指向下一个兄弟Fiber节点
    this.index = 0 // 在父节点children中的索引

    this.ref = null // ref引用

    // Props 与 State 管理
    this.pendingProps = pendingProps // 新传入的props
    this.memoizedProps = null // 上次渲染使用的props
    this.updateQueue = null // 状态更新、回调函数的队列
    this.memoizedState = null // 上次渲染产生的state (hooks链表等)
    this.dependencies = null // contexts, events订阅等依赖

    this.mode = mode // 渲染模式

    // 副作用 (Effects) 标记
    this.flags = NoFlags // 标记该Fiber节点需要进行的操作(Placement, Update, Deletion等)
    this.subtreeFlags = NoFlags // 子树中存在的副作用标记 (优化遍历)
    this.deletions = null // 记录待删除的子节点 (用于安全卸载)

    // 优先级与调度相关 (Lane 模型)
    this.lanes = NoLanes // 该Fiber上待处理的更新优先级 (lanes)
    this.childLanes = NoLanes // 子树中存在的最高优先级 (优化子树的跳过)

    // 双缓冲技术关键指针
    this.alternate = null // 指向current树或workInProgress树中的对应节点

    // 性能分析(Profiler)相关属性 (开发/分析构建下启用)
    if (enableProfilerTimer) { /* ... */ }
    // 开发模式调试属性
    if (__DEV__) { /* ... */ }
  }
  ```

### 调度器（Scheduler）、协调器（Reconciler）、渲染器（Renderer）

```mermaid
flowchart TB
    S[Scheduler] --> |调度任务| R[Reconciler]
    R --> |生成副作用列表| D[Renderer]
    D --> |更新宿主环境| H[DOM/Native]

    subgraph 核心流程
        direction LR
        R --> |可中断遍历| F[Fiber树]
        F --> |时间切片| T[主线程控制]
    end

    U[用户交互] --> |高优先级| S
    N[网络响应] --> |低优先级| S
```

React Fiber 架构将渲染流程清晰地划分为三个协同工作的层级：

* **调度器（Scheduler）**：

  * **职责**：作为 React 16+ 新增的核心模块，负责 **任务调度**。
    它管理一个任务队列，根据任务的 **优先级**
    （如：`Immediate` - 用户输入、`UserBlocking` - 交互反馈、`Normal` - UI更新、`Low` - 数据分析、`Idle` - 非必要任务）决定任务的执行顺序。
  * **解决关键问题**：直接应对 **I/O瓶颈优化需求** 和 **高优先级任务抢占需求** 。确保用户交互（高优先级）能及时打断并插队正在进行的低优先级渲染任务（如大数据列表更新），极大提升应用响应度（Responsiveness）。
  * **机制**：通常利用浏览器的`requestIdleCallback`(或polyfill/shim)在浏览器空闲期执行低优先级任务，并实现任务的中断与恢复。

* **协调器（Reconciler） - 运行于Fiber架构之上**：

  * **职责**：执行核心的 **diff算法** 。它接收更新请求，在内存中操作 **工作树（workInProgress tree）** ，对比新旧Fiber树（或根据状态变化生成新树），计算出 **副作用列表（Effect List）** - 即描述哪些节点需要被插入、更新或删除。
  * **关键特性**：得益于Fiber节点的链表结构，协调过程是 **可中断的异步过程** 。协调器与调度器紧密配合，根据调度器分配的优先级和时间片进行工作。

* **渲染器（Renderer）** (如 ReactDOM, React Native)：

  * **职责**：**平台特异性渲染**。接收协调器产生的副作用列表，将其 **安全、高效地应用到真实的宿主环境（如浏览器DOM或原生移动视图）** 上，完成最终的UI更新。
  * **关注点分离**：Renderer不关心如何计算更新，只负责执行更新命令。这使得React核心协调逻辑可以跨平台复用。

### 时间切片（Time Slicing）

```mermaid
gantt
    title React时间切片机制执行流程（单位：毫秒）
    dateFormat  X
    axisFormat %L
    section 帧1 (16.6ms)
    JS任务单元A : crit, a1, 0, 4
    JS任务单元B : a2, after a1, 4
    浏览器渲染阶段 : active, b1, after a2, 5
    空闲时段 : done, b2, after b1, 3.6

    section 帧2 (16.6ms)
    JS任务单元C : crit, c1, after b2, 5
    用户输入处理 : active, c2, after c1, 3
    JS任务单元D : c3, after c2, 4
    浏览器渲染阶段 : active, c4, after c3, 4.6
```

* **核心思想**：将原本可能长时间阻塞主线程的大型更新任务，**分解成多个小的、有限时的工作单元**。
* **实现方式**：调度器与协调器协同工作。协调器在遍历处理Fiber节点时，会检查当前帧剩余时间（通过调度器提供的能力）。如果一个工作单元执行时间过长或超过了分配的帧时间（如5ms），协调器会暂停当前工作，将控制权交还给浏览器，让其处理更紧急的任务（如绘制、用户输入）。
* **价值**：有效避免JavaScript长时间独占主线程，保证浏览器有 **足够的时间进行渲染（Rendering）和响应用户输入（Input Handling）**，从而维持界面的 **流畅性（Fluency）** 和 **响应性（Responsiveness）**。这是解决**CPU瓶颈**的核心手段之一。

### 双重缓冲（Double Buffering）

```mermaid
graph LR
    C[Current Tree] --> |屏幕当前显示| D[真实DOM]
    W[WorkInProgress Tree] --> |内存中构建| V[新虚拟DOM]

    C -->|克隆| W
    W -->|提交完成| C
    C -.->|alternate指针| W

    style C fill:#e6f7ff
    style W fill:#f6ffed
    style D stroke:#ff7875
    style V stroke:#52c41a
```

* **技术类比**：借鉴图形学中的双重缓冲技术，避免画面撕裂。

* **在Fiber中的实现**：React在内存中同时维护两棵Fiber树：

  * **当前树（Current Tree）**：对应屏幕上当前显示的UI状态。Fiber节点的`stateNode`指向真实的DOM节点。
  * **工作树（Work-In-Progress Tree, WIP Tree）**：正在后台构建的、反映下一次更新后UI状态的树。构建过程不会直接影响当前显示的UI。

* **工作流程**：

  1. 更新开始时，协调器基于当前树克隆（或创建）出工作树。
  2. 所有diff计算和状态更新都在工作树上进行。
  3. 当工作树完整构建完成（或达到可提交状态），且当前无更高优先级任务时，Renderer将 **原子性地（Atomically）** 将工作树的更新应用到真实DOM上。此过程称为 **提交（Commit）**。
  4. 提交完成后，工作树即成为新的当前树。旧的当前树节点可能被回收或作为下次更新的备用（Alternate）。

* **优势**：

  * **非破坏性更新**：更新计算过程不影响当前显示，确保UI稳定性。
  * **快速回滚**：若更新过程中有更高优先级任务介入，可直接丢弃未完成的工作树，避免显示中间的不一致状态。
  * **并发模式基础**：是实现异步渲染（Concurrent Rendering）的关键机制。

## 结语

Fiber架构通过引入 **Fiber节点（链表结构）**、**任务调度器（Scheduler）**、**时间切片（Time Slicing）** 和 **双重缓冲（Double Buffering）** 等核心机制，成功将React的协调过程从 **同步不可中断** 转变为 **异步可中断且具备优先级调度能力**。

这一变革从根本上解决了栈式协调器面临的 **CPU瓶颈**（长时间任务阻塞主线程）与 **I/O瓶颈优化需求**（优先级调度），为React应用的 **流畅性、响应性** 奠定了坚实基础。理解这些基础概念是深入探索React Concurrent Features（并发特性）如`useTransition`、`useDeferredValue`以及Suspense流式渲染等高级能力的前提。

---

---
url: /article/ur80anlr/index.md
---
# React 原理解析：Diff 算法机制与优化策略
::: info React 的 Diff 算法是其高性能渲染的核心保障，本文将从原理到实现剖析这一关键机制。
:::

## Diff 算法：React 高效渲染的基石

在 React 框架中，**Diff 算法**扮演着至关重要的角色，它决定了在组件状态或属性变更时，React 如何高效地更新 DOM 结构。

其核心功能是在构建 **workInProgress Fiber Tree** 时，智能复用 **current Fiber Tree** 中对应的 FiberNode。

### 核心定位

当组件状态或属性发生变化时，React 需要精确识别需要更新的 DOM 部分。Diff 算法通过以下方式实现这一目标：

```mermaid
flowchart TD
    A[组件状态/属性变化] --> B[生成新JSX对象]
    B --> C[Diff算法对比]
    D[Current Fiber Tree] --> C
    C --> E[生成WorkInProgress Fiber Tree]
    E --> F[DOM更新]
```

**JSX对象**（类组件 render 方法的返回值或函数组件的执行结果）包含描述 DOM 节点的关键信息。
Diff 算法的本质就是对比 **current Fiber Tree** 和 **JSX 对象**，生成 **workInProgress Fiber Tree**。

## 核心策略

### 1. 分层同级比较

React 将 DOM 树分解为多个层级，**只比较同一层级的节点**，避免跨层级比较带来的复杂度爆炸。
同级节点按照**从左到右的顺序**进行对比。

```mermaid
graph TD
    A[Root] --> B[Level 1]
    A --> C[Level 1]
    B --> D[Level 2]
    B --> E[Level 2]
    C --> F[Level 2]
    C --> G[Level 2]
```

### 2. 元素类型对比

当节点类型发生变化时，React 会销毁旧树并创建新树：

```jsx
// 更新前
<div>
  <Button />
</div>
```

```jsx
// 更新后 - 元素类型改变
<div>
  <Input />
</div>
```

### 3. Key 属性的关键作用

Key 是 React 中标识节点唯一性的核心机制，帮助 React 在 Diff 过程中**精准识别节点**：

```jsx
// 更新前
<div>
  <p key="a">a</p>
  <span key="b">b</span>
</div>
```

```jsx
// 更新后
<div>
  <span key="b">b</span>
  <p key="a">a</p>
</div>
```

**关键机制**：当使用 key 时，React 能识别节点只是位置变化而非元素类型改变，从而**复用现有节点**而非重建整个子树。

## 实现机制

### 核心函数：reconcileChildFibers

Diff 算法在 React 源码中通过 `reconcileChildFibers` 函数实现，其核心逻辑如下：

```ts
function reconcileChildFibers(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  newChild: any
): Fiber | null {
  // 处理对象类型的新子元素
  if (typeof newChild === 'object' && newChild !== null) {
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE:
        return placeSingleChild(
          reconcileSingleElement(returnFiber, currentFirstChild, newChild)
        )
      // 处理其他类型...
    }

    // 处理数组类型
    if (isArray(newChild)) {
      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild)
    }

    // 处理迭代器类型
    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild)
    }
  }

  // 处理文本节点
  if ((typeof newChild === 'string' && newChild !== '') || typeof newChild === 'number') {
    return placeSingleChild(
      reconcileSingleTextNode(returnFiber, currentFirstChild, `${newChild}`)
    )
  }

  // 处理删除操作
  return deleteRemainingChildren(returnFiber, currentFirstChild)
}
```

## 两轮遍历流程

### 第一轮遍历：可复用节点处理

```mermaid
flowchart TD
    A[开始遍历] --> B{Key & Type相同?}
    B -->|是| C[复用节点]
    B -->|Key相同 Type不同| D[创建新节点<br>标记旧节点删除]
    B -->|Key不同| E[结束第一轮遍历]
    C --> F[继续遍历下一个节点]
    D --> F
    E --> G[进入第二轮遍历]
```

**示例场景**：

```html
<!-- 更新前 -->
<ul>
  <li key="a">a</li>
  <li key="b">b</li>
  <li key="c">c</li>
  <li key="d">d</li>
</ul>

<!-- 更新后 -->
<ul>
  <li key="a">a</li>
  <li key="b">b</li>
  <li key="c2">c2</li> <!-- key改变 -->
  <li key="d">d</li>
</ul>
```

**处理流程**：

1. 处理 key="a"：key 和 type 相同 → **复用**
2. 处理 key="b"：key 和 type 相同 → **复用**
3. 处理 key="c" vs key="c2"：key 不同 → **结束第一轮遍历**

### 第二轮遍历：处理剩余节点

将剩余旧 FiberNode 存入 Map：

```javascript
const existingChildren = mapRemainingChildren(returnFiber, oldFiber)
```

遍历剩余 JSX 元素：

* 从 Map 中查找可复用节点
* 找到则移动复用
* 未找到则创建新节点
* 遍历结束后 Map 中剩余节点标记删除

**复杂场景示例**：

```html
<!-- 更新前 -->
<ul>
  <li key="a">a</li>
  <li key="b">b</li>
  <li key="c">c</li>
  <li key="d">d</li>
  <li key="e">e</li>
</ul>

<!-- 更新后 -->
<ul>
  <li key="a">a</li>
  <li key="b">b</li>
  <li key="e">e</li> <!-- 位置移动 -->
  <li key="f">f</li> <!-- 新增 -->
  <li key="c">c</li> <!-- 位置移动 -->
</ul>
```

**处理流程**：

1. 第一轮遍历处理前两个节点后中断
2. 剩余旧节点存入 Map：`{c, d, e}`
3. 遍历新节点：
   * key="e"：在 Map 中找到 → **移动复用**
   * key="f"：未找到 → **新建**
   * key="c"：在 Map 中找到 → **移动复用**
4. Map 中剩余 key="d" → **标记删除**

## 优化策略

### 1. 时间复杂度优化

React 的 Diff 算法时间复杂度为 $O(n)$，远优于传统树比较算法的 $O(n³)$，这得益于：

* 分层同级比较策略
* Key 机制快速定位节点

### 2. Key 的最佳实践

```jsx
// 推荐：稳定唯一标识
{ items.map(item => (
  <Item key={item.id} data={item} />
)) }

// 避免：数组索引作为key
{ items.map((item, index) => (
  <Item key={index} data={item} /> // 可能导致渲染问题
)) }
```

### 3. 批量更新机制

React 将多个状态变更合并为单次渲染，减少 DOM 操作次数：

```mermaid
sequenceDiagram
    participant User as 用户交互
    participant React as React
    participant DOM as 真实DOM

    User->>React: 触发多个状态更新
    React->>React: 批量处理更新
    React->>React: 执行Diff算法
    React->>DOM: 单次DOM更新
```

### 4. 节点类型优化

对于相同类型的组件，React 会递归比较子节点；对于不同类型的组件，则直接替换整棵子树。

## 总结与最佳实践

React 的 Diff 算法通过以下机制保证高性能：

1. **分层比较策略**：避免跨层级比较
2. **Key 机制**：精确识别节点变化
3. **两轮遍历**：平衡效率与准确性
4. **批量更新**：减少 DOM 操作次数

**开发建议**：

* 为列表项提供稳定唯一的 key
* 避免在渲染过程中改变组件类型
* 保持组件树结构稳定
* 使用 React.memo/PureComponent 减少不必要渲染

理解 Diff 算法的工作原理，有助于开发者编写高性能 React 应用，避免常见的性能陷阱，充分发挥 React 的渲染效能优势。

---

---
url: /article/vhpmovsm/index.md
---
# 移动端适配方案
## 背景

移动端设备由于不同品牌、不同机型，不同设备中，使用的不同浏览器，带来的一系列适配问题。在这些设备中，如何实现展示效果、交互的一致性，是比较头疼的问题。

## 发展

早期的适配方案五花八门。

在2015年双十一左右， 阿里前端团队 AmFe 分享了 `flexiable` 的移动端适配方案，在往后的几年中， `flexiable`成为了主流的移动端适配方案在各大移动端应用中使用。

随着技术的发展，CSS3的`viewport`越来越得到了更多的设备支持， 逐渐的可以直接使用 viewport 来作为 移动端适配方案，2017年左右开始步入开发者的视野。

后来 AmFe 宣布 推荐使用 `viewport` 方案代替 `flexible`，`viewport`方案逐渐成为主流适配方案。

## lib-flexible 方案介绍

### viewport

viewport 即浏览器窗口，在移动端设备中，viewport太窄，为了更好的服务于CSS，提供了 `visual viewport` 和 `layout viewport`

### 物理像素（physical pixel）

物理像素即设备像素，是显示设备中最微小的物理部件。

### 设备独立像素（density-independent pixel）

设备独立像素也称为 密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素，然后由系统转换为物理像素

### CSS像素（CSS pixel）

css像素是一个抽象单位，主要用在浏览器上，用来精确的度量Web页面上的内容。

一般情况下， CSS像素称为设备无关的像素，简称 `DIPs`

### 屏幕密度

屏幕密度是指一个设备表面上存在的像素密度，它通常已每英寸有多少像素来计算（`PPI`）

### 设备像素比（device pixel ratio）

简称 `DPR`，定义了物理像素和设备独立像素的对应关系

```html
设备像素比 = 物理像素 / 设备独立像素
```

### 简要说明

`flexiable` 通过hack手段，根据设备的dpr值相应改变 `<meta>` 标签中viewport的值：

```html
<!-- dpr = 1-->
<meta name="viewport" content="initial-scale=scale,maximum-scale=scale,minimum-scale=scale,user-scalable=no" />
<!-- dpr = 2-->
<meta name="viewport" content="initial-scale=0.5,maximum-scale=0.5,minimum-scale=0.5,user-scalable=no" />
<!-- dpr = 3-->
<meta
  name="viewport"
  content="initial-scale=0.3333333333,maximum-scale=0.3333333333,minimum-scale=0.3333333333,user-scalable=no"
/>
```

从而让页面达到缩放的效果，变相的实现页面的适配功能。

主要的思想：

1. 根据 `dpr`的值来修改 `viewport` 实现1px的线
2. 根据 `dpr`的值来修改 `html`的 `font-size`，从而使用rem实现等比缩放
3. 使用 `hack` 手段用`rem`模拟 `vw`的特性

### 使用

> github: <https://github.com/amfe/lib-flexible>

> px-to-rem: <https://www.npmjs.com/package/postcss-pxtorem>

## px-to-viewport 适配方案

`Flexiable` 是通过javascript 模拟 `vw`的特性，到今天未知，`vw`已经得到了众多浏览器的支持，完全可以考虑直接将`vw`单位用于我们的适配布局中。

在css level3 中，定义了和 viewport相关的四个单位，分别是 `vw`、`vh`、`vmin`、`vmax`。

* `vw`: viewport width 简写，1vw等于 `window.innerWidth` 的 `1%`
* `vh`： viewport height简写，1vh 等于 `window.innerHeight` 的 `1%`
* `vmin`：vmin的值是当前 vw和vh中较小值
* `vmax`： vmax的值是当前 vw和vh中较大值

![viewport](/images/viewport.png)

在一张 750px的设计稿中， 100vw=750px， 1vw=7.5px，通过公式即可转换px单位为vw单位，实现适配。

可以通过 postcss-px-to-viewport 来帮助实现自动转换

> github: [https://github.com/evrone/postcss-px-to-viewport](https://github.com/evrone/postcss-px-to-viewport/blob/master/README_CN.md)

### 适用vw适配页面的场景

1. 容器适配
2. 文本适配
3. 大于1px的边框、圆角、阴影
4. 内边距和外边距

---

---
url: /article/vpqgx0t7/index.md
---
# 谈谈微前端
微前端 是最近比较新兴的一个话题，它不具体指某个库某个框架，而是一个思想，一种概念，运用这种思想，
根据自身的需求，从而实现适用于自身的 微前端 。

> 本文根据最近我在公司内部举行的 微前端技术解决方案 分享而写。
> 提供的 微前端方案 也应用于公司内部的项目，并取得了良好的反馈，获得广泛好评。
> 本文不具体谈如何实现微前端，仅讲述微前端的概念，期望能够通过本文理解微前端。

## 前言

微前端 目前在行业内是一个新兴的思想。

诞生这个思想的背景是，在公司内部，常常会有一类项目，这类项目很大、很重，
涉及的业务内容多而杂，还涉及了跨部门共同维护，积累的庞大的技术债 等各种问题。
这类项目在维护成本上、部署成本上等，都会花费巨大的开销，前端开发人员对于维护这类项目，苦不堪言，
急需找到解决这类问题的方案。

基于这样的背景下，开始探讨 解决方案的可行性， 微前端 正是基于此 开始慢慢 出现在人们的视野中。

## 现状

### 发展历程

在 Web 的发展初期，还没有所谓的前端的概念，网页的内容也相对简单，大多仅涉及文字图片信息的展示和表单内容，
这些工作可能网站负责人自己就包办了。
然后微软推出了 **Ajax** 技术，引起了网页的技术变革，从此网站开始具备了动态交互性，
能够在网页发起请求动态获取服务器的内容，这丰富了网页的可交互性，网页的开发也从UI界面和表单交互，进一步增加了
数据和逻辑的开发，前端也慢慢的被划分一个相对独立的职能。

而伴随着 nodejs 的出现，以及 angular 的出现，还包括 vue/react 等库，以及建立在 nodejs 上的生态，
包括grunt、gulp、webpack 等工具的诞生，前端进入了一个喷井式爆发的时期，也是我们所处的时期。前端越来越专业化，
包含的技术内容越来越丰富，依托于nodejs 以及众多的技术框架等，向着工程化进一步的发展，前端项目也越来越大。

### 浮现的问题

你是否维护过一个可能有着四五年以上历史的项目？是否维护过一个糅杂了各种各样的库的项目？
是否维护过一个多个公司部门参与的跨团队联合开发的项目？

对于很多人来说，入职的某个公司，最怕被安排去维护一个这样的项目。因为每一次维护迭代，就如同开盲盒一样，
永远不知道有什么惊喜在等着自己。

对于这类项目，可能存在的问题包括：

* 跨部门，夸团队联合开发，如何沟通？如何协作？
* 业务线多，页面多，如何管理？
* 如何进行代码管理？
* 如何进行分支管理？
* 多部门进行迭代，如何把控版本？
* 存在发布冲突，如何解决？
* 如何进行测试？
* 如何管理公共代码？
* ...

可能改动某一行代码，都会带来意想不到的结果，种种问题的积累，技术债的、业务债的，使得项目越来越臃肿，越来越难以维护。

亟需寻找一种方案，能够解决这些问题。

### iframe嵌入

于是，在大多数时候，我们不得不去选择通过 iframe嵌入 的方式，先把臃肿的项目一点一点的拆开给回各个部门或者团队自行维护，
再提供一个 系统门户应用，用 iframe嵌入 的方式，加上维护一个菜单列表与其他项目入口链接的映射，来糅合成一个 网站应用。

![iframe嵌入](//assets.processon.com/chart_image/630f92445653bb0c5d1040ab.png)

通过 iframe嵌入，在一定程度上，满足了 各部门各团队各业务线 独立开发独立部署的需求，只需要提供对应的页面链接就可以接入到
整个系统中。但也存在着一些问题

#### 安全问题

然而，我们知道， iframe是存在安全问题的，如果攻击者使用 iframe访问一个 未知来源的链接，有可能被注入恶意脚本，从而盗取
系统的隐私信息，这需要我们去严格配置 SCP，以及配置 sandbox，尽可能的保证 iframe 的安全性。

#### 资源加载过多

而由于仅需要提供链接就可以嵌入，那么对于各自的项目来说，灵活度就很高，各个项目可以随意的选择各种技术框架来实现自己的业务，
又或者即使使用了相同的技术框架，但各项目的资源相对独立，对于整个系统而言，需要加载的资源量会十分庞大，
从而导致了页面访问速度变慢，经常会出现页面部分区域白屏等待时间过长等，这也带来了体验问题。

#### 访问地图丢失

由于 iframe 嵌入的站点，独享访问历史记录，与外部的历史记录是相互独立的，即通过浏览器的 前进/回退 按钮来访问历史记录并
不能得到预期的结果，这在一定程度上影响了用户的操作。

## 寻找解决方案

有没有什么其他的方案，来进一步解决这些问题呢？

首先我们明确的知道，单项目管理目前来看不是一个可行的方案，需要在多项目管理上寻求解决方案。

### 多项目公共业务组件

对于多数的大型系统项目而言，大体上都采用以下布局结构：

![微前端-2](//assets.processon.com/chart_image/6311781d079129320755bec5.png)

主体布局结构包括：

* 导航栏 （可选）
* 左侧菜单栏 （可选）
* 内容区域
* 页脚 (可选)

在这种布局结构下，各个业务板块通常通过 导航栏 或者 左侧菜单栏 进行 导航切换，在 内容区域 展示 业务板块。
即，总体上看，对于业务来说，导航栏、左侧菜单栏、页脚，这几个都是可能 共同的，主要的不同点在于 内容区域。

那么我们可以把 共同的部分，如 导航栏、左侧菜单栏、页脚 这几个部分，抽离为公共业务组件，
对于每个业务板块，独立为单独的项目进行开发维护，并在项目中引入这些 公共业务组件。
公共业务组件其中主要负责之一是提供 链接到各个业务板块。

![微前端-3](//assets.processon.com/chart_image/631301e65653bb40f833b613.png)

这种方案具有如下的优点：

* 整体系统根据业务板块拆分为了多个项目；
* 实现了项目的独立性，可独立进行开发、发布；
* 通过在主项目重载渲染，实现类似 **SPA应用** 的访问体验；

但同样也带来了新的问题：

* 公共业务组件

  * 公共业务组件 如何进行管理；
  * 公共业务组件 如何在业务板块项目之间保持同步更新；

以及没有解决的问题：

* 资源加载过多；

  各个业务板块项目重复加载公共业务组件，重复加载各种库资源。

* 项目无法实现统一管理；

### 主项目重载业务项目资源

在上一个方案中，公共业务组件的引入解决了一部分问题，也带来了一部分问题，如何把公共业务组件进行统一管理，并保持一致性？

我们回到 iframe方案，在这个 iframe方案中，有一个主项目用于管理这些 菜单栏、导航栏等。 同样的，可以借鉴这个思路，
也抽象一个主项目，用于管理这些 公共业务组件，然后寻找另一种方式来加载渲染其他的业务板块项目。

我们知道，业务板块的项目，也是通过链接去访问的，而每个链接都对应着一个 html 资源文件，通过加载这个资源，以及HTML内的 css资源、js资源等来渲染页面。那么，我们可以通过解析这个 html资源，然后将得到的 html内容、css文件、js文件，在主项目中加载后渲染到特定的区域，
那么就可以做到在主项目中加载业务板块项目。

![微前端-4](//assets.processon.com/chart_image/6314ea9cf346fb55d89d4e77.png)

在主项目中，实现一个 资源加载器与解析器，通过业务板块项目的访问链接，获取 html资源文件，并解析 html 的内容，包括：

* `<head>` 标签中的 `<title>`, `<link>`, `<script>` 等;
* `<body>` 标签中的 html 内容，`<script>` 等

然后加载 解析得到的 CSS资源、JS资源，将 html内容 插入到 特定的区域中，并进行渲染。
从而呈现完整的网页内容。

这种方案，进一步解决了如下的问题：

* 公共业务组件交由 主项目进行统一管理，直接避免了同步问题；
* 业务板块均在主项目中渲染，提高了用户体验；

然而，也引入了新的问题：

* 业务板块都运行在同一个环境中，多个板块之间切换，加载的资源容易对环境产生污染，
  如污染了某个全局变量、polyfill相互污染等。
* 可能存在 加载资源跨域问题。

但是也拥有了如下的优点：

* 拆分项目，可独立开发和部署；
* 主项目统一管理 公共业务组件，更易于维护；
* 项目间的切换得到体验优化；

当方案思考到了这里，发现，主项目是通过 解析 **链接** 来加载业务板块项目，
而 **链接** 对于现代前端来说，更多的意义是可能是 **路由**。那么我们顺着这个思路，继续优化，

## 新的方案

说起路由，我们很容易想到，像如今的 `react`, `vue`, `angular` 等主流的库/框架， 通过 路由 来实现 `SPA` 应用，
或者说， 通过 **路由分发页面**。

那么，我们可以进一步的扩展这个思路，是否可以通过 **路由分发应用** ？

### 路由

在前端的范畴中，路由指 随着浏览器的地址栏变化，而呈现不同的内容给用户。

通常使用 **hash** 或者 **history API** 实现前端路由。

```js
// hash
;`https://pengzhanbo.com/#route` // history API
;`https://pengzhanbo.com/route`
```

路由进一步细化，通过 `/` ，又可以 划分为 一级路由、二级路由、三级路由... 等多级路由。

在现代的前端框架如 `React` / `Vue` / `Angular` 等，均有通过 路由 实现 SPA应用 的技术方案。
而 SPA应用 就是 **路由分发页面** 。

### 路由分发应用

与 **路由分发页面** 类似，我们也可以通过 **路由分发应用** 。

类似于 主项目重载业务项目资源，通过 实现 路由与业务板块项目的映射关系，
在主项目中通过路由寻找业务板块项目，加载相关资源并渲染在相关区域。

### 主应用与子应用

从这里开始， 我们将 主项目 定位为 主应用， 将各个 业务板块项目 定义为 子应用。
在主应用中实现 子应用加载器，加载器通过 解析路由来获取加载对应的子应用。

**主应用：** 作为独立的项目，整个系统的入口应用，负责统一管理公共业务组件（如 菜单栏、导航栏、页脚等），负责实现子应用加载器，负责实现渲染子应用的容器。

**子应用：** 作为独立的项目，系统的各个业务板块分别独立为单独的项目，单独开发维护与部署。

### 注册子应用

主应用需要通过路由发现子应用，需要建议起 路由与子应用的映射关系，所以需要有一套机制，用于向主应用注册子应用，
并关联相关资源文件等。

```json
[
  {
    "AppName": "Sub Application",
    "route": "/sub-app-route",
    "resource": {
      "js": ["https://example.com/index.js"],
      "css": ["https://example.com/style.css"]
    }
  }
  // more ...
]
```

## 微前端

通过将整个系统拆分为一个个小型的项目，小型项目即为子应用，通过细化，将整个系统细化为一个个微小的应用，
从而实现了降低整个系统的复杂性。
一个小型项目可以是某个部门的业务项目，可以是某个业务项目中的某个板块，也可以是一个单独的页面。

这也是为什么将新的方案称之为 **微前端**。

微前端是指，通过将一个系统，拆分为一个个 微小的独立的子应用，通过主应用聚合为一个完整的系统。
微前端是一个与框架无强关联的概念，可以类比于服务端的微服务，是浏览器端的微服务。

![microfront](//assets.processon.com/chart_image/6318b7297d9c0833ec81b2cd.png)

由于子应用是独立的，理论上是支持使用任意的技术框架进行开发，无论是使用 jQuery开发，还是使用 Vue、React、Angular等。
然而在实际中，对于整个系统而言，技术框架的选择应该保持统一性，以保证整个系统的可维护性。

## 微前端的局限性

微前端的技术方案，更适合于 中大型的项目中使用，而对于小型项目而言，由于本身体量不大，没有必要对整个系统进行进一步的细化，
细化反而增加了项目的复杂度。

而对于中大型项目而言，如果是老系统迁移到微前端的方案，那么不可避免的，还需考虑新旧方案之间的迁移过渡的方案以及规划。
如果老系统中存在应用了多种不同的技术框架，或者同框架的不同版本，由于主应用、所有子应用均运行在同一个浏览器环境中，
不可避免的存在环境污染问题，如全局环境污染，polyfill对于原生对象的多次污染等，还包括CSS的命名污染等问题。
所以如何保证子应用的正确渲染，如何避免环境污染问题，也是亟需解决的问题。

## 微前端的未来

目前来看，微前端主要分为 主应用 和 子应用，在 **微** 上，也仅细化到页面级别，然而，对于微前端而已，还可以进一步的细化，
如，细化到页面的某一个区块，细化到某一个逻辑功能，均可以通过微前端的技术方案，共享到主应用以及子应用中使用。
整个系统愈加化整为零，将复杂度进一步的拆解，细化，令每一块功能、逻辑等都能使用通过某个项目提供，甚至独立的项目进行维护和部署。

微前端是一个与框架无关的概念，但在实现微前端时，如果允许多技术框架共存，所带来的问题的，反而比不使用微前端时所存在的问题，要更难以预料，难以解决。在实际的场景中，最好还是限定在统一的技术框架范畴中，避免由于共存不同的技术框架，而引入更为复杂的问题，

## 结语

微前端是一个相对新兴的技术概念，适用于一些前端场景，但最好是你已经考虑清楚了，微前端是解决你的场景问题的最好方案，否则，除非必要，
无需选择微前端方案。

---

---
url: /article/wo7znd9i/index.md
---
# 从零开始实现最小化的 AI MCP 服务
今天，我们就来聊聊一个日益流行的开放标准——**模型上下文协议（Model Context Protocol，简称 MCP）**，并用 TypeScript 从零开始，构建一个最小但功能齐全的 MCP 服务。

别担心，本文专为初学者打造，我将用最通俗易懂的语言，带你一步步揭开 MCP 的神秘面纱，让你不仅知道它是什么，更能亲手实现它！

:::tip 什么是 MCP？
简单来说，MCP 就像是为大语言模型（LLM）和外部工具、API、数据源之间搭建的一座标准化桥梁。

以前，我们可能需要为每个 AI 应用和外部服务编写大量定制化的“胶水代码”，不仅混乱且难以维护。 MCP 的出现，正是为了统一标准，提供一套通用的“沟通语言”和接口，让 AI 能更顺畅、更安全地调用外部能力。

它采用的是一种客户端-主机-服务器（Client-Host-Server）的架构。 你可以这样理解：

* **主机 (Host)**：比如 VS Code、Claude Desktop 这类我们直接操作的应用。
* **客户端 (Client)**：由主机创建，负责与某一个具体的 MCP 服务进行一对一通信。
* **服务器 (Server)**：这就是我们今天要构建的主角！它封装了具体的工具或数据，等待 AI 调用。

:::

准备好了吗？我们开始吧！

## 准备工作 - 环境搭建

“工欲善其事，必先利其器”。在开始编码前，我们需要先把开发环境搭好。

::::steps

* **初始化项目**
  首先，找一个合适的文件夹，创建新项目，并初始化 `package.json` 文件。

  ```bash
  mkdir my-mcp-server
  cd my-mcp-server
  npm init -y
  ```

* **安装核心依赖**
  我们需要安装 MCP 的 TypeScript SDK、`zod` 和 TypeScript 本身。`@modelcontextprotocol/sdk` 是我们的核心。

  ```bash
  npm install @modelcontextprotocol/sdk zod
  npm install typescript tsx @types/node --save-dev
  ```

  > `zod` 是一个出色的 TypeScript 优先的 schema 校验库，MCP 官方也用它来定义工具的输入输出规范，强烈推荐！ `tsx` 能让我们直接运行 TypeScript 文件，无需手动编译，非常方便。

* **配置 TypeScript**
  在项目根目录创建一个 `tsconfig.json` 文件，这是 TypeScript 的配置文件。

  ```json title="tsconfig.json"
  {
    "compilerOptions": {
      "target": "ES2022",
      "module": "NodeNext",
      "moduleResolution": "NodeNext",
      "strict": true,
      "esModuleInterop": true,
      "outDir": "dist"
    },
    "include": ["src/**/*"]
  }
  ```

* **创建项目结构**
  清晰的目录结构使代码更易于维护。

  :::file-tree

  * my-mcp-server
  * node\_modules
    * src
      * index.ts  # 我们的主入口文件
    * package.json
    * tsconfig.json

  :::

::::

搞定！开发环境已经就绪，我们开始构建服务吧。

## 第一个 MCP 服务 - "Hello World"

我们先从最简单的例子开始，创建一个能返回 "Hello, \[name]!" 的 MCP 服务。

### 1. 初始化服务器

在 `src/index.ts` 文件里，我们引入所需模块，并创建一个 MCP 服务器实例。

```typescript title="src/index.ts"
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp'
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio'
import { z } from 'zod'

// 1. 创建一个 MCP 服务器实例
const server = new McpServer({
  name: 'hello-mcp-server',
  version: '1.0.0',
})

console.log('Hello MCP Server is starting...')

// 后面我们会在这里注册工具...

// 4. 选择通信方式并启动服务
// StdioServerTransport 表示通过标准输入输出进行通信，非常适合本地调试
async function main() {
  const transport = new StdioServerTransport()
  await server.connect(transport)
  console.log('Server connected to transport. Waiting for requests...')
}

main().catch(console.error)
```

### 2. 定义并注册一个“工具”

在 MCP 的世界里，一个具体的功能被称为“工具”(Tool)。 我们的第一个工具是 `sayHello`。

在 `src/index.ts` 中添加如下代码（放在服务器实例创建之后）：

```typescript title="src/index.ts"
// ... (之前的代码)

// 2. 定义工具的输入和输出 schema
const SayHelloInput = z.object({
  name: z.string().describe('The name of the person to greet.'),
})
const SayHelloOutput = z.object({
  message: z.string(),
})

// 3. 注册我们的第一个工具
server.registerTool(
  'sayHello',
  {
    title: 'Say Hello',
    description: 'Generates a friendly greeting to a person.',
    inputSchema: SayHelloInput,
    outputSchema: SayHelloOutput,
  },
  // 这是工具的具体实现逻辑
  async (input) => {
    const greeting = `Hello, ${input.name}! Welcome to the world of MCP.`
    console.log(`Generated greeting: ${greeting}`)

    const output = { message: greeting }

    // 按照 MCP 规范返回内容
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify(output, null, 2),
        },
      ],
      structuredContent: output,
    }
  }
)

// ... (之后的 main 函数)
```

:::info 代码解读

* **McpServer**: 这是 MCP 服务端的核心类，我们通过它来定义服务信息和注册功能。
* **registerTool**: 此方法用于注册一个工具。它需要三个参数：工具的唯一名称、工具的元数据（描述、输入输出规范等）和工具的异步执行函数。
* **Schema 定义**: 我们用 `zod` 定义了清晰的输入 (`name: string`) 和输出 (`message: string`)。这样做的好处是，AI 模型就能清楚地知道调用这个工具需要什么参数，以及会返回什么结果。
* **实现逻辑**: 核心逻辑很简单，只是拼接一个字符串。但请注意返回值的格式，`content` 字段是一个数组，可以包含多种格式（如文本、图片等），`structuredContent` 则是结构化的 JSON 数据，便于程序处理。
* **StdioServerTransport**: MCP 支持多种通信协议，`stdio`（标准输入输出）是最简单的一种，适合本地开发和与 VS Code 等编辑器集成。

:::

### 3. 运行与测试

写好代码后，我们该如何测试呢？MCP 生态提供了一个非常方便的调试工具：**MCP Inspector**。

首先，在 `package.json` 中添加一个启动脚本：

```json title="package.json"
{
  // ...
  "scripts": {
    "start": "tsx src/index.ts"
  }
  // ...
}
```

然后在一个终端中启动我们的服务：

::: npm-to

```bash
npm start
```

:::

你会看到 `Hello MCP Server is starting...` 的输出。

接着，打开**另一个终端**，运行 MCP Inspector：

```bash
npx @modelcontextprotocol/inspector
```

这会在浏览器中打开一个调试界面。选择 "Stdio" 连接方式，然后将我们 `npm start` 的命令填入 "Command" 输入框中，点击 "Connect"。

连接成功后，你就能在 Inspector 里看到我们注册的 `sayHello` 工具了。你可以直接在界面上输入参数进行调用，观察返回结果，是不是非常方便？

## 进阶示例 - 调用外部 API

“Hello World” 只是开胃菜。MCP 强大的地方在于连接真实世界，比如调用一个天气 API。

我们来创建一个 `getWeather` 工具。

### 1. 安装 `axios`

我们需要一个 HTTP 客户端来发送网络请求。这里选用 `axios`。

```bash
npm install axios
```

### 2. 注册 `getWeather` 工具

在 `src/index.ts` 中添加获取天气的工具。

```typescript title="src/index.ts"
import axios from 'axios'
// ... (其他 import)

// ... (hello-mcp-server 的定义)

// ... (sayHello 工具的注册)

// --- 获取天气的工具 ---
const GetWeatherInput = z.object({
  city: z.string().describe('The city name, e.g., Shanghai'),
})

const GetWeatherOutput = z.object({
  city: z.string(),
  temperature: z.number(),
  description: z.string(),
})

server.registerTool(
  'getWeather',
  {
    title: 'Get Weather',
    description: 'Fetches the current weather for a specified city.',
    inputSchema: GetWeatherInput,
    outputSchema: GetWeatherOutput,
  },
  async ({ city }) => {
    try {
      // 注意：这里使用 OpenWeatherMap API，实际使用时请替换 'YOUR_API_KEY'
      const response = await axios.get(`https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=YOUR_API_KEY&units=metric`)

      const weatherData = response.data
      const output = {
        city: weatherData.name,
        temperature: weatherData.main.temp,
        description: weatherData.weather[0].description,
      }

      return {
        content: [{ type: 'text', text: JSON.stringify(output, null, 2) }],
        structuredContent: output,
      }
    }
    catch (error: any) {
      // 错误处理很重要！
      const errorMessage = `Failed to get weather for ${city}: ${error.message}`
      console.error(errorMessage)
      // 同样将错误信息返回给 AI
      return { content: [{ type: 'text', text: errorMessage }] }
    }
  }
)

// ... (main 函数)
```

:::warning 提醒
上面的代码用到了 OpenWeatherMap 的 API，你需要去官网注册并获取一个免费的 `API_KEY` 替换 `YOUR_API_KEY` 才能正常工作。
:::

现在，重新启动服务 (`npm start`)，并刷新 MCP Inspector，你就会看到新的 `getWeather` 工具。试试查询 "Beijing" 的天气，看看会返回什么结果。

## 再进一步 - 多模型协调的思考

我们已经实现了两个独立的工具。但如果一个任务需要多个工具协作完成呢？比如，“查询北京的天气，然后用友好地问候语告诉我今天的天气情况”。

这个任务需要两步：

1. 调用 `getWeather` 工具获取天气数据。
2. 将天气数据作为上下文信息，让 AI 模型生成一段自然语言描述。

这正是 MCP 发挥作用的地方。当一个 AI 客户端（如 VS Code 内的 Copilot）连接到我们的 MCP 服务后，它就能“看到”我们提供的所有工具。当用户提出复杂需求时，AI 模型会自动进行任务拆解 (Task Decomposition)：

1. **AI 分析需求**：识别出需要“查询天气”和“生成问候语”。
2. **选择工具**：发现我们的 MCP 服务提供了 `getWeather` 工具，决定调用它。
3. **执行工具**：向我们的服务发送请求 `getWeather({ city: 'Beijing' })`。
4. **获取结果**：我们的服务返回 `{ "city": "Beijing", "temperature": 25, "description": "sunny" }`。
5. **整合上下文并生成回答**：AI 将上一步的结果作为新的上下文信息，结合原始问题，最终生成回答：“你好！北京今天天气晴朗，温度是 25 摄氏度。祝你拥有愉快的一天！”

> 整个过程对 MCP 服务的开发者而言是透明的。我们只需专注于提供稳定、原子化的工具，而工具的编排和协调则交给了上层的 AI 模型。

这正是 MCP “关注点分离” (Separation of Concerns) 设计思想的体现。

## 总结

恭喜你！到这里，你已经成功构建了一个最小化但包含核心功能的 MCP 服务。我们回顾一下关键点：

1. **MCP 的核心价值**：为 AI 和外部世界提供了一套标准的“连接器”，大大简化了 AI 应用的开发。
2. **核心 SDK**：使用 `@modelcontextprotocol/sdk`，通过 `McpServer` 类来创建服务，并通过 `registerTool` 来暴露能力。
3. **工具 (Tool)**：是 MCP 服务功能的最小单元。一个设计良好的工具应该功能单一、职责明确，并使用 `zod` 定义清晰的输入输出。
4. **通信 (Transport)**：我们使用了 `StdioServerTransport`，它非常适合本地开发和IDE集成。
5. **调试**：`@modelcontextprotocol/inspector` 是我们开发过程中的好伙伴。
6. **可组合性**：我们只需提供独立的工具，复杂的任务编排将由 AI 模型自动完成。

当然，MCP 的世界远不止于此，还包括更复杂的概念如资源 (Resources)、提示 (Prompts)、身份验证、流式 HTTP 传输等。 但今天，你已经迈出了至关重要的一步。

***

**参考资料**：

* [Model Context Protocol 官方文档](https://modelcontextprotocol.io/)
* [MCP TypeScript SDK (GitHub)](https://github.com/modelcontextprotocol/typescript-sdk)
* [VS Code 中使用 MCP 服务](https://code.visualstudio.com/docs/copilot/customization/mcp-servers)

---

---
url: /article/wrp2givr/index.md
---
# 浅谈反爬虫
::: note
初版，待校对。
:::

爬虫 与 反爬虫 是一场持久的攻防战，不仅仅是 商业上的斗争，也是 技术人的斗争，是看不见硝烟的战场。
爬虫不存在一劳永逸的技术手段，反爬虫也难以找到能够杜绝被爬取的防御手段，双方都是在不断地斗争，
进攻者不断变换攻击手段，防御者也不断地针对攻击手段更新防御手段。

爬虫的行为很难被杜绝，反爬虫的大多数措施，都是在不断地增加 爬取 的难度，使得 爬虫的成本不断上升，
直至行为带来的收益低于付出的成本。

本文只 探讨 反爬虫 的一些 技术方案，对一些 涉及到 安全保密 的技术方案，不会给出方案细节和实现方法。

***

## 爬虫

爬虫是一种通过爬取网页内容来获取信息的程序。

在当下，很多的电商类、内容类的网站，一方面承受来自正常的用户访问行为带来的压力，
一方面也承受了来自各种各样爬虫的爬取行为带来的远超用户访问的压力。

不仅耗费了大量的服务器的资源和带宽，还被第三方非法获取了大量具有商业价值的数据，
从而带来巨大的损失。

### 常见的爬虫策略

常见的网页爬虫策略包括以下几种：

#### 宽度优先遍历策略

这是最常见的爬取策略，从起始网页开始，先尽可能多地抓取起始网页所在的主页链接，
然后对这些链接进行宽度优先的遍历，尽可能抓取所有可抓取的网页。

#### 非完全PageRank策略

利用PageRank算法来确定抓取网页的优先级，优先抓取PageRank值高的网页。

#### OPIC策略

该策略考虑了网页的重要性，根据网页的重要性来分配抓取的优先级。

#### 大站优先策略

该策略优先抓取大型网站的网页，因为大型网站通常包含更多的有价值信息。

#### 网页更新策略

该策略根据网页的更新频率来分配抓取优先级，优先抓取更新频繁的网页。

#### 分布式集群爬虫

对于大规模的数据抓取任务，可以使用分布式集群爬虫来进行。该类型爬虫能够同时从多个节点进行数据抓取，提高抓取效率。

除此之外，还有 使用代理IP池、模拟登陆等策略。

### 常见爬取内容的技术方案

爬取网页内容的技术方案有很多种，其中一些常见的方法：

#### HTTP请求库

Python有很多强大的HTTP请求库，如 `requests`、`urllib3` 、`http.client` 等，
这些库可以发送各种类型的HTTP请求，包括 `GET` 、 `POST` 等。

#### 浏览器自动化工具

如 `Selenium`、`Pyppeteer` 等，这些工具可以模拟用户在浏览器中的操作，从而抓取动态网页内容。

#### 代理IP

在爬取网页时，可能会遇到IP被封禁的情况，通过代理IP来避免被封禁。

#### 多线程或多进程

多线程或多进程可以提高爬虫的效率，但需要注意线程安全或进程安全。

#### 分布式爬虫

分布式爬虫可以同时从多个节点进行数据抓取

#### 数据库存储数据

在爬取大量数据时，使用数据库来存储数据，如MySQL、MongoDB等。

#### 缓存技术

使用缓存技术避免重复抓取网页

#### 正则表达式或BeautifulSoup等解析工具

这些工具可以帮助从网页中提取需要的数据。

## 反爬虫

反爬虫 是为了应对 爬虫 而进行的一系列防御措施。

从 爬虫的策略，以及 技术方案 来看，爬虫程序常见的特征包括：

1. 高频访问
2. 抓取 html 内容
3. 抓取 数据接口
4. 模拟用户行为，如借助 Selenium、Pyppeteer 等工具

### 反爬虫策略

基于这些特征，常见的反爬虫策略有：

1. User-Agent + Referer检测
2. 账号及Cookie验证
3. 验证码
4. IP限制频次

然而由于 Selenium、Pyppeteer 等工具的存在，像 User-Agent + Referer 检测 很容易就被绕过。

国内外都存在一些贩卖虚拟手机号的灰色产业，甚至还有一些针对各种企业的账号体系的
`"养号"` 产业，导致 账号和 Cookie 验证 需要更加复杂的策略。

而 IP 限制频次，很容易就能通过 代理IP池 进行绕过，当然，我们也可以 建立 黑名单 IP池 来封禁这些
被识别为 爬虫的IP。

而且现在的 图像识别技术越来越成熟，包括 AI识图 也越来越准确，一些简单的图片噪点验证码早已完全
失去了其作用，成为只会影响用户体验的方案。当然现在也有很多 如 滑动验证码、人脸识别 等方案能够
提供更好的反爬虫保护。

***

以上这些策略，是在 **爬虫触及内容前** 做的防御措施。而如果 爬虫攻破了这些防御措施，那么我们
还可以在 内容上 做防御措施。

## 内容防御

内容防御 是指，在 爬取 内容前，对内容进行一些防御措施。主要从两个方向上进行防御：

1. 让爬虫 `看不到` 内容
2. 让爬虫 `读不到` 内容

### `看不到` 内容

通常来说，对于一个新发布、或 版本更新后 的网页，爬虫以及爬虫的开发者需要重新爬取该网页。
对于爬虫开发者，则需要先查看网页做了哪些更新，然后调整 爬虫程序，再进行爬取。
在这个过程中，爬虫开发者 可能会通过 浏览器，打开 调试控制台 查看 网页源代码、数据接口 等。

为了应对这一行为，我们可以针对 打开 调试控制台 这一行为，根据其特性，或者其行为，进行一些
防御措施。

#### 调试控制台

第一种常见的是， 在源代码中 加入 `debugger` 语句，当打开控制台时，就会进入 调试模式。

我们可以利用 无限循环 来实现 无限调试。

```ts
function bun() {
  setInterval(() => {
    debugger
  }, 50)
}
try {
  bun()
}
catch (err) {}
```

当 打开控制台 时，由于程序被 `debugger` 阻止，无法进行断点调试，网页的请求也看不到。

**无限 `debugger` 反制措施**

无限 `debugger` 通常只能 防止 新手小白 ，但对于有一定经验的 技术人员来说，基本不会起到什么作用。

技术人员可以通过控制台中的 `Deactivate breakpoints` 按钮或者使用快捷键 `Ctrl + F8` 关闭无限 `debugger`；
还可以通过添加 `add script ignore list` 需要忽略执行代码行或文件。

***

于是，又衍生了一些更加复杂的变式：

通过 格式化代码 将 `debugger` 写在一行中，`Deactivate breakpoints` 按钮或者使用快捷键 `Ctrl + F8` 就
无法关闭 `debugger`，但 `add script ignore list` 依然能够阻止 `debugger` 运行。

```ts
function bun() {
  setInterval(() => {
    debugger
  }, 50)
}
try {
  bun()
}
catch (err) {}
```

进一步的，可以通过将 `debugger` 改写成 `Function("debugger")();` 的形式来应对 `add script ignore list`

```ts
function bun() {
  setInterval(() => {
    new Function('debugger')()
  }, 50)
}
try {
  bun()
}
catch (err) {}
```

还可以继续将代码写得更加复杂：

```ts
function bun() {
  setInterval(() => {
    ;(function () {
      return false
    })
      .constructor('debugger')
      .call()
  }, 50)
}
try {
  bun()
}
catch (err) {}
```

再进行 代码加密混淆 等。

#### 检测窗口大小变化

当打开控制台时，如果是 窗口内打开，控制台会吸附在 侧栏，从而引起 浏览器窗口变化。
可以通过检测 外部窗口大小 和 内部窗口大小 的差值，来侧面判断是否打开了控制台。

```ts
if (window.outerHeight - window.innerHeight > 200 || window.outerWidth - window.innerWidth > 200) {
  // 替换网页内容
  document.body.innerHTML = '检测到非法调试,请关闭后刷新重试!'
}
```

当检测到打开控制台后，我们可以直接替换网页的所有内容，或者重定向到一个新的空白窗口。
使之 看不到 正确的内容。

但其缺陷就是，如果 控制台模式是选择 窗口外打开的，并不会引起 浏览器窗口变化。则无法判断是否打开了控制台。

***

我们可以 综合以上两点，形成一个方案：

```ts
function bun() {
  if (window.outerHeight - window.innerHeight > 200 || window.outerWidth - window.innerWidth > 200) {
    // 替换网页内容
    document.body.innerHTML = '检测到非法调试,请关闭后刷新重试!'
  }
  setInterval(() => {
    ;(function () {
      return false
    })
      .constructor('debugger')
      .call()
  }, 50)
}
try {
  bun()
}
catch (err) {}
```

***

但其实认真想一想，基于是否打开控制台 来判断是否有潜在爬虫行为，**虽然有作用，但只有一点点** 。

在 现代浏览器 `Chrome` ，从 `117` 版本开始, 提供了 `Override content` 的功能，它不仅可以在
`Network` 面板中发起 Mock 请求，还可以直接在 `Sources` 面板中，直接 替换当前网页的资源内容。
这意味着，即使我们 在代码中加入了 这些检测，爬虫开发者 完全可以直接在 `Sources` 面板中，直接
修改网页内容，删除掉 这些代码。

再者，还有比如 `Fiddler`、`Charles` 等抓包工具，可以直接抓取到 内容，还包括 伪装 `https` 证书等。

基于 是否打开控制台 的检测 形同虚设。可能带来的唯一收益就是 防新手小白，其负面收益 可能是 进一步
提高了 网站的所有者、维护者自己 的调试、排查成本。

所以是否有这么做的必要，只能是见仁见智。

### `读不到` 内容

当无论如何都不能防止爬虫触及内容，被爬取到网页内容或者数据，还可以继续在内容本身上进行防御。

在内容本身上进行防御，前提是保证正常的用户访问行为呈现到内容应该都是正确的，
再通过其他措施使爬虫行为读取到的内容是不正确的。

在这一方面，不同类型的网站会运用到不同的技术手段。

对于 内容类的网站：

#### 以图片为主要内容的

通常是给 图片添加 **水印** ，水印包括 **可见水印** 和 **隐藏式水印** 。

#### 以文字创作为主要内容的

常见的方法包括， 在 文字内容 中，插入不可见的字符，或者 重新建立 一套 Unicode 字符映射表，
使源码中的字符与网页实际渲染的字符不一致。

但如果 重新建立所有的字符映射表，其工作量将会变得很大，增加了很多不必要的复杂度，所以通常来说，
只需要对 部分关键的内容进行处理。

***

### 字符混淆策略

通过对 关键内容的 字符，采用 一些技术手段进行处理，使得源代码中的 字符与网页实际渲染的字符不一致，
确保用户看到的内容为真实内容，而爬虫获取的内容为包含混淆字符的内容。

#### font-face 字符集

font-face 在 CSS 中被用于定义字体。

如 [`iconfont`](https://www.iconfont.cn/) 中的图标字体。 将关键内容的字符，使用 SVG 进行渲染，整合成一个
字体文件，再通过 `font-face` 定义字体，在网页源代码中，引入该字体库后，使用 `unicode` 编码编写内容，再
渲染为正常的内容。

这种做法，由于关键内容被替换为了 `unicode`，爬虫只能爬取到 `unicode`码，而不是真实的内容，它还需要解析
对应的字体库进行 编码映射，才能获取到真实内容，提高了爬取的复杂度。还可以通过 动态字体库，通过不定期的
更新 字体库的编码映射关系，来增加进一步爬取的复杂度。

#### background-image 拼凑

背景图片的拼凑，一般是运用在一些 关键内容为 数字、字母 的场景上，因为其 字符数量较少，转换为图片一般
不会占用过多的资源，还可以使用 “雪碧图” 合并为一张图片，通过 背景定位 的方式控制显示的内容。

这种方式爬取到的内容只有 一组空的 标签，爬虫还需要进一步的 读取 CSS 、获取图片、定位信息等才能分析获取
内容。

#### 字符穿插

字符穿插，主要是通过在 正常的内容之间，插入不会被渲染的字符，但这些 字符在源代码内容中，是可读取的。

比如， `12234` 之间插入随机的其他 数字：

```html
<span>1</span><span>2</span><span>2</span><span>3</span><span>4</span>
```

插入随机数字

```html
<span>1</span><span>3</span><span>2</span><span>2</span><span>3</span><span>6</span><span>4</span>
```

然后通过 类名、选择器等方式，根据某些规则，将插入的随机数字进行设置为 `display: node` 等隐藏不显示。

这种方式 由于在 正常的内容中插入了正常的内容，如果爬虫不知道规则的话，会误认为获取到了正确的内容，

#### 伪元素隐藏

借助 伪元素 `::before` ， `::after` ，将 关键内容 填充到 CSS 属性 `content` 中。

#### 元素定位穿插

元素定位穿插，是将 正确的内容 进行 打乱重组，然后再通过 定位 的方式调整到 正确的顺序位置上。

#### shadowDOM 隐藏

`shadowDOM`， 通过 `Element.attachShadow()` 方法给指定的元素挂载一个 Shadow DOM，
将 关键内容 写入到 Shadow DOM 中。 由于 Shadow DOM 的 特性，可以指定其 `mode` 为 `false`，
拒绝从 js 外部访问关闭的 shadow root 节点。

即使 爬虫 通过 `Selenium`、`Pyppeteer` 也读取不到内容。缺点就是 `shadowDOM` 的兼容性问题，
可能会导致部分用户也看不到内容。

***

当 爬虫行为 在商业上 带来的收益十分巨大时，就会投入更多的资源去应对反爬虫的措施，做出更有
针对性的爬虫程序。

这一现象特别是在 电商类、平台类 的网站尤为严重。为了打出 价格优势，需要及时的获取 竞争平台
的商品价格，调整自身平台的价格、优惠策略等。包括了 价格监控、价格变动监控、价格预警 等等
一些列措施。

往往当 一方的反爬虫 方案进行技术调整后，另一方的爬虫一旦获取不到内容，就会立即发出邮件、短信等
进行预警通知。双方就形成了一种长时间的持久的互为攻防的拉锯战。

从现状来看，反爬虫 是很难完全实现 防御住爬虫爬取到内容的，而且爬虫 也有各种手段 判断是否
爬取到了正确的内容。

既然杜绝不了，那么除了常规的必要的反爬虫措施之外，给 爬虫 一些 真实内容，又有何不可呢，
然后我们可以在 真实内容中，掺杂上一些不那么真实的内容，又有何不可呢？

---

---
url: /article/wsn3vekb/index.md
---
# JavaScript 进阶 十一： 迭代器和生成器
在 JavaScript 的进阶之路上，迭代器和生成器是两个非常重要且强大的特性。它们不仅改变了我们遍历数据的方式，更为异步编程带来了全新的思路。本文将深入探讨这两个 ES6+ 的核心特性，帮助你掌握现代 JavaScript 开发的关键技能。

## 迭代器（Iterator）

### 什么是迭代器？

迭代器是一个对象，它定义了一个序列，并在终止时可能附带一个返回值。更具体地说，迭代器是通过使用 `next()` 方法实现了**迭代器协议**的对象。

:::info 迭代器协议
迭代器协议要求对象必须实现一个 `next()` 方法，该方法返回包含两个属性的对象：

* `value`：序列中的下一个值
* `done`：如果已经迭代到序列中的最后一个值，则为 `true`
  :::

### 基础示例

```javascript title="基础迭代器示例"
function makeRangeIterator(start = 0, end = Infinity, step = 1) {
  let nextIndex = start
  let iterationCount = 0

  const rangeIterator = {
    next() {
      let result
      if (nextIndex < end) {
        result = { value: nextIndex, done: false }
        nextIndex += step
        iterationCount++
        return result
      }
      return { value: iterationCount, done: true }
    },
  }
  return rangeIterator
}

// 使用迭代器
let it = makeRangeIterator(1, 10, 2)
let result = it.next()
while (!result.done) {
  console.log(result.value) // 1, 3, 5, 7, 9
  result = it.next()
}
console.log(`已迭代序列的大小：${result.value}`) // 5
```

### 迭代器的价值

迭代器的真正价值在于它们可以表示**无限序列**，而数组必须完整分配内存：

```javascript title="无限序列示例"
function* infiniteSequence() {
  let i = 0
  while (true) {
    yield i++
  }
}

const infinite = infiniteSequence()
console.log(infinite.next().value) // 0
console.log(infinite.next().value) // 1
console.log(infinite.next().value) // 2
// 可以无限继续...
```

## 可迭代对象（Iterable）

### 什么是可迭代对象？

若一个对象拥有迭代行为（比如在 `for...of` 中会循环一些值），那么它就是一个可迭代对象。要实现可迭代，对象必须实现 `[Symbol.iterator]()` 方法。

:::tip 内置可迭代对象

* `String`、`Array`、`TypedArray`
* `Map` 和 `Set`
* `arguments` 对象
* DOM NodeList 对象
  :::

### 自定义可迭代对象

```javascript title="自定义可迭代对象"
const myIterable = {
  * [Symbol.iterator]() {
    yield 1
    yield 2
    yield 3
  },
}

// 使用 for...of 遍历
for (let value of myIterable) {
  console.log(value) // 1, 2, 3
}

// 使用展开语法
console.log([...myIterable]) // [1, 2, 3]
```

### 斐波那契数列迭代器

```javascript title="斐波那契数列迭代器"
const fibonacci = {
  [Symbol.iterator]() {
    let pre = 0
    let cur = 1
    return {
      next() {
        [pre, cur] = [cur, pre + cur]
        return { value: cur, done: false }
      }
    }
  }
}

for (let num of fibonacci) {
  if (num > 1000)
    break
  console.log(num) // 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987
}
```

## 生成器（Generator）

### 什么是生成器？

生成器函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。生成器函数使用 `function*` 语法编写。

:::warning 重要特性

* 调用生成器函数不会立即执行，而是返回一个生成器对象
* 生成器对象实现了迭代器协议
* 可以使用 `yield` 关键字暂停函数执行
  :::

### 基础生成器示例

```javascript title="基础生成器"
function* simpleGenerator() {
  yield 'Hello'
  yield 'World'
  yield '!'
}

const generator = simpleGenerator()

console.log(generator.next()) // { value: 'Hello', done: false }
console.log(generator.next()) // { value: 'World', done: false }
console.log(generator.next()) // { value: '!', done: false }
console.log(generator.next()) // { value: undefined, done: true }
```

### 使用生成器重写范围迭代器

```javascript title="生成器版本的范围迭代器"
function* makeRangeIterator(start = 0, end = Infinity, step = 1) {
  let iterationCount = 0
  for (let i = start; i < end; i += step) {
    iterationCount++
    yield i
  }
  return iterationCount
}

const range = makeRangeIterator(1, 10, 2)
for (let value of range) {
  console.log(value) // 1, 3, 5, 7, 9
}
```

## 高级生成器特性

### 双向通信

生成器支持双向通信，可以通过 `next()` 方法向生成器传递值：

```javascript title="双向通信示例"
function* twoWayGenerator() {
  const name = yield 'What is your name?'
  const age = yield `Hello ${name}, how old are you?`
  return `So you are ${age} years old, ${name}!`
}

const gen = twoWayGenerator()

console.log(gen.next().value) // "What is your name?"
console.log(gen.next('Alice').value) // "Hello Alice, how old are you?"
console.log(gen.next(25).value) // "So you are 25 years old, Alice!"
```

### 错误处理

生成器支持错误处理，可以通过 `throw()` 方法向生成器抛出错误：

```javascript title="错误处理示例"
function* errorHandlingGenerator() {
  try {
    yield 'Start'
    yield 'Processing...'
    yield 'End'
  }
  catch (error) {
    yield `Caught error: ${error.message}`
  }
}

const errorGen = errorHandlingGenerator()
console.log(errorGen.next().value) // "Start"
console.log(errorGen.next().value) // "Processing..."
console.log(errorGen.throw(new Error('Something went wrong!')).value)
// "Caught error: Something went wrong!"
```

### yield\* 委托

`yield*` 表达式用于委托给另一个生成器或可迭代对象：

```javascript title="yield* 委托示例"
function* generatorA() {
  yield 'A1'
  yield 'A2'
}

function* generatorB() {
  yield 'B1'
  yield* generatorA()
  yield 'B2'
}

console.log([...generatorB()]) // ['B1', 'A1', 'A2', 'B2']
```

## 实际应用场景

### 1. 异步流程控制

在 async/await 出现之前，生成器是处理异步操作的重要工具：

```javascript title="异步流程控制"
function* asyncFlow() {
  try {
    const user = yield fetchUser()
    const posts = yield fetchUserPosts(user.id)
    const comments = yield fetchPostComments(posts[0].id)
    return { user, posts, comments }
  }
  catch (error) {
    console.error('Flow failed:', error)
  }
}

// 运行器函数
function runGenerator(generator) {
  const iterator = generator()

  function handle(result) {
    if (result.done)
      return Promise.resolve(result.value)

    return Promise.resolve(result.value)
      .then(res => handle(iterator.next(res)))
      .catch(err => handle(iterator.throw(err)))
  }

  try {
    return handle(iterator.next())
  }
  catch (err) {
    return Promise.reject(err)
  }
}

runGenerator(asyncFlow).then(console.log)
```

### 2. 状态机

生成器非常适合实现状态机：

```javascript title="状态机示例"
function* trafficLight() {
  while (true) {
    yield '🔴 Red - Stop'
    yield '🟡 Yellow - Prepare'
    yield '🟢 Green - Go'
    yield '🟡 Yellow - Slow down'
  }
}

const light = trafficLight()
console.log(light.next().value) // "🔴 Red - Stop"
console.log(light.next().value) // "🟡 Yellow - Prepare"
console.log(light.next().value) // "🟢 Green - Go"
```

### 3. 数据流处理

```javascript title="数据流处理"
function* dataProcessor() {
  let data = yield
  while (true) {
    // 处理数据
    data = data.toUpperCase()
    data = yield data
  }
}

const processor = dataProcessor()
processor.next() // 启动生成器

console.log(processor.next('hello').value) // "HELLO"
console.log(processor.next('world').value) // "WORLD"
console.log(processor.next('generator').value) // "GENERATOR"
```

## 性能考虑和最佳实践

### 性能提示

:::caution 性能注意事项

1. **内存使用**：生成器按需计算值，适合处理大数据集
2. **一次性使用**：大多数生成器只能迭代一次
3. **错误处理**：确保正确处理生成器中的异常
   :::

### 最佳实践

:::steps

* **使用场景判断**：在需要惰性求值或处理无限序列时使用生成器
* **错误处理**：在生成器内部使用 try-catch 处理可能的错误
* **资源清理**：使用 `return()` 方法及时清理资源
* **代码可读性**：对于简单的迭代，优先使用内置迭代方法

:::

## 现代 JavaScript 中的迭代器和生成器

### 与 async/await 的关系

虽然 async/await 已经成为异步编程的主流，但生成器仍然是理解异步编程原理的重要基础：

```javascript title="生成器与异步函数对比"
// 生成器方式
function* fetchDataGenerator() {
  const user = yield fetch('/api/user')
  const posts = yield fetch('/api/posts')
  return { user, posts }
}

// async/await 方式
async function fetchDataAsync() {
  const user = await fetch('/api/user')
  const posts = await fetch('/api/posts')
  return { user, posts }
}
```

### 最新特性支持

现代 JavaScript 环境对迭代器和生成器有很好的支持：

```javascript title="环境支持检查"
const supportsGenerators = function* () {}.constructor === Function
const supportsSymbol = typeof Symbol === 'function' && Symbol.iterator

console.log('Generator support:', supportsGenerators)
console.log('Symbol.iterator support:', supportsSymbol)
```

## 总结

迭代器和生成器是 JavaScript 中非常强大的特性，它们：

1. **提供统一的迭代机制**：让不同数据结构可以使用相同的遍历方式
2. **支持惰性求值**：只在需要时计算值，节省内存
3. **简化异步编程**：为 async/await 奠定了基础
4. **增强代码表达能力**：让复杂的状态管理和数据流处理更加清晰

:::important 关键要点

* 迭代器是实现了 `next()` 方法的对象
* 可迭代对象必须实现 `[Symbol.iterator]()` 方法
* 生成器使用 `function*` 声明，通过 `yield` 暂停执行
* 生成器支持双向通信和错误处理
* 在实际项目中，合理使用这些特性可以显著提升代码质量
  :::

掌握迭代器和生成器，你将能够编写更加优雅、高效的 JavaScript 代码，为理解现代前端框架和库的实现原理打下坚实基础。

## 参考

* [MDN 迭代器和生成器指南](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators)
* [ECMAScript 规范中的迭代协议](https://tc39.es/ecma262/#sec-iteration)
* [生成器与协程的关系](https://en.wikipedia.org/wiki/Coroutine)

---

---
url: /article/wu41neza/index.md
---
# 为什么你应该停止使用 enum
## 什么是 enum ？{#what-is-enum}

在 TypeScript 中，`enum` 是一种用于定义一组命名常量的数据类型。它看起来很像其他语言中的枚举，例如 C# 或 Java：

```ts
// 定义一个枚举
enum Status {
  Pending = 'PENDING',
  Fulfilled = 'FULFILLED',
  Rejected = 'REJECTED',
}

// 使用枚举
let current: Status = Status.Pending
console.log(current) // 输出: PENDING
```

枚举被设计为既能作为 ==类型== 使用，也能作为 ==值== 使用，这让它们看起来很方便。
然而，在 TypeScript 项目中，尤其是现代前端开发中，枚举并不是最佳实践。
接下来，我们将深入探讨为什么你应该考虑丢弃 **枚举** ，转向更现代、更轻量级的替代方案。

## 为什么应该停止使用 enum ？{#why-stop-using-enum}

### 运行时开销 {#runtime-overhead}

枚举会生成额外的 JavaScript 代码。
当编译器将 TypeScript 转换为 JavaScript 时，枚举不仅会留下类型声明，还会生成运行时的对象字面量。

```ts
// TypeScript 代码
enum Color {
  Red,
  Green,
  Blue
}
```

```js
// 编译后的 JavaScript
let Color;
(function (Color) {
  Color[Color.Red = 0] = 'Red'
  Color[Color.Green = 1] = 'Green'
  Color[Color.Blue = 2] = 'Blue'
})(Color || (Color = {}))
```

这段代码在运行时占用了内存。对于追求极致性能的移动前端应用来说，这可能是不可忽视的开销。

### 打包体积膨胀 {#bundle-size-increase}

正如上述编译后的代码：

```js
// 编译后的 JavaScript
let Color;
(function (Color) {
  Color[Color.Red = 0] = 'Red'
  Color[Color.Green = 1] = 'Green'
  Color[Color.Blue = 2] = 'Blue'
})(Color || (Color = {}))
```

即使你没有在代码中使用枚举的值，它依然会被打包到最终的 bundle 中。这段代码会增加了几 KB 的体积。

::: warning 在大型框架中，多个枚举会累积成显著的体积负担。
:::

### 与 tree-shaking 不兼容 {#incompatible-with-tree-shaking}

现代打包工具（如 `Webpack`、`Rollup` 或 `Vite`）都支持 ==Tree-shaking== ，即在打包时移除未使用的代码。
然而，TypeScript 枚举却与这一机制存在兼容性问题。

由于枚举既定义了类型又生成了值，即使在代码中只引用了类型，运行时对象也可能被保留，导致 Tree-shaking 失效。

::: tip 解决方案
使用 `const enum` 可以在某些情况下解决问题，但它要求开启 `preserveConstEnums` 选项，并且会牺牲一些开发体验。
:::

一个在 [Stack Overflow 上的热门问题](https://stackoverflow.com/questions/68720866/why-does-webpack-5-include-my-unused-typescript-enum-exports-even-when-tree-sha)
指出：即使使用了 `const enum`，`Webpack 5` 仍然可能包含未使用的枚举导出。

### 不是纯粹的类型 {#not-pure-type}

枚举是一种“双重身份”的结构：它既是一个 ==类型== ，又是一个 ==值== 。
这种模糊的界限在跨模块使用时会导致问题。

```ts
// module-a.ts
enum Status {
  Active = 'active',
  Inactive = 'inactive'
}

// module-b.ts
import { Status } from './module-a'

// 这里 Status 既是类型，也是值
const userStatus: Status = Status.Active
```

这种设计在类型系统中引入了不必要的运行时依赖。
相比之下，联合类型（Union Types）是纯粹的类型，完全不会生成运行时代码。

### 不兼容 ES6+ {#not-compatible-with-es6-plus}

TypeScript `enum` 不是 ECMAScript 标准的一部分。

这意味着它无法被浏览器或 Node.js 原生识别。
当你使用 ES 模块进行开发时，枚举总是需要编译转换，增加了构建步骤的复杂性。

而像 `as const` 这样的现代 TypeScript 特性，生成的代码更贴近原生 JavaScript，更易于与现代工具链集成。

## enum 替代方案 {#enum-alternatives}

### 联合类型 + 字符串字面量 {#union-types-and-string-literals}

```ts twoslash
// 代替枚举
type Status = 'PENDING' | 'FULFILLED' | 'REJECTED'

let current: Status = 'PENDING' // 纯类型，无运行时开销
```

**联合类型**：

* 零运行时代码生成
* 完美支持 **Tree-shaking**
* 类型安全和自动补全
* 更简洁的语法

### `as const` 对象 {#as-const-object}

```ts twoslash
// 代替枚举
const Status = {
  Pending: 'PENDING',
  Fulfilled: 'FULFILLED',
  Rejected: 'REJECTED',
} as const

type Status = typeof Status[keyof typeof Status]
//    ^?
//

// 使用
const current = Status.Pending // 类型安全，且生成简单对象
```

这种方法结合了运行时值和类型推断的优势，同时保持低开销。

### Symbol （特定场景） {#symbol}

对于需要唯一标识的场景，可以使用 `Symbol`，但需注意兼容性和内存开销。

## 枚举的适用场景（如果有的话） {#use-cases}

虽然强烈建议避免使用枚举，但在极少数情况下，它们可能仍有合理性：

* **与遗留代码的深度集成**：如果团队已有大量基于枚举的代码，全面重构的成本可能过高。
* **需要运行时反射**：如果你确实需要将枚举作为值进行遍历或序列化，枚举可能比联合类型更方便。

即便如此，也建议对这些场景进行严格评估，并考虑逐步迁移到更轻量的方案。

## 迁移步骤 {#migration-steps}

:::steps

* **评估现有枚举**

  列出项目中所有的枚举定义，评估它们的使用频率和影响范围。

* **替换为联合类型**

  对于大多数场景，直接将枚举值提取为字符串字面量的联合类型。

* **使用 as const 对象**

  局搜索并替换所有旧枚举的使用点。

* **验证打包结果**
  使用 source-map-explorer 或类似工具确认 bundle 体积是否减小。

:::

## 总结 {#summary}

TypeScript 枚举虽然初期使用便捷，但它们带来了 **运行时开销**、**树摇不兼容** 以及 **非标准语法** 等问题。
在现代前端开发中，使用 **联合类型** 和 **`as const` 对象** 是更轻量、更类型安全且更符合 JavaScript 标准的做法。

在考虑使用枚举时，问问自己：“我真的需要运行时值吗？” 如果答案是否定的，果断拥抱联合类型吧！
你的代码体积、构建速度和团队维护性都会因此受益。

## 参考

* [为什么你应该避免在 TypeScript 中使用枚举](https://medium.com/@hanyikoh/why-you-should-avoid-using-enum-in-typescript-487cc79dceb6)
* [TypeScript 枚举：用例和替代方案](https://2ality.com/2025/01/typescript-enum-patterns.html)
* [为什么 TypeScript 枚举会增加 Angular 包体积](https://dev.to/rohtashsethi/why-typescript-enums-increase-angular-bundle-size-and-how-to-fix-it-1908)
* [Webpack 5 为何包含未使用的 TypeScript 枚举](https://stackoverflow.com/questions/68720866/why-does-webpack-5-include-my-unused-typescript-enum-exports-even-when-tree-sha)

---

---
url: /article/wucfrrye/index.md
---
# CSS 媒体查询与用户体验
我们都知道，在如今设备多样化的时代，响应式设计已经不再是“加分项”，而是“必选项”。
而 ==CSS 媒体查询=={.info}，正是我们实现响应式布局的得力助手。
但你有没有想过，媒体查询除了可以根据屏幕尺寸适配布局，还能更进一步地与用户交互方式、设备特性以及个人偏好等要素结合，从而 ==提供更智能、更个性化的用户体验呢=={.tip}？

今天，我们就来深入探讨一些高级的、与用户体验息息相关的 CSS 媒体查询条件。这些条件能让我们在更细致的维度上感知用户的需求，从而打造出真正“以用户为中心”的网页。

## 一、交互能力感知：`any-hover`, `hover`, `any-pointer`, `pointer`

在开始讲解这几个特性之前，我们先来思考一个问题：用户是通过鼠标精准点击，还是通过手指触摸屏幕进行操作？不同的交互方式，往往意味着不同的设计偏好和优化策略。

传统的 `hover` 伪类只能检测当前元素是否被鼠标悬停，但它的局限性在于无法区分设备本身的交互能力。而 `any-hover`, `hover`, `any-pointer`, `pointer` 结合起来，就能为我们提供更细粒度的交互能力检测。

### 1.1 `any-hover` 与 `hover`：悬停能力的考量

* **`hover`**：针对 ==主输入设备=={.info} 的悬停能力。如果用户的“主”输入设备（比如鼠标）支持悬停，则匹配。这与我们常用的 `:hover` 伪类概念相似。

  ```css
  /* 只有当存在支持悬停的主输入设备时，文本才会有蓝色背景 */
  @media (hover: hover) {
    .my-element:hover {
      background-color: lightblue;
      cursor: pointer;
    }
  }
  ```

* **`any-hover`**：针对 ==任何可用输入设备=={.info} 的悬停能力。只要用户 *任何一个* 输入设备支持悬停（比如用户可能同时连接了鼠标和触摸屏设备，只要鼠标支持悬停即可），则匹配。

这俩有啥区别呢？举个例子：

想象你正在使用一台 ==Surface Pro=={.tip}。它既有触摸屏，又可以连接鼠标和键盘。

* 当使用手写笔或手指在触摸屏上操作时，通常是没有“悬停”这个概念的。
* 当连接并使用鼠标时，鼠标是可以“悬停”的。

:::code-tabs
@tab 场景解读

```
// 情况1: 无鼠标，纯触屏设备（如手机、iPad）
// any-hover 不匹配
// hover 不匹配

// 情况2: 有鼠标，但当前操作是触摸（如 Surface Pro 用手指滑动）
// any-hover 匹配 (因为鼠标支持悬停)
// hover 匹配 (因为鼠标是主输入设备，支持悬停)

// 情况3: 有鼠标，当前操作是鼠标
// any-hover 匹配
// hover 匹配
```

@tab 总结

```
💡 简单来说，`any-hover` 只要系统有一个能悬停的输入设备就匹配，而 `hover` 只有当==主==输入设备支持悬停才匹配。
```

:::

**实际应用场景**：

如果你的网站有很多需要鼠标悬停才能显示内容的交互（比如菜单项的二级下拉，或者图片库的详细信息），你可能不希望在触摸屏设备上展示这些交互，因为用户根本无法“悬停”。

```css
/* 仅当存在任何悬停能力时，才显示悬停提示 */
@media (any-hover: hover) {
  .tooltip-trigger:hover .tooltip-content {
    display: block;
    /* 其他悬停样式 */
  }
}

/* 如果主输入设备是触控，则不显示悬停效果，改为点击显示 */
@media (hover: none) {
  .main-menu-item {
    padding: 10px; /* 增大点击区域 */
  }
  .main-menu-item:active { /* 或者使用 JavaScript 模拟点击显示 */
    background-color: #eee;
  }
}
```

### 1.2 `any-pointer` 与 `pointer`：指针精度的考量

* **`pointer`**：针对 ==主输入设备=={.info} 的指针精度。它有三个可选值：
  * `none`：没有指针设备或指针精度未知（比如早期的TV遥控器）。
  * `coarse`：粗略的指针设备（比如手指触摸屏）。
  * `fine`：精确的指针设备（比如鼠标、触摸板、手写笔）。

* **`any-pointer`**：针对 ==任何可用输入设备=={.info} 的指针精度。与 `any-hover` 类似，只要 *任何一个* 输入设备具有指定的指针精度，则匹配。

**实际应用场景**：

这对于优化触摸屏和鼠标用户的界面设计至关重要。

* **`coarse` 指针**意味着用户主要通过手指进行操作，因此点击区域应该更大，元素之间的间距也应该更大，以避免误触。
* **`fine` 指针**意味着用户可以使用更高的精度进行操作，因此可以设计更紧凑的布局和更小的交互元素。

:::: demo normal title="指针精度优化示例" desc="通过检测指针类型，我们为不同设备的用户提供更符合直觉的交互元素大小。"
::: code-tabs
@tab HTML

```html
<button class="action-button">点击操作</button>
<button class="secondary-button">次要操作</button>
```

@tab CSS

```css
/* 默认按钮大小 */
.action-button, .secondary-button {
  padding: 8px 16px;
  font-size: 16px;
  margin: 5px;
  border-radius: 4px;
  transition: all 0.2s ease-in-out;
  border: 1px solid #007bff;
  background-color: #007bff;
  color: white;
  cursor: pointer;
}

/* 当主输入设备为粗略指针时 (如触摸屏)，增大按钮和间距 */
@media (pointer: coarse) {
  .action-button, .secondary-button {
    padding: 15px 30px; /* 增大内边距 */
    font-size: 20px;   /* 增大字体 */
    margin: 10px;      /* 增大外边距 */
    min-width: 80px;   /* 确保最小点击区域 */
    min-height: 80px;

  }
}

/* 当页面上存在任何精确指针设备时，可以设计更精细的交互 */
@media (any-pointer: fine) {
  .secondary-button {
    background-color: transparent;
    color: #007bff;
  }
  .secondary-button:hover {
    background-color: #e6f2ff;
  }
}
```

:::
::::

:::tip
**什么时候用 `any-*`，什么时候用 `*`？**

* 当你希望 ==只要用户有能力，就提供相应的功能或样式=={.info} 时，使用 `any-hover` 或 `any-pointer`。
  例如，即使主设备是触摸屏，但外接了鼠标，你可能也希望网站能对鼠标悬停做出反应。
* 当你希望 ==只针对用户当前正在使用的主要交互方式=={.info} 进行优化时，使用 `hover` 或 `pointer`。例如，你可能不希望在触摸屏上“误触发”鼠标悬停的菜单。

大多数情况下，优先使用 `any-*` 可以提供更灵活的用户体验，因为用户可能会切换输入方式。但如果主次分明，比如移动设备上的菜单样式，你可能只关心 `pointer: coarse`。
:::

***

## 二、个性化偏好：`prefers-color-scheme`, `prefers-contrast`, `prefers-reduced-motion`

这些媒体查询条件不再关注设备的物理属性或交互方式，而是深入到用户的 ==系统级偏好设置=={.info}。这为我们提供了真正个性化和辅助无障碍设计的强大能力。

### 2.1 `prefers-color-scheme`：查询是否浅色/深色模式

`prefers-color-scheme` 是当前最常用也是最受欢迎的媒体查询之一。它允许你根据用户的操作系统或浏览器主题设置为网站提供 ==亮色（light）或深色（dark）模式=={.info}。

**可选值**：

* `no-preference`：用户没有指定偏好。
* `light`：用户偏好亮色主题。
* `dark`：用户偏好深色主题。

**使用姿势**：

```css
/* 默认亮色主题 */
body {
  background-color: #fff;
  color: #333;
}

/* 当用户偏好深色主题时 */
@media (prefers-color-scheme: dark) {
  body {
    background-color: #333;
    color: #eee;
  }
  a {
    color: #87ceeb; /* 调整链接颜色，确保可见性 */
  }
  /* 其他深色模式下的样式调整 */
}

/* 当用户偏好亮色主题时 (可以明确指定，也可以作为默认 fallback) */
@media (prefers-color-scheme: light) {
  /* 可以覆盖或补充亮色模式特有的样式，通常是默认样式 */
}
```

:::: demo normal title="深色模式切换演示" desc="尝试在您的操作系统设置中切换亮色/深色模式，查看本Demo的颜色变化。"
::: code-tabs
@tab HTML

```html
<p>
  当系统设置为深色模式时，此文本将变为浅色背景深色，反之亦然。 <br>
  当前主题：<span id="theme-status"></span>
</p>
```

@tab CSS

```css
body {
  font-family: sans-serif;
  padding: 20px;
  background-color: #f0f0f0;
  color: #333;
  transition: all 0.3s ease;
}

@media (prefers-color-scheme: dark) {
  body {
    background-color: #222;
    color: #eee;
  }
}
```

@tab Javascript

```js
const themeStatus = document.getElementById('theme-status')

function updateThemeStatus() {
  if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
    themeStatus.textContent = '深色模式'
  }
  else if (window.matchMedia('(prefers-color-scheme: light)').matches) {
    themeStatus.textContent = '亮色模式'
  }
  else {
    themeStatus.textContent = '未指定偏好 (通常是亮色)'
  }
}

// 初始化状态
updateThemeStatus()

// 监听主题变化
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', updateThemeStatus)
window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', updateThemeStatus)
```

:::
::::

深色模式不仅能降低夜间阅读的眼睛疲劳，还能在 OLED 屏幕上节省电量。 ==提供深色模式是提升用户体验和满足个性化需求的重要一步=={.success}。

### 2.2 `prefers-contrast`：高对比度模式的使者

对于一些视觉障碍用户，或者在某些光线强烈（如户外阳光直射）的环境下，高对比度模式能显著提升文本和界面的可读性。`prefers-contrast` 媒体查询允许我们根据用户的系统对比度设置调整网站样式。

**可选值**：

* `no-preference`：用户没有指定对比度偏好。
* `high`：用户偏好高对比度。
* `low`：用户偏好低对比度（相对少见，但存在）。
* `custom`：用户设置了自定义对比度（此值尚未广泛支持，目前主要关注 `high` 和 `no-preference`）。

**使用姿势**：

```css
/* 默认样式 */
body {
  background-color: #f0f0f0;
  color: #333;
}
button {
  border: 1px solid #777;
  background-color: #eee;
  color: #333;
}

/* 当用户偏好高对比度时 */
@media (prefers-contrast: high) {
  body {
    background-color: black; /* 更深的背景 */
    color: white;             /* 更亮的文字 */
  }
  button {
    border: 2px solid yellow; /* 醒目的边框 */
    background-color: black;
    color: yellow;
    font-weight: bold;
  }
  a {
    color: limegreen; /* 高对比度链接色 */
    text-decoration: underline; /* 增加下划线确保识别 */
  }
  /* 去除可能影响对比度的阴影 */
  box-shadow, text-shadow {
    display: none;
  }
}
```

高对比度模式的关键在于 ==确保前景和背景之间有足够的亮度差异=={.warning}，并且重要的 UI 元素（如按钮、链接）具有清晰的视觉边界。 这对无障碍访问（Accessibility）至关重要。

### 2.3 `prefers-reduced-motion`：减少动态效果

一些用户可能会对快速、频繁或过于复杂的动画感到不适，甚至可能引发==前庭系统紊乱或癫痫=={.caution}。`prefers-reduced-motion` 媒体查询允许我们检测用户是否偏好减少动态效果。

**可选值**：

* `no-preference`：用户没有指定偏好。
* `reduce`：用户偏好减少动态效果。

**使用姿势**：

```css
/* 默认情况下，有平滑的动画效果 */
.animate-box {
  width: 100px;
  height: 100px;
  background-color: #007bff;
  transition: transform 0.3s ease-in-out, background-color 0.3s ease;
}

.animate-box:hover {
  transform: translateX(20px) rotate(5deg);
  background-color: #0056b3;
}

/* 当用户偏好减少动态效果时 */
@media (prefers-reduced-motion: reduce) {
  .animate-box {
    /* 移除或简化过渡和动画 */
    transition: none;
    animation: none;
    /* 也可以直接将动画持续时间设置为0 */
    /* transition-duration: 0.001ms; */
    /* animation-duration: 0.001ms; */
  }

  /* 如果仍需提示状态改变，可以用简单的瞬时变化替代 */
  .animate-box:hover {
    background-color: #0056b3;
    /* 瞬间改变，不带动画 */
    transform: none; /* 不进行位移和旋转 */
  }

  /* 还可以针对视差滚动、背景视频等进行处理 */
  .parallax-effect {
    background-position: center; /* 移除滚动时的背景位移效果 */
    background-attachment: scroll;
  }
}
```

:::: demo normal title="动画效果优化演示" desc="在操作系统设置中开启“减少动画/运动”，然后刷新页面，查看下方方块的Hover效果变化。"
::: code-tabs
@tab HTML

```html
<div class="motion-box">悬停我</div>
<p>
  <small>（在 macOS 上，可在“系统设置”>“辅助功能”>“显示”>“减少动态效果" 中设置）</small><br>
  <small>（在 Windows 上，可在“设置”>“辅助功能”>“视觉效果”>“动画效果”中设置）</small>
</p>
```

@tab CSS

```css
.motion-box {
  width: 120px;
  height: 60px;
  background-color: #28a745;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  border-radius: 8px;
  margin-top: 20px;
  cursor: pointer;
  transition: transform 0.5s ease-out, background-color 0.3s ease; /* 默认平滑动画 */
}

.motion-box:hover {
  transform: scale(1.1) rotate(5deg);
  background-color: #218838;
}

/* 当用户偏好减少动态效果时 */
@media (prefers-reduced-motion: reduce) {
  .motion-box {
    transition: none; /* 直接移除动画 */
    /* 或者更精细地控制动画时间，使其变得非常快 */
    /* transition-duration: 0.001ms; */
  }
}
```

:::
::::

\==尊重用户的个人偏好，尤其是在无障碍领域，是现代前端开发不可或缺的一环=={.important}。通过 `prefers-reduced-motion`，我们可以避免不必要的视觉干扰，让网站对更多用户友好。

***

## 三、总结与展望

今天我们深入探讨了多个与用户体验息息相关的 CSS 媒体查询，它们是：

:::steps

* **交互能力感知**：
  * `any-hover`, `hover`：判断设备是否有悬停输入能力。
  * `any-pointer`, `pointer`：判断设备指针的精度是粗略（如触摸）还是精确（如鼠标）。
* **个性化偏好设置**：
  * `prefers-color-scheme`：根据用户系统设置的亮色/深色模式调整主题。
  * `prefers-contrast`：根据用户系统设置的高对比度偏好调整样式，提升可读性。
  * `prefers-reduced-motion`：根据用户系统设置的减少动态效果偏好，优化动画和过渡。

:::

学会灵活运用这些媒体查询，能让你的网站不仅仅是“响应式布局”，更是“==响应式用户体验=={.success}”！这意味着你的网站更懂用户，能根据不同的上下文和偏好，提供最适宜的界面和交互。

未来，W3C 还在继续探索更多的用户偏好媒体查询，例如 `prefers-reduced-data` (减少流量消耗)、`prefers-reduced-transparency` (减少透明度)、甚至可能出现 `prefers-time` (夜猫子或是早起鸟?)。这些都预示着前端将更加注重==以人为本的设计理念=={.info}。

希望这篇文章能帮助你更好地理解和使用这些强大的 CSS 媒体查询，从而打造出更棒的用户体验！

## 参考

* [MDN Web Docs: @media - Features](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media#media_features)
* [W3C CSS Media Queries Level 4](https://www.w3.org/TR/mediaqueries-4/)
* [A Complete Guide to Dark Mode on the Web](https://css-tricks.com/dark-mode-basics/)

---

---
url: /article/wzcjdidr/index.md
---
:::center
![jsr logo](/images/jsr-logo.svg){style="width:100%;max-width:128px;margin-bottom:16px;"}
:::

## 介绍

最近，**Deno** 发布了一个 [Javascript Registry (JSR)](https://jsr.io/)，一个新的 JavaScript 包注册表。
它类似于 npm ，但不是一个包管理工具，而是提供 包注册、包发布的包存储服务。

它可以搭配 `npm`, `yarn` 和 `pnpm` 等一起使用，支持 `Node.js` 、`Deno`、`Bun` 和 `browser` 等运行时。

JSR 的目标不是为了取代 NPM，而是作为 NPM 的超集，更符合 现代 JavaScript 开发者的需求，提高 开发者的体验，
并在 可靠性、安全性、性能等各方面得到更好的支持。

## 使用 JSR

你可以在任何支持 ES 模块的运行时中使用 JSR 包，例如 Deno、Node.js、Bun、Cloudflare Workers 等。
你还可以将 JSR 包与支持 ES 模块的构建工具一起使用，例如 Vite、esbuild、Webpack 和 Rollup 。

你可以使用以下任意命令，将 JSR 包导入到你的项目中：

```sh
# deno
deno add @luca/cases

# npm (以下选项之一，取决于你的包管理器)
npx jsr add @luca/cases
yarn dlx jsr add @luca/cases
pnpm dlx jsr add @luca/cases
bunx jsr add @luca/cases
```

如果是使用 Deno, `deno add` 命令将在 `deno.json` 文件中生成指定的 JSR 模块添加导入映射条目：
::: code-tabs
@tab deno.json

```json
{
  "imports": {
    "@luca/cases": "jsr:@luca/cases@^1.0.1"
  }
}
```

:::

对于 npm 和 npm 兼容的包管理器， jsr 命令会将依赖项添加到您的 `package.json` 文件，
并将 `.npmrc` 文件添加到您的项目根目录，其中包含将 JSR 与 npm 结合使用所需的配置。

::: code-tabs
@tab package.json

```json
{
  "dependencies": {
    "@luca/cases": "npm:@jsr/luca__cases@^1.0.1"
  }
}
```

:::

此 npm 依赖项配置使用了一个名为 @jsr 的特殊自定义范围，
在 `.npmrc` 中自动添加以下配置：

::: code-tabs
@tab .npmrc

```sh
@jsr:registry=https://npm.jsr.io
```

:::

::: note
你应该将 `.npmrc` 添加到你的源代码管理中，以便后续安装或更新 JSR 包时使用它。
:::

## 为什么选择 JSR ？

Node.js 取得巨大的成功，很大程度上得益于 NPM 的成功。NPM 拥有 200万+ 个（未来可能达到 300万个） 包，
可能是历史上最成功的包管理器和注册表。这是 JavaScript 社区足以自豪的成就。

那么，既然已经有 NPM 了，为什么还要构建 JSR ？
因为在当今的世界，与当初引入 NPM 时，已发生了翻天覆地的变化：

* **ECMAScript 模块已经成为了标准。**
  Web 平台现已采用 ESM 作为首选模块格式，取代 CommonJS 。
* **除了 Node.js 和 Browser 以外，还有更多的 JavaScript 运行时。**
  随着 Deno、Bun、workerd 和其他新的 JavaScript 环境出现，已 `Node.js` 为中心的 包注册表已不再能满足需求。
* Typescript 已成为事实上的标准。
  TypeScript 作为 JavaScript 的超集和 ECMAScript 最新功能的测试平台，已成为众多重要的 JavaScript 库的选择。
  现代注册表的设计应考虑到 TypeScript 。

以下是你考虑使用 JSR 的理由：

### 原生 Typescript 支持

JSR 的设计考虑到了 TypeScript 的支持。TypeScript 源文件可以直接发布到 JSR。
原生支持 TypeScript 的平台（如 Deno）可以直接使用这些文件。

对于缺乏 TypeScript 原生支持的其它环境（如 Node.js），JSR 会将源代码转换为 JavaScript，并生成 `d.ts` 类型声明文件，
以支持 Node.js 项目的 TypeScript 工具。模块作者不需要额外的配置或构建步骤。

JSR 还将从 TypeScript 源代码为包生成参考文档，提供丰富的在线文档，你可以将其与代码一起维护。

### 仅限 ESM 模块

JavaScript 模块的web标准是 [ESM](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) 。
一个现代的包注册中心应该围绕这个标准团结起来，并将社区转向这个方向。因此，JSR 仅为 ESM 设计。

### 跨运行时支持

JSR 的目标是能够在 JavaScript 工作的任何地方工作，并为 JavaScript 和 TypeScript 代码提供与运行时无关的注册表。
如今，JSR 可以与 Deno 和其他 包括 `node_modules` 的 NPM 环境一起使用。这意味着 Node.js、Bun、Cloudflare Workers 以及其他使用 `package.json` 管理依赖项的项目也可以与 JSR 进行互操作。

### JSR 是 NPM 的超集

JSR 是 npm 的超集，就像 TypeScript 是 JavaScript 的超集一样。

JSR 旨在与基于 npm 的项目和包进行互操作。你可以在任何使用 `node_modules` 文件夹的运行时环境中使用 JSR 包。
JSR 模块可以从 npm 导入依赖项。

### 出色的开发体验

JSR 具有许多旨在帮助模块发布者提高工作效率的功能，包括但不限于：

* 使用单个命令即可轻松发布 - CLI 将引导你完成其余部分
* 从源代码自动生成 API 文档
* 从 GitHub Actions 进行零配置发布
* 自动包含 Node.js/npm 分发的 `.d.ts` 文件
* TypeScript 最佳实践的自动指导将使你的代码加载尽可能快
* 更多...

### 快速，安全，可靠

JSR 旨在安全、快速、灵活，并且在资源受限的环境中也能很好地工作。

* JSR 使用全局 CDN 来提供包，并使用本地缓存和高并行性来加速下载。
* JSR 包上传是不可变的，因此你可以相信包在下载后永远不会改变或消失在你的底层。
* JSR 包下载非常高效，仅下载你正在导入的确切文件。
* JSR 使用基于 OIDC 的身份验证从 CI 发布包，并使用无令牌交互式身份验证流程从本地计算机发布。

## JSR 包规则

上传到 JSR 的所有包都会在发布过程中自动处理和验证，以确保 JSR 上托管的所有代码都遵守一组一致的规则。
这些规则旨在实现跨环境的可移植性。代码必须遵循这些规则才能发布到 JSR。

### 仅支持 ESM 模块

JSR 包只支持 ESM 模块，这意味着你只能发布使用 `import` 和 `export` 关键字的模块。
无法发布 CommonJS 模块

### 支持 NPM 包

可以通过在 `package.json` 的 `dependencies` 中指定它们来依赖 npm 包，
或者使用 `npm:` 说明符在代码中引用它们，例如作为 `import { cloneDeep } from "npm:lodash@4";` 。

### 支持 JSR 包

通过在 `package.json` 的 `dependencies` 中指定它们来依赖 JSR 包，
或者使用 `jsr:` 说明符在代码中引用它们，例如 `import { encodeBase64 } from "jsr:@std/encoding@1/base64";` 。

支持 node: 内置函数

使用 `node:` 方案导入 Node.js 内置函数。
例如，可以使用 `import { readFile } from "node:fs";` 导入 fs 模块。如果包有 `package.json` ，
您还可以使用裸说明符（不带 `node:` 前缀）导入 Node.js 内置程序。

### 简单文件名

文件名必须与 Windows 和 Unix 兼容。这意味着文件名不能包含 `*` 、 `:` 或 `?` 等字符。
应避免存在多个同名但大小写不同的文件。

### 最好不要使用 TypeScript“slow types”

为了加快类型检查，支持文档生成和 Node.js 的兼容性，
JSR 包不应在导出的函数、类或变量中使用某些 TypeScript 类型。这是默认强制执行的，但可以选择忽略。

### 有效的跨文件导入

包中模块之间的所有相对导入必须在发布时解析。支持的说明符的格式取决于是否使用 `package.json`。

## 发布包到 JSR

您可以将使用 ESM 模块编写的大多数 JavaScript 和 TypeScript 代码发布为 JSR 包。
JSR 包发布到 **jsr.io** ，并且可以从 Deno、Node.js 和其他工具导入。

为使用 `package.json` 的运行时编写的代码，和为 Deno 编写的代码，都可以作为包发布到 JSR。
JSR 支持并鼓励发布 TypeScript 源代码，而不是成对的 `.js + .d.ts` 文件。
这使得 JSR 能够提供更有用的自动生成文档，并有助于在编辑器中提供改进的自动完成功能。

### 包配置文件

你必须在你的包中添加一个 包配置文件，该文件名为 `jsr.json`。文件中包含包括 包的元数据，如 包名、
版本号、入口点。Deno 用户还可以在其 `deno.json` 中包含所需的属性，以避免创建另一个文件。

::: code-tabs
@tab jsr.json / deno.json

```json
{
  "name": "@luca/greet",
  "version": "1.0.0",
  "exports": "./mod.ts"
}
```

:::

### 创建 scope 和 package

发包到 JSR，首先必须创建 一个 scope，然后在这个 scope 下创建 package。scope 与 NPM scope 类似，
scope 以 `@` 符号开头，后面紧跟名称，如 `@luca` 就是一个

可以在 [jsr.io/new](https://jsr.io/new) 创建 scope。 scope 的名称长度范围必须在 2 到 32 个字符之间，
只能使用 小写字符、连字符 和 数字。仅当名称未被使用，禁止使用与现有 scope 非常相似的名称。

创建 scope 后，就可以在这个 scope 中创建 package。包名称的长度必须在 2 到 20 个字符之间，
并且只能包含小写字母、数字和连字符。仅当名称未被使用，禁止使用与现有 package 非常相似的名称。

::: center
![jsr new](/images/jsr-new.png){style="width:100%;max-width: 450px;"}
:::

### 验证 package

要发布包（包括执行试运行以确认包满足所有 JSR 规则），
需要使用 `jsr publish` 或 `deno publish` 。
这两个命令的语法大致相同。根据不同的工具，可以按如下方式调用发布命令。

```sh
# deno
deno publish
# npm
npx jsr publish
# yarn
yarn dlx jsr publish
# pnpm
pnpm dlx jsr publish
```

可以使用 `--dry-run` 标志运行 `jsr publish` 来执行实际发布期间发生的所有发布验证。
这将打印出将要发布的文件列表，但不会实际发布到注册表。

```sh
# deno
$ deno publish --dry-run
# npm
$ npx jsr publish --dry-run
# yarn
yarn dlx jsr publish --dry-run
# pnpm
pnpm dlx jsr publish --dry-run
```

### 从本机发布包

使用 `jsr publish` 或 `deno publish` 命令可以从本地计算机发布包。

身份验证是通过浏览器进行，因此无需向 JSR cli 提供任何身份验证信息。

进入 包的根目录（包含 `jsr.json` / `deno.json` 文件），然后运行 ​​ `jsr publish` 。

```sh
# deno
$ deno publish
# npm
$ npx jsr publish
# yarn
yarn dlx jsr publish
# pnpm
pnpm dlx jsr publish
```

在发布期间，JSR CLI 和 JSR 服务器都会对 包 运行许多检查以确保其有效。
如果其中任何检查失败，CLI 将输出 错误消息。必须先修复这些错误，然后才能尝试再次发布。

### 从 GitHub Actions 发布包

要从 Github Actions 发布包，首先必须在 JSR 的 package 页 的 `Setting` 选项卡中，将包 链接到 Github Repo。

::: center
![jsr link](/images/jsr-github-link.png){style="width:100%;max-width: 650px;"}
:::

然后，在 Github Repo 中，添加一个 工作流的配置文件，例如 `.github/workflows/publish.yml` 。

::: code-tabs
@tab .github/workflows/publish.yml

```yml
name: Publish

on:
  push:
    branches:
      - main

jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write # The OIDC ID token is used for authentication with JSR.
    steps:
      - uses: actions/checkout@v4
      - run: npx jsr publish
```

:::

每次推送到存储库的 main 分支时，此工作流程都会运行。
它将把您的包发布到 JSR，并根据 `jsr.json` 文件中的版本自动使用正确的版本号。
如果 `jsr.json` 文件中指定的版本已发布到 JSR， `jsr publish` 将不会尝试发布。

### 过滤文件

`jsr publish` 将忽略包根目录中 `.gitignore` 文件中列出的文件。
此外，可以在 `jsr.json` / `deno.json` 文件中指定 `include` 和 `exclude` 字段以包含、
忽略或取消 gitignore 特定的操作文件。

例如，要仅选择性地包含某些文件，可以使用 `include` 选项指定与所有文件匹配的 glob：

::: code-tabs
@tab jsr.json

```json
{
  "name": "@luca/greet",
  "version": "1.0.0",
  "exports": "./src/mod.ts",
  // note: this will be collapsed down to just include in the future
  "publish": {
    "include": ["LICENSE", "README.md", "src/**/*.ts"]
  }
}
```

:::

还可以通过 exclude 选项排除某些文件：

::: code-tabs
@tab jsr.json

```json
{
  "name": "@luca/greet",
  "version": "1.0.0",
  "exports": "./src/mod.ts",
  "publish": {
    "include": ["LICENSE", "README.md", "src/**/*.ts"],
    "exclude": ["src/tests"]
  }
}
```

:::

#### 不使用“include”时取消忽略文件

你可能有一个包含 `.gitignore` 文件的包，其中包含以下内容：

::: code-tabs
@tab .gitignore

```txt
.env
dist/
```

:::

在这种情况下，发布时将忽略 `dist/` 目录中的所有文件以及名为 `.env` 的任何文件。

然而，如果想要发布 `dist/` 目录，这可能会很不方便，因为有 "exports" 指向它（或其子目录）。
在这种情况下，可以通过在 `jsr.json` / `deno.json` 文件中的 `exclude` 字段中使用否定来取消忽略 `dist/` 目录。

::: code-tabs
@tab jsr.json

```json
{
  "name": "@luca/greet",
  "version": "1.0.0",
  "exports": "./dist/mod.ts",
  "publish": {
    "exclude": ["!dist"]
  }
}
```

:::

在这种情况下，发布时将包含 `dist/` 目录，即使它列在 `.gitignore` 文件中。

## `jsr.json` 文件

JSR 包需要包含一个配置文件，用于指定包的名称、版本和导出。该文件应命名为 `jsr.json` 或 `jsr.jsonc` 。
使用 Deno 时， `jsr.json` 配置文件的所有属性都可以放置在 `deno.json` 中。

::: code-tabs
@tab jsr.json / deno.json

```json
{
  "name": "@luca/greet",
  "version": "1.0.0",
  "exports": "./mod.ts"
}
```

:::

### name

name 字段是包的名称，以 JSR scope 为前缀。

### version

version 字段是包的版本，它必须是有效的 [SemVer](https://semver.org/) 版本。每次发布新版本时，都必须增加包的版本。

### exports

`exports` 字段告诉 JSR 包的用户应该导入哪些模块。
`exports` 字段可以指定为单个字符串，也可以指定为将入口点名称映射到包中的路径的对象。

```json
{
  "name": "@luca/greet",
  "version": "1.0.0",
  "exports": {
    ".": "./mod.ts",
    "./greet": "./greet.ts"
  }
}
```

在上面的示例中， `exports` 字段是一个对象。 `.` 入口点是包的默认入口点。 `./greet` 入口点是一个命名入口点。
通过此入口点，可以使用 `import { greet } from "@luca/greet/greet";` 导入 `greet.ts` 模块，
使用 `import { greet } from "@luca/greet";` 导入 `mod.ts` 模块。

还可以将 `exports` 字段指定为单个字符串。
如果包中只有一个入口点，这非常有用。它在语义上等同于以对象形式指定默认入口点。

```json
{
  "name": "@luca/greet",
  "version": "1.0.0",
  "exports": { // [!code --]
    ".": "./mod.ts" // [!code --]
  }, // [!code --]
  "exports": "./mod.ts" // [!code ++]
}
```

### include 和 exclude

还可以使用 `include` 和 `exclude` 选项在发布过程中包含和排除文件。
使用 `deno.json` 时，可以使用 `publish.include` 和 `publish.exclude` 来包含和排除仅用于发布的文件，
而不是用于所有 Deno 子命令。查看 [过滤文件](#过滤文件) 了解更多。

## 编写文档

编写文档对于包的成功至关重要。 JSR 使包作者很容易获得优秀的文档，因为它根据包源代码中的 JSDoc 注释生成文档。

生成的文档显示在包页面上。该文档还将以补全和悬停描述的形式在编辑器中向用户显示。

文档有两个重要部分：

* **symbol documentation**：这是包导出的每个单独函数、接口、常量或类的文档。
* **module documentation**：这是包中每个导出模块的文档 - 它充当模块中所有符号的概述或摘要。

### symbol documentation

为每个导出的 函数、接口、常量或类 添加 JSDoc 注释。

```ts
/**
 *  // [!code ++]
 * This function takes two numbers as input, and then adds these numbers using // [!code ++]
 * floating point math.  // [!code ++]
 */ // [!code ++]
export function add(a: number, b: number): number {
  return a + b
}
```

对于函数，可以将文档添加到特定参数或返回类型：

```ts
/**
 * Search the database with the given query.
 *
 * @param query This is the query to search with. It should be less than 50 chars to ensure good performance.  // [!code ++]
 * @param limit The number of items to return. If unspecified, defaults to 20. // [!code ++]
 * @returns The array of matched items. // [!code ++]
 */
export function search(query: string, limit: number = 20): string[]
```

对于更复杂的，通常最好包含一个演示如何使用该函数的示例：

````ts
/**
 * Search the database with the given query.
 *
 * ```ts // [!code ++]
 * search("Alan") // ["Alan Turing", "Alan Kay", ...] // [!code ++]
 * ``` // [!code ++]
 */
export function search(query: string, limit: number = 20): string[]
````

interfaces 也可以使用 JSDoc 进行注释。它们的属性和方法也可以被注释：

```ts
/** The options bag to pass to the {@link search} method. */
export interface SearchOptions {
  /**
   * The maximum number of items to return from the search. Defaults to 50 if
   * unspecified.
   */
  limit?: number
  /**
   * Skip the given number of items. This is helpful to implement pagination.
   * Defaults to 0 (do not skip) if not specified.
   */
  skip?: number

  /**
   * The function to call if the {@link search} function needs to show warnings
   * to the user. If not specified, warnings will be silently swallowed.
   */
  reportWarning?: (message: string) => void
}
```

类可以类似地注释为接口和函数：

```ts
/**
 * A class to represent a person.
 */
export class Person {
  /** The name of the person. */
  name: string
  /** The age of the person. */
  age: number

  /**
   * Create a new person with the given name and age.
   * @param name The name of the person.
   * @param age The age of the person. Must be non-negative.
   */
  constructor(name: string, age: number) {
    if (age < 0) {
      throw new Error('Age cannot be negative')
    }
    this.name = name
    this.age = age
  }

  /** Print a greeting to the console. */
  greet() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`)
  }
}
```

### module documentation

为 模块 添加 JSDoc 注释，对于提供模块及其导出符号的概述很有用。

要记录模块，请在模块文件的顶部添加 JSDoc 注释，并在注释中的任意位置包含 `@module` 标记：

```ts{1-4}
/**
 * This module contains functions to search the database.
 * @module
 */

/** The options bag to pass to the {@link search} method. */
export interface SearchOptions {}

/** Search the database with the given query. */
export function search(query: string, options?: SearchOptions): string[];
```

您还可以在模块文档中包含示例：

````ts{6-10}
/**
 * @module
 *
 * This module contains functions to search the database.
 *
 * ```ts
 * import { search } from "@luca/search";
 *
 * search("Alan") // ["Alan Turing", "Alan Kay", ...]
 * ```
 */
````

## Slow Types

JSR 的许多功能都分析源代码，特别是源代码中的 TypeScript 类型。
这样做是为了生成文档、为 npm 兼容层生成类型声明，以及使用 JSR 中的包加速 Deno 项目的类型检查。

为了使这些功能发挥作用，TypeScript 源不得导出任何本身或引用“Slow Types”的函数、类、接口或变量或类型别名。
“Slow Types”是未明确编写的类型，或者过于复杂以至于需要大量推理才能理解的类型。

对于这些功能，JSR 执行这种推断的成本太高，因此公共 API 不支持这些类型。

::: warning
如果 JSR 在包中发现“Slow Types”，某些功能将无法工作或质量下降。包括：

* 对包的使用者进行类型检查会更慢。对于大多数软件包来说，速度至少会降低 1.5-2 倍。它可能会高得多。
* 该包将无法为 npm 兼容层生成类型声明，或者在生成的类型声明中“Slow Types”将被省略或替换为 any 。
* 该包将无法生成该包的文档，或者生成的文档中将省略“Slow Types”或丢失详细信息。

:::

### 什么是 "Slow Types"?

当函数、变量或接口从包中导出，并且其类型未显式写入，或者过于复杂以至于无法简单推断时，就会出现“Slow Types”。

例子：

```ts
// 这个函数有问题，因为没有显式地编写返回类型，因此必须从函数体中推断。
export function foo() {
  return Math.random().toString()
}
```

```ts
const foo = 'foo'
const bar = 'bar'
export class MyClass {
  // 这个属性是有问题的，因为没有显式地编写类型，因此必须从初始化项推断出它。
  prop = `${foo} ${bar}`
}
```

包内部的Slow Types（即未导出）对于 JSR 和包的使用者来说不会有问题。

### TypeScript 限制

本节列出了“no slow types”策略对 TypeScript 代码施加的所有限制：

1. 所有导出的函数、类、变量和类型都必须具有显式类型。例如，函数应具有显式返回类型，类应具有显式属性类型。
2. 不得使用模块增强和全局增强。
   这意味着包不能使用 `declare global` 、 `declare module` 或 `export as namespace` 来扩大全局范围或其他模块。
3. 不得使用 CommonJS 功能。这意味着包不能使用 `export =` 或 `import foo = require("foo")` 。
4. 导出函数、类、变量和类型中的所有类型都必须是简单推断或显式的。
   如果表达式太复杂而无法推断，则应将其类型显式分配给中间类型。
5. 不支持导出中的解构。单独导出每个符号，而不是解构。
6. 类型不得引用类的私有字段。

#### 显式类型

从包导出的所有符号都必须显式指定类型。例如，函数应该有一个显式的返回类型：

```ts
export function add(a: number, b: number) { // [!code --]
export function add(a: number, b: number): number {  // [!code ++]
  return a + b;
}
```

类的属性应该有明确的类型：

```ts
export class Person {
  name // [!code --]
  age // [!code --]
  name: string // [!code ++]
  age: number // [!code ++]
  constructor(name: string, age: number) {
    this.name = name
    this.age = age
  }
}
```

#### 全局增强

不得使用模块增强和全局增强。
这意味着包不能使用 `declare global` 引入新的全局变量，或 `declare module` 来扩充其他模块。

以下是一些不受支持的代码示例：

```ts
declare global {
  const globalVariable: string
}
```

```ts
declare module 'some-module' {
  const someModuleVariable: string
}
```

#### CommonJS 特性

不得使用 CommonJS 功能。这意味着包不能使用 `export =` 或 `import foo = require("foo")` 。

使用 ESM 语法代替：

```ts
export = 5 // [!code --]
export default 5 // [!code ++]
```

```ts
import foo = require('foo') // [!code --]
import foo from 'foo' // [!code ++]
```

#### 类型必须是简单推断或显式的

导出函数、类、变量和类型中的所有类型都必须是简单推断或显式的。
如果表达式太复杂而无法推断，则应将其类型显式分配给中间类型。

例如，在以下情况下，默认导出的类型太复杂而无法推断，因此必须使用中间类型显式声明它：

```ts
class Class {}

export default {
  // [!code --]
  test: new Class(), // [!code --]
} // [!code --]
const obj: { test: Class } = {
  // [!code ++]
  test: new Class(), // [!code ++]
} // [!code ++]
// [!code ++]
export default obj // [!code ++]
```

或者使用 as 断言：

```ts
class Class {}

  export default {
    test: new Class(),
};  // [!code --]
} as { test: Class }; // [!code ++]
```

对于超类表达式，计算表达式并将其分配给中间类型：

```ts
interface ISuperClass {}

function getSuperClass() {
  return class SuperClass implements ISuperClass {}
}

export class MyClass extends getSuperClass() {} // [!code --]
const SuperClass: ISuperClass = getSuperClass() // [!code ++]
export class MyClass extends SuperClass {} // [!code ++]
```

#### 导出没有解构

不支持导出中的解构。不要使用解构，而是单独导出每个符号：

```ts
export const { foo, bar } = { foo: 5, bar: 'world' } // [!code --]
const obj = { foo: 5, bar: 'world' } // [!code ++]
export const foo: number = obj.foo // [!code ++]
export const bar: string = obj.bar // [!code ++]
```

#### 类型不得引用类的私有字段

在推断过程中，类型不得引用类的私有字段。

在此示例中，公共字段引用私有字段，这是不允许的。

```ts
export class MyClass {
  prop!: typeof MyClass.prototype.myPrivateMember // [!code --]
  private myPrivateMember!: string // [!code --]
  prop!: MyPrivateMember // [!code ++]
  private myPrivateMember!: MyPrivateMember // [!code ++]
}

type MyPrivateMember = string // [!code ++]
```

## package 分数

JSR 分数是 JSR 根据指示包质量的某些因素自动分配给每个包的度量标准。
该分数用于对搜索结果中的软件包进行排名，帮助用户一目了然地了解软件包的质量。

JSR 分数是 0 到 100 之间的百分比，根据 4 个高级类别的因素计算得出：

* **文档**：存在自述文件、模块文档以及公共函数和类型的文档。
* **最佳实践**：包不应使用 SLow Types ，并且应随包来源一起发布。
* **可发现性**：包应该有一个描述，以帮助用户通过搜索找到包。
* **兼容性**：包应该至少有一个在包页面的“运行时兼容性”部分标记为“兼容”的运行时。
  此外，软件包因具有多个兼容运行时而受到奖励。

每个类别都有不同的影响分数的具体因素。每个因素的权重都不同。

---

---
url: /article/xb4woxjg/index.md
---
# 有用的工具列表
## 浏览器插件

* [Vue.js devtools](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?) 顾名思义，非常有用的浏览器 vue开发调试插件
* [React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi) React 开发调试插件
* [Octotree - GitHub code tree](https://chrome.google.com/webstore/detail/octotree-github-code-tree/bkhaagjahfmjljalopjnoealnfndnagc) 对github仓库的文件tree生成侧边栏，方便在线查阅浏览/跳转
* [XPath Helper](https://chrome.google.com/webstore/detail/xpath-helper/hgimnogjllphhhkhlmebbmlgjoejdpjl) 提取当前网站选中的 DOM 元素的 XPath，做埋点测试之类时有用

## cli开发

* [commander](https://www.npmjs.com/package/commander) 完整的命令行解决方案
* [cac](https://www.npmjs.com/package/cac) 轻量级的用于构建cli工具的解决方案

***

* [minimist](https://www.npmjs.com/package/minimist) 命令行参数解析工具
* [yargs](https://www.npmjs.com/package/yargs) 命令行参数解析工具

***

* [Inquirer](https://www.npmjs.com/package/inquirer) 交互式命令行工具
* [prompt](https://www.npmjs.com/package/prompt) 命令行 对话工具

***

* [shelljs](https://www.npmjs.com/package/shelljs) shell调用工具

* [execa](https://www.npmjs.com/package/execa) shell 调用工具

* [chalk](https://www.npmjs.com/package/chalk) node终端输出美化工具

* [ora](https://www.npmjs.com/package/ora) 终端 loading 工具

* [chokidar](https://www.npmjs.com/package/chokidar) 文件监听工具

* [is-ci](https://www.npmjs.com/package/is-ci) 检查当前环境是否是集成环境

## Http server

* [express](http://expressjs.com/)
* [connect](https://github.com/senchalabs/connect)
* [koa](https://koajs.com/)
* [fastify](https://www.fastify.io/)

## Server Framework

* [Nestjs](https://nestjs.com/) 类Spring boot的 Node端开发框架

* [Next.js](https://nextjs.org/) React 应用开发框架

* [Nuxt.js](https://nuxtjs.org/) Vue 应用开发框架

* [Think.js](https://thinkjs.org/) Node端开发框架

* [Egg.js](https://www.eggjs.org/index) 阿里开源的Node端开发框架

## VSCode 插件

### 皮肤

* [One Dark Pro](https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme) 个人觉得非常耐看，好用，舒服的一个皮肤。
* [Material Icon Theme](https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme) 非常全面又好看的文件图标主题

### 辅助开发

* [IntelliCode](https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode) 辅助代码提示
* [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker) 拼写检查插件
* [Error Lens](https://marketplace.visualstudio.com/items?itemName=usernamehw.errorlens) 用更友好更直观的方式，将错误信息显示出来
* [Better Comments](https://marketplace.visualstudio.com/items?itemName=aaron-bond.better-comments) 更加友好的注释高亮
* [Bracket Pair Colorizer](https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer) 代码缩进高亮
* [Import Cost](https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost) 显示包体积
* [Todo Tree](https://marketplace.visualstudio.com/items?itemName=Gruntfuggly.todo-tree) TODO注释高亮
* [indent-rainbow](https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow) 缩进高亮标识
* [Path Intellisense](https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense) 文件路径提示
* [TypeScript Hero](https://marketplace.visualstudio.com/items?itemName=rbbit.typescript-hero) typescript 辅助开发工具

***

* [any-rule](https://marketplace.visualstudio.com/items?itemName=russell.any-rule) 正则表达式大全

***

* [Rest Client](https://marketplace.visualstudio.com/items?itemName=humao.rest-client) 类 Postman 的 Rest工具

## 测试工具

### assertion

* [chai](https://www.npmjs.com/package/chai)
* [should](https://www.npmjs.com/package/should)

### unit

* [jest](https://www.npmjs.com/package/jest)
* [ava](https://www.npmjs.com/package/ava)
* [mocha](https://www.npmjs.com/package/mocha)
* [karma](https://www.npmjs.com/package/karma)
* [tape](https://www.npmjs.com/package/tape)
* [@vue/test-utils](https://www.npmjs.com/package/@vue/test-utils)

### 2e2

* [nightwatch](https://www.npmjs.com/package/nightwatch)
* [cypress](https://www.npmjs.com/package/cypress)

## GIT相关

* [@commitlint/cli](https://www.npmjs.com/package/@commitlint/cli)
* [@commitlint/config-conventional](https://www.npmjs.com/package/@commitlint/config-conventional)
* [commitizen](https://www.npmjs.com/package/commitizen)
* [conventional-changelog-cli](https://www.npmjs.com/package/conventional-changelog-cli)
* [cz-conventional-changelog](https://www.npmjs.com/package/cz-conventional-changelog)
* [husky](https://www.npmjs.com/package/husky)
* [lint-staged](https://www.npmjs.com/package/lint-staged)

## 其他

* [Slidev](https://github.com/slidevjs/slidev) 为开发者打造的演示文稿工具
* [loupe](http://latentflip.com/loupe/) 代码执行流程可视化

---

---
url: /article/xhb2iacu/index.md
---
# 前端路由
在现代前端中，SPA应用是一种主流的前端应用交互方案，其中，前端路由是实现SPA应用的关键技术之一。

## 路由

**路由（Router）** 一般指的是 URI 中 pathname + basename + hash + query 所组成的 路径。

在前端中， **路由** 一般指的是 **随着浏览器中的地址栏的变化，呈现不同的内容给用户**。
浏览器地址栏的变化，即是 访问链接的变化，具体指的就是 pathname + basename + hash + query 部分的变化。

示例：

```
/a/b
/a/b/#/hash
/a/b/#/hash?c=1
```

对于前端路由，一般会选择 监听 hash 部分的变化， 或者监听 pathname 部分的变化，从而一般有两种路由模式：

### hash 模式

通过监听 地址栏中 hash 部分的变化，从而呈现不同的内容。

::: center
**<https://example.com/index.html> ==#/a/b/==**
:::

在浏览器中，通过注册 **hashchange** 事件，监听 **hash** 变化。

```js
window.addEventListener('hashchange', () => {
  const hash = window.location.hash
  console.log(hash) // #/a/b/
})
```

通过 hash 实现路由的优势在于， hash 仅依赖于浏览器，且hash的变化不会直接导致页面刷新，天然适合于实现 前端路由。

### history 模式

通过监听 地址栏中 pathname 部分的变化，从而呈现不同的内容。

history模式是依赖于 浏览器端的 History API 而实现。
History API 允许我们对浏览器会话历史记录进行访问并操作。

::: center
**<https://example.com> ==/a/b/==**
:::

History API 通过 history.pushState() 和 history.replaceState() 方法，新增或者替换历史记录，
通过 popState 事件监听历史记录的变化。

直接操作历史记录的变化，结果会改变浏览器地址栏的显示内容，但不会引起浏览器刷新页面。
但是由于变化的部分一般是 `pathname + basename` 的部分，如果手动刷新页面，可能会导致浏览器通过当前路径
向服务器发起请求找不到对应的资源而返回404，所以一般需要在服务器端的HTTP服务器进行配置，将相关的路径请求资源，
都指向同一个html资源文件。

> [History API](https://developer.mozilla.org/zh-CN/docs/Web/API/History_API)

### 其他模式

除了上述两种一般用于浏览器端中的路由模式，为了满足其他的场景，比如 在SSR场景下，需要在服务端模拟路由在生成页面内容，
或者在 electron 桌面应用中。一般会基于 memory 实现一种 仅通过 memory 的变化的路由的模式。

在这个模式中，通过一个普通的 JavaScript 字符串或者对象，来实现模拟 路由路径地址以及相关功能。

## Router解析

前端路由在不同的库或者框架中实现，一般会采用一套通用的解析规则，在实现细节上有所差异。

一个路由地址，一般包含如下几个部分：

* **path** 表示路由的路径
* **params** 表示路由的路径动态匹配结果
* **query** 表示路由携带的参数，未解析前为 queryString, 解析后为 queryObject

如一个 路由地址： `/a/b/?c=1` 中， `/a/b/` 部分一般称为 **path** ， `?c=1` 部分一般被称为 `query`。

### 具名路由

具名路由，也称 静态路由 指在声明一个路由时，对地址栏路径地址使用 全等匹配，仅当声明的路由与路径地址全等时，才命中路由。

```js
// 浏览器地址栏： https://example.com/a/b/
// 声明路由：
const routes = [
  {
    path: '/a/b', // 命中当前路由
  },
  {
    path: '/a/c', // 不一致，未命中
  },
  {
    path: '/a', // 不一致，未命中
  },
  {
    path: '/a/b/c', // 不一致，未命中
  },
]
```

### 路由匹配

路由匹配，指通过 一套匹配规则，对地址栏路径地址 进行 规则匹配，当命中匹配规则时，则命中路由。
一般场景下， 通过 `/:pathname` 的格式来表示路由路径中的动态部分。

如 `/user/:id`， 则可以匹配 `/user/123`，`/user/456` 等满足规则的地址栏路径。

`/:pathname` 部分会被解析到 `params` 对象中，如上述的 通过`/user/:id`规则解析 `/user/123`，表示为：

```js
const currentRoute = {
  path: '/user/123',
  params: { id: 123 },
}
```

### 其他

在不同的框架或库中， 对路由解析会在基于上述的规则的基础上，进行补充和扩展，提供更加丰富的功能，以满足更多的场景。

比如， **Vue-Router** 使用了 `path-to-regexp` 库作为其路由解析的依赖，该库提供了非常丰富且灵活的路径匹配功能，
能够适配非常多的从简单到复杂的场景。**React-Router** 则在其内部实现了和扩展了相关的规则。

---

---
url: /article/xqniz7cb/index.md
---
# View Transitions API：打造丝滑流畅的页面动画
在现代 Web 开发中，流畅的页面过渡效果能够显著提升用户体验。View Transitions API 是一个革命性的浏览器原生 API，它让创建复杂的页面过渡动画变得前所未有的简单。本文将带你从零开始，全面掌握这个强大的 API。

## 什么是 View Transitions API？

View Transitions API 是一个新的 Web 标准，它提供了一种声明式的方法来创建页面之间的平滑过渡动画。想象一下，当你在相册应用中切换图片时，图片会平滑地从一个位置过渡到另一个位置——View Transitions API 让这样的效果变得轻而易举。

:::info 核心优势

* **简化复杂动画**：以前需要大量 JavaScript 和 CSS 的动画，现在几行代码就能实现
* **性能优化**：浏览器原生支持，性能远超 JavaScript 实现的动画
* **跨文档过渡**：支持单页应用和多页应用中的页面过渡
* **自动状态捕获**：浏览器自动处理前后状态的快照
  :::

## 基础用法

### 1. 启用 View Transitions

要使用 View Transitions API，首先需要检查浏览器支持情况：

```javascript
// 检查浏览器支持
if (document.startViewTransition) {
  // 浏览器支持 View Transitions API
}
else {
  // 降级方案
  console.log('View Transitions API 不被支持')
}
```

### 2. 基本页面过渡

最简单的用法是在页面导航时添加过渡效果：

```javascript
// 拦截导航事件
document.addEventListener('click', (event) => {
  const link = event.target.closest('a')
  if (!link)
    return

  // 如果是站内链接
  if (link.href && link.origin === location.origin) {
    event.preventDefault()

    // 开始视图过渡
    document.startViewTransition(() => {
      // 导航到新页面
      location.href = link.href
    })
  }
})
```

### 3. 单页应用中的使用

在单页应用（SPA）中，View Transitions API 可以创建更精细的过渡效果：

```javascript
// 假设我们有一个简单的 SPA 路由
async function navigateTo(url) {
  // 开始视图过渡
  const transition = document.startViewTransition(async () => {
    // 获取新内容
    const response = await fetch(url)
    const html = await response.text()

    // 更新页面内容
    document.body.innerHTML = html
  })

  // 等待过渡完成
  await transition.finished
  console.log('过渡完成！')
}
```

## 深入理解过渡过程

View Transitions API 的过渡过程分为几个关键阶段：

:::steps

* **捕获快照**：浏览器捕获当前页面的快照
* **更新 DOM**：执行你提供的回调函数来更新页面
* **捕获新快照**：浏览器捕获更新后页面的快照
* **执行动画**：浏览器在两个快照之间执行过渡动画

:::

## 自定义过渡动画

### 1. 使用 CSS 自定义动画

View Transitions API 的强大之处在于可以使用 CSS 完全自定义动画效果：

```css
/* 为所有视图过渡设置基础样式 */
::view-transition-old(root) {
  animation: 0.5s ease-out both fade-out;
}

::view-transition-new(root) {
  animation: 0.5s ease-out both fade-in;
}

@keyframes fade-out {
  from {
    opacity: 1;
    transform: translateY(0);
  }
  to {
    opacity: 0;
    transform: translateY(20px);
  }
}

@keyframes fade-in {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}
```

### 2. 为特定元素创建命名过渡

你可以为页面中的特定元素创建独立的过渡效果：

```javascript
// 更新特定元素的过渡名称
function updateElementWithTransition(element, newContent) {
  // 为元素设置唯一的过渡名称
  element.style.viewTransitionName = 'special-element'

  document.startViewTransition(() => {
    element.innerHTML = newContent
  }).finished.then(() => {
    // 过渡完成后清除名称
    element.style.viewTransitionName = 'none'
  })
}
```

然后在 CSS 中定义这个命名过渡：

```css
::view-transition-old(special-element) {
  animation: 0.3s both slide-out;
}

::view-transition-new(special-element) {
  animation: 0.3s both slide-in;
}

@keyframes slide-out {
  to {
    transform: translateX(-100%);
    opacity: 0;
  }
}

@keyframes slide-in {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
}
```

## 高级特性

### 1. 共享元素过渡

共享元素过渡是 View Transitions API 最强大的功能之一，它允许元素在不同页面间平滑移动：

```javascript
// 为图片元素设置过渡名称
function setupImageTransitions() {
  const images = document.querySelectorAll('.gallery-image')

  images.forEach((img, index) => {
    // 为每个图片设置唯一的过渡名称
    img.style.viewTransitionName = `image-${index}`

    img.addEventListener('click', () => {
      // 在详情页使用相同的过渡名称
      document.startViewTransition(() => {
        // 导航到详情页
        showImageDetail(img.src, `image-${index}`)
      })
    })
  })
}
```

### 2. 控制过渡时序

你可以精确控制过渡的时序和分组：

```css
::view-transition-group(special-element) {
  /* 控制整个过渡组的动画时长 */
  animation-duration: 0.8s;
}

::view-transition-image-pair(special-element) {
  /* 控制新旧图片对的隔离行为 */
  isolation: auto;
}
```

## 实际应用示例

### 1. 图片画廊

让我们创建一个完整的图片画廊过渡示例：

::: code-tabs
@tab HTML

```html title="gallery.html"
<div class="gallery">
  <img src="image1.jpg" class="gallery-item" data-id="1">
  <img src="image2.jpg" class="gallery-item" data-id="2">
  <img src="image3.jpg" class="gallery-item" data-id="3">
</div>
```

@tab JavaScript

```javascript title="gallery.js"
document.addEventListener('DOMContentLoaded', () => {
  const galleryItems = document.querySelectorAll('.gallery-item')

  galleryItems.forEach((item) => {
    item.addEventListener('click', async () => {
      const imageId = item.getAttribute('data-id')

      // 设置过渡名称
      item.style.viewTransitionName = `gallery-image-${imageId}`

      await document.startViewTransition(async () => {
        // 导航到详情页
        await showImageDetail(imageId)

        // 在详情页设置相同的过渡名称
        const detailImage = document.querySelector('#detail-image')
        detailImage.style.viewTransitionName = `gallery-image-${imageId}`
      }).finished

      // 清理过渡名称
      item.style.viewTransitionName = 'none'
    })
  })
})
```

@tab CSS

```css title="gallery.css"
/* 画廊样式 */
.gallery {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
}

.gallery-item {
  width: 100%;
  height: 200px;
  object-fit: cover;
  cursor: pointer;
  border-radius: 8px;
}

/* 过渡动画 */
::view-transition-old(gallery-image-1),
::view-transition-old(gallery-image-2),
::view-transition-old(gallery-image-3) {
  animation: 0.4s both scale-out;
}

::view-transition-new(gallery-image-1),
::view-transition-new(gallery-image-2),
::view-transition-new(gallery-image-3) {
  animation: 0.4s both scale-in;
}

@keyframes scale-out {
  to {
    transform: scale(0.8);
    opacity: 0;
  }
}

@keyframes scale-in {
  from {
    transform: scale(1.2);
    opacity: 0;
  }
}
```

:::

### 2. 列表到详情过渡

另一个常见的使用场景是列表项到详情页的过渡：

```javascript
// 列表项点击处理
function setupListTransitions() {
  const listItems = document.querySelectorAll('.list-item')

  listItems.forEach((item, index) => {
    item.style.viewTransitionName = `item-${index}`

    item.addEventListener('click', () => {
      document.startViewTransition(async () => {
        // 显示详情
        await showItemDetail(item.dataset.id)

        // 在详情页设置过渡名称
        const detailElement = document.querySelector('.detail-content')
        detailElement.style.viewTransitionName = `item-${index}`
      })
    })
  })
}
```

## 性能优化和最佳实践

### 1. 性能考虑

:::warning 性能提示

* **避免过度使用**：不是所有的页面变化都需要过渡效果
* **注意内存使用**：快照会占用内存，特别是在移动设备上
* **测试降级方案**：确保在不支持的浏览器中页面仍能正常工作
  :::

### 2. 降级方案

```javascript
function safeViewTransition(updateCallback) {
  if (document.startViewTransition) {
    return document.startViewTransition(updateCallback)
  }
  else {
    // 直接执行更新，没有过渡效果
    updateCallback()
    return {
      finished: Promise.resolve(),
      ready: Promise.resolve(),
      updateCallbackDone: Promise.resolve()
    }
  }
}

// 使用安全的过渡函数
safeViewTransition(() => {
  // 更新页面内容
  updateContent()
})
```

### 3. 可访问性考虑

```css
/* 为偏好减少动画的用户提供支持 */
@media (prefers-reduced-motion: reduce) {
  ::view-transition-group(*),
  ::view-transition-old(*),
  ::view-transition-new(*) {
    animation: none !important;
  }
}
```

## 常见问题解答

### Q: View Transitions API 支持哪些浏览器？

**A:** 目前 Chrome/Edge 111+ 和 Opera 98+ 支持，其他浏览器正在逐步支持中。

### Q: 可以在 iframe 中使用吗？

**A:** 目前 iframe 中的 View Transitions 支持有限，建议在主文档中使用。

### Q: 过渡过程中可以取消吗？

**A:** 是的，你可以使用 `transition.skipTransition()` 来取消进行中的过渡。

## 总结

View Transitions API 为 Web 开发带来了革命性的页面过渡体验。通过本文的学习，你应该已经掌握了：

* \==基础使用方法=={.success}：如何使用 `document.startViewTransition()` 创建基本过渡
* \==自定义动画=={.info}：通过 CSS 伪元素完全控制过渡效果
* \==高级特性=={.important}：共享元素过渡、命名过渡等高级用法
* \==实际应用=={.tips}：在图片画廊、列表详情等场景中的具体实现
* \==最佳实践=={.warning}：性能优化、降级方案和可访问性考虑

## 参考

* [MDN View Transitions API 文档](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API)
* [Chrome Developers 官方指南](https://developer.chrome.com/docs/web-platform/view-transitions/)
* [View Transitions API 示例集合](https://github.com/argyleink/view-transitions-api-examples)

---

---
url: /article/xu1kn104/index.md
---
# CSS 使用 initial / unset / revert 重置样式
## 前言

你是否有过这样的需求：想彻底清掉某个元素继承来或者自己设置的样式？想让某个属性回到浏览器默认的样子？
想穿越层层叠叠的 CSS 规则，直接回到浏览器最原始的状态？

你可能会想到使用 `!important` 或者 写一堆覆写规则。

但其实 CSS 早已准备好了三个关键词来帮你做这件事：`initial`、`unset`、`revert`。

## 继承与默认值

`initial`、`unset`、`revert` 三个关键词长得像，作用也像（都是 “重置”） ，但背后的逻辑却是不同的。
在理解这三个值之前，我们需要了解两个基础的概念：**继承** 和 **初始值** 。

### 继承 (Inheritance)

**某些 CSS 属性（比如 `color`, `font-family`）会从父元素自动传递给子元素。**

这就是为什么你给 `body` 设置了颜色，里面的 `p`、`span` 通常也跟着变。

### 初始值 (Initial Value)

**每个 CSS 属性在规范里都定义了一个默认值。**
这个默认值跟你用什么浏览器、什么元素通常没有直接关系（注意，我说的是 **“通常”** ！）。

比如 `display` 的初始值是 `inline`，不管它是用在 `div` 还是 `span` 上，初始值都是 `inline`
（虽然浏览器默认给 `div` 的是 `block`，这稍后解释）。

[CSS Display Module Level 3 - **display initial**](https://www.w3.org/TR/css-display-3/#the-display-properties){.read-more}

### 浏览器的内置样式表

需要注意的是，**规范中定义的默认值，并不一定是在浏览器中的默认值**。

因为在浏览器中，还存在着内置的 **用户代理样式表（User Agent Stylesheet）** （UAS）。UAS 会根据其它的因素，
比如元素的类型等，来决定不同元素下的不同属性的默认值。

因此，虽然 CSS 规范中定义了 `display` 的默认值为 `inline` ， 但是在 `div` 上，它的实际默认值为 `block` 。
又如 `li` 的 `list-style`，作为 `ul` 或 `ol` 的子元素时，它的默认值也不一样。

![uas div](/images/css/uas-div.png)

::: info 在开始前，我们先做一些前置的名词定义

* **作者样式表**：指网站的作者自己写的样式表，这也可能包含了用户使用其它工具修改覆盖的样式。
* **浏览器默认样式**：即 用户代理样式表（User Agent Stylesheet）。
* **规范初始值**：指 CSS 规范中定义的初始值。

:::

## `initial`

`initial` 相当于 ==恢复出厂设置==，其作用是，**将属性的值重置为 CSS 规范中定义的初始值**。

`initial` 完全无视元素的类型、继承性、以及任何之前设置的样式规则（包括 作者样式表 和 浏览器默认样式），
强制将属性设置为它的 **规范初始值**。

举个例子：

```css
div {
  display: block; /* 浏览器默认给div的 */
  color: red;     /* 我们自己设置的 */
  font-weight: bold; /* 我们自己设置的 */
  border: 1px solid blue; /* 我们自己设置的 */
}

.my-reset-div {
  display: initial; /* 规范里 display 的初始值是 'inline'！ */
  color: initial;   /* 规范里 color 的初始值是 'black' */
  font-weight: initial; /* 规范里 font-weight 的初始值是 'normal' */
  border: initial;  /* 规范里 border 的初始值是 'none' (各个分属性初始值的组合) */
}
```

我们来看看它会有什么表现：(背景色加以区分，便于理解)

:::: demo normal expanded

::: code-tabs

@tab CSS

```css
div {
  display: block;
  color: red;
  font-weight: bold;
  border: 1px solid blue;
  background-color: yellow;
}

.my-reset-div {
  display: initial;
  color: initial;
  font-weight: initial;
  border: initial;
}
```

@tab HTML

```html
<div>我是没有 Reset 的 div</div>
<br>
<div class="my-reset-div">我是有 Reset 的 div</div>
```

:::
::::

可以看到，应用了 `.my-reset-div` 后，这个 `div` 变成：

* display: inline (不再是 block)
* color: black (不再是 red)
* font-weight: normal (不再是 bold)
* border: none (蓝边框消失)

`initial` 对 `div` 的 `display` 重置成了 `inline`，而不是我们熟悉的 `block`。

**因为 `initial` 只认规范初始值！**

## `unset`

`unset` 的行为与 属性是否具有 **继承性** 有关：

* **可继承属性 (Inherited Property)**: 行为等同于 `inherit` 。值来自父元素。
* **不可继承属性 (Non-inherited Property)**: 行为等同于 `initial`。值重置为规范定义的初始值。

举个例子:

:::: demo normal expanded

::: code-tabs

@tab CSS

```css
body {
  color: darkblue;
  font-size: 18px;
}
div {
  display: block; /* 浏览器默认 */
  color: red;     /* 覆盖继承 */
  border: 2px dashed green; /* 新增 */
  padding: 20px; /* 新增 */
}
.unset-example {
  color: unset;      /* color可继承 -> 行为像 inherit, 变成 body 的 darkblue */
  border: unset;     /* border不可继承 -> 行为像 initial, 变成规范初始值 'none' */
  padding: unset;    /* padding不可继承 -> 行为像 initial, 变成规范初始值 0 */
  display: unset;    /* display不可继承 -> 行为像 initial, 变成规范初始值 'inline' */
  font-size: unset;  /* font-size可继承 -> 行为像 inherit, 变成 body 的 18px */
}
```

@tab HTML

```html
<div class="unset-example">这个div的样式被unset了！</div>
```

:::

::::

对元素应用 `.unset-example` 后，这个 `div` 变成:

* color: darkblue (继承自 body，因为 color 可继承)
* border: none (不可继承，回到初始值)
* padding: 0 (不可继承，回到初始值)
* display: inline (不可继承，回到初始值 `inline` - 不再是 `block`！)
* font-size: 18px (继承自 body，因为可继承)

**注意 `display` 又变成了 `inline`！`unset` 对不可继承属性也是回到规范初始值。**

## `revert`

`revert` 让属性 **回到浏览器默认的样式**。

它是层级最高的重置：

1. 首先： 移除所有作者样式表对该属性设置的影响。
2. 然后： 看浏览器默认样式表 (User Agent Stylesheet) 对这个特定元素有没有定义该属性的值。如果有，就用这个值。
3. 最后： 如果浏览器默认样式表也没定义，那就回退到该属性的规范初始值 (Initial Value)。

**这是唯一一个会回到浏览器默认样式表的值！**

举个例子：

:::: demo normal expanded
::: code-tabs

@tab CSS

```css
button {
  all: unset; /* 先粗暴地清掉浏览器默认button样式 */
  background: lightgray;
  border: none;
  padding: 5px 15px;
  border-radius: 4px;
  cursor: pointer;
}
.native-button {
  all: revert; /* 魔法！让这个按钮变回浏览器默认样式 */
}
```

@tab HTML

```html
<button>被自定义样式的按钮</button>

<button class="native-button">被 revert 还原的按钮</button>
```

:::
::::

在这个例子中：

* 第一个按钮被我们的自定义 CSS 改造成了灰色无边框圆角按钮。
* 第二个按钮应用了 `.native-button { all: revert; }`。`all: revert` 表示将这个元素所有 CSS 属性都重置到浏览器默认或规范初始值。
  * revert 会移除我们写的 `background`, `border`, `padding`, `border-radius`, `cursor` 等所有自定义样式。
  * 然后，它发现 `button` 在浏览器默认样式表里是有特定样式的（比如背景渐变、边框、字体、内边距、鼠标手型等），于是恢复这些浏览器默认样式。
  * 最终效果：第二个按钮又变回了你操作系统/浏览器原生的那个按钮样子！

**这才是我们通常理解的 “重置到默认” 。**

revert 让 div 的 `display` 变回 `block`，让 `li` 重新出现项目符号，让 `button` 变回原生按钮。

***

好的，这篇博客就来聊聊 CSS 里那几个看起来有点像、但用起来大不同的“魔法值”：`initial`、`unset` 和 `revert`。它们都是用来“重置”样式的，但重置的目标和范围可大不一样。搞懂它们，能让你在控制样式继承和重置时事半功倍！

## 比较

| 值            | 主要目标                        | 是否尊重继承性？           | 是否尊重浏览器默认样式？ | 典型用例                                       |
| :------------ | :------------------------------ | :------------------------- | :----------------------- | :--------------------------------------------- |
| **`initial`** | **规范初始值**                  | ❌ 强制设为初始值，无视继承 | ❌ 无视浏览器默认样式     | 需要彻底、绝对地重置到最原始状态               |
| **`unset`**   | **依赖继承性**                  | ✅ 根据属性是否可继承决定   | ❌ 无视浏览器默认样式     | 智能地撤销设置，让属性自然继承或回初始值       |
| **`revert`**  | **浏览器默认值 (或规范初始值)** | ✅ 最终效果由浏览器默认决定 | ✅ 首先尊重浏览器默认样式 | 真正地“重置到浏览器默认外观”，移除作者样式影响 |

## 使用建议

* 如果需要重置回浏览器默认样式，应该使用 `revert`。
  （特别是配合 `all: revert` 一起使用，可以直接将元素重置回浏览器默认样式）
  这是最符合直觉的重置到“默认” 。
* 如果需要撤销样式，让属性跟随其父元素（如果可继承），或回到初始值（如果不可继承），应该使用 `unset`。
* 如果需要彻底重置，让属性回到最原始状态（通常比较激进），应该使用 `initial`

::: tip `all` 属性
`all: initial` / `all: unset` / `all: revert` 可以一次性重置元素的所有（或几乎所有）CSS 属性到对应的状态，非常强力。常用于创建样式隔离区域或深度重置。
:::

---

---
url: /article/y2lpax2i/index.md
---
# 深入理解 JWT 身份验证
在现代 Web 应用中，身份验证是保障应用安全的核心环节。JSON Web Token（JWT）作为一种轻量级、自包含的身份验证方案，因其简洁性和易用性在前端开发中广受欢迎。本文将从前端开发者的角度，深入探讨 JWT 的工作原理、实现方式以及最佳实践。

## 什么是 JWT？

JWT（JSON Web Token）是一个开放标准（RFC 7519），用于在各方之间安全地传输信息作为 JSON 对象。这些信息可以被验证和信任，因为它们是数字签名的。

### JWT 的结构

一个典型的 JWT 由三部分组成，用点号分隔：

```
Header.Payload.Signature
```

让我们通过代码示例详细了解每个部分：

```javascript
// 一个实际的 JWT 示例
const jwt = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c'
```

::: code-tabs
@tab Header

```json
// Header 解码后
{
  "alg": "HS256", // 签名算法
  "typ": "JWT" // token 类型
}
```

@tab Payload

```json
// Payload 解码后
{
  "sub": "1234567890", // 用户标识
  "name": "John Doe", // 用户信息
  "iat": 1516239022 // 签发时间
}
```

@tab Signature

```javascript
// Signature 生成方式
HMACSHA256(
  `${base64UrlEncode(header)}.${base64UrlEncode(payload)}`,
  secret
)
```

:::

## JWT 在前端的工作流程

JWT 身份验证的典型流程如下：

:::steps

1. **用户登录** - 用户提交凭据到认证服务器
2. **服务器验证** - 服务器验证凭据并生成 JWT
3. **返回 Token** - 服务器将 JWT 返回给客户端
4. **存储 Token** - 前端安全地存储 JWT
5. **发送请求** - 前端在后续请求中包含 JWT
6. **服务器验证** - 服务器验证 JWT 并返回数据

:::

### 前端实现示例

让我们看看如何在前端应用中实现 JWT 认证：

```javascript title="authService.js"
class AuthService {
  constructor() {
    this.token = localStorage.getItem('jwt_token')
  }

  // 登录方法
  async login(credentials) {
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(credentials),
      })

      if (!response.ok) {
        throw new Error('登录失败')
      }

      const { token, user } = await response.json()
      this.setToken(token)
      return user
    }
    catch (error) {
      console.error('登录错误:', error)
      throw error
    }
  }

  // 设置 token
  setToken(token) {
    this.token = token
    localStorage.setItem('jwt_token', token)
  }

  // 获取 token
  getToken() {
    return this.token
  }

  // 验证 token 是否有效
  isTokenValid() {
    if (!this.token)
      return false

    try {
      const payload = JSON.parse(atob(this.token.split('.')[1]))
      const currentTime = Date.now() / 1000
      return payload.exp > currentTime
    }
    catch {
      return false
    }
  }

  // 登出
  logout() {
    this.token = null
    localStorage.removeItem('jwt_token')
  }
}
```

## JWT 存储策略

选择合适的 JWT 存储方式对应用安全至关重要：

### 1. LocalStorage（简单但不安全）

```javascript
// 存储
localStorage.setItem('jwt_token', 'your_token')

// 读取
const token = localStorage.getItem('jwt_token')
```

:::warning 安全风险
LocalStorage 容易受到 XSS 攻击，攻击者可以通过注入的脚本直接读取 token。
:::

### 2. HttpOnly Cookies（推荐）

```javascript
// 登录请求
async function login(credentials) {
  const response = await fetch('/api/auth/login', {
    method: 'POST',
    credentials: 'include', // 重要：包含 cookies
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(credentials),
  })
  return response.json()
}

// 自动发送请求（cookie 会自动包含）
async function fetchUserData() {
  const response = await fetch('/api/user', {
    credentials: 'include',
  })
  return response.json()
}
```

### 3. 内存存储（高安全要求）

```javascript
class SecureAuthService {
  constructor() {
    this.token = null
  }

  // 只在内存中保存 token
  setToken(token) {
    this.token = token
  }

  // 页面刷新时重新登录
  async ensureAuthenticated() {
    if (!this.token) {
      // 重定向到登录页或静默刷新
      await this.silentRefresh()
    }
  }
}
```

## 自动 token 刷新机制

为了避免用户频繁重新登录，实现自动 token 刷新：

```javascript title="tokenRefresh.js"
class TokenRefreshService {
  constructor(authService) {
    this.authService = authService
    this.refreshTimeout = null
  }

  // 安排 token 刷新
  scheduleRefresh() {
    if (!this.authService.isTokenValid()) {
      return
    }

    const payload = this.authService.getTokenPayload()
    const expiresIn = payload.exp * 1000 - Date.now()
    const refreshTime = expiresIn - (5 * 60 * 1000) // 提前 5 分钟刷新

    if (this.refreshTimeout) {
      clearTimeout(this.refreshTimeout)
    }

    this.refreshTimeout = setTimeout(() => {
      this.refreshToken()
    }, Math.max(0, refreshTime))
  }

  // 刷新 token
  async refreshToken() {
    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        credentials: 'include',
      })

      if (response.ok) {
        const { token } = await response.json()
        this.authService.setToken(token)
        this.scheduleRefresh() // 重新安排下一次刷新
      }
      else {
        this.authService.logout()
        window.location.href = '/login'
      }
    }
    catch (error) {
      console.error('Token 刷新失败:', error)
      this.authService.logout()
    }
  }
}
```

## 请求拦截器实现

为了自动在请求中添加 JWT，我们可以实现请求拦截器：

```javascript title="apiClient.js"
class ApiClient {
  constructor(authService) {
    this.authService = authService
    this.baseURL = process.env.REACT_APP_API_URL
  }

  // 通用请求方法
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`
    const config = {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
      ...options,
    }

    // 自动添加认证头
    if (this.authService.isTokenValid()) {
      config.headers.Authorization = `Bearer ${this.authService.getToken()}`
    }

    try {
      const response = await fetch(url, config)

      // 处理 401 未授权响应
      if (response.status === 401) {
        await this.handleUnauthorized()
        return this.request(endpoint, options) // 重试请求
      }

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      return await response.json()
    }
    catch (error) {
      console.error('API 请求错误:', error)
      throw error
    }
  }

  // 处理未授权情况
  async handleUnauthorized() {
    try {
      await this.authService.refreshToken()
    }
    catch {
      this.authService.logout()
      window.location.href = '/login'
    }
  }

  // 便捷方法
  get(endpoint) {
    return this.request(endpoint)
  }

  post(endpoint, data) {
    return this.request(endpoint, {
      method: 'POST',
      body: JSON.stringify(data),
    })
  }

  put(endpoint, data) {
    return this.request(endpoint, {
      method: 'PUT',
      body: JSON.stringify(data),
    })
  }

  delete(endpoint) {
    return this.request(endpoint, {
      method: 'DELETE',
    })
  }
}
```

## React 集成示例

在 React 应用中集成 JWT 认证：

```jsx title="AuthProvider.jsx"
import React, { createContext, useContext, useEffect, useState } from 'react'
import { AuthService, TokenRefreshService } from './services'

const AuthContext = createContext()

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null)
  const [loading, setLoading] = useState(true)

  const authService = new AuthService()
  const tokenRefreshService = new TokenRefreshService(authService)

  useEffect(() => {
    initializeAuth()
  }, [])

  async function initializeAuth() {
    if (authService.isTokenValid()) {
      try {
        const userData = await fetchUserData()
        setUser(userData)
        tokenRefreshService.scheduleRefresh()
      }
      catch (error) {
        await authService.logout()
      }
    }
    setLoading(false)
  }

  const login = async (credentials) => {
    const userData = await authService.login(credentials)
    setUser(userData)
    tokenRefreshService.scheduleRefresh()
    return userData
  }

  const logout = () => {
    authService.logout()
    setUser(null)
  }

  const value = {
    user,
    login,
    logout,
    isAuthenticated: !!user,
    loading,
  }

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth 必须在 AuthProvider 内使用')
  }
  return context
}
```

## 安全最佳实践

:::important JWT 安全要点

* \==始终使用 HTTPS=={.success} 传输 JWT
* \==设置合理的过期时间=={.info}（通常 15-30 分钟）
* \==使用强密钥=={.warning} 进行签名
* \==实现安全的 token 刷新机制=={.important}
* \==防范 CSRF 攻击=={.caution}（使用 SameSite cookies）
* \==定期轮换签名密钥=={.warning}
  :::

### 额外的安全措施

```javascript
// 添加额外的安全头
app.use((req, res, next) => {
  res.setHeader('X-Content-Type-Options', 'nosniff')
  res.setHeader('X-Frame-Options', 'DENY')
  res.setHeader('X-XSS-Protection', '1; mode=block')
  next()
})

// 速率限制防止暴力攻击
const rateLimit = require('express-rate-limit')
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 分钟
  max: 5, // 最多 5 次登录尝试
  message: '尝试次数过多，请稍后重试'
})
app.use('/api/auth/login', authLimiter)
```

## 常见问题与解决方案

### 1. Token 被盗用

:::caution 解决方案

* 实现 token 撤销列表
* 使用短期 token 配合刷新机制
* 监控异常访问模式
  :::

### 2. 跨域问题

```javascript
// CORS 配置
app.use(cors({
  origin: process.env.FRONTEND_URL,
  credentials: true, // 允许发送 cookies
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
}))
```

### 3. 移动端兼容性

```javascript
// 响应式认证处理
function getStorageMethod() {
  if (typeof window === 'undefined')
    return 'memory'
  if (window.cordova || window.Capacitor)
    return 'secureStorage'
  return 'httpOnly'
}
```

## 总结

JWT 为前端应用提供了简洁高效的身份验证方案，但正确实现需要考虑多个安全因素。关键要点包括：

* **选择合适的存储策略**：根据安全需求选择 HttpOnly Cookies 或内存存储
* **实现自动刷新机制**：提升用户体验同时保持安全性
* **遵循安全最佳实践**：HTTPS、合理过期时间、密钥管理等
* **错误处理**：完善的未授权处理和用户重定向

通过本文的介绍，你应该能够在前端应用中正确、安全地实现 JWT 身份验证。记住，安全是一个持续的过程，需要定期审查和更新你的实现。

## 参考

* [JWT 官方文档](https://jwt.io/)
* [OWASP 认证指南](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
* [RFC 7519 - JSON Web Token](https://tools.ietf.org/html/rfc7519)

---

---
url: /article/y979pp8x/index.md
---
# 表单配置化生成方案
一个简单的基于 vue3 的表单配置化生成方案，可以作为思路参考。

## 前言

本方案是个人在做某个项目时，需要实现一个简单的表单配置化生成，而做的一个方案。
最终结果是通过一份表单配置，渲染为一个表单，并支持：

* 支持多种表单字段类型 （单行文本/多行文本/数字/下拉/多选/单选 等），并支持嵌套字段（对象/数组）
* 支持字段校验
* 支持条件判断显示/隐藏 表单字段
* 支持字段分组展示

::: tip
完整代码仓库地址： [formative](https://github.com/pengzhanbo/formative)
:::

## 效果展示

**通过配置生成表单：**
![demo 1](/images/formative-demo-1.png)

**配置的字段为对象或者数组时：**
![demo 2](/images/formative-demo-2.png)

**对配置的字段进行分组展示：**
![demo 3](/images/formative-demo-3.png)

## 方案说明

通过配置生成表单，需要明确如何实现 **表单字段** 与对应的表单组件进行关联，并实现**数据绑定**。

### 协议配置

约定一个协议，通过一个对象来表示 表单中某一个字段：

**FieldSchema:**

```json
{
  "type": "表示字段的类型，比如单选、多选、单行文本、多行文本等",
  "field": "表示字段的名",
  "label": "表示字段显示的标签",
  "default": "字段默认值",
  "description": "字段描述信息，作为提示信息使用"
}
```

对于完整的表单，则使用 `FieldSchema[]` 的数组形式进行配置。

### 表单字段与组件关联

在 vue 中， 组件可以通过 `h(component, attrs[, children])` 渲染函数 进行渲染，
通过 `h()` 函数，可以实现动态渲染不同的组件。

我们可以利用这一特性，首先 字段类型与对应的组件进行映射，通过映射关系，用 字段类型获取对应的组件，
然后调用 `h()` 进行渲染。

```ts
// 字段类型 与 组件 映射
const componentMap = {
  radio: RadioField,
  checkbox: CheckboxField,
  text: TextField,
  select: SelectField,
}
```

```tsx
defineComponent({
  name: 'Field',
  props: ['fieldType'],
  setup(props) {
    return () => h(componentMap[props.fieldType])
  }
})
```

### 表单数据绑定

对于表单数据，需要实现 数据初始化，以及 对应的 Field组件对数据的可读写。

在vue中，我们可以使用 `provide/inject` API， 在 表单组件的根组件，通过 `provide()` 进行注入，在内部的
`FieldComponent` 中通过 `inject()` 获取对应的数据，进行读写。

```ts
/**
 * 通过 provide 输入数据
 */
function useFormDataProvide(formData: FormData): FormInjectKey {
  const key: FormInjectKey = Symbol('formData')
  provide(key, formData)

  return key
}

/**
 * 通过 inject 获取数据
 */
const useFormData = (key: FormInjectKey): FormData => inject<FormData>(key)!
```

由于需要支持 字段为对象/数组时产生的 多层级数据结构，还需要考虑 `FieldComponent` 对 `FormData.a.b` 的
深层数据的读写。

可以通过实现 `dotPath`， 通过 `FormData['a.b']` 的形式来读写 `FormData.a.b`，这样 `FieldComponent`
只需要知道 `a.b` 的 `dotPath` 字段路径即可配合 `inject()` 获取的表单数据进行读写。

```ts
function useDotPath<T = any>(model: FormData, dotKey: ComputedRef<string>) {
  const binding = computed<T>({
    set(data) {
      setDotPath(model.value, dotKey.value, data)
    },
    get() {
      return getDotPath(model.value, dotKey.value)
    },
  })

  return binding
}
```

## 技术实现

在 [formative](https://github.com/pengzhanbo/formative) 仓库中， 通过本方案实现了一个 配置化生成表单的库。

* `src/components/Formative.tsx` 文件作为表单根组件。
* `src/components/Field.tsx` 文件作为根据表单字段动态选择对应组件进行表单字段渲染。
* `src/components/Group.tsx` 文件实现了对表单字段进行分组。
* `src/components/[other].tsx` 其他文件实现了 各种表单字段组件。

有兴趣了解细节的，可以阅读 [formative 源码](https://github.com/pengzhanbo/formative)，
我在关键位置进行了相关的代码注释说明。

同时，你可以直接拉取 源码，在本地进行运行。并授权代码使用。

---

---
url: /article/z09dssz9/index.md
---
# JavaScript 进阶 二：闭包
闭包是 JavaScript 中一个既强大又容易让人困惑的概念。很多开发者虽然知道闭包的存在，但对它的理解往往停留在表面。本文将带您深入探索闭包的奥秘，从基础概念到高级应用，再到性能优化，让您真正掌握这个 JavaScript 的核心特性。

## 什么是闭包？

### 闭包的基本定义

:::tip 核心概念
闭包可以简单理解为：**一个函数和其词法环境的组合**。当一个函数能够记住并访问其词法作用域，即使函数在其词法作用域之外执行，这个函数就被称为闭包。
:::

在 JavaScript 中，函数在创建时会形成一个包含函数内部变量和外部环境的闭包。这意味着，闭包可以"记住"其创建时的上下文，并能在稍后调用时访问这些变量。

### 闭包的工作原理

要理解闭包的工作原理，我们首先需要理解 JavaScript 的执行上下文和作用域链。当一个函数在另一个函数内部被定义时，它会包含对外部函数变量的引用。这些引用在外部函数执行完毕后不会被销毁，而是被闭包所保留。

```javascript title="基础闭包示例"
function outerFunction() {
  let outerVariable = 'I am from outer scope'
  function innerFunction() {
    console.log(outerVariable)
  }
  return innerFunction
}

const closure = outerFunction()
closure() // 输出: I am from outer scope
```

在上面的例子中，`innerFunction` 保留了对 `outerVariable` 的访问权，即使 `outerFunction` 已经执行完毕。这就是闭包的基本特性。

## 闭包的高级应用场景

### 1. 模拟私有变量

JavaScript 中没有真正的私有变量概念，但通过闭包可以完美模拟出类似的效果。

```javascript title="计数器实现"
function createCounter() {
  let count = 0
  return {
    increment() {
      count++
      return count
    },
    decrement() {
      count--
      return count
    },
    getValue() {
      return count
    }
  }
}

const counter = createCounter()
console.log(counter.increment()) // 输出: 1
console.log(counter.increment()) // 输出: 2
console.log(counter.decrement()) // 输出: 1
console.log(counter.count) // 输出: undefined
```

在这个例子中，`count` 变量无法直接从外部访问，只能通过 `increment`、`decrement` 和 `getValue` 方法进行操作。这种方式在编写模块化代码时尤为有用。

### 2. 柯里化（Currying）

柯里化是一种将接受多个参数的函数转换成一系列接受单个参数的函数的技术。

```javascript title="柯里化函数"
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args)
    }
    else {
      return function (...args2) {
        return curried.apply(this, args.concat(args2))
      }
    }
  }
}

// 使用示例
function multiply(a, b, c) {
  return a * b * c
}

const curriedMultiply = curry(multiply)
console.log(curriedMultiply(2)(3)(4)) // 输出: 24
console.log(curriedMultiply(2, 3)(4)) // 输出: 24
```

### 3. 函数记忆化（Memoization）

记忆化是一种优化技术，通过缓存函数调用的结果来避免重复计算。

```javascript title="记忆化实现"
function memoize(fn) {
  const cache = new Map()
  return function (...args) {
    const key = JSON.stringify(args)
    if (cache.has(key)) {
      console.log('从缓存中获取结果')
      return cache.get(key)
    }
    else {
      console.log('计算新结果')
      const result = fn.apply(this, args)
      cache.set(key, result)
      return result
    }
  }
}

// 斐波那契数列示例
const fibonacci = memoize((n) => {
  if (n <= 1)
    return n
  return fibonacci(n - 1) + fibonacci(n - 2)
})

console.log(fibonacci(10)) // 只会计算必要的值
```

### 4. 模块模式

闭包是实现 JavaScript 模块化的核心机制。

```javascript title="模块模式实现"
const myModule = (function () {
  let privateVariable = 0

  function privateMethod() {
    return privateVariable
  }

  return {
    publicMethod() {
      privateVariable++
      return privateMethod()
    },
    getValue() {
      return privateVariable
    }
  }
})()

console.log(myModule.publicMethod()) // 输出: 1
console.log(myModule.getValue()) // 输出: 1
console.log(myModule.privateVariable) // 输出: undefined
```

## 闭包在异步编程中的应用

### 解决循环中的闭包问题

这是一个经典的闭包应用场景，也是很多开发者容易犯错的地方。

```javascript title="循环中的闭包问题与解决方案"
// 问题代码 - 所有按钮都会显示最后一个值
function problematicSetup() {
  let buttons = document.querySelectorAll('.problem-btn')
  // eslint-disable-next-line vars-on-top, no-var
  for (var i = 0; i < buttons.length; i++) {
    buttons[i].addEventListener('click', () => {
      console.log(`Button ${i} clicked`) // 总是输出 Button 3 clicked
    })
  }
}

// 解决方案1：使用立即执行函数
function solution1() {
  let buttons = document.querySelectorAll('.solution1-btn')
  for (let i = 0; i < buttons.length; i++) {
    (function (index) {
      buttons[index].addEventListener('click', () => {
        console.log(`Button ${index} clicked`)
      })
    })(i)
  }
}

// 解决方案2：使用let（推荐）
function solution2() {
  const buttons = document.querySelectorAll('.solution2-btn')
  for (let i = 0; i < buttons.length; i++) {
    buttons[i].addEventListener('click', () => {
      console.log(`Button ${i} clicked`)
    })
  }
}
```

### 异步操作中的状态保持

```javascript title="异步操作中的闭包应用"
function createAsyncProcessor(delay) {
  let processing = false
  let queue = []

  return function (data) {
    return new Promise((resolve) => {
      queue.push({ data, resolve })

      if (!processing) {
        processing = true
        processQueue()
      }

      function processQueue() {
        if (queue.length === 0) {
          processing = false
          return
        }

        const item = queue.shift()
        setTimeout(() => {
          console.log(`处理数据: ${item.data}, 延迟: ${delay}ms`)
          item.resolve(`结果: ${item.data}`)
          processQueue()
        }, delay)
      }
    })
  }
}

const processor = createAsyncProcessor(1000)
processor('任务1').then(console.log)
processor('任务2').then(console.log)
```

## 闭包的性能考量与最佳实践

### 内存泄漏风险

:::warning 注意
不当的闭包使用会导致内存泄漏，特别是在循环中创建大量闭包时。
:::

```javascript title="内存泄漏示例"
function createLeakyClosure() {
  let largeData = Array.from({ length: 1000000 }).join('*') // 大量数据
  let unusedVariable = Array.from({ length: 500000 }).join('x') // 未使用的数据

  return function () {
    console.log(largeData.length) // 只使用了largeData
    // unusedVariable 也被保留在内存中！
  }
}

const leakyFunction = createLeakyClosure()
// largeData 和 unusedVariable 都保留在内存中
```

### 性能优化策略

:::steps

* **控制闭包数量**：避免在不必要的场合创建闭包
* **及时释放引用**：在适当时候将不再需要的变量设置为 `null`
* **使用块级作用域**：优先使用 `let` 和 `const` 代替 `var`
* **避免循环引用**：注意闭包与 DOM 元素之间的循环引用

:::

```javascript title="优化后的闭包使用"
function createOptimizedClosure() {
  let importantData = Array.from({ length: 1000000 }).join('*')
  let temporaryData = Array.from({ length: 500000 }).join('x')

  // 使用完毕后立即释放不需要的变量
  temporaryData = null

  return {
    getData() {
      return importantData.length
    },
    cleanup() {
      importantData = null // 提供清理方法
    }
  }
}
```

## 现代 JavaScript 中的闭包

### ES6+ 对闭包的改进

随着 ES6 的普及，`let` 和 `const` 的引入让闭包的使用更加安全和直观。

```javascript title="现代闭包写法"
// 使用 const 和箭头函数
function createModernCounter() {
  let count = 0

  return {
    increment: () => ++count,
    decrement: () => --count,
    getValue: () => count,
    reset: () => count = 0
  }
}

// 类中的闭包
class Counter {
  #count = 0 // 私有字段

  createClosure() {
    return () => this.#count // 箭头函数自动绑定 this
  }
}
```

### 模块系统中的闭包

在 ES6 模块中，闭包的行为更加清晰：

```javascript title="counter.js"
let count = 0

export const increment = () => ++count
export const decrement = () => --count
export const getValue = () => count

// count 变量被模块作用域的闭包保护
```

```javascript title="main.js"
import { getValue, increment } from './counter.js'

console.log(increment()) // 1
console.log(getValue()) // 1
// 无法直接访问 count 变量
```

## 实战案例：构建一个状态管理器

让我们用一个完整的例子来展示闭包在实际项目中的应用：

```javascript title="简单状态管理器"
function createStore(reducer, initialState) {
  let state = initialState
  let listeners = []

  const getState = () => state

  const dispatch = (action) => {
    state = reducer(state, action)
    listeners.forEach(listener => listener())
    return action
  }

  const subscribe = (listener) => {
    listeners.push(listener)
    return () => {
      listeners = listeners.filter(l => l !== listener)
    }
  }

  dispatch({ type: '@@INIT' })

  return { getState, dispatch, subscribe }
}

// 使用示例
function counterReducer(state = 0, action) {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1
    case 'DECREMENT':
      return state - 1
    default:
      return state
  }
}

const store = createStore(counterReducer, 0)

store.subscribe(() => {
  console.log('状态更新:', store.getState())
})

store.dispatch({ type: 'INCREMENT' }) // 输出: 状态更新: 1
store.dispatch({ type: 'INCREMENT' }) // 输出: 状态更新: 2
store.dispatch({ type: 'DECREMENT' }) // 输出: 状态更新: 1
```

## 总结

闭包是 JavaScript 中不可或缺的部分，它为我们提供了：

:::info 关键要点

* **数据封装**：实现私有变量和方法
* **状态保持**：在函数调用之间维持状态
* **函数工厂**：动态创建具有特定行为的函数
* **模块化**：构建可维护的代码结构
* **异步编程**：处理回调和高阶函数
  :::

然而，闭包的强大也意味着需要谨慎使用。记住以下最佳实践：

1. **理解作用域链**：清楚知道每个闭包引用了哪些变量
2. **避免不必要的闭包**：特别是在性能敏感的场景中
3. **注意内存管理**：及时释放不再需要的引用
4. **利用现代语法**：使用 `let`/`const` 和箭头函数让闭包更清晰

掌握闭包不仅能让您写出更优雅的 JavaScript 代码，还能帮助您深入理解 JavaScript 的语言特性。

## 参考

* [MDN 闭包文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)
* 《你不知道的 JavaScript》上卷
* JavaScript.info 关于闭包的章节

---

---
url: /article/z7btimbk/index.md
---
# 玩转 CSS @property
`@property` CSS at-rule是 [CSS Houdini API](https://developer.mozilla.org/zh-CN/docs/Web/Guide/Houdini)
的一部分，它允许开发者显式地定义他们的 [CSS 自定义属性](https://developer.mozilla.org/zh-CN/docs/Web/CSS/--*),
允许进行属性类型检查、设定默认值以及定义该自定义属性是否可以被继承。

`@property` 的出现，极大的增强了 CSS 的能力。

::: info CSS Houdini
`CSS Houdini` 开放 CSS 的底层 API 给开发者，使得开发者可以通过这套接口自行扩展 CSS，并提供相应的工具允许开发者介入浏览器渲染引擎的样式和布局流程中，使开发人员可以编写浏览器可以解析的 CSS 代码，从而创建新的 CSS 功能。
:::

***

通常情况下，我们定义和使用一个 CSS 自定义属性是这样的：

```css
:root {
  --c-red: #fff;
}

p {
  color: (--c-red);
}
```

而有了 `@property` 规则，我们可以这样做：

```css
@property --c-red {
  syntax: '<color>';
  inherits: false;
  initial-value: #f00;
}

p {
  color: var(--c-white);
}
```

效果：

:::: demo 代码演示

::: code-tabs
@tab HTML

```html
<p class="css-vars">这是使用 css vars 定义的文字颜色</p>
<p class="css-property">这是使用 css @property 定义的文字颜色</p>
```

@tab CSS

```css
.css-vars {
  --c-red: #f00;
  color: var(--c-red);
}
@property --p-red {
  syntax: '<color>';
  inherits: false;
  initial-value: #f00;
}
.css-property {
  color: var(--p-red);
}
```

:::
::::

## @property

`@property` 规则提供了一个直接在样式表中注册自定义属性的方式，而无需运行任何 JS 代码。
有效的 `@property` 规则会注册一个自定义属性，就像 `CSS.registerProperty` 函数被使用同样的参数调用了一样。

### 语法

```css
@property <custom-property-name> {
  syntax: <string>;
  inherits: <boolean>;
  initial-value: <declaration-value>;
}
```

* `<custom-property-name>`: 自定义属性名，定义后可在 CSS 中通过 `var(<custom-property-name>)` 进行引用。
* syntax：该自定义属性的语法规则，也可以理解为表示定义的自定义属性的类型。
* inherits：该自定义属性是否可以被继承。
* initial-value：该自定义属性的初始值。

一个有效的 `@property` 规则代表一项自定义属性的注册，使用自定义属性名作为规则内代码序列的序部。

`@property` 规则中 `syntax` 和 `inherits` 描述符是必需的;
如果其中任何一项缺失，整条规则都将失效并且会被忽略。
`initial-value` 描述符仅在 `syntax` 描述符为通用 `syntax` 定义时是可选的，
否则 `initial-value` 也是必需的——如果此时该描述符缺失，整条规则都将失效且被忽略。

未知的描述符自身都是无效的，且会被忽略。但是不会造成整条 `@property` 规则的失效。

### syntax语法类型

* `<length>` : 任何有效的 length 值， 如 `12px`， `12rem` 等。
* `<number>` : 任何有效的 number 值， 如 `12`， `12.5`, `-12` 等。
* `<percentage>` : 任何有效的 percentage 值， 如 `12%` 等。
* `<length-percentage>` : 任何有效的 length-percentage 值， 如 `12px` 或 `12%` 等。
* `<color>` : 任何有效的 color 值， 如 `#fff` 或 `rgb(255, 255, 255)` 等。
* `<image>` : 任何有效的 image 值, 如 `url('foo.png')`，或 `linear-gradient(red, blue)` 等。
* `<url>` : 任何有效的 url 值， 如 `url('foo.png')` 等。
* `<integer>` : 任何有效的 integer 值， 如 `12` 等。
* `<angle>` : 任何有效的 angle 值， 如 `12deg` 等。
* `<time>` : 任何有效的 time 值， 如 `12s` 等。
* `<resolution>` : 任何有效的 resolution 值， 如 `12dpi` 等。
* `<transform-function>` : 任何有效的 transform-function 值， 如 `rotate(12deg)` 等。
* `<custom-ident>` : 任何有效的 custom-ident 值， 如 `foo` 等。

### syntax语法符号

`syntax` 支持 `+`、`#`、`|` 符号， 用于接收特殊的类型定义。

* `syntax: '<color#>'` : 接受逗号分隔的颜色值列表
* `syntax: '<length+>'` ：接受以空格分隔的长度值列表
* `syntax: '<length | length+>'`：接受单个长度或者以空格分隔的长度值列表

## 示例

在了解完 `@property` 规则之后，我们来看一些例子。

### 渐变过渡效果

通常我们实现一个渐变图案的代码如下：

::::demo title="渐变图案"
::: code-tabs

@tab HTML

```html
<div class="gradient"></div>
```

@tab CSS

```css
.gradient {
  width: 150px;
  height: 150px;
  margin: auto;
  background: linear-gradient(45deg, #f66, #ff0);
}
```

:::
::::

我们改造一下代码，使用 自定义属性实现，并尝试通过修改自定义属性，实现渐变过渡效果：

:::: demo title="自定义属性"
::: code-tabs

@tab HTML

```html
<div class="gradient"></div>
<p>鼠标悬停到方块中查看效果</p>
```

@tab CSS

```css
.gradient {
  --color-1: #f66;
  --color-2: #ff0;
  width: 150px;
  height: 150px;
  margin: auto;
  background: linear-gradient(45deg, var(--color-1), var(--color-2));
  transition: background 1s;
}
.gradient:hover {
  --color-1: #fcc;
  --color-2: #606;
}
```

::::

可以看到，虽然我们使用 `transition` 添加了 过渡动画，在 `hover` 时修改了 自定义属性。
当我们把鼠标移动到 `.gradient` 上时，并没有渐变过渡动画效果，我们只是得到了 两侦之间的变化。

#### 使用 @property 进行改造

现在，我们把使用 `@property` 替换 CSS 自定义属性：

```css
@property --houdini-color-1 {
  syntax: '<color>';
  inherits: false;
  initial-value: #f66;
}

@property --houdini-color-2 {
  syntax: '<color>';
  inherits: false;
  initial-value: #ff0;
}
```

使用了 @property 语法，定义了两个 CSS Houdini 自定义变量 `--houdini-color-1` 和 `--houdini-color-2`，在 hover 变化的时候，改变这两个颜色。

同时， 修改 `transition` 语句，**不再是对`background` 进行过渡，而是对`--houdini-color-1` 和 `--houdini-color-2` 进行过渡**。

:::: demo title="自定义属性" desc="鼠标悬停到方块中查看效果"
::: code-tabs

@tab HTML

```html
<div class="gradient"></div>
```

@tab CSS

```css
@property --houdini-color-1 {
  syntax: '<color>';
  inherits: false;
  initial-value: #f66;
}

@property --houdini-color-2 {
  syntax: '<color>';
  inherits: false;
  initial-value: #ff0;
}

.gradient {
  width: 150px;
  height: 150px;
  margin: auto;
  background: linear-gradient(45deg, var(--houdini-color-1), var(--houdini-color-2));
  transition:
    --houdini-color-1 1s,
    --houdini-color-2 1s;
}
.gradient:hover {
  --houdini-color-1: #fcc;
  --houdini-color-2: #606;
}
```

:::
::::

可以看到， 渐变过渡动画效果成功了！

由此，我们可以实现更加复杂的渐变过渡效果：

:::: demo title="渐变过渡动画"
::: code-tabs

@tab HTML

```html
<div class="bg-animate"></div>
```

@tab CSS

```css
@property --an-color-1 {
  syntax: '<color>';
  inherits: false;
  initial-value: fuchsia;
}
@property --an-color-2 {
  syntax: '<color>';
  inherits: false;
  initial-value: #f79188;
}
@property --an-color-3 {
  syntax: '<color>';
  inherits: false;
  initial-value: red;
}

.bg-animate {
  width: 150px;
  height: 150px;
  margin: auto;
  background: linear-gradient(45deg, var(--an-color-1), var(--an-color-2), var(--an-color-3));
  animation: change 10s infinite linear;
}
@keyframes change {
  20% {
    --an-color-1: red;
    --an-color-2: #a93ee0;
    --an-color-3: fuchsia;
  }
  40% {
    --an-color-1: #ff3c41;
    --an-color-2: #e228a0;
    --an-color-3: #2e4c96;
  }
  60% {
    --an-color-1: orange;
    --an-color-2: green;
    --an-color-3: teal;
  }
  80% {
    --an-color-1: #ae63e4;
    --an-color-2: #0ebeff;
    --an-color-3: #efc371;
  }
}
```

:::
::::

### 复杂背景动画

我们通过代码实现一个复杂的 渐变图案背景：

:::: demo title="复杂背景"
::: code-tabs

@tab HTML

```html
<div class="bg"></div>
```

@tab CSS

```css
.bg {
  width: 100%;
  height: 350px;
  background-image: radial-gradient(
      circle at 86% 7%,
      rgba(40, 40, 40, 0.04) 0%,
      rgba(40, 40, 40, 0.04) 50%,
      rgba(200, 200, 200, 0.04) 50%,
      rgba(200, 200, 200, 0.04) 100%
    ), radial-gradient(
      circle at 15% 16%,
      rgba(99, 99, 99, 0.04) 0%,
      rgba(99, 99, 99, 0.04) 50%,
      rgba(45, 45, 45, 0.04) 50%,
      rgba(45, 45, 45, 0.04) 100%
    ), radial-gradient(
      circle at 75% 99%,
      rgba(243, 243, 243, 0.04) 0%,
      rgba(243, 243, 243, 0.04) 50%,
      rgba(37, 37, 37, 0.04) 50%,
      rgba(37, 37, 37, 0.04) 100%
    ), linear-gradient(#6cc, #09c);
}
```

:::
::::

如果我们想让它动起来，如果不是用 `@property`，可能要废一番功夫，但是，在 `@property` 的支持下，
我们可以实现不错的动画效果：

:::: demo title="复杂背景动画"
::: code-tabs

@tab HTML

```html
<div class="bg"></div>
```

@tab CSS

```css
@property --per-1 {
  syntax: '<percentage>';
  inherits: false;
  initial-value: 75%;
}

@property --per-2 {
  syntax: '<percentage>';
  inherits: false;
  initial-value: 99%;
}

@property --per-3 {
  syntax: '<percentage>';
  inherits: false;
  initial-value: 15%;
}

@property --per-4 {
  syntax: '<percentage>';
  inherits: false;
  initial-value: 16%;
}

@property --per-5 {
  syntax: '<percentage>';
  inherits: false;
  initial-value: 86%;
}

@property --angle {
  syntax: '<angle>';
  inherits: false;
  initial-value: 0deg;
}

.bg {
  width: 100%;
  height: 350px;
  background-image: radial-gradient(
      circle at var(--per-5) 7%,
      rgba(40, 40, 40, 0.04) 0%,
      rgba(40, 40, 40, 0.04) 50%,
      rgba(200, 200, 200, 0.04) 50%,
      rgba(200, 200, 200, 0.04) 100%
    ), radial-gradient(
      circle at var(--per-3) var(--per-4),
      rgba(99, 99, 99, 0.04) 0%,
      rgba(99, 99, 99, 0.04) 50%,
      rgba(45, 45, 45, 0.04) 50%,
      rgba(45, 45, 45, 0.04) 100%
    ), radial-gradient(
      circle at var(--per-1) var(--per-2),
      rgba(243, 243, 243, 0.04) 0%,
      rgba(243, 243, 243, 0.04) 50%,
      rgba(37, 37, 37, 0.04) 50%,
      rgba(37, 37, 37, 0.04) 100%
    ), linear-gradient(#6cc, #09c);
  animation: move 30s infinite alternate linear;
}
@keyframes move {
  100% {
    --per-1: 85%;
    --per-2: 49%;
    --per-3: 45%;
    --per-4: 39%;
    --per-5: 70%;
    --angle: 360deg;
  }
}
```

:::
::::

## 参考

* [MDN CSS Properties and Values API](https://developer.mozilla.org/zh-CN/docs/Web/API/CSS_Properties_and_Values_API)
* [CSS Houdini API css-properties-values-api](https://drafts.css-houdini.org/css-properties-values-api/#syntax-strings)

---

---
url: /article/zdzhswo6/index.md
---
> 当我们每天在浏览器中输入网址时，背后是一个复杂而精妙的系统在默默工作——它就是 DNS（域名系统）。这个看似简单的过程，实际上涉及全球数百万台服务器的协同工作。本文将带你深入理解 DNS 的工作原理、解析过程及其在现代互联网中的关键作用。

## 什么是 DNS？

**DNS（Domain Name System，域名系统）** 是互联网的电话簿，它将人类可读的域名（如 `google.com`）转换为机器可读的 IP 地址（如 `142.251.42.206`）。

### 为什么需要 DNS？

想象一下，如果你需要记住每个网站的 IP 地址而不是简单的域名，访问互联网将会变得多么困难。DNS 解决了这个根本问题：

* **人类友好**：我们更容易记住 `baidu.com` 而不是 `110.242.68.66`
* **抽象层**：当服务器 IP 变更时，只需更新 DNS 记录，用户无需任何操作
* **负载均衡**：可以将流量分发到多个服务器
* **故障转移**：当某台服务器宕机时，可以指向备用服务器

## DNS 的核心组成

DNS 系统由四个关键组件构成：

### 1. 域名空间（Domain Name Space）

采用层次树状结构，从根域名开始，逐级向下：

```
根域名 (.)
│
├── 顶级域名 (TLD): com, org, net, cn, uk 等
│   │
│   ├── 二级域名: google, baidu, github
│   │   │
│   │   ├── 子域名: www, mail, api
```

### 2. DNS 服务器

* **根域名服务器**：全球共13组，存储顶级域名服务器的地址
* **TLD 服务器**：管理特定顶级域名（如 .com、.org）
* **权威域名服务器**：存储特定域名的实际记录
* **递归解析器**：为用户提供查询服务的本地 DNS 服务器

### 3. 资源记录（Resource Records）

DNS 数据库中存储的各种记录类型：

| 记录类型 | 作用                 | 示例                                 |
| -------- | -------------------- | ------------------------------------ |
| A        | 将域名指向 IPv4 地址 | `A example.com 192.0.2.1`            |
| AAAA     | 将域名指向 IPv6 地址 | `AAAA example.com 2001:db8::1`       |
| CNAME    | 域名别名             | `CNAME www.example.com example.com`  |
| MX       | 邮件服务器记录       | `MX example.com 10 mail.example.com` |
| NS       | 指定域名服务器       | `NS example.com ns1.example.com`     |
| TXT      | 文本记录，用于验证等 | `TXT example.com "v=spf1..."`        |

### 4. 解析器（Resolver）

客户端设备上的软件，负责发起 DNS 查询请求。

## DNS 解析过程详解

让我们通过一个具体的例子，详细了解当你在浏览器中输入 `www.example.com` 时发生的 DNS 解析过程：

### 步骤 1：本地缓存查询

```javascript
// 类似的前端缓存概念
const dnsCache = {
  'www.example.com': {
    ip: '93.184.216.34',
    ttl: 300, // 生存时间（秒）
    timestamp: Date.now()
  }
}

function checkLocalCache(domain) {
  const cached = dnsCache[domain]
  if (cached && (Date.now() - cached.timestamp) < cached.ttl * 1000) {
    return cached.ip // 缓存命中
  }
  return null // 缓存未命中，需要查询
}
```

解析器首先检查：

* **浏览器缓存**：最近访问过的域名
* **操作系统缓存**：系统级别的 DNS 缓存
* **hosts 文件**：本地手动配置的域名映射

### 步骤 2：递归解析器查询

如果本地缓存没有记录，请求会发送到递归解析器（通常由 ISP 提供）：

```javascript
// 模拟递归解析器的工作流程
class RecursiveResolver {
  constructor() {
    this.cache = new Map()
  }

  async resolve(domain) {
    // 1. 检查自身缓存
    if (this.cache.has(domain)) {
      return this.cache.get(domain)
    }

    // 2. 开始迭代查询过程
    let currentServer = 'root'
    let currentDomain = domain

    while (true) {
      // 查询当前服务器
      const response = await this.queryServer(currentServer, currentDomain)

      if (response.answer) {
        // 找到最终答案，缓存并返回
        this.cache.set(domain, response.answer)
        return response.answer
      }
      else if (response.referral) {
        // 被重定向到其他服务器
        currentServer = response.referral
      }
    }
  }
}
```

### 步骤 3：完整的迭代查询过程

1. **查询根域名服务器**：询问 `.com` 域名的 TLD 服务器地址
2. **查询 TLD 服务器**：询问 `example.com` 的权威服务器地址
3. **查询权威服务器**：获取 `www.example.com` 的 A 记录
4. **返回结果**：递归解析器将最终 IP 返回给客户端

### 可视化解析流程

```
客户端 → 递归解析器 → 根服务器 → TLD 服务器 → 权威服务器
                ↓（缓存答案）            ↓（返回引用）        ↓（返回引用）
客户端 ← 递归解析器 ←······································
```

## DNS 记录类型深度解析

### A 和 AAAA 记录

```dns
; IPv4 地址记录
example.com.    IN  A     93.184.216.34

; IPv6 地址记录
example.com.    IN  AAAA  2606:2800:220:1:248:1893:25c8:1946
```

### CNAME 记录：域名别名

```dns
; 将 www.example.com 指向 example.com
www.example.com.    IN  CNAME   example.com.
example.com.        IN  A       93.184.216.34
```

**实际应用场景**：

* CDN 配置
* 服务迁移时保持链接可用性
* 简化域名管理

### MX 记录：邮件交换

```dns
; 邮件服务器配置，数字表示优先级（值越小优先级越高）
example.com.    IN  MX  10  mail1.example.com.
example.com.    IN  MX  20  mail2.example.com.
mail1.example.com. IN  A    192.0.2.1
```

### NS 记录：域名服务器委托

```dns
; 指定域名的权威服务器
example.com.    IN  NS   ns1.cloudflare.com.
example.com.    IN  NS   ns2.cloudflare.com.
```

## DNS 在 Web 开发中的实际应用

### 1. 性能优化：DNS 预解析

```html
<!-- 告诉浏览器提前解析域名 -->
<link rel="dns-prefetch" href="//cdn.example.com">
<link rel="dns-prefetch" href="//api.example.com">
<link rel="dns-prefetch" href="//fonts.googleapis.com">
```

```javascript
// 或者在 JavaScript 中控制
const preconnectLinks = [
  'https://cdn.example.com',
  'https://fonts.googleapis.com'
]

preconnectLinks.forEach((link) => {
  const preconnect = document.createElement('link')
  preconnect.rel = 'preconnect'
  preconnect.href = link
  preconnect.crossOrigin = ''
  document.head.appendChild(preconnect)
})
```

### 2. 基于 DNS 的负载均衡

```dns
; 轮询负载均衡
www.example.com.    IN  A   192.0.2.1
www.example.com.    IN  A   192.0.2.2
www.example.com.    IN  A   192.0.2.3
```

### 3. 故障转移和灾备

```dns
; 主要服务
api.example.com.    IN  A       203.0.113.1
; 备份服务
api-backup.example.com. IN  A   203.0.113.2
```

## DNS 安全考虑

### 1. DNS 劫持

恶意修改 DNS 记录，将用户引导到钓鱼网站。

**防护措施**：

* 使用 DNSSEC（DNS 安全扩展）
* 配置可靠的 DNS 解析器（如 Cloudflare 1.1.1.1、Google 8.8.8.8）
* 定期检查 DNS 记录

### 2. DNS 缓存投毒

攻击者向 DNS 解析器注入伪造的 DNS 记录。

### 3. DDoS 攻击

通过大量 DNS 查询请求使服务器瘫痪。

## 现代 DNS 增强技术

### 1. DNS over HTTPS (DoH)

```javascript
// 传统的 DNS 查询是明文的，容易被监听
// DoH 通过 HTTPS 加密 DNS 查询
async function dohQuery(domain) {
  const response = await fetch(
    `https://cloudflare-dns.com/dns-query?name=${domain}&type=A`,
    {
      headers: {
        Accept: 'application/dns-json'
      }
    }
  )
  const data = await response.json()
  return data.Answer[0].data
}
```

### 2. DNS over TLS (DoT)

在 TLS 层加密 DNS 查询，提供端到端安全。

## 前端开发者的 DNS 调试技巧

### 1. 使用命令行工具

```bash
# 查询 A 记录
nslookup example.com

# 查询所有记录类型
dig example.com ANY

# 跟踪完整的 DNS 解析路径
dig +trace example.com

# 查询特定 DNS 服务器
nslookup example.com 8.8.8.8
```

### 2. 在线 DNS 查询工具

* [DNS Checker](https://dnschecker.org/) - 全球 DNS 传播检查
* [MX Toolbox](https://mxtoolbox.com/) - 专业的 DNS 诊断工具
* [What's My DNS](https://www.whatsmydns.net/) - 简单的 DNS 查询工具

### 3. 浏览器开发者工具

在 Network 标签中：

* 查看每个资源的 DNS 查询时间
* 识别 DNS 解析性能问题
* 验证 DNS 预解析效果

## 实际案例：网站迁移中的 DNS 管理

假设你要将网站从旧服务器迁移到新服务器：

```dns
; 迁移前的配置
www.example.com.    IN  A       192.0.2.100

; 迁移步骤：
; 1. 首先降低 TTL，加快记录更新
www.example.com.    IN  A       192.0.2.100
; TTL 设置为 300 秒（5分钟）

; 2. 迁移时更新记录
www.example.com.    IN  A       192.0.2.200

; 3. 迁移后监控
; 使用工具检查全球 DNS 传播状态
```

**最佳实践**：

* 提前降低 TTL 值
* 分阶段迁移
* 保持旧服务器运行一段时间
* 密切监控错误日志

## 总结

DNS 作为互联网的基础设施，其重要性不言而喻。作为前端开发者，深入理解 DNS：

1. **性能优化**：通过 DNS 预解析减少延迟
2. **故障排查**：快速定位网络问题
3. **安全防护**：识别和防范 DNS 相关攻击
4. **用户体验**：确保网站的可靠性和可访问性

掌握 DNS 知识不仅能让你成为更好的开发者，还能在关键时刻快速解决生产环境问题。下次当你在浏览器中输入网址时，不妨想一想背后那个精妙的分布式系统正在为你服务。

## 参考

* [MDN Web Docs - DNS](https://developer.mozilla.org/zh-CN/docs/Glossary/DNS)
* [Cloudflare Learning Center](https://www.cloudflare.com/learning/dns/)
* [DNS RFC 文档](https://datatracker.ietf.org/doc/html/rfc1035)

---

---
url: /build-tools/webpack/index.md
---
# webpack 指南

---

---
url: /build-tools/webpack/what-is-webpack/index.md
---
# 什么是 webpack ?
本质上，**webpack** 是一个用于现代 JavaScript 应用程序的 ==静态模块打包工具=={.important}。

当 **webpack** 处理应用程序时，它会在内部从一个或多个入口点构建一个 **依赖图(dependency graph)** ，
然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。

## Webpack 解决了什么？

在复杂的前端项目中，我们会面临诸多挑战：

* **模块化开发**： 现代前端使用 ES Modules、CommonJS 等将代码拆分为小模块。浏览器对原生 ES Modules 的支持虽在提升，但在兼容性、性能（大量 HTTP 请求）上仍有不足。
* **资源多样性**： 项目不仅需要 JavaScript，还包括 CSS（Sass/Less）、图片、字体、HTML 模板等，浏览器无法直接处理非 JS 资源。
* **代码优化**： 未压缩的代码体积庞大；重复代码；未使用的代码（Dead Code）影响性能。
* **开发效率**： 手动管理依赖、刷新浏览器、等待构建缓慢。
* **兼容性**： 需要使用新语法（ES6+、JSX、TypeScript）但需确保在旧浏览器中运行。

**Webpack 的核心价值正是优雅地解决上述问题！**

## webpack 工作流程

* **初始化**： 读取配置，创建 Compiler 实例，加载插件。
* **开始编译**： 从配置的 **entry** 开始，调用 Compiler 的 `run` 方法启动编译。
* **确定依赖**： 从入口文件开始，对遇到的每一个 `import/require` 语句，解析模块路径，**递归** 地构建项目的依赖图(Dependency Graph)。
* **Loader 处理**： 对依赖图中的每个模块（文件），根据 `module.rules` 配置，使用匹配的 Loader 进行转换（如 TS -> JS, SCSS -> CSS -> JS 可处理字符串）。
* **编译模块**： 经过 Loader 转换后的模块内容，被解析为 **AST 语法树**，分析其依赖关系和导出内容。
* **生成 Chunks**： 将处理好的模块及其依赖，根据配置（入口点、动态导入、SplitChunksPlugin 优化策略）组合成 **Chunk(s)**。一个 Bundle 通常对应一个 Chunk（但可通过代码分割有多个）。
* **输出资源**： 根据 `output` 配置，将每个 Chunk 转换为最终的输出文件（Bundle）。在这个过程中，插件可以介入执行特定任务（如生成 HTML、压缩代码、拷贝静态文件等）。
* **完成**： 所有 Chunks 和 Assets 输出到目标目录，构建结束。

```mermaid
graph LR
    A[入口 Entry] --> B[解析依赖图]
    B --> C[Loader 转换模块]
    C --> D[编译模块 AST]
    D --> E[生成 Chunks]
    E --> F[应用插件 Plugin]
    F --> G[输出 Bundles]
```

## Webpack 带来的核心优势

* **模块化打包**： 解决依赖管理和浏览器加载问题，将碎片化模块打包成少量高效资源。

* **万物皆模块**： 通过 Loader，任何资源都能像 JS 模块一样被导入和使用 (import './style.css')。

* **强大的预处理/转换能力**： 利用 Loader 链，支持 Babel (ES6+/JSX/TS)、Sass/Less、PostCSS 等现代开发工具链。

* **高度可扩展性**： 庞大的 Plugin 生态系统覆盖开发、优化、部署等全生命周期需求。

* **开发效率提升**：

  * **开发服务器(webpack-dev-server)**: 提供热更新(HMR)，文件修改后局部刷新，保持应用状态。
  * **Source Map**: 调试打包后的代码如同调试源代码。

* **生产环境优化**：

  * **代码压缩/混淆(TerserPlugin)**: 减小文件体积。
  * **Tree Shaking**: 移除未使用的 JS 代码 (ES Module 静态结构)。
  * **Code Splitting / Lazy Loading**: 拆分代码，按需加载，提升首屏速度。
  * **Scope Hoisting**: 提升作用域，减少闭包，优化运行速度。
  * **文件哈希命名**： 利用缓存策略提升加载性能。

## Webpack 在现代前端中的地位

尽管时下其它工具如 Vite 在开发体验（利用原生 ESM）上带来了革新，
Webpack 凭借其 **无与伦比的成熟度、稳定性、灵活性和极其丰富的生态系统**，依然是：

* 大型复杂项目的首选： 其配置的深度和 Plugin 生态能应对极其复杂的定制化需求。
* 生产优化的标杆： 在构建生产环境优化 Bundle 方面经验丰富，功能强大且可靠。

## 社区支持

* [vue-cli](https://github.com/vuejs/vue-cli) -&#x20;

  Vue 官方维护的，基于 webpack 构建，集成了常规 Vue 项目的开发、构建、部署流程等套件，易上手。

* [create-react-app](https://github.com/facebook/create-react-app) -&#x20;

  Create React App 是官方支持的创建单页 React 应用程序的方式。它提供了无需配置的现代化构建环境。

  目前已经不再维护，不推荐使用。

* [awesome-webpack](https://webpack.docschina.org/awesome-webpack/)

---

---
url: /cli/index.md
---
本篇仅收集记录 常用的命令行，及在具体场景中的使用，并不对它们进行详细介绍。

## 拷贝

### 拷贝一个文件

将 `file.txt` 拷贝到 `documents/` 目录下

```sh
cp file.txt documents/
```

### 拷贝一个目录

把 `music/` 整个目录拷贝到 `media/` 目录下

```sh
cp -a music media/
# 或者写成
cp -a music/ media/music/
```

### 创建文件副本

从 `file.txt` 创建副本 `file.bak.txt`

```sh
cp file.txt file.bak.txt
# 或者写成
cp file{,.bak}.txt
```

### 创建目录副本

从 `music/` 创建副本

```sh
cp -a music/ media/
# 如果 media 目录不存在
cp -a music media/
```

## 移动

### 移动文件

将 `file.txt` 移动到 `documents/` 目录下

```sh
mv file.txt documents/
# 不要忽略 document 后面的 `/`，不然会被当成重命名文件
```

### 重命名文件

将 `file.txt` 重命名为 `readme.md`

```sh
mv file.txt readme.md
```

### 移动目录

将 目录 `music/` 移动到 `media/` 目录下

```sh
mv music media/
# 或者写成
mv music/ media/music
```

### 重命名目录

将 目录 `music/` 重命名为 `media/`

```sh
mv music/ media/
```

## 合并目录文件

将 `images/` 目录合并到 `images2/` 目录中

```sh
# -a 相当于 -rlptgoD , 表示归档，同名文件会被覆盖
rsync -a images/ images2/
```

## 创建

### 创建文件

创建 `file.txt`

```sh
touch file.txt # 如果文件存在，则更新它的权限和修改时间
# 或者使用
> file.txt  # 如果文件存在，则会清空文件内容
```

### 创建目录

创建 `music/` 目录

```sh
mkdir music
# 创建一连串的文件夹
mkdir -p media/music/rock
```

## 查看信息

### 文件和目录大小

```sh
du -sh node_modules/
```

### 文件信息

```sh
stat -x file # MacOS
stat file    # Linux
```

### 文件内容

查看文件内容

```sh
cat file.txt
# 如果文件太大，可以使用 `less` 来一次查看一页内容
less file.txt
```

### 目录文件

查看目录中的文件

```sh
ls folder
# -l: 以列表格式显示. -a: 显示包括隐藏文件的所有文件. -la 结合以上两个选项.
ls -la folder
# -r: 倒序显示. -t: 按修改时间排序. -h: 以易读的格式显示大小.
ls -alrth folder
```

显示目录下所有文件和子目录的文件树

```sh
tree folder  # Linux
find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g' # MacOS
# 也可以在 MacOS 上使用 `brew install tree` 安装 `tree` 命令行工具
```

## 打开文件

使用默认程序打开文件

```sh
xdg-open file # Linux
open file     # MacOS
start file    # Windows
```

在任意程序中打开文件

```sh
open -a appName file
```

## 删除

### 删除一个文件

删除 `file.txt`

```sh
rm file.txt
```

### 删除一个目录

删除 `music/` 目录

```sh
rm -r music
```

## 解压缩

### 压缩整个目录

将 目录 `music/` 压缩到 `archive.zip`

```sh
zip -r archive.zip music
```

### 解压文件

将 `archive.zip` 解压

```sh
unzip archive.zip
```

### 速览压缩文件

速览压缩包中的文件

```sh
zipinfo archive.zip
# 或者
unzip -l archive.zip
```

## 搜索

### 找出陈旧文件

找出所有最近一次修改在 5 天之前的文件

```sh
find folder -mtime +5
```

### 检索文件内容

```sh
grep -i "music" file.txt
```

`grep` 能在文件中检索特定内容，一些常见的配套命令行参数:

* `-i`：大小写敏感
* `-A/-B/-C <N>`：顺带显示前后文，`-A`表示后面 N 行，-B表示前面 N 行，`-C`表示前后各 N 行
* `-E`：使用正则表达式来匹配
* `-v`：反选（输出不匹配的行）
* `-l`：只输出能匹配到内容的文件名
* `-F`：不要将检索内容视为正则表达式
* `-r`：递归匹配目录下所有文件的内容
* `-o`：只输出匹配上了的部分（而不是整行）
* `-a`：也对二进制文件进行检索，而不是忽略它们！

## 强制退出程序

```sh
killall program_name
```

## 网络

### 服务器响应

```sh
curl -i https://pengzhanbo.cn
```

### 检查域名/地址连接

检查域名或者地址某端口是否能够连接

```sh
nc -vz pengzhanbo.cn 443
nc -vz 1.1.1.1 443
```

### 域名DNS配置

```sh
dig pengzhanbo.cn
```

### 域名所有人和注册信息

```sh
whois pengzhanbo.cn
```

## 热键

* `Ctrl + A` 跳转到你当前编辑的命令行行首
* `Ctrl + E` 跳转到你当前编辑的命令行行尾
* `Ctrl + L` 清屏，和 clear 指令类似
* `Ctrl + U` 清除行中光标之前的内容（在行尾时即清除整行）
* `Ctrl + H` 和退格一样
* `Ctrl + R` 能让你搜索之前使用过的命令行记录
* `Ctrl + C` 强制停止当前的程序
* `Ctrl + D` 退出当前 shell （壳层/命令行界面）
* `Ctrl + Z` 将当下运行的程序挂起，使用 fg 来恢复运行
* `Ctrl + W` 删除光标前的一个词
* `Ctrl + K` 清除行中光标之后的内容
* `Ctrl + T` 交换光标前两个字符
* `Esc + T` 交换光标前两个词
* `Alt + F` 将光标移至行内下一个词处
* `Alt + B` 将光标移至行内上一个词处
* `Tab` 自动补全文件/目录的名称

### MacOS

```sh
!!                            # 再一次执行上一条指令
sudo !!                       # 以管理员身份执行上一条指令
!<word>                       # 加上特定命令行前缀再执行上一条指令
!<word>:p                     # 显示上一条指令加上前缀，但不要执行
<space>command                # 执行指令，但不要存到历史记录中
echo "ls -l" | at midnight    # 在特定时间执行指令
caffeinate -u -t 3600         # 接下来一小时内阻止你的mac休眠
ls -lhs                       # 将目录中文件按大小排序显示
qlmanage -p <file>            # 从命令行调用"速览"
top -o vsize                  # 查看是什么拖慢了你的mac
```

---

---
url: /cpwp/index.md
---
# 中国程序员容易发音错误的单词
::: tip 数据来源 [chinese-programmer-wrong-pronunciation](https://github.com/shimohq/chinese-programmer-wrong-pronunciation)
:::

你说得对，我经常读错。

是的，第一个单词我就读错了。（怪不好意思的）

| 单词          | 正确发音（英音）                                                                                                       | 正确发音（美音）                                                                                             | 错误发音                |
| ------------- | ---------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ | ----------------------- |
| access        | /'ækses/ @[audioReader](https://dict.youdao.com/dictvoice?audio=access\&type=1)                                         | /ˈækses/ @[audioReader](https://dict.youdao.com/dictvoice?audio=access\&type=2)                               | ❌ /ək'ses/              |
| Adobe         | /ə'dəʊbi/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Adobe\&type=1)                                         | /ə'dəʊbi/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Adobe\&type=2)                               | ❌ /əˈdub/               |
| admin         | /'ædmɪn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=admin\&type=1)                                          | /ˈædmɪn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=admin\&type=2)                                | ❌ /ɜ:d'mɪn/             |
| adversarial   | /ˌædvəˈseəriəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=adversarial\&type=1)                             | /ˌædvərˈseriəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=adversarial\&type=2)                   | ❌ /ədˈvɜːrsəriəl/       |
| agile         | /'ædʒaɪl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=agile\&type=1)                                         | /ˈædʒl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=agile\&type=2)                                 | ❌ /ə'dʒaɪl/             |
| amazon        | /'æməzən/ @[audioReader](https://dict.youdao.com/dictvoice?audio=amazon\&type=1)                                        | /ˈæməzɑːn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=amazon\&type=2)                             | ❌ /'əmeizən/ /ə'meizən/ |
| analogy       | /əˈnælədʒi/ @[audioReader](https://dict.youdao.com/dictvoice?audio=analogy\&type=1)                                     | /əˈnælədʒi/ @[audioReader](https://dict.youdao.com/dictvoice?audio=analogy\&type=2)                           | ❌ /ænə'lɒdʒi/           |
| Angular       | /'æŋgjʊlə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Angular\&type=1)                                      | /ˈæŋɡjələr/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Angular\&type=2)                           | ❌ /'æŋɡələ/ /'æŋdʒʌlə/  |
| AJAX          | /'eidʒæks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=AJAX\&type=1)                                         | /'eidʒæks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=AJAX\&type=2)                               | ❌ /ə'dʒʌks/             |
| alias         | /ˈeɪliəs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=alias\&type=1)                                         | /ˈeɪliəs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=alias\&type=2)                               | ❌ /ə'lais/              |
| align         | /əˈlaɪn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=align\&type=1)                                          | /əˈlaɪn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=align\&type=2)                                | ❌ /ə'lidʒen/            |
| Apache        | /ə'pætʃɪ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Apache\&type=1)                                        | /əˈpætʃi/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Apache\&type=2)                              | ❌ /ʌpʌtʃ/               |
| app           | /æp/ @[audioReader](https://dict.youdao.com/dictvoice?audio=app\&type=1)                                                | /æp/ @[audioReader](https://dict.youdao.com/dictvoice?audio=app\&type=2)                                      | ❌ /eipi'pi/             |
| archive       | /'ɑːkaɪv/ @[audioReader](https://dict.youdao.com/dictvoice?audio=archive\&type=1)                                       | /'ɑːkaɪv/ @[audioReader](https://dict.youdao.com/dictvoice?audio=archive\&type=2)                             | ❌ /'ətʃɪv/              |
| array         | /ə'rei/ @[audioReader](https://dict.youdao.com/dictvoice?audio=array\&type=1)                                           | /əˈreɪ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=array\&type=2)                                 | ❌ /æ'rei/               |
| ASCII         | /'æski/ @[audioReader](https://dict.youdao.com/dictvoice?audio=ascii\&type=1)                                           | /ˈæski/ @[audioReader](https://dict.youdao.com/dictvoice?audio=ascii\&type=2)                                 | ❌ /ɑːsk/                |
| aspect        | /'æspekt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=aspect\&type=1)                                        | /ˈæspekt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=aspect\&type=2)                              | ❌ /ə'spekt/             |
| async         | /əˈsɪŋk/ @[audioReader](https://dict.youdao.com/dictvoice?audio=async\&type=1)                                          | /æˈsɪŋk/ @[audioReader](https://dict.youdao.com/dictvoice?audio=async\&type=2)                                | ❌ /'æsɪŋk/              |
| avatar        | /'ævətɑː/ @[audioReader](https://dict.youdao.com/dictvoice?audio=avatar\&type=1)                                        | /ˈævətɑːr/ @[audioReader](https://dict.youdao.com/dictvoice?audio=avatar\&type=2)                             | ❌ /ə'vʌtɑ/              |
| Azure         | /'æʒə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=azure\&type=1)                                            | /ˈæʒər/ @[audioReader](https://dict.youdao.com/dictvoice?audio=azure\&type=2)                                 | ❌ /ˈæzʊʒə/              |
| Bazel         | /ˈbeɪzəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=bazel\&type=1)                                         | /ˈbeɪzəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=bazel\&type=1)                               | ❌ /bæ zəl/              |
| bind          | /baɪnd/ @[audioReader](https://dict.youdao.com/dictvoice?audio=bind\&type=1)                                            | /baɪnd/ @[audioReader](https://dict.youdao.com/dictvoice?audio=bind\&type=2)                                  | ❌ /bɪnd/                |
| BIOS          | /ˈbaɪɒs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=bios\&type=1)                                           | /'baɪɑs/                                                                                                     | ❌ /ˈbɪɒs/               |
| cache         | /kæʃ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=cache\&type=1)                                             | /kæʃ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=cache\&type=2)                                   | ❌ /kætʃ/                |
| canal         | /kəˈnæl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=canal\&type=1)                                          | /kəˈnæl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=canal\&type=2)                                | ❌ /ˈkænl/               |
| chaos         | /ˈkeɪɒs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=chaos\&type=1)                                          | /ˈkeɪɑːs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=chaos\&type=2)                               | ❌ /ˈtʃoʊs/              |
| Chrome        | /krəʊm/ @[audioReader](https://dict.youdao.com/dictvoice?audio=chrome\&type=1)                                          | /kroʊm/ @[audioReader](https://dict.youdao.com/dictvoice?audio=chrome\&type=2)                                | ❌ /tʃɔːm/               |
| clang         | /klæŋ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=clang\&type=1)                                            | /klæŋ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=clang\&type=2)                                  | ❌ /sɪlæŋ/               |
| context       | /ˈkɒntekst/ @[audioReader](https://dict.youdao.com/dictvoice?audio=context\&type=1)                                     | / ˈkɑːntekst/ @[audioReader](https://dict.youdao.com/dictvoice?audio=context\&type=2)                         | ❌ /kənˈtekst/           |
| Coq           | IPA French \['kɔkʲ] 读若拼音“goq” @[audioReader](https://upload.wikimedia.org/wikipedia/commons/4/47/Fr-coq.ogg)        |                                                                                                              | ❌ IPA English \['kʰɒk]   |
| daemon        | /'diːmən/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Daemon\&type=1)                                        | /ˈdiːmən/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Daemon\&type=2)                              | ❌ /dæmən/               |
| debt          | /det/ @[audioReader](https://dict.youdao.com/dictvoice?audio=debt\&type=1)                                              | /det/ @[audioReader](https://dict.youdao.com/dictvoice?audio=debt\&type=2)                                    | ❌ /de'bit/              |
| deny          | /dɪ'naɪ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=deny\&type=1)                                           | /dɪˈnaɪ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=deny\&type=2)                                 | ❌ /'dæni/               |
| deprecate     | /ˈdeprəkeɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=deprecate\&type=1)                                  | /ˈdeprəkeɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=deprecate\&type=2)                        |                         |
| deque         | /'dek/ @[audioReader](https://dict.youdao.com/dictvoice?audio=deque\&type=1)                                            | /dɛk/ @[audioReader](https://dict.youdao.com/dictvoice?audio=deque\&type=2)                                   | ❌ /di'kju/              |
| digest        | n. /'dɑɪdʒɛst/ v. /dɑɪ'dʒɛst/ @[audioReader](https://dict.youdao.com/dictvoice?audio=digest\&type=1)                    | /daɪˈdʒest,dɪˈdʒest/ @[audioReader](https://dict.youdao.com/dictvoice?audio=digest\&type=2)                   | ❌ /'dɪgɛst/             |
| Dijkstra      | Dutch:/ˈdɛikstra/ English:/ˈdaɪkstrə/ @[audioReader](https://upload.wikimedia.org/wikipedia/commons/8/85/Dijkstra.ogg) | @[audioReader](https://upload.wikimedia.org/wikipedia/commons/8/85/Dijkstra.ogg)                             |                         |
| Django        | /ˈdʒæŋɡoʊ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Django\&type=1)                                       | /ˈdʒæŋɡoʊ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Django\&type=2)                             | ❌ /diˈdʒæŋɡoʊ/          |
| doc           | /dɒk/ @[audioReader](https://dict.youdao.com/dictvoice?audio=doc\&type=1)                                               | /dɒk/ @[audioReader](https://dict.youdao.com/dictvoice?audio=doc\&type=2)                                     | ❌ /daʊk/                |
| dotnet        | /dɒtnet/ @[audioReader](https://dict.youdao.com/dictvoice?audio=dotnet\&type=1)                                         | /dɑːtnet/ @[audioReader](https://dict.youdao.com/dictvoice?audio=dotnet\&type=2)                              | ❌ /daʊtnet/             |
| edition       | /ɪˈdɪʃ(ə)n/ @[audioReader](https://dict.youdao.com/dictvoice?audio=edition\&type=1)                                     | /ɪˈdɪʃn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=edition\&type=2)                              | ❌ /eˈdɪʃn/              |
| ephemeral     | /ɪˈfemərəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=ephemeral\&type=1)                                   | /ɪˈfemərəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=ephemeral\&type=2)                         | ❌ /efe'merəl/           |
| epoch         | /ˈiːpɒk/ @[audioReader](https://dict.youdao.com/dictvoice?audio=epoch\&type=1)                                          | /ˈepək/ @[audioReader](https://dict.youdao.com/dictvoice?audio=epoch\&type=2)                                 | ❌ /'ɛpətʃ/              |
| execute       | /ˈeksɪkjuːt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=execute\&type=1)                                    | /ˈeksɪkjuːt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=execute\&type=2)                          |                         |
| executor      | /ɪɡˈzekjətə(r)/ @[audioReader](https://dict.youdao.com/dictvoice?audio=executor\&type=1)                                | /ɪɡˈzekjətər/ @[audioReader](https://dict.youdao.com/dictvoice?audio=executor\&type=2)                        |                         |
| event         | /ɪ'vent/ @[audioReader](https://dict.youdao.com/dictvoice?audio=event\&type=1)                                          | /ɪˈvent/ @[audioReader](https://dict.youdao.com/dictvoice?audio=event\&type=2)                                | ❌ /'ɪvənt/              |
| exit          | /ˈeksɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=exit\&type=1)                                           | /ˈeksɪt; ˈeɡzɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=exit\&type=2)                         | ❌ /ig'zit/              |
| facade        | /fə'sɑːd/ @[audioReader](https://dict.youdao.com/dictvoice?audio=facade\&type=1)                                        | /fəˈsɑːd/ @[audioReader](https://dict.youdao.com/dictvoice?audio=facade\&type=2)                              | ❌ /'feikeid/            |
| fedora        | /fɪ'dɔːrə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=fedora\&type=1)                                       | /fɪˈdɔːrə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=fedora\&type=2)                             | ❌ /'fedərə/             |
| format        | /'fɔːmæt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=format\&type=1)                                        | /ˈfɔːrmæt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=format\&type=2)                             | ❌ /fɔ'mæt/              |
| gauge         | /ɡeɪdʒ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=gauge\&type=1)                                           | /ɡeɪdʒ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=gauge\&type=2)                                 | ❌ /ɡɑudʒ/               |
| Git           | /ɡɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=git\&type=1)                                               | /ɡɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=git\&type=2)                                     | ❌ /dʒɪt/                |
| GNU           | /gnu:/ @[audioReader](https://upload.wikimedia.org/wikipedia/commons/2/24/En-gnu.ogg)                                  | /gnuː,gnjuː/ @[audioReader](https://upload.wikimedia.org/wikipedia/commons/2/24/En-gnu.ogg)                  |                         |
| Grafana       | /grəˈfɑːnˌɑː/ @[audioReader](http://www.howtopronounce.cc/file/e204a97ed1e440c5ab15ea0117beb955.mp3)                   | /grəˈfɑːnˌɑː/ @[audioReader](http://www.howtopronounce.cc/file/e204a97ed1e440c5ab15ea0117beb955.mp3)         |                         |
| GraphQL       | /græf kju ɛl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=GraphQL\&type=1)                                   | /græf kju ɛl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=GraphQL\&type=2)                         | ❌ /dʒɪgræf kju ɛl/      |
| GUI           | /ˈɡu:i/ @[audioReader](https://dict.youdao.com/dictvoice?audio=GUI\&type=1)                                             | /ˈɡu:i/ @[audioReader](https://dict.youdao.com/dictvoice?audio=GUI\&type=2)                                   |                         |
| Haskell       | /ˈhæskəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=haskell\&type=1)                                       | /ˈhæskəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=haskell\&type=2)                             | ❌ /hæˈskəl/             |
| height        | /haɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=height\&type=1)                                           | /haɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=height\&type=2)                                 | ❌ /heɪt/                |
| hidden        | /'hɪdn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=hidden\&type=1)                                          | /ˈhɪdn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=hidden\&type=2)                                | ❌ /'haɪdn/              |
| IEEE          | /aɪ ˈtrɪpəl i/ @[audioReader](https://dict.youdao.com/dictvoice?audio=I_triple_e\&type=1)                               | /aɪ ˈtrɪpəl i/ @[audioReader](https://dict.youdao.com/dictvoice?audio=I_triple_e\&type=2)                     | ❌ /'aɪ'iː'iː'iː/        |
| image         | /'ɪmɪdʒ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=image\&type=1)                                          | /ˈɪmɪdʒ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=image\&type=2)                                | ❌ /ɪ'meɪdʒ/             |
| implement     | /'ɪmplɪm(ə)nt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=implement\&type=1)                                | /ˈɪmplɪmənt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=implement\&type=2) /ˈɪmpləˌment/          | ❌ /ɪm'plem(ə)nt/        |
| integer       | /'ɪntɪdʒə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=integer\&type=1)                                      | /ˈɪntɪdʒər/ @[audioReader](https://dict.youdao.com/dictvoice?audio=integer\&type=2)                           | ❌ /ˈɪntaɪgə/            |
| issue         | /'ɪʃuː/ @[audioReader](https://dict.youdao.com/dictvoice?audio=issue\&type=1)                                           | /ˈɪʃuː/ @[audioReader](https://dict.youdao.com/dictvoice?audio=issue\&type=2)                                 | ❌ /ˈaɪʃuː/              |
| Java          | /'dʒɑːvə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=java\&type=1)                                          | /ˈdʒɑːvə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=java\&type=2)                                |                         |
| jpg           | /'dʒeɪpeɡ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=JPEG\&type=1)                                         | /'dʒeɪpeɡ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=JPEG\&type=2)                               | ❌ /ˈdʒeɪˈpi:ˈdʒiː/      |
| key           | /kiː/ @[audioReader](https://dict.youdao.com/dictvoice?audio=key\&type=1)                                               | /kiː/ @[audioReader](https://dict.youdao.com/dictvoice?audio=key\&type=2)                                     | ❌ /kei/                 |
| kubernetes\*   | /kubз'netɪs/ @[audioReader](https://content.swncdn.com/biblestudytools/audio/lexicons/greek-mp3/2942g.mp3)             | /kuːbə˞'netiz/ @[audioReader](https://content.swncdn.com/biblestudytools/audio/lexicons/greek-mp3/2942g.mp3) |                         |
| lambda        | /ˈlæmdə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=lambda\&type=1)                                         | /ˈlæmdə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=lambda\&type=2)                               | ❌ /ˈlɒŋmdɑ/             |
| Ldap          | /el'dæp/ @[audioReader](https://dict.youdao.com/dictvoice?audio=ldap\&type=1)                                           | /el'dæp/ @[audioReader](https://dict.youdao.com/dictvoice?audio=ldap\&type=2)                                 | ❌ /el'daːp/             |
| legacy        | /'leɡəsi/ @[audioReader](https://dict.youdao.com/dictvoice?audio=legacy\&type=1)                                        | /'leɡəsi/ @[audioReader](https://dict.youdao.com/dictvoice?audio=legacy\&type=2)                              | ❌ /'li:gasi/            |
| linear        | /'lɪnɪə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=linear\&type=1)                                         | /ˈlɪniər/ @[audioReader](https://dict.youdao.com/dictvoice?audio=linear\&type=2)                              | ❌ /'laɪə/               |
| LINQ          | /lɪŋk/ @[audioReader](https://dict.youdao.com/dictvoice?audio=link\&type=1)                                             | /lɪŋk/ @[audioReader](https://dict.youdao.com/dictvoice?audio=link\&type=2)                                   | ❌ /lɪŋkju:/             |
| Linux         | /'lɪnəks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=linux\&type=1)                                         | /ˈlaɪnəks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=linux\&type=2) /ˈlɪnəks/                    | ❌ /ˈlɪnʌks/ /ˈlɪnjuːks/ |
| locale        | /ləʊ'kɑːl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=locale\&type=1)                                       | /loʊˈkæl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=locale\&type=2)                              | ❌ /ˈloʊk(ə)l/           |
| Lucene        | /lu'siːn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=lucene\&type=1)                                        | /lu'siːn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=lucene\&type=2)                              | ❌ /'lu:sən/             |
| macro         | /ˈmækrəʊ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=macro\&type=1)                                         | /ˈmækroʊ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=macro\&type=2)                               | ❌ /ˈmakroʊ/             |
| main          | /meɪn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=main\&type=1)                                             | /meɪn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=main\&type=2)                                   | ❌ /mɪn/                 |
| margin        | /'mɑːdʒɪn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=margin\&type=1)                                       | /ˈmɑːrdʒɪn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=margin\&type=2)                            | ❌ /'mʌgɪn/              |
| matrix        | /ˈmeɪtrɪks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=matrix\&type=1)                                      | /ˈmeɪtrɪks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=matrix\&type=2)                            | ❌ /ˈmɑ:trɪks/           |
| maven         | /'meɪvn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=maven\&type=1)                                          | /ˈmeɪvn/ @[audioReader](https://dict.youdao.com/dictvoice?audio=maven\&type=2)                                | ❌ /'maːvn/              |
| max           | /mæks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=max\&type=1)                                              | /mæks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=max\&type=2)                                    | ❌ /mɑ:ks/               |
| Microsoft     | /'maikrəusɔft/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Microsoft\&type=1)                                | /ˈmaɪkrəsɔːft/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Microsoft\&type=2)                      | ❌ /'mikrəusɔft/         |
| migrate       | /maɪˈɡreɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=migrate\&type=1)                                     | /ˈmaɪɡreɪt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=migrate\&type=2)                           | ❌ /ˈmɪɡreɪt/            |
| miscellaneous | /ˌmɪsəˈleɪniəs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=miscellaneous\&type=1)                           | /ˌmɪsəˈleɪniəs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=miscellaneous\&type=2)                 |                         |
| module        | /'mɒdjuːl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=module\&type=1)                                       | /ˈmɑːdʒuːl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=module\&type=2)                            | ❌ /'məʊdl/              |
| native        | /ˈneɪtɪv/ @[audioReader](https://dict.youdao.com/dictvoice?audio=native\&type=1)                                        | /ˈneɪtɪv/ @[audioReader](https://dict.youdao.com/dictvoice?audio=native\&type=2)                              | ❌ /ˈnætɪv/              |
| nginx         | Engine X                                                                                                               | Engine X                                                                                                     |                         |
| null          | /nʌl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=null\&type=1)                                              | /nʌl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=null\&type=2)                                    | ❌ /naʊ/                 |
| obsolete      | /ˈɒbsəliːt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=obsolete\&type=1)                                    | /ˌɑːbsəˈliːt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=obsolete\&type=2)                        |                         |
| OS X          | OS ten                                                                                                                 | OS ten                                                                                                       | ❌ /ɔs eks/              |
| phantom       | /'fæntəm/ @[audioReader](https://dict.youdao.com/dictvoice?audio=phantom\&type=1)                                       | /ˈfæntəm/ @[audioReader](https://dict.youdao.com/dictvoice?audio=phantom\&type=2)                             | ❌ /'pæntəm/             |
| parameter     | /pə'ræmɪtə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=parameter\&type=1)                                   | /pəˈræmɪtər/ @[audioReader](https://dict.youdao.com/dictvoice?audio=parameter\&type=2)                        | ❌ /'pærəmɪtə/           |
| premise       | /ˈpremɪs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=premise\&type=1)                                       | /ˈpremɪs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=premise\&type=2)                             | ❌ /prɪ'mɪs/             |
| privilege     | /'prɪvəlɪdʒ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=privilege\&type=1)                                  | /ˈprɪvəlɪdʒ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=privilege\&type=2)                        | ❌ /'prɪvɪlɪdʒ/          |
| probe         | /prəʊb/ @[audioReader](https://dict.youdao.com/dictvoice?audio=probe\&type=1)                                           | /proʊb/ @[audioReader](https://dict.youdao.com/dictvoice?audio=probe\&type=2)                                 | ❌ /proʊbi/              |
| Prometheus    | /prə-ˈmē-thē-əs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=prometheus\&type=1)                             | /pro'miθɪəs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=prometheus\&type=2)                       |                         |
| putty         | /ˈpʌti/ @[audioReader](https://dict.youdao.com/dictvoice?audio=putty\&type=1)                                           | /ˈpʌti/ @[audioReader](https://dict.youdao.com/dictvoice?audio=putty\&type=2)                                 | ❌ /ˈpuːti/              |
| Qt            | /kjuːt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=cute\&type=1)                                            | /kjuːt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=cute\&type=2)                                  |                         |
| query         | /'kwɪəri/ @[audioReader](https://dict.youdao.com/dictvoice?audio=query\&type=1)                                         | /ˈkwɪri/ @[audioReader](https://dict.youdao.com/dictvoice?audio=query\&type=2)                                | ❌ /'kwaɪri/             |
| Realm         | /relm/ @[audioReader](https://dict.youdao.com/dictvoice?audio=realm\&type=1)                                            | /relm/ @[audioReader](https://dict.youdao.com/dictvoice?audio=realm\&type=2)                                  | ❌ /riəlm/               |
| reconcile     | /ˈrekənsaɪl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=reconcile\&type=1)                                  | /ˈrekənsaɪl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=reconcile\&type=2)                        |                         |
| Redux         | /ri'dʌks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=redux\&type=1)                                         | /ri'dʌks/ @[audioReader](https://dict.youdao.com/dictvoice?audio=redux\&type=2)                               | ❌ /'ridju:ks/           |
| resume        | /rɪ'zju:m/ @[audioReader](https://dict.youdao.com/dictvoice?audio=resume\&type=1)                                       | /rɪˈzuːm/ @[audioReader](https://dict.youdao.com/dictvoice?audio=resume\&type=2)                              | ❌  /rɪ'sju:m/           |
| résumé        | /rezjumeɪ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=résumé\&type=1)                                       | /ˈrezəmeɪ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=résumé\&type=2)                             | ❌  /rɪ'sju:m/           |
| resolved      | /rɪ'zɒlvd/ @[audioReader](https://dict.youdao.com/dictvoice?audio=resolved\&type=1)                                     | /rɪˈzɑːlvd/ @[audioReader](https://dict.youdao.com/dictvoice?audio=resolved\&type=2)                          | ❌ /rɪ'səʊvd/            |
| resort        | /rɪˈzɔ:t/ @[audioReader](https://dict.youdao.com/dictvoice?audio=resort\&type=1)                                        | /rɪˈzɔːrt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=resort\&type=2)                             | ❌ /rɪˈsɔ:t/             |
| retina        | /'retɪnə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=retina\&type=1)                                        | /ˈretɪnə/ @[audioReader](https://dict.youdao.com/dictvoice?audio=retina\&type=2)                              | ❌ /ri'tina/             |
| RISC-V        | /'rɪsk faɪv/ @[audioReader](https://dict.youdao.com/dictvoice?audio=risk-five\&type=1)                                  | /'rɪsk faɪv/ @[audioReader](https://dict.youdao.com/dictvoice?audio=risk-five\&type=2)                        | ❌ /'rɪsk v/             |
| route         | /ruːt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=route\&type=1)                                            | /ruːt,raʊt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=route\&type=2)                             | ❌ /rəʊt/                |
| San Jose      | /sænhəu'zei/ @[audioReader](https://dict.youdao.com/dictvoice?audio=san%20jose\&type=1)                                 | /sænhəu'zei/ @[audioReader](https://dict.youdao.com/dictvoice?audio=san%20jose\&type=2)                       | ❌ /sæn'ju:s/            |
| safari        | /sə'fɑːrɪ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=safari\&type=1)                                       | /səˈfɑːri/ @[audioReader](https://dict.youdao.com/dictvoice?audio=safari\&type=2)                             | ❌ /sæfərɪ/              |
| scheme        | /skiːm/ @[audioReader](https://dict.youdao.com/dictvoice?audio=scheme\&type=1)                                          | /skiːm/ @[audioReader](https://dict.youdao.com/dictvoice?audio=scheme\&type=2)                                | ❌ /s'kæmə/              |
| scala         | /ˈskɑːlɑ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=scala\&type=1)                                         | /ˈskɑːlɑ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=scala\&type=2)                               | ❌ /ˈskæːlɑ/             |
| segue         | /'sɛɡwe/ @[audioReader](https://dict.youdao.com/dictvoice?audio=segue\&type=1)                                          | /ˈseɡweɪ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=segue\&type=2)                               | ❌ /se'dʒ/               |
| SQL           | /ˈsiːkwəl/ /ˈesˈkjuːˈel/                                                                                               | /ˈsiːkwəl/ /ˈesˈkjuːˈel/                                                                                     | ❌ /sərk(ə)l/            |
| sudo          | /'suːduː/                                                                                                              | /'suːduː/                                                                                                    |                         |
| suite         | /swiːt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=suite\&type=1)                                           | /swiːt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=suite\&type=2)                                 | ❌ /sjuːt/               |
| telemetry     | /təˈlemətri/ @[audioReader](https://dict.youdao.com/dictvoice?audio=telemetry\&type=1)                                  | /təˈlemətri/ @[audioReader](https://dict.youdao.com/dictvoice?audio=telemetry\&type=2)                        | ❌ /ˈtelɪmətri/          |
| thymeleaf     | /ˈtaɪmˌlɪːf/ @[audioReader](https://dict.youdao.com/dictvoice?audio=thymeleaf\&type=1)                                  | /ˈtaɪmˌlɪːf/ @[audioReader](https://dict.youdao.com/dictvoice?audio=thymeleaf\&type=2)                        | ❌ /θiːmɪlɪːf/           |
| tuple         | /tjʊpəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=tuple\&type=1)                                          | /tuːpəl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=tuple\&type=2)                                |                         |
| typical       | /'tɪpɪkl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=typical\&type=1)                                       | /ˈtɪpɪkl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=typical\&type=2)                             | ❌ /'taɪpɪkəl/           |
| Ubuntu        | /ʊ'bʊntʊ/ @[audioReader](https://upload.wikimedia.org/wikipedia/commons/b/b5/En-Ubuntu_pronunciation.oga)              | /ʊ'bʊntʊ/ @[audioReader](https://upload.wikimedia.org/wikipedia/commons/b/b5/En-Ubuntu_pronunciation.oga)    | ❌ /juː'bʊntʊ/           |
| UEFI          | U-E-F-I                                                                                                                | U-E-F-I                                                                                                      | ❌ /jufi/ /ɔːfi/         |
| Vagrant       | /ˈveɪɡrənt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Vagrant\&type=1)                                     | /ˈveɪɡrənt/ @[audioReader](https://dict.youdao.com/dictvoice?audio=Vagrant\&type=2)                           | /ˈvagɹent/              |
| variable      | /'veəriəbl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=variable\&type=1)                                    | /ˈveriəbl,ˈværiəbl/ @[audioReader](https://dict.youdao.com/dictvoice?audio=variable\&type=2)                  | ❌ /və'raiəbl/           |
| verbose       | /vɜːˈbəʊs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=verbose\&type=1)                                      | /vɜːrˈboʊs/ @[audioReader](https://dict.youdao.com/dictvoice?audio=verbose\&type=2)                           | ❌ /'vɜːrboʊs/           |
| vue           | /v'ju:/ @[audioReader](https://dict.youdao.com/dictvoice?audio=vue\&type=1)                                             | /v'ju:/ @[audioReader](https://dict.youdao.com/dictvoice?audio=vue\&type=2)                                   | ❌ /v'ju:i/              |
| width         | /wɪdθ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=width\&type=1)                                            | /wɪdθ,wɪtθ/ @[audioReader](https://dict.youdao.com/dictvoice?audio=width\&type=2)                             | ❌ /waɪdθ/               |
| YouTube       | /'juː'tjuːb/ @[audioReader](https://dict.youdao.com/dictvoice?audio=youtube\&type=1)                                    | /'juː'tjuːb/ @[audioReader](https://dict.youdao.com/dictvoice?audio=youtube\&type=2)                          | ❌ /'juː'tʊbɪ/           |
| Vite          | /vit/ @[audioReader](https://dict.youdao.com/dictvoice?audio=vite\&type=1)                                              | /vit/ @[audioReader](https://dict.youdao.com/dictvoice?audio=vite\&type=2)                                    | ❌ /vaɪt/                |

---

---
url: /defensive-css/index.md
---
# 防御性CSS
## 什么是防御性CSS ？

防御性CSS 是 一系列的 CSS 实践技巧。
设计师和开发人员可以使用这些实践技巧来编写 安全、健壮的 CSS 代码，从而减少 用户界面 可能发生的错误。

我们 可以 将防御性CSS 当做一种策略，它可以帮助我们揭示一些 潜在的问题，
使我们在 进行 设计 或 编写代码时，尽可能的避免这些问题，更好的完成 用户界面构建和交互。

对于 设计师而言，防御性CSS 可以帮助 设计师 了解可能发生的 未知的内容，处理这些未知的内容，完善设计。

对于 开发人员， 防御性CSS 可以当做一种 高阶的 CSS重置 。

当前， 防御性CSS 包括了 `24` 个 防御技巧。

---

---
url: /defensive-css/accidental-hover-on-mobile/index.md
---
# Accidental Hover On Mobile
## Accidental Hover On Mobile

在应用中，我们会使用 `hover` 效果向用户提供 元素可点击或者出于活动状态的提示。
这在具有鼠标或触控面板的设备来说表现良好，但是这在移动端的设备上， `hover` 效果可能会令人困惑。

```css
.card:hover {
  background: blue;
}
```

在页面中滚动时，手指可能会意外地轻点半下，这将触发特定元素的 `hover` 状态。

:::demo-wrapper
如果是桌面端浏览器，请打开 控制台，切换为 移动设备。在下面元素上点击，会看到 `hover` 效果。

这种意外的触发了 `hover` 状态，可能不是用户想看到的，毕竟在 移动设备上，并不需要 `hover` 。

对此，我们可以通过 `hover` 媒体查询，来解决这个问题。
检测到用户当前的设备是否可以将 鼠标指针 悬停在 元素上。

```css
@media (hover: hover) {
  .card:hover {
    /* Add hover styles.. */
  }
}
```

:::demo-wrapper
如果是桌面端浏览器，请打开 控制台，切换为 移动设备。在下面元素上点击。

可以看到，在 桌面端浏览器中，`hover` 效果被激活，在移动端浏览器中，不触发 `hover` 效果。

---

---
url: /defensive-css/auto-fit-fill/index.md
---
# Auto-fit Vs Auto-fill
## Auto-fit Vs Auto-fill

当我们在使用 `CSS Grid` 网格布局时，会经常使用到 `minmax()` 函数。
在使用 `minmax()` 函数时，决策使用 `auto-fit` 还是 `auto-fill` 关键词非常重要，
如果使用不当，可能会导致意想不到的后果。

使用 `minmax()` 函数 时：

* `auto-fit`： 将展开网格项以填充可用空间。
* `auto-fill`： 将保留可用空间，而不改变网格项的宽度。

![auto fit fill](/images/defensive-css/auto-fit-fill.png){style="border:var(--vp-c-divider) 1px solid;border-radius:5px;box-shadow:var(--vp-shadow-2)"}

尽管如此，使用 `auto-fit` 可能会导致网格项太宽，尤其是当它们小于预期时。请看以下示例。

```css
.wrapper {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  grid-gap: 1rem;
}
```

如果只有一个网格项并且使用 `auto-fit` ，则该项目将展开以填充容器宽度。

:::demo-wrapper
四个子项：

一个子项：

***

在大多数情况下，不需要 这样的行为。所以在我看来，使用 `auto-fill` 会更好。

:::demo-wrapper
四个子项：

一个子项：

## 示例

```css
.wrapper {
  --sizing: auto-fit;
  display: grid;
  grid-template-columns: repeat(var(--sizing), minmax(100px, 1fr));
  grid-gap: 1rem;
}
```

:::: demo title="auto-fit-fill" desc="调整容器大小查看效果"
::: code-tabs

@tab HTML

```html
<div class="demo-wrapper">
  <div class="wrapper" id="gridWrapper">
    <div class="card">
      <div class="card__thumb"></div>
      <p>css grid 布局</p>
    </div>
    <div class="card">
      <div class="card__thumb"></div>
      <p>css grid 布局</p>
    </div>
    <div class="card-outline"></div>
    <div class="card-outline"></div>
  </div>
</div>
<div class="actions">
  <input type="checkbox" id="toggle" />
  <label for="toggle">启用 auto-fill</label>
</div>
```

@tab CSS

```css
.demo-wrapper {
  position: relative;
  width: 300px;
  max-width: 100%;
  resize: horizontal;
  overflow: hidden;
  border-right: solid 2px var(--vp-c-border, #c2c2c4);
  padding-right: 3rem;
  padding-left: 1rem;
  padding-top: 1.5rem;
  padding-bottom: 1.5rem;
  background: var(--vp-c-bg-alt, #f0f0f0);
}
.demo-wrapper::after {
  content: 'Resize me';
  position: absolute;
  right: 0;
  top: 50%;
  writing-mode: tb-rl;
  transform: translateY(-50%);
  font-size: 13px;
  line-height: 1.2;
}
.wrapper {
  --sizing: auto-fit;
  display: grid;
  grid-template-columns: repeat(var(--sizing), minmax(100px, 1fr));
  grid-gap: 1rem;
  width: 100%;
}
.wrapper .card {
  border-radius: 5px;
  overflow: hidden;
}
.wrapper .card__thumb {
  height: 90px;
  background: var(--vp-c-brand-1, #f0f0f0);
}
.wrapper .card p {
  margin: 0;
  padding: 5px 10px;
  background: var(--vp-c-brand-3, #f0f0f0);
}
.wrapper .card-outline {
  display: none;
  border: 1px dashed;
  border-radius: 5px;
  min-height: 20px;
}

.wrapper.checked {
  --sizing: auto-fill;
}

.wrapper.checked .card-outline {
  display: block;
}
```

@tab Javascript

```js
const wrapper = document.querySelector('#gridWrapper')
document.querySelector('#toggle').addEventListener('change', (e) => {
  wrapper.classList.toggle('checked', e.target.checked)
})
```

:::
::::

---

---
url: /defensive-css/background-repeat/index.md
---
# Background repeat
## Background repeat

通常，当使用大图像作为背景时，我们往往会忘记考虑在大屏幕上查看时的情况。
默认情况下，该背景将重复。

这在笔记本电脑屏幕上大多不可见，但在较大的屏幕上可以清楚地看到。
::::demo-wrapper
:::center
小屏幕

大屏幕

:::
::::

为提前避免该行为，请确保重置 `background-repeat` 。

```css
.hero {
  background-image: url('..');
  background-repeat: no-repeat;
}
```

---

---
url: /defensive-css/button-minimum-width/index.md
---
# Button Minimum Width
## Button Minimum Width

一个常见的错误是假设按钮宽度应等于其内容加水平填充。
这对于单语言网站（例如：英语）可能如预期般工作，但对于多语言网站很容易出现意外的问题。

请看以下示例：

:::demo-wrapper
英语：
Done

中文：
完成

阿拉伯语：
تم
:::

可以看到， 在 英语 和 中文 下， 按钮的宽度表现很好，因为其内容足够长。
但是在 阿拉伯语 中， 按钮的宽度就很窄，从拥护体验来说，这很不友好，
因为对一个主要的按钮来说，它的表现应该足够的直观，方便用户操作。

为避免这种情况，我们可以提前设置按钮的最小宽度。

```css
button {
  min-width: 90px;
}
```

:::demo-wrapper
英语：
Done

中文：
完成

阿拉伯语：
تم
:::

---

---
url: /defensive-css/component-spacing/index.md
---
# Component Spacing
## Component Spacing

在一些布局场景中， 我们应该考虑不同的内容长度对布局的影响。
这意味着，我们需要将 **间距** 添加到组件中，即使它看起来不需要。

:::demo-wrapper

在此示例中，右侧有一个部分标题和一个操作按钮。
目前，它看起来还不错。但是，让我们看看当标题更长时会发生什么。

:::demo-wrapper

可以看到， 文本距离操作按钮太近了。也许我们可以考虑换行，但在我们将在其它章节讨论。
现在我们关注 **间距** 。

如果标题有 间距 和 文本截断 ，我们不会看到这样的问题。

```css
.section__title {
  margin-right: 1rem;
}
```

:::demo-wrapper

---

---
url: /defensive-css/default-flexbox-stretching/index.md
---
# Default FlexBox Stretching
## Default FlexBox Stretching

在 flexbox 中，flex 项的默认行为是拉伸。如果子项的内容长于其同级项，则会导致其他项拉伸。

但这不容易被发现， 除非我们向 Flex 项中添加比预期更长的内容。

***

在这个示例中，我们有一个包含 图像、标题、介绍 的组件。

```html
<div class="food">
  <img class="food__img" src="image/food.jpg" alt="" />
  <div class="food__content">
    <h3>一份美食</h3>
    <p><!-- Description goes here.. --></p>
  </div>
</div>
```

```css
.food {
  display: flex;
}
```

:::demo-wrapper

可以发现，当内容长度过长时，搞过了图片的高度时，图片被拉伸了。

为了解决这个问题，我们需要覆盖默认的拉伸行为。

```css
.food__img {
  align-self: flex-start;
}
```

:::demo-wrapper

---

---
url: /defensive-css/fixed-sizes/index.md
---
# Fixed sizes
## Fixed sizes

破坏布局的常见情况之一是， 具有固定宽度或固定高度的容器，填充了长度不一的内容，
当内容过长时，就会发生 内容溢出的情况，导致 布局被破坏。

### 固定高度

一种常见的情况是， 一个卡片容器的高度是固定的，但是 它的内容 却大于 容器的高度，
导致了布局被破坏。

```css
.card {
  height: 100px;
}
```

:::demo-wrapper

为了避免内容从 卡片 中溢出，我们需要使用 `min-height` 而不是 `height` 。

```css
.card {
  min-height: 100px;
}
```

:::demo-wrapper

这样就可以避免内容从 卡片 中溢出。

### 固定宽度

另一种常见的情况是，一个标签的内容太靠近左右边缘，发生溢出。
这是由于使用了 固定宽度。

```css
.tag {
  width: 100%;
}
```

:::demo-wrapper

要解决这个问题，我们可以使用 `min-width` 替代 `width`

```css
.tag {
  min-width: 100px;
}
```

:::demo-wrapper

---

---
url: /defensive-css/flex-box-wrapping/index.md
---
# FlexBox Wrapping
## FlexBox Wrapping

当下 `CSS FlexBox` 是用途最宽泛，最有用的 CSS 布局功能之一。
它只需要给 容器添加一个 `display: flex` 就可以使 容器内的 子项 一个个并排排序，简单强大，十分诱人。

但是有一个问题，如果容器没有足够的空间时，在默认情况下，这些子项不会被换行到新行中。
因此，我们需要使用 `flex-wrap: wrap` 来改变这个行为。

下面是一个 典型例子，我们有一组选项，应该彼此相邻：

:::demo-wrapper

当容器空间较小时，容器内的子项将被挤压，甚至溢出容器。这应该是意料之中的，实际上并不是一个“问题”。

:::demo-wrapper

请注意，这些子项仍然彼此相邻。为了解决这个问题，我们需要使用 `flex-wrap: wrap`：

:::demo-wrapper

## 示例：面包屑导航

::::demo title="面包屑导航" desc="调整容器大小查看效果"
::: code-tabs

@tab HTML

```html
<div class="wrapper">
  <ul class="breadcrumbs" id="breadcrumbs">
    <li class="item"><a href="#">Home</a></li>
    <li class="item"><a href="#">Article</a></li>
    <li class="item"><a href="#">Defensive CSS</a></li>
  </ul>
</div>
<div class="actions">
  <input type="checkbox" id="toggle" />
  <label for="toggle">启用 Flex Wrap</label>
</div>
```

@tab CSS

```css
.wrapper {
  position: relative;
  width: 300px;
  max-width: 100%;
  display: flex;
  align-items: center;
  resize: horizontal;
  overflow: hidden;
  flex: 1;
  border-right: solid 2px var(--vp-c-border, #c2c2c4);
  padding-right: 3rem;
  padding-left: 1rem;
  padding-top: 1.5rem;
  padding-bottom: 1.5rem;
  background: var(--vp-c-bg-alt, #f0f0f0);
}
.wrapper::after {
  content: 'Resize me';
  position: absolute;
  right: 0;
  top: 50%;
  writing-mode: tb-rl;
  transform: translateY(-50%);
  font-size: 13px;
  line-height: 1.2;
}
.breadcrumbs {
  display: flex;
  list-style: none;
  padding-left: 0;
}
.item:not(:last-child):after {
  content: '>';
  margin-left: 0.5rem;
  margin-right: 1rem;
}
.item a {
  color: var(--vp-c-brand, #5086a1);
}
```

@tab Javascript

```js
const breadcrumbs = document.querySelector('#breadcrumbs')
document.querySelector('#toggle').addEventListener('change', (e) => {
  breadcrumbs.style.flexWrap = e.target.checked ? 'wrap' : 'nowrap'
})
```

:::
::::

---

---
url: /defensive-css/grid-fixed-values/index.md
---
# Grid fixed values
## Grid fixed values

假设我们有一个 网格 布局，包含一个 aside 和 一个 main。
CSS 如下所示：

```css
.wrapper {
  display: grid;
  grid-template-columns: 250px 1fr;
  gap: 1rem;
}
```

:::demo-wrapper

由于空间不足，这将在较小的视口尺寸上导致溢出。
为避免此类问题，请在使用上述 CSS 网格时始终使用媒体查询。

在视口尺寸较小时，换行显示，在视口尺寸较大时，使用 网格布局。

```css
@media (min-width: 600px) {
  .wrapper {
    display: grid;
    grid-template-columns: 250px 1fr;
    gap: 1rem;
  }
}
```

:::demo-wrapper

:::center
调整浏览器窗口大小查看效果。
:::

---

---
url: /defensive-css/grouping-vendor-selector/index.md
---
# Grouping Vendor Selector
## Grouping Vendor Selector

不建议对带有不同浏览器前缀的选择器进行分组。

例如，设置输入占位符的样式需要每个浏览器有多个选择器。

这是由于， 根据 [W3C](https://www.w3.org/TR/selectors/#grouping) ，如果选择器分组中，有某一个
选择器 无效，则会使整个分组的所有选择器都无效。

```css
/* 请不要这样做 */
input::-webkit-input-placeholder,  /* [!code warning] */
input:-moz-placeholder {
  /* [!code warning] */
  color: #222;
}
```

相反，请这样做：

```css
input::-webkit-input-placeholder {
  color: #222;
}

input:-moz-placeholder {
  color: #222;
}
```

---

---
url: /defensive-css/image-distortion/index.md
---
## Image Distortion

当我们无法控制网页中的图像的横纵比时，最好提前考虑并提供 图像横纵比不一致 时的解决方案。

在下面的示例中，我们有一个带有照片的卡片组件。看起来不错。

:::demo-wrapper

当时，如果使用的图片的尺寸横纵比不一致，图片会被拉伸：

:::demo-wrapper

最简单的解决方法是使用 CSS `object-fit` 。

```css
.card__image {
  object-fit: cover;
}
```

## 示例

:::: demo title="object-fit: cover" desc="调整容器大小查看效果"
::: code-tabs

@tab HTML

```html
<div class="wrapper">
  <img id="image" src="/images/defensive-css/ratio.png" />
</div>
<div class="actions">
  <input type="checkbox" id="toggle" />
  <label for="toggle">启用 object-fit</label>
</div>
```

@tab CSS

```css
.wrapper {
  position: relative;
  width: 300px;
  max-width: 100%;
  display: flex;
  align-items: center;
  resize: horizontal;
  overflow: hidden;
  flex: 1;
  border-right: solid 2px var(--vp-c-border, #c2c2c4);
  padding-right: 3rem;
  padding-left: 1rem;
  padding-top: 1.5rem;
  padding-bottom: 1.5rem;
  background: var(--vp-c-bg-alt, #f0f0f0);
}
.wrapper::after {
  content: 'Resize me';
  position: absolute;
  right: 0;
  top: 50%;
  writing-mode: tb-rl;
  transform: translateY(-50%);
  font-size: 13px;
  line-height: 1.2;
}

#image {
  width: 100%;
  height: 140px;
}
```

@tab Javascript

```js
const image = document.querySelector('#image')
document.querySelector('#toggle').addEventListener('change', (e) => {
  image.style.objectFit = e.target.checked ? 'cover' : 'initial'
})
```

:::
::::

---

---
url: /defensive-css/image-inner-border/index.md
---
# Image Inner Border
## Image inner border

在处理用户头像时，以清晰的方式显示它们，并且与 视图 很好的保持统一性，可能具有一定的挑战性。
因为有些 头像的亮度很高，有些头像的亮度很低，又有可能有些是 jpg 格式，有些是 png 格式，
对透明度的支持不一，就很可能与背景色 混合 在一起。

::::demo-wrapper
:::center

由于头像存在透明部分，导致与背景色融合在一起，看不出来 头像的 UI 为 圆形，与其它的部分失去了整体性。

对此，我们可以增加 边框，可以让 UI 看起来更为舒服。

```css
.avatar {
  position: relative;
}
.avatar::after {
  position: absolute;
  content: '';
  top: 0;
  left: 0;
  display: block;
  z-index: 2;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  border: 2px solid #000;
  opacity: 0.1;
}
```

::::demo-wrapper
:::center

---

---
url: /defensive-css/image-maximum-width/index.md
---
# Image Maximum Width
## Image Maximum Width

作为一般规则， 请不要忘记为 所有图像设置 `max-width: 100%`。
这可以添加到你的 CSS 重置 规则中。

```css
img {
  max-width: 100%;
  object-fit: cover;
}
```

---

---
url: /defensive-css/input-zoom-on-ios-safari/index.md
---
# Input Zoom On iOS Safari
## Input Zoom On iOS Safari

在 iOS Safari 中， 当我们 聚焦 一个 `input` 元素进行输入时，默认情况整个网页都会进行缩放。
这是 Safari 的默认行为。虽然在输入时方法 `input` 输入框，可以让用户看到 更大的文字，
但是，不再聚焦 `input` 元素，离开输入框后，整个网页并不会缩小复原，这就很让人恼了。

:::demo-wrapper img no-padding

:::

解决方法很简单，只需要添加 `font-size` 属性到 `input` 元素即可。

```css
input {
  font-size: 16px;
}
```

:::demo-wrapper img no-padding

:::

---

---
url: /defensive-css/long-content/index.md
---
# Long Content
## Long Content

这是常见的联系人列表，现在看起来很完美。

:::demo-wrapper

但是，由于 联系人名字是由用户输入的，因此我们需要注意如何在内容过长的情况下保护布局。

如：

:::demo-wrapper

在此类布局中，一致性很重要。为了实现这一点，我们可以简单地使用 `text-overflow` 来截断名称。

```css
.username {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
```

:::demo-wrapper

## 示例

在某些情况下，我们可能需要截断对用户不重要或不影响用户体验的文本。在这种情况下，截断文本是个好主意。

:::: demo title="text-overflow: ellipsis" desc="调整容器大小查看效果"
::: code-tabs

@tab HTML

```html
<p>调整容器大小查看效果：</p>
<div class="wrapper">
  <div class="container">
    <h3 id="title">编写防御性CSS 是避免样式混乱的好方法</h3>
    <div class="more">more</div>
  </div>
</div>
<div class="actions">
  <input type="checkbox" id="toggle" />
  <label for="toggle">启用 text-overflow</label>
</div>
```

@tab CSS

```css
.wrapper {
  position: relative;
  width: 300px;
  max-width: 100%;
  display: flex;
  align-items: center;
  resize: horizontal;
  overflow: hidden;
  flex: 1;
  border-right: solid 2px var(--vp-c-border, #c2c2c4);
  padding-right: 3rem;
  padding-left: 1rem;
  padding-top: 1.5rem;
  padding-bottom: 1.5rem;
  background: var(--vp-c-bg-alt, #f0f0f0);
}
.wrapper::after {
  content: 'Resize me';
  position: absolute;
  right: 0;
  top: 50%;
  writing-mode: tb-rl;
  transform: translateY(-50%);
  font-size: 13px;
  line-height: 1.2;
}

.container {
  width: 100%;
  display: flex;
  align-items: center;
}
.container h3 {
  padding-right: 20px;
  min-width: 0;
}
.container h3.ellipsis {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
```

@tab Javascript

```js
const til = document.querySelector('#title')
document.querySelector('#toggle').addEventListener('change', (e) => {
  til.classList.toggle('ellipsis', e.target.checked)
})
```

:::
::::

---

---
url: /defensive-css/minimum-content-size-in-flex-box/index.md
---
# Minimum Content Size In CSS FlexBox
## Minimum Content Size In CSS FlexBox

CSS FlexBox 的 最小内容大小：
如果 flex 项的文本元素或图像大于项本身，则浏览器不会收缩它们。这是 flexbox 的默认行为。

:::demo-wrapper

可以看到内容发生了溢出，即使我们使用 `overflow-wrap: break-word` 来强制换行，也不会起作用。

```css
.card__title {
  overflow-wrap: break-word;
}
```

要改变 FlexBox 的默认行为，我们需要将 FlexBox 的子项 的 `min-width` 设置为 0。

```css
.card__title {
  overflow-wrap: break-word;
  min-width: 0;
}
```

:::demo-wrapper

***

同样的， 在 列方向上，也可以使用 `min-height` 来改变 FlexBox 的默认行为。

---

---
url: /defensive-css/minimum-content-size-in-grid/index.md
---
# Minimum Content Size In CSS Grid
## Minimum Content Size In CSS Grid

网格布局的最小内容大小：
CSS 网格的子项具有默认的最小内容大小，即 `auto` 。
这意味着，如果存在大于网格项的元素，它将溢出。

```css
.wrapper {
  width: 250px;
  display: grid;
  grid-template-columns: 1fr 100px;
  grid-gap: 20px;
}
```

:::demo-wrapper

由于 左侧栏中的内容长度过宽，大于剩余的内容空间，导致了 内容溢出。

为了解决这个问题，我们有三种不同的解决方案：

1. 在 网格项中使用 `min-width: 0`
2. 使用 `minmax()`
3. 在 网格项中使用 `overflow: hidden`

作为 防御性 CSS 策略，选择使用 哪种方案并不重要，只要能够解决问题即可。

在这里，我们选择 `min-width: 0`

:::demo-wrapper

---

---
url: /defensive-css/scroll-chaining/index.md
---
# Scroll Chaining
## Scroll Chaining

我们可能会经常遇到， 当我们打开一个 modal 框并开始滚动，并滚动到底后继续滚动时，
modal 框的外部容器 `body` 元素还会继续滚动。

这被称之为 **滚动关联(scroll chaining)** 。

:::demo-wrapper no-padding

在过去，我们需要一些技术方案（如，使用JavaScript事件）来解决这个问题。
但是现在，我们可以直接使用 CSS 属性 `overscroll-behavior` 来解决这个问题。

```css
.modal {
  overscroll-behavior-y: contain; /* [!code highlight] */
  overflow-y: auto;
}
```

:::demo-wrapper no-padding

---

---
url: /defensive-css/scroll-gutter/index.md
---
# Scroll Gutter
## Scroll Gutter

与滚动相关的另一件事是滚动条装订线。
以前面的 [例子](/defensive-css/scroll-chaining/) 为例，当内容变长时，添加滚动条将导致布局偏移。
发生布局偏移的原因是为滚动条保留空间。

:::demo-wrapper
\<button type="button" class="add-btn-120" @click="toggle">
{{ show ? '重置内容' : '添加内容' }}


请注意，当内容因显示滚动条而变长时，内容是如何移动的。
我们可以通过使用属性 `scrollbar-gutter` 来避免这种行为。

```css
.body {
  scrollbar-gutter: stable;
}
```

:::demo-wrapper
\<button type="button" class="add-btn-120" @click="toggle2">
{{ show2 ? '重置内容' : '添加内容' }}


`scrollbar-gutter: stable` 将会预先为 滚动条保留空间。
因此，在计算 内填充 `padding` 时，应考虑滚动条的宽度，从而适配 UI 效果。

---

---
url: /defensive-css/scrollbar-on-demand/index.md
---
# Scrollbar On Demand
## Scrollbar On Demand

按需使用滚动条。当下，我们可以控制是否显示滚动条，或者仅在内容较长的时候显示滚动条。
但强烈建议在不确定内容的情况下使用 `auto` 作为 `overflow` 属性值。

:::demo-wrapper

可以看到，即使内容很短，也能看到 滚动条，这对 UI 而言很不利。
在不需要 滚动条的时候看到滚动条是一件令人不快的事情。

使用 `overflow-y: auto` 时，滚动条只有在内容较长时才可见。
这是更好的 视觉交互体验。

:::demo-wrapper

---

---
url: /defensive-css/sticky-with-grid/index.md
---
# Position Sticky With CSS Grid
## Position Sticky With CSS Grid

你有没有试过与 网格布局的 子项 一起使用 `position: sticky`？
网格项的默认行为是拉伸。因此，以下示例中的 aside 元素等于 main 元素高度。

:::demo-wrapper

若要使其按预期工作，需要重置 `align-self` 属性。

```css
aside {
  align-self: start;
  position: sticky;
}
```

:::demo-wrapper

---

---
url: /defensive-css/text-over-image/index.md
---
# Text Over Image
## Text Over Image

在 图像 上显示文本时，需要考虑 图像 加载失败时的情况，文本会成什么样。

看下面的示例：

:::demo-wrapper no-padding

但是，当图片加载失败时, 文本几乎看不见。

:::demo-wrapper no-padding

我们可以通过为 `<img>` 元素添加背景颜色来解决这个问题。
仅当图像加载失败时，此背景才可见。

:::demo-wrapper no-padding

---

---
url: /defensive-css/using-space-between/index.md
---
# Using Space Between
## Using Space Between

在 Flex 容器中， 我们可以使用 `space-between` 来定义项目之间的间距。
当子项的数量 符合我们的 布局预期时，在 UI 效果上来看还不错。
但是，如果 项目的数量过多或过少时，布局就会看起来很糟糕。

请看下面示例：

```css
.wrapper {
  display: flex;
  justify-content: space-between;
}
```

:::demo-wrapper

项目为 4 个时，看起来还不错。

项目为 3 个时，间隔就过大了。

对此，我们有不同的解决方案：

* 使用 `margin` 设置外边距作为间隔
* 使用 flexbox `gap` 设置间隔
* 在父元素上使用 `padding` 作为 子元素 间隔
* 添加空白元素作为间隔

比如，我们使用 `gap` 设置 间隔

```css
.wrapper {
  display: flex;
  gap: 1rem;
}
```

:::demo-wrapper

---

---
url: /defensive-css/variable-fallback/index.md
---
# CSS Variable Fallback
## CSS Variable Fallback

CSS 变量越来越多的应用于前端开发中。
但我们可能在使用 CSS 变量的过程中，可能由于某些原因导致 CSS 变量值为空，特别是，如果这个 CSS 变量
的值是通过 JavaScript 控制的。

下面有一个例子：

```css
.message__bubble {
  max-width: calc(100% - var(--actions-width));
}
```

变量 `--actions-width` 在 CSS 函数 `calc()` 中使用， 它的值通过 JavaScript 控制的。
假设 JavaScript 由于某些原因，设置 `--actions-width` 的值失败了。
这会导致 `calc()` 计算的 `max-width` 值为 无效的，这可能导致 意外的布局问题。

我们可以提前避免这种情况，给 `--actions-width` 设置一个 回退值。

```css
.message__bubble {
  max-width: calc(100% - var(--actions-width, 70px));
}
```

如果未定义变量，将使用回退 `70px` 。
可以使用这种方法避免设置变量可能失败（例如：来自 Javascript）。

---

---
url: /defensive-css/vertical-media-queries/index.md
---
# Vertical Media Queries
## Vertical Media Queries

有时候，构建一个组件，并且通过调整浏览器的宽度的大小进行测试，是非常有用的。
但可能会经常的忽略针对 高度 进行测试。

一种常见的场景是，在一个 main 和 aside 布局的场景中，一些 辅助的导航链接位于 aside 的底部位置。

请看以下示例，辅助导航链接 通过 `position:sticky` 粘在 aside 的底部。在高度足够的情况下，看起来
还不错。

:::demo-wrapper

但是，如果浏览器窗口的高度较小，辅助导航链接会被挤压，与其他内容发生重叠。

:::demo-wrapper

通过使用 CSS 垂直媒体查询，我们可以避免这个问题。

```css
@media (min-height: 600px) {
  .aside__nav {
    position: sticky;
    bottom: 1rem;
  }
}
```

这样，只有当视口高度大于或等于 600px 时，辅助导航才会粘在底部。

可能有更好的方法来实现该行为（例如使用 margin-auto ），但在此示例中专注于 `vertical media queries`。

---

---
url: /design-pattern/index.md
---
# 设计模式

---

---
url: /design-pattern/adapter/index.md
---
# 适配器模式
## 什么是适配器模式？

\==Adapter(适配器)模式== 是一种结构型设计模式。

用于将不兼容的接口转换为客户端期望的接口。它通过创建一个中间层（适配器），
使原本因接口不匹配而无法协作的类或对象能够协同工作。适配器模式的核心是 **转换**，而非修改原有代码。

## 实现适配器模式

在 JavaScript 中，适配器模式可以通过以下两种方式实现：

### 对象适配器

通过组合（持有被适配对象的实例）实现接口转换：

```ts
// 被适配的旧接口
class OldLogger {
  logMessage(message) {
    console.log(`旧日志格式: [${new Date()}] ${message}`)
  }
}

// 新系统期望的接口
class NewLoggerAdapter {
  constructor(oldLogger) {
    this.oldLogger = oldLogger
  }

  // 适配旧接口到新接口
  print(text) {
    this.oldLogger.logMessage(text.toUpperCase()) // 转换逻辑
  }
}

// 使用适配器
const oldLogger = new OldLogger()
const adapter = new NewLoggerAdapter(oldLogger)
adapter.print('hello world') // 输出：旧日志格式: [当前时间] HELLO WORLD
```

### 函数适配器

通过高阶函数包装原有函数：

```ts
// 旧函数：参数顺序是 (width, height)
function calculateArea(width, height) {
  return width * height
}

// 适配器：将新接口 (height, width) 转换为旧接口
const adaptedCalculateArea = (height, width) => calculateArea(width, height)

console.log(adaptedCalculateArea(10, 5)) // 输出 50
```

## 优点

* **解耦性**：分离客户端代码与被适配对象，避免直接依赖不兼容的接口。
* **复用性**：整合旧代码或第三方库时无需修改其源码。
* **灵活性**：适配器可以作为临时过渡方案，支持逐步重构。
* **开闭原则**：通过新增适配器扩展功能，而非修改现有代码。

## 缺点

* **复杂度增加**：过多适配器会使得代码结构复杂，维护成本上升。
* **性能损耗**：额外的调用层可能轻微影响性能（通常可忽略）。
* **可能掩盖问题**：滥用适配器可能导致设计缺陷被隐藏，而非彻底解决。

## 适用场景

* **整合第三方库**：将外部库的接口转换为符合当前系统的接口。
* **旧系统改造**：逐步迁移遗留代码时，新旧接口共存。
* **统一接口规范**：多个类/对象功能类似但接口不同，需统一调用方式。
* **数据格式转换**：如将 XML 响应适配为 JSON 格式。

---

---
url: /design-pattern/builder/index.md
---
# 建造者模式
## 什么是建造者模式？

\==Builder(建造者)模式== 是一种创建型设计模式。

它用于分步骤构建复杂对象。
它通过将对象的构造过程与其表示分离，允许相同的构建过程创建不同的表示。

该模式的核心思想是：

* **分离构建步骤**：将对象的构建分解为多个独立步骤。
* **统一构建流程**：通过一个指挥者（Director）控制构建顺序。
* **灵活组合**：通过不同建造者（Builder）实现不同配置的对象。

## 实现建造者模式

下面是一个简单的示例，展示了建造者模式的实现：

```js
// 1. 产品类（最终要构建的复杂对象）
class Pizza {
  constructor() {
    this.base = null
    this.sauce = null
    this.toppings = []
  }

  describe() {
    return `Pizza with ${this.base} base, ${this.sauce} sauce, and toppings: ${this.toppings.join(', ')}`
  }
}

// 2. 建造者接口（定义构建步骤）
class PizzaBuilder {
  constructor() {
    this.pizza = new Pizza()
  }

  prepareBase(base) {
    this.pizza.base = base
    return this // 返回this支持链式调用
  }

  addSauce(sauce) {
    this.pizza.sauce = sauce
    return this
  }

  addTopping(topping) {
    this.pizza.toppings.push(topping)
    return this
  }

  build() {
    return this.pizza
  }
}

// 3. 指挥者（可选，封装构建流程）
class PizzaDirector {
  constructor(builder) {
    this.builder = builder
  }

  makeMargherita() {
    return this.builder
      .prepareBase('thin crust')
      .addSauce('tomato')
      .addTopping('mozzarella')
      .addTopping('basil')
      .build()
  }

  makePepperoni() {
    return this.builder
      .prepareBase('thick crust')
      .addSauce('spicy tomato')
      .addTopping('pepperoni')
      .addTopping('cheese')
      .build()
  }
}

// 使用示例
const builder = new PizzaBuilder()

// 方式1: 直接使用建造者（链式调用）
const customPizza = builder
  .prepareBase('gluten-free')
  .addSauce('pesto')
  .addTopping('mushrooms')
  .addTopping('olives')
  .build()
console.log(customPizza.describe()) // Pizza with gluten-free base...

// 方式2: 通过指挥者创建预定义对象
const director = new PizzaDirector(builder)
const margherita = director.makeMargherita()
console.log(margherita.describe()) // Pizza with thin crust base...
```

## 优点

* **分离构造与表示**：将对象的构建细节封装在建造者中，客户端无需了解内部结构。
* **灵活扩展**：新增建造者即可支持新类型的对象，符合开闭原则。
* **精细控制构建过程**：分步构建允许精确控制对象配置。
* **复用构建逻辑**：指挥者封装通用构建流程，避免代码重复。
* **链式调用**：提供流畅接口（Fluent Interface），提升代码可读性。

## 缺点

* **增加代码复杂度**：需创建多个新类（产品、建造者、指挥者）。
* **过度设计风险**：简单对象直接构造更高效，无需使用此模式。
* **建造者依赖**：产品类发生变更时，所有建造者都需要同步修改。

## 适用场景

* **构造复杂对象**：当对象需要多个步骤/组件组合时（如配置复杂的 UI 组件）。
* **不同对象变体**：需要创建多个相似但配置不同的对象（如不同套餐的 Pizza）。
* **避免构造函数参数爆炸**：当构造函数参数过多（>4个）且部分可选时。
* **不可变对象**：配合返回新对象的链式调用，适合构建不可变对象。
* **多步骤构造过程**：当对象构造需要特定顺序或条件检查时。

---

---
url: /design-pattern/command/index.md
---
# 命令模式
\==命令模式== 在前端领域的用例相对有限，这里仅做简单的介绍。

## 什么是命令模式？

\==Command(命令)模式== 旨在将方法调用、请求或操作封装到单一对象中，从而根据我们不同的请求对客户进行参数化
和 传递可供执行的方法调用。这种模式将调用操作的对象与知道如何实现该操作的对象解耦，并在交换出具体类（对象）
方面提供更大的整体灵活性。

用基于类的变成语言解释 **具体类** 是最恰当的，它们与抽象类的思想有关。
一个抽象类定义一个结构，但不一定为它所有的成员函数提供实现。
它作为一个基类，派生出其他类。实现确实功能的派生类被称为一个 **具体类**。

```mermaid
classDiagram
  Client --> Receiver
  Client <--> ConcreteCommand
  Receiver <-- ConcreteCommand
  Invoker <--> Command
  Command <-- ConcreteCommand
  class Receiver{
    +action()
  }
  class Command{
    +execute()
  }
  class ConcreteCommand{
    +execute()
  }
```

\==Command(命令)模式== 背后的主要思想是：它为我们提供了一种分离职责的手段，这些职责包括从执行命令的任意地方
发布命令以及将该职责转而委托给不同对象。

实施明智的、简单那的命令对象将把 **Action** 动作和调用该动作的对象绑定在一起。它们始终包括一个执行操作
（如 `run()` 或 `execute()`）。所有具有相同接口的 Command 对象可以根据需要轻松交换，这被认为是该模式的一个更大的好处。

## 使用命令模式

假设我们有一个在线购物系统，用户可以下单、跟踪订单 和 取消订单。

```ts
class OrderManager {
  constructor() {
    this.orders = []
  }

  placeOrder(order, id) {
    this.orders.push(id)
    return `Successfully ordered ${order} (${id})`
  }

  trackOrder(id) {
    return `Order ${id} is in progress`
  }

  cancelOrder(id) {
    this.orders = this.orders.filter(order => order.id !== id)
    return `Order ${id} has been canceled`
  }
}
```

在 `OrderManager` 类中，我们可以访问 `placeOrder`、`trackOrder` 和 `cancelOrder` 方法。

```ts
const manager = new OrderManager()

manager.placeOrder('shoes', '1234')
manager.trackOrder('1234')
manager.cancelOrder('1234')
```

但是，直接在 manager 实例上调用方法也有缺点。我们可能在未来的某些时候，重命名这些方法，或者某些功能发生变化，
或者移除它们。

假设我们把 `placeOrder` 方法重命名为 `addOrder`，这意味着我们需要确保在整个程序应用中没有任何位置调用
`placeOrder` 方法，这在大型的程序中可能是一个大问题。

我们希望将方法与管理者对象解耦，并为每个命令创建独立的命令函数！

我们开始对 `OrderManager` 类进行重构，移除 `placeOrder` 、`trackOrder` 和 `cancelOrder` 方法，
并添加一个新的 `execute` 方法，此方法将执行任何给它的命令。

每个命令都应该可以访问 manager 的 `orders`，我们将作为它的第一个参数传递。

```ts
class OrderManager {
  constructor() {
    this.orders = []
  }

  execute(command, ...args) {
    return command.execute(this.orders, ...args)
  }
}
```

我们需要为订单管理器创建三个 Command：

* `PlaceOrderCommand`
* `CancelOrderCommand`
* `TrackOrderCommand`

```ts
class Command {
  constructor(execute) {
    this.execute = execute
  }
}

function PlaceOrderCommand(order, id) {
  return new Command((orders) => {
    orders.push(id)
    return `Successfully ordered ${order} (${id})`
  })
}

function CancelOrderCommand(id) {
  return new Command((orders) => {
    orders = orders.filter(order => order.id !== id)
    return `Order ${id} has been canceled`
  })
}

function TrackOrderCommand(id) {
  return new Command(() => `Order ${id} is in progress`)
}
```

它们不再直接耦合到 `OrderManager` 实例，而是独立的、解耦的函数，
我们可以通过 `OrderManager` 上可用的 `execute` 方法调用它们。

```ts
class OrderManager {
  constructor() {
    this.orders = []
  }

  execute(command, ...args) {
    return command.execute(this.orders, ...args)
  }
}

const manager = new OrderManager()

manager.execute(new PlaceOrderCommand('shoes', '1234'))
manager.execute(new TrackOrderCommand('1234'))
manager.execute(new CancelOrderCommand('1234'))
```

## 优点

命令模式允许我们将方法与执行作的对象解耦。
如果正在处理具有特定生命周期的命令，或者应该排队并在特定时间执行的命令，它将提供更多控制权。

## 缺点

命令模式的用例非常有限，并且通常会向应用程序添加不必要的样板内容。

---

---
url: /design-pattern/composite/index.md
---
# 组合模式
## 什么是组合模式？

\==Composite（组合）模式== 是一种结构型设计模式。

它用于将对象组织成树形结构，以表示 **“部分-整体”** 的层次关系。
它允许客户端以统一的方式处理单个对象和组合对象，忽略对象层次结构的差异。

组合模式主要由以下部分组成：

### Component（抽象构件）

* 定义所有对象的通用接口（包括叶子节点和容器）。
* 声明操作子节点的方法（如 add、remove）。

### Leaf（叶子节点）

* 表示树中的末端对象（无子节点）。
* 实现 Component 接口的基本行为。

### Composite（容器节点）

* 包含子节点（Leaf 或 Composite）。
* 实现操作和管理子节点的方法。

## 实现组合模式

```js
// 1. 抽象构件
class Component {
  constructor(name) {
    this.name = name
  }

  // 默认抛出错误（叶子节点需重写）
  add(component) {
    throw new Error('Leaf nodes cannot add children.')
  }

  remove(component) {
    throw new Error('Leaf nodes cannot remove children.')
  }

  // 核心方法（所有构件必须实现）
  operation(depth = 0) {
    throw new Error('Subclass must implement operation().')
  }
}

// 2. 叶子节点（无子节点）
class Leaf extends Component {
  operation(depth = 0) {
    console.log(`${' '.repeat(depth * 2)}Leaf: ${this.name}`)
  }
}

// 3. 容器节点（可包含子节点）
class Composite extends Component {
  constructor(name) {
    super(name)
    this.children = []
  }

  add(component) {
    this.children.push(component)
  }

  remove(component) {
    const index = this.children.indexOf(component)
    if (index !== -1)
      this.children.splice(index, 1)
  }

  operation(depth = 0) {
    console.log(`${' '.repeat(depth * 2)}Composite: ${this.name}`)
    // 递归调用子节点的 operation()
    this.children.forEach(child =>
      child.operation(depth + 1)
    )
  }
}

// 客户端使用
const root = new Composite('Root')
const branch1 = new Composite('Branch 1')
const branch2 = new Composite('Branch 2')

root.add(branch1)
root.add(branch2)

branch1.add(new Leaf('Leaf A'))
branch1.add(new Leaf('Leaf B'))
branch2.add(new Leaf('Leaf C'))

root.operation()
```

```console
Composite: Root
  Composite: Branch 1
    Leaf: Leaf A
    Leaf: Leaf B
  Composite: Branch 2
    Leaf: Leaf C
```

## 优点

* **统一处理**：客户端无需区分叶子节点和容器节点。
* **开闭原则**：新增节点类型无需修改现有代码。
* **简化复杂结构**：通过递归机制处理树形结构，代码简洁。
* **灵活性**：动态组合对象，构建任意复杂度的结构。

## 缺点

* **违反单一职责**：Component 需同时管理叶子/容器逻辑（通过异常处理限制叶子节点）。
* **过度泛化**：所有构件使用相同接口，可能包含不适用方法（如叶子节点的 add()）。
* **类型检查问题**：需在运行时检查节点类型（如避免在叶子上调用 add()）。

## 适用场景

* **树形结构处理**：

  * 文件系统（文件是叶子，文件夹是容器）。
  * 组织架构（员工是叶子，部门是容器）。
  * UI 组件库（按钮是叶子，面板是容器）。

* **统一操作需求**：

  * 递归计算（如目录总大小）。
  * 批量执行（如禁用整个表单控件）。

* **嵌套菜单/导航**：

  菜单项（叶子）和子菜单（容器）的统一渲染。

---

---
url: /design-pattern/decorator/index.md
---
# 装饰者模式
## 什么是装饰者模式？

\==Decorator(装饰者)模式== 是一种结构型设计模式。

它允许动态地为对象添加额外的职责，而无需修改其原有代码。
它通过将对象包装在装饰者类中，以透明的方式扩展功能，避免了静态继承带来的类爆炸问题，
符合开闭原则（对扩展开放，对修改关闭）。

## 实现装饰者模式

在 JavaScript 中，装饰者模式可以通过以下方式实现：

### 函数装饰（高阶函数）

通过高阶函数包装原函数，添加新功能：

```ts
function logDecorator(func) {
  return function (...args) {
    console.log('Function called:', func.name)
    const result = func.apply(this, args)
    console.log('Result:', result)
    return result
  }
}

// 使用
const add = (a, b) => a + b
const decoratedAdd = logDecorator(add)
decoratedAdd(2, 3) // 输出日志并计算结果
```

### 对象方法装饰

替换对象的方法以实现增强功能：

```ts
function decorateMethod(obj, methodName, decorator) {
  const originalMethod = obj[methodName]
  obj[methodName] = function (...args) {
    console.log('Method execution started')
    const result = originalMethod.apply(this, args)
    console.log('Method execution ended')
    return result
  }
}

// 使用
const calculator = { add: (a, b) => a + b }
decorateMethod(calculator, 'add', original => original)
calculator.add(1, 2) // 输出执行日志
```

### 类装饰（基于组合）

通过装饰类包裹原对象，扩展其方法：

```ts
class Coffee {
  cost() { return 5 }
}

class MilkDecorator {
  constructor(coffee) {
    this.coffee = coffee
  }

  cost() { return this.coffee.cost() + 2 }
}

class SugarDecorator {
  constructor(coffee) {
    this.coffee = coffee
  }

  cost() { return this.coffee.cost() + 1 }
}

// 使用
let coffee = new Coffee()
coffee = new MilkDecorator(coffee)
coffee = new SugarDecorator(coffee)
console.log(coffee.cost()) // 输出：8
```

### ES7/TypeScript 装饰器语法

利用 `@decorator` 语法糖简化实现（需 Babel 或 TypeScript 支持）：

```ts
function log(target, key, descriptor) {
  const originalMethod = descriptor.value
  descriptor.value = function (...args) {
    console.log(`Calling ${key} with args:`, args)
    return originalMethod.apply(this, args)
  }
  return descriptor
}

class Example {
  @log
  add(a, b) { return a + b }
}
```

## 优点

* **动态扩展**：运行时添加或移除功能，灵活性强。
* **单一职责**：每个装饰类只关注一个功能，代码更清晰。
* **替代继承**：避免多层继承导致的类膨胀问题。
* **开闭原则**：无需修改原有代码即可扩展功能。

## 缺点

* **复杂度增加**：多层装饰可能导致代码结构复杂，调试困难。
* **性能开销**：装饰链较长时，可能影响执行效率。
* **依赖管理**：装饰者需要与原对象保持接口一致，否则可能破坏调用逻辑。

## 适用场景

* **动态功能扩展**：如为对象添加日志、缓存、权限检查等。
* **不可修改的第三方库**：在不修改源码的情况下增强功能。
* **组合替代继承**：需要多维度扩展对象功能时。
* **中间件机制**：如 Express 的中间件、Redux 的 enhancer。

---

---
url: /design-pattern/facade/index.md
---
# 外观模式
:::tip 当系统复杂度达到需要频繁查阅文档才能调用时，就是考虑引入外观模式的最佳时机。它如同一位优秀的翻译官，在复杂的技术细节与简洁的业务逻辑之间架起沟通的桥梁。
:::

## 什么是外观模式？

\==Facade(外观)模式== 是一种结构型设计模式，核心思想是 **为复杂的子系统提供一个简化的统一接口**。
如同建筑外墙隐藏内部结构，它通过创建一个高层接口，将底层模块的复杂性屏蔽，使客户端调用更简单直观。

## 实现外观模式

```ts
// 复杂子系统
class CPU {
  start() { console.log('启动CPU') }
}
class Memory {
  load() { console.log('加载内存') }
}

// 外观接口
class ComputerFacade {
  constructor() {
    this.cpu = new CPU()
    this.memory = new Memory()
  }

  start() {
    this.cpu.start()
    this.memory.load()
    console.log('计算机启动完成')
  }
}

// 客户端调用
const computer = new ComputerFacade()
computer.start() // 隐藏底层细节
```

**实际应用示例：浏览器事件处理**：

```ts
// 封装不同浏览器的事件处理差异
const eventFacade = {
  addListener(element, type, handler) {
    if (element.addEventListener) {
      element.addEventListener(type, handler, false)
    }
    else if (element.attachEvent) {
      element.attachEvent(`on${type}`, handler)
    }
    else {
      element[`on${type}`] = handler
    }
  },

  removeListener(element, type, handler) {
    // 类似实现移除逻辑...
  }
}

// 统一调用方式
eventFacade.addListener(document.getElementById('btn'), 'click', handleClick)
```

## 优点

* **简化接口**：将复杂调用简化为清晰的方法
* **解耦系统**：客户端与子系统松耦合，易于维护
* **渐进式重构**：逐步替换旧代码的利器
* **安全隔离**：隐藏敏感操作，提升安全性

## 潜在局限

* **过度封装风险**：可能创建"上帝对象"
* **灵活性限制**：需要平衡简化与扩展性

## 最佳实践

* 明确外观层的职责边界
* 避免直接暴露子系统内部
* 保持外观接口的稳定性

---

---
url: /design-pattern/factory/index.md
---
# 工厂模式
你可能每天都在使用 ==工厂模式=={.caution} ！

## 什么是工厂模式？

\==Factory(工厂)== 模式是一种创建型模式，涉及创建对象的概念。

它不显式的要求使用一个构造函数。
Factory 可以提供一个通用的接口来创建对象，我们可以指定我们所希望创建的工厂对象的类型。

```mermaid
classDiagram
  Product <-- ConcreteProduct
  Creator --> ConcreteCreator
  ConcreteProduct <.. ConcreteCreator
  class Creator {
    +factoryMethod()
    +operation()
  }
  class ConcreteCreator {
    +factoryMethod()
  }
```

## 使用工厂模式

假设我们的应用程序需要许多用户。
我们需要创建具有 `firstName`、`lastName` 和 `email` 属性的新用户。
工厂函数还会向新创建的对象添加 `fullName` 属性，该属性将返回 `firstName` 和 `lastName`。

```ts
function createUser({ firstName, lastName, email }) {
  return {
    firstName,
    lastName,
    email,
    fullName() {
      return `${this.firstName} ${this.lastName}`
    },
  }
}
```

我们可以通过调用 `createUser` 函数来轻松创建多个用户。

```ts
const user1 = createUser({
  firstName: 'Jame',
  lastName: 'Wick',
  email: 'jame@wick.com'
})

const user2 = createUser({
  firstName: 'Juan',
  lastName: 'Jonson',
  email: 'juan@jonson.com'
})

console.log(user1)
console.log(user2)
```

对于对象创建过程相对比较复杂，这种方法特别有用。
比如，我们需要根据动态因素或者配置文件创建对象。

```ts
function createStore() {
  if (process.env.NODE_ENV === 'production') {
    return { env: 'production' }
  }

  return { env: 'development' }
}
```

---

---
url: /design-pattern/filter/index.md
---
# 过滤器模式
## 什么是过滤器模式？

\==Filter(过滤器)模式== 是一种结构型设计模式。

它允许使用不同标准过滤一组对象，并通过逻辑操作（AND、OR）组合这些标准。
核心思想是 **解耦过滤逻辑与业务代码，使系统更灵活、可扩展**。
在 JavaScript 中，通常结合高阶函数（如 `filter()`）实现。

## 实现 Filter(过滤器)模式

### 简单实现（函数式风格）

```js
// 过滤器函数
function genderFilter(gender) {
  return persons =>
    persons.filter(p => p.gender === gender)
}

function statusFilter(status) {
  return persons =>
    persons.filter(p => p.maritalStatus === status)
}

// 组合过滤器
const andFilter = (f1, f2) => persons => f2(f1(persons))
function orFilter(f1, f2) {
  return persons =>
    [...new Set([...f1(persons), ...f2(persons)])]
}

// 使用示例
const getSingleFemales = andFilter(
  genderFilter('Female'),
  statusFilter('Single')
)

console.log(getSingleFemales(persons)) // [Alice]
```

### 类实现（对象方面）

```js
// 1. 定义数据对象
class Person {
  constructor(name, gender, maritalStatus) {
    this.name = name
    this.gender = gender
    this.maritalStatus = maritalStatus
  }
}

// 2. 定义过滤器接口
class Criteria {
  meetCriteria(persons) {
    throw new Error('必须实现 meetCriteria 方法')
  }
}

// 3. 具体过滤器实现
class GenderCriteria extends Criteria {
  constructor(gender) {
    super()
    this.gender = gender
  }

  meetCriteria(persons) {
    return persons.filter(p => p.gender === this.gender)
  }
}

class MaritalStatusCriteria extends Criteria {
  constructor(status) {
    super()
    this.status = status
  }

  meetCriteria(persons) {
    return persons.filter(p => p.maritalStatus === this.status)
  }
}

// 4. 组合过滤器 (AND/OR)
class AndCriteria extends Criteria {
  constructor(criteria1, criteria2) {
    super()
    this.criteria1 = criteria1
    this.criteria2 = criteria2
  }

  meetCriteria(persons) {
    return this.criteria2.meetCriteria(this.criteria1.meetCriteria(persons))
  }
}

class OrCriteria extends Criteria {
  constructor(criteria1, criteria2) {
    super()
    this.criteria1 = criteria1
    this.criteria2 = criteria2
  }

  meetCriteria(persons) {
    const result1 = this.criteria1.meetCriteria(persons)
    const result2 = this.criteria2.meetCriteria(persons)
    // 合并并去重
    return [...new Set([...result1, ...result2])]
  }
}

// 5. 使用示例
const persons = [
  new Person('Alice', 'Female', 'Single'),
  new Person('Bob', 'Male', 'Single'),
  new Person('Charlie', 'Male', 'Married')
]

// 创建过滤器
const female = new GenderCriteria('Female')
const single = new MaritalStatusCriteria('Single')
const singleFemale = new AndCriteria(female, single)
const maleOrSingle = new OrCriteria(
  new GenderCriteria('Male'),
  single
)

// 应用过滤器
console.log(singleFemale.meetCriteria(persons))
// 输出: [Person{name: 'Alice', ...}]

console.log(maleOrSingle.meetCriteria(persons))
// 输出: [Bob, Charlie, Alice] (男性或单身)
```

## 优点

* **开闭原则**：新增过滤标准无需修改已有代码。
* **解耦**：过滤逻辑与业务逻辑分离。
* **可组合性**：通过 AND/OR 轻松组合多个条件。
* **复用性**：过滤器可在多处重复使用。
* **函数式友好**：天然契合 JavaScript 的高阶函数特性。

## 缺点

* **性能开销**：链式过滤可能需多次遍历数据（大型数据集需优化）。
* **类膨胀**：每个新标准需创建新类（可改用函数式简化）。
* **过度设计**：简单场景下直接使用 Array.filter() 更合适。

## 适用场景

* **动态查询条件**：如电商产品的多维度筛选（价格、品牌、评分）。
* **数据报表**：按不同业务标准过滤统计信息。
* **权限系统**：组合角色/权限规则过滤用户。
* **API 数据过滤**：后端返回数据集，前端按需过滤展示。
* **复杂条件组合**：需要支持 AND/OR/NOT 逻辑的查询。

---

---
url: /design-pattern/flyweight/index.md
---
# 享元模式
## 什么是享元模式？

\==Flyweight(享元)模式== 是一种结构型设计模式，用于优化重复、缓慢以及数据共享效率较低的代码。

它旨在通过与相关的对象共享尽可能多的数据来减少应用程序中内存的使用（如：应用程序配置、状态等）。

Flyweight 数据共享会涉及获取多个对象使用的若干相似对象或数据结构，
以及将这些数据放到一个单一的外部对象中。
我们可以将该对象传递给依赖这些数据的对象，而不是在每一个对象都存储相同的数据。

## 使用享元模式

我们通过实现一个系统来管理图书馆中的所有书籍。

我们使用构造函数来创建图书馆中的书籍，每个书籍都有 `id`、 `title`、`author`、`isbn` 等基本属性，
同时，还需要使用 `checkoutDate`、`checkoutMember` `dueReturnDate` 等属性来管理借阅信息。

```ts
class Book {
  constructor(id, title, author, isbn) {
    this.title = title
    this.author = author
    this.isbn = isbn
    this.id = id
    this.checkoutDate = null
    this.checkoutMember = null
    this.dueReturnDate = null
  }
}
```

还需要添加 `updateCheckout` 方法来更新借阅信息:

```ts
class Book {
  // ...
  updateCheckout(checkoutDate, checkoutMember, dueReturnDate) {
    this.checkoutDate = checkoutDate
    this.checkoutMember = checkoutMember
    this.dueReturnDate = dueReturnDate
  }
}
```

`Book` 的每一个实例表示一本书。在刚开始对于少量书籍可能是行得通的。
但是，当图书馆夸大到拥有一个更大的库存，每本书都有多个副本时，就会发现随着时间的推移，
管理系统运行的越来越慢，使用数以千计的书籍对象可能会淹没可用内存。

我们可以使用 ==享元模式== 来改善这个问题。

我们将 `Book` 的数据分为 内部状态和 外部状态 两个部分。

内部状态包含 `title`、`author`、`isbn` 等基本属性。
外部状态包含 `checkoutDate`、`checkoutMember` `dueReturnDate` 等属性。

`Book` 只需要存储内部状态，虽然仍然会处理相当多的书籍对象，当需要处理的数据明显减少了：

```ts
export class Book {
  constructor(title, author, isbn) {
    this.title = title
    this.author = author
    this.isbn = isbn
  }
}
```

我们可以使用一个工厂来创建 `Book`，该工厂会返回一个 `Book` 的实例，在集合中存储图书馆中的书，
当往集合中添加数据时，如果该书已存在，则不会添加，否则往集合中添加新的实例。

```ts
const bookDatabase: Map<Book> = new Map()

export function createBook(title, author, isbn) {
  if (bookDatabase.has(isbn)) {
    return bookDatabase.get(isbn)
  }
  else {
    const book = new Book(title, author, isbn)
    bookDatabase.set(isbn, book)
    return book
  }
}
```

我们还需要追踪图书馆的书籍总数，书籍可能存在或者多个副本，当我们添加新的副本时，我们不必要每次都创建新的 `Book` 实例，
而是可以复用已经存在的 `Book` 实例：

```ts
const bookList = [] // 图书馆中的书籍（包含副本）

function addBook(title, author, isbn, sales, availibility) {
  const book = createBook(title, author, isbn)
  bookList.push({
    book,
    sales,
    availibility,
    isbn,
  })
}
```

而对于书籍借出记录，我们也进行单独的管理:

```ts
const bookCheckoutRecords = new Map()

function addRecord(isbn, checkoutDate, checkoutMember, dueReturnDate) {
  // 从图书馆中找到对应的可用的书籍
  const item = bookList.find(book => book.isbn === isbn && book.availibility)
  if (item) {
    const record = {
      book: item.book,
      checkoutDate,
      checkoutMember,
      dueReturnDate
    }
    item.availibility = false
    const recordId = `${isbn}-${checkoutMember}-${checkoutDate}`
    bookCheckoutRecords.set(recordId, record)
  }
  else {
    console.log(`isbn ${isbn} is not available`)
  }
}
```

完美！在图书馆书籍总数 和 借出记录中，我们复用了 `book` 对象，不必每次都创建新的 `Book` 对象。

当我们添加新的书籍副本时：

```ts
addBook('JavaScript', 'James', '978-1-59327-482-1', 100, true)
addBook('JavaScript', 'Jams', '978-1-59327-482-1', 100, true)
addBook('HTML', 'Jhon', '978-1-59327-482-2', 80, true)
addBook('HTML', 'Jhon', '978-1-59327-482-2', 80, false)
addBook('CSS', 'Yang', '978-1-59327-482-3', 50, true)
```

虽然书籍总数增加了 5 本，但在 bookDatabase 中，只新增了 3 本不同的图书。

当我们添加新的借出记录时，如果图书馆中有对应的书籍，那么就可以复用已经存在的 `book` 对象，不必创建新的 `book` 对象。

```ts
addRecord('978-1-59327-482-1', '2022-01-01', 'Jams', '2018-01-31')
addRecord('978-1-59327-482-2', '2022-01-01', 'Li', '2018-02-01')
addRecord('978-1-59327-482-3', '2022-01-01', 'Huang', '2018-03-31')
addRecord('978-1-59327-482-4', '2022-01-01', 'Has', '2018-04-11')
```

## 优点

当我们需要创建大量对象时，并且在这些对象中存在大量相同的数据时，享元模式 非常有用，可以大大减少内存开销。

---

---
url: /design-pattern/interceptor/index.md
---
# 拦截过滤器模式
## 什么是拦截过滤器模式？

\==Interceptor(拦截过滤器)模式== 是一种结构型设计模式。

它用于在请求处理流程中动态添加预处理（如验证、日志）和后处理逻辑。
它通过可插拔的过滤器链在核心业务逻辑执行前后拦截请求/响应，实现横切关注点（Cross-Cutting Concerns）的解耦。

它主要由 四个部分 组成：

### 过滤器（Filter）

执行具体拦截任务的独立模块（如身份验证、日志记录）。

### 过滤器链（Filter Chain）

管理过滤器的有序执行，控制流程传递。

### 目标对象（Target）

核心业务逻辑（如 API 处理器）。

### 过滤器管理器（Filter Manager）

创建和组装过滤器链（可选）。

## 实现拦截过滤器模式

::: steps

* 创建过滤器接口

  ```js
  class Filter {
    execute(request, response, chain) {
      throw new Error('execute() must be implemented')
    }
  }
  ```

* 实现具体过滤器

  ```js
  // 身份验证过滤器
  class AuthFilter extends Filter {
    execute(request, response, chain) {
      console.log('AuthFilter: Checking authentication')
      if (!request.headers.token) {
        throw new Error('Unauthorized!')
      }
      chain.execute(request, response) // 传递到下一个过滤器
    }
  }

  // 日志过滤器
  class LogFilter extends Filter {
    execute(request, response, chain) {
      console.log(`LogFilter: ${request.url} at ${new Date()}`)
      chainexecute(request, response)
      consolelog('LogFilter: Response sent')
    }
  }
  ```

* 创建过滤器链

  ```js
  class FilterChain {
    constructor() {
      this.filters = []
      this.target = null
    }

    addFilter(filter) {
      this.filters.push(filter)
      return this // 支持链式调用
    }

    setTarget(target) {
      this.target = target
    }

    execute(request, response) {
      if (this.filters.length === 0) {
        this.target?.execute(request, response)
        return
      }

      const [currentFilter, ...remainingFilters] = this.filters
      const nextChain = new FilterChain()
      nextChain.filters = remainingFilters
      nextChain.target = this.target

      currentFilter.execute(request, response, nextChain)
    }
  }
  ```

* 目标对象（业务逻辑）

  ```js
  class ApiHandler {
    execute(request, response) {
      console.log('Processing API request')
      response.status = 200
      response.body = { data: 'Success' }
    }
  }
  ```

* 客户端使用

  ```js
  // 组装过滤器链
  const chain = new FilterChain()
  chain
    .addFilter(new AuthFilter())
    .addFilter(new LogFilter())
    .setTarget(new ApiHandler())

  // 模拟请求
  const request = { url: '/api/data', headers: { token: 'abc123' } }
  const response = {}

  try {
    chain.execute(request, response)
    console.log('Response:', response)
  }
  catch (err) {
    console.error('Error:', err.message)
  }

  // 输出顺序:
  // AuthFilter: Checking authentication
  // LogFilter: /api/data at [timestamp]
  // Processing API request
  // LogFilter: Response sent
  // Response: { status: 200, body: { data: "Success" } }
  ```

:::

## 优点

* **解耦性**

  业务逻辑与横切关注点（如日志、安全）分离。

* **可复用性**

  过滤器可在不同场景重复使用。

* **灵活扩展**

  动态增删过滤器，无需修改核心代码。

* **职责清晰**

  每个过滤器专注单一任务。

## 缺点

* **性能开销**

  链式调用增加额外处理时间。

* **调试复杂度**

  多级过滤增加调试难度。

* **过度设计风险**

  简单场景可能引入不必要的复杂性。

---

---
url: /design-pattern/mediator/index.md
---
# 中介者模式
> \==中介者==，指 “协助谈判和解决冲突的中立方”

## 什么是中介者模式？

\==中介者模式== 是一种行为型设计模式。它允许我们公开一个统一的接口，系统的不同部分可以通过该接口进行通信。

如果一个系统的各个组件之间看起来有太多的直接关系，也许是时候需要一个中心控制点了，以便各个组件可以通过
这个中心控制点进行通信。

Mediator 模式促进松散耦合的方式是：确保组件的交互是通过这个中心点来处理的，而不是通过显式地引用彼此。
这种模式可以帮助我们解耦系统并提高组件的可重用性。

一个典型的例子是机场交通控制系统。机场控制塔（中介者）处理飞机的起飞和降落，因为所有的通信（监听到货发出的通知）
都是从飞机到控制塔，而不是从飞机和飞机直接相互听信的。
中央控制系统是该系统成功的关键，而这也是中介者在软件设计中所担任的角色。

```mermaid
classDiagram
  Colleague1 <--> Mediator
  Mediator <--> Colleague4
  Mediator <--> Colleague5
  Colleague2 <--> Mediator
  Colleague3 <--> Mediator
  class Colleague1 {
    +mediator
  }
  class Colleague2 {
    +mediator
  }
  class Colleague3 {
    +mediator
  }
  class Colleague4 {
    +mediator
  }
  class Colleague5 {
    +mediator
  }
  class Mediator {
    +component
  }
```

## 使用中介者模式

我们来实现一个简单的 聊天室 应用，在这个应用中，用户之间不会直接交谈，而是通过将消息发送到
聊天室（中介者）中，再由聊天室将消息广播给其他用户。

```ts
class ChatRoom {
  logMessage(user, message) {
    const time = new Date()
    const sender = user.getName()

    console.log(`${time} [${sender}]: ${message}`)
  }
}

class User {
  constructor(name, chatroom) {
    this.name = name
    this.chatroom = chatroom
  }

  getName() {
    return this.name
  }

  send(message) {
    this.chatroom.logMessage(this, message)
  }
}
```

在这个应用中，我们创建一个聊天室（中介者）实例，然后创建新的用户实例加入到聊天室中，
用户通过 `send()` 将消息发送给其他用户：

```ts
const chatroom = new ChatRoom()

const user1 = new User('John', chatroom)
const user2 = new User('Jane', chatroom)
const user3 = new User('Bob', chatroom)

user1.send('Hi!')
user2.send('Hello!')
```

## 优点

* **降低复杂度**：将多个对象间的一对多关系转换为一对一关系。
* **解耦**：对象之间不再直接引用，通过中介者进行交互。
* **符合迪米特原则**：对象只需知道中介者，不需要知道其他对象。

## 缺点

中介者可能会变得庞大和复杂，难以维护。

## 中介者 与 观察者

> 在 Observer 模式中，不存在封装约束的单一对象。Observer 和 Subject (合作) 必须合作才能维持约束。
> Communication (通信) 模式由观察者和目标互连的方式所决定：
> 单一目标通常有很多观察者，有时一个目标的观察者是另一个观察者的目标。

中介者 和 观察者 都能够促进松耦合；然而，中介者模式通过限制对象严格通过 中介者进行通信来实现这一目的。
观察者模式创建观察者对象，观察者对象订阅他们的对象发布其感兴趣的事件。

---

---
url: /design-pattern/middleware/index.md
---
# 中间件模式
::: tip
中间件模式通过将复杂流程分解为独立处理单元，显著提升了代码的可维护性和扩展性，
是 JavaScript 生态中不可或缺的设计模式。
:::

## 什么是中间件模式？

\==Middleware(中间件)模式== 是一种通过串联多个处理函数来处理请求的设计模式。

每个函数（中间件）接收输入，执行特定操作，可选择修改数据，并将控制权传递给下一个函数。
这种模式在 Web 开发（如 **Express/Koa**）、数据流处理等场景中广泛应用。

```mermaid
flowchart TD
  I[Input]
  O[Output]
  I --> Middleware1 -- next --> Middleware2 -- next --> O
```

## 实现中间件模式

以下是基于 Express 风格的中间件实现：

```js
function createMiddleware() {
  const middlewares = []

  const use = fn => middlewares.push(fn)

  const execute = async (context) => {
    let index = 0
    const next = async () => {
      if (index < middlewares.length) {
        const middleware = middlewares[index++]
        await middleware(context, next) // 关键：传入next实现链式调用
      }
    }
    await next()
  }

  return { use, execute }
}

// 使用示例
const app = createMiddleware()

// 中间件1：日志记录
app.use(async (ctx, next) => {
  console.log('Request started at', new Date())
  await next() // 传递控制权
  console.log('Request ended')
})

// 中间件2：数据处理
app.use(async (ctx, next) => {
  ctx.data = { modified: true }
  await next()
})

// 执行中间件链
const context = {}
app.execute(context).then(() => {
  console.log('Context:', context) // 输出修改后的数据
})
```

### 核心流程

* **注册顺序**：中间件按 use() 调用顺序排列。
* **控制传递**：next() 将执行权交给下一个中间件。
* **洋葱模型**：执行顺序类似洋葱（请求从外向内，响应从内向外）。

## 优点

* **解耦性**：每个中间件专注单一职责（如日志、验证）。
* **可扩展性**：动态添加/移除中间件，无需修改核心逻辑。
* **灵活性**：支持异步操作（通过 async/await）。
* **复用性**：通用中间件（如 CORS 处理）可跨项目复用。

## 缺点

* **性能开销**：多层函数调用可能影响性能（需控制中间件数量）。
* **错误处理复杂**：需统一错误处理机制（如 Express 的 error-handling middleware）。
* **调试困难**：深层调用栈增加调试难度。
* **顺序依赖**：中间件顺序错误可能导致逻辑问题（如先验证后解析 Body）。

## 适用场景

* **Web 框架**：

  * 请求/响应处理（Express/Koa）。
  * 身份验证、日志、压缩、CORS。

* **数据处理管道**：

  * 数据转换链（如图像处理管道）。
  * 消息队列消费流程。

* **状态管理**：

  Redux 中间件（如 redux-thunk、redux-logger）。

* **构建工具**：

  Webpack 插件（基于 tapable 的中间件系统）。

---

---
url: /design-pattern/mixin/index.md
---
# 混入模式
::: tip
Mixin 模式在 JavaScript 中提供了一种强大的代码复用机制，尤其适合需要横向扩展功能的场景。
然而，需谨慎处理命名冲突和代码组织问题。随着 ES6 Class 和组合式 API（如 Vue 3 Composables、React Hooks）的普及，Mixin 的使用有所减少，但其核心思想（组合优于继承）仍是现代开发的重要原则。
:::

## 什么是混入模式？

\==Mixin(混入)模式== 是一种行为型设计模式，它允许在不使用传统继承的情况下向类或对象添加功能。
它通过组合而非继承实现代码复用，支持将多个功能模块（Mixin）动态“混合”到目标对象中，避免了单继承的局限性。

```mermaid
classDiagram
  newObject <-- Mixin1
  newObject <-- Mixin2
  class Mixin1 {
    +operation1()
  }
  class Mixin2 {
    +operation2()
  }
  class newObject {
    +operation1()
    +operation2()
  }
```

## 实现混入模式

### 对象合并

将 Mixin 对象的方法复制到目标类的原型中（使用 `Object.assign`）：

```js
const loggerMixin = {
  log(message) {
    console.log(`Log: ${message}`)
  }
}

class User {}
Object.assign(User.prototype, loggerMixin)

const user = new User()
user.log('Hello') // Log: Hello
```

### 函数式混入

通过函数返回扩展后的类，支持链式组合多个 Mixin：

```js
function Serializable(Base) {
  return class extends Base {
    serialize() {
      return JSON.stringify(this)
    }
  }
}

function Loggable(Base) {
  return class extends Base {
    log() { console.log('Logged') }
  }
}

class User {}
const EnhancedUser = Serializable(Loggable(User))
const user = new EnhancedUser()
user.serialize() // 调用 Serializable 方法
```

## 优点

* **灵活复用代码**

  跨不同类共享功能，无需建立复杂的继承链。

* **避免继承陷阱**

  解决单继承限制，支持多 Mixin 组合。

* **模块化清晰**

  功能拆分为独立模块，便于维护和扩展。

* **动态组合**

  运行时按需添加或移除功能。

## 缺点

* **命名冲突**

  多个 Mixin 的同名方法/属性可能被覆盖（如 serialize 方法重复）。

* **隐式依赖**

  代码逻辑分散，难以追踪方法来源。

* **原型污染**

  直接修改原型可能导致副作用（如影响其他实例）。

* **类型检查失效**

  instanceof 无法检测 Mixin 的存在。

## 适用场景

* **跨层级共享功能**

  例如日志、事件管理、序列化等通用功能。

* **替代多继承**

  需要组合多个独立功能的场景（如游戏角色的技能系统）。

* **动态扩展对象**

  运行时按需增强对象能力（如插件系统）。

---

---
url: /design-pattern/module/index.md
---
# 模块模式
::: warning 建议优先使用 ES6 模块（静态加载、显式依赖）和 class（面向对象）实现类似功能。

模块模式的价值更多体现在遗留项目维护或需要精细控制闭包的场景中。
:::

## 什么是模块模式？

\==Module (模块)模式== 是用于封装代码、实现私有作用域的一种设计模式。

它通过闭包和立即执行函数表达式（IIFE），将变量和方法划分为“私有”和“公有”两部分，从而减少全局污染、提高代码可维护性。

## 实现模块模式

### 基本模块模式

通过 IIFE 创建闭包，返回一个包含公有方法的对象：

```ts
const myModule = (function () {
  // 私有变量和方法
  let privateVar = '私有数据'
  function privateMethod() {
    console.log(privateVar)
  }

  // 公有接口
  return {
    publicMethod() {
      privateMethod()
    },
  }
})()

myModule.publicMethod() // 输出 "私有数据"
```

### 揭示模块（Revealing Module）模式

明确声明公有方法，直接暴露内部函数引用，增强可读性：

```ts
const myModule = (function () {
  function privateMethod() { /* ... */ }
  function publicMethod() {
    privateMethod()
  }

  return { publicMethod } // 直接暴露公有方法
})()
```

### 其它

* AMD 模块
* CommonJS 模块
* ES6 模块

## 优点

* **封装性**

  私有变量和方法仅在模块内部可见，避免外部误操作。

* **减少全局污染**

  所有逻辑封装在模块内，避免全局命名冲突。

* **代码组织清晰**

  通过公有接口管理外部可访问的方法，提高可维护性。

* **支持依赖注入**

  可通过参数注入依赖（如 jQuery）：

  ```ts
  const myModule = (function ($) {
    // 使用 $ 作为局部变量
  })(jQuery)
  ```

## 缺点

* **内存占用**

  闭包导致私有变量无法被垃圾回收，长期存在可能增加内存消耗。

* **扩展性差**

  模块是单例的，难以直接继承或扩展（需通过组合或混入模式实现）。

* **测试困难**

  私有方法无法直接测试，需通过公有接口间接验证。

* **ES6 替代方案**

  ES6 模块（import/export）和 class 语法更现代，模块模式在部分场景下已过时。

---

---
url: /design-pattern/mvc/index.md
---
# MVC
:::info
MVC 实际上是三个经典设计模式的变体：Observer （观察者）模式、Strategy （策略）模式 和 Composite（组合）模式。
它也可以使用 Factory （工厂）模式 和  Template（模板）模式。
:::

## 什么是MVC模式？

MVC 是一种软件设计模式，它将应用程序分成三个部分：**Model**，**View**，**Controller**。

```mermaid
flowchart TD
  V["`**View**
  *UI,Represets current model state*`"]
  C["`**Controller**
  *Makes decision
  for the View*`"]
  M["`**Model**
  *Domain-specific
  data*`"]
  IO(User Input/
  Display Output)
  IO <==> V
  V -. "Pull data <br>via getters" .-> M
  C -. "Pull data <br>via getters" .-> M
  V -- "Updates" --> C
  M -- "Informs<br>Observers <br>Of Changes" --> V
  C -- "Passes<br>calls" --> V
  C -- "Modifies" --> M
  V -- "Observers" --> M
```

### Model

Model 管理应用程序的数据。Model 不涉及用户界面，也不涉及表示层，而是代表应用程序可能需要的特度形式的数据。
当 Model (模型) 改变时，它通常会通知它的观察者（如 View），以便它们可以做出相应的改变（更新）。

### View

视图是 Model 的可视化表示，表示当前状态的筛选视图。一个 View 通常检测一个 Model，并在 Model 更改是进行通知，
使 View 本身能够相应的更新。

用户可以与 View 交互，包括读取和编辑 Model ，即在 Model 中获取或设置属性值。

### Controller

Controller 是 Model 和 View 之间的中介，当用户操作 View 时，它通常负责更新 Model 。

## 实现 MVC 模式

在 JavaScript 中，MVC 常用于构建单页应用（SPA），通过解耦代码提升可维护性。

以下是一个原生 JavaScript 实现的简单 Todo 应用：

::: code-tabs

@tab index.js

```js
import TodoController from './todo-controller'
import TodoModel from './todo-model'
import TodoView from './todo-view'

// 初始化
const model = new TodoModel()
const view = new TodoView()
const controller = new TodoController(model, view)
```

@tab todo-model.js

```js
class TodoModel {
  constructor() {
    this.todos = []
    this.listeners = []
  }

  addTodo(text) {
    this.todos.push({ text, completed: false })
    this.emitChange()
  }

  toggleTodo(index) {
    this.todos[index].completed = !this.todos[index].completed
    this.emitChange()
  }

  on(event, listener) {
    this.listeners.push(listener)
  }

  emitChange() {
    this.listeners.forEach(listener => listener(this.todos))
  }
}
```

@tab todo-view.js

```js
class TodoView {
  constructor() {
    this.todoList = document.getElementById('todo-list')
    this.addButton = document.getElementById('add-todo')
    this.input = document.getElementById('todo-input')
  }

  bindAddTodo(handler) {
    this.addButton.addEventListener('click', () => {
      const text = this.input.value
      if (text) {
        handler(text)
        this.input.value = ''
      }
    })
  }

  render(todos) {
    this.todoList.innerHTML = todos
      .map((todo, index) => `
        <li class="${todo.completed ? 'completed' : ''}">
          ${todo.text}
          <button onclick="controller.toggleTodo(${index})">✓</button>
        </li>
      `)
      .join('')
  }
}
```

@tab todo-controller.js

```js
class TodoController {
  constructor(model, view) {
    this.model = model
    this.view = view

    this.view.bindAddTodo(this.handleAddTodo.bind(this))
    this.model.on('change', todos => this.view.render(todos))
  }

  handleAddTodo(text) {
    this.model.addTodo(text)
  }

  toggleTodo(index) {
    this.model.toggleTodo(index)
  }
}
```

:::

## 优点

* **解耦代码**：数据、界面、逻辑分离，便于维护。
* **可复用性**：View 可复用（如 Web 和移动端共用 Model）。
* **可测试性**：Model 和 Controller 可独立测试。
* **团队协作**：不同开发者可并行开发不同组件。

## 缺点

* **复杂度高**：小型项目可能因分层过度而冗余。
* **数据流混乱**：若未严格分层，可能导致 View 直接操作 Model。
* **性能开销**：频繁的 DOM 更新可能影响性能（需优化或结合虚拟 DOM）。

## 适用场景

* 复杂交互的 SPA（如管理后台、社交平台）。
* 长期维护的项目：结构清晰降低迭代成本。
* 团队协作开发：明确分工，减少代码冲突。

---

---
url: /design-pattern/mvp/index.md
---
# MVP
::: tip
MVP 模式通过强制视图与逻辑解耦，显著提升前端代码的可维护性和可测试性，特别适合业务复杂的 Web 应用。
尽管在现代框架（如 React/Vue）中部分职责被组件化替代，但其分层思想仍深刻影响前端架构设计。
:::

## 什么是MVP模式？

MVP (模型-视图-表示器) 是 一种用户界面架构模式，核心目标是分离业务逻辑与视图逻辑，
提升代码可维护性和可测试性。它是 MVC 的变体，通过明确角色分工解决传统 MVC 在 Web 前端中的耦合问题。

```mermaid
flowchart TD
  V["`**View**
  *UI and UI events*`"]
  P["`**Presenter**
  *Formats data for display*`"]
  M["`**Model**
  *Domain-specific data*`"]

  V -- Passes calls --> P
  P -- Manipulates --> M
  M -- Raises events --> P
  P -- Updates --> V
```

它将应用程序分成三个部分：**Model**，**View**，**Presenter**。

### Model (模型)

负责数据和业务逻辑（如数据获取、验证、存储）。

独立于 UI，不直接与 View 交互。

### View (视图)

被动的 UI 层，仅负责渲染和用户输入转发。

通过接口/约定与 `Presenter` 通信（无业务逻辑）。

### Presenter（协调器）

中介者角色：监听 View 事件，调用 Model，更新 View。
包含展示逻辑（如数据格式化、状态控制）。

## 实现 MVP 模式

::: code-tabs

@tab index.js

```js
// 初始化
const model = new UserModel()
const view = new UserListView()
const presenter = new UserPresenter(model, view)

// 首次渲染
presenter.loadInitialData()
```

@tab user-model.js

```js
class UserModel {
  constructor() {
    this.users = []
  }

  addUser(name) {
    this.users.push({ id: Date.now(), name })
    return this.users
  }
}
```

@tab user-list-view.js

```js
class UserListView {
  constructor(presenter) {
    this.presenter = presenter
    this.list = document.getElementById('user-list')
    this.form = document.getElementById('user-form')
    this.form.addEventListener('submit', e => this.onSubmit(e))
  }

  render(users) {
    this.list.innerHTML = users.map(u => `<li>${u.name}</li>`).join('')
  }

  onSubmit(e) {
    e.preventDefault()
    const name = document.getElementById('name-input').value
    this.presenter.addUser(name) // 转发给 Presenter
  }
}
```

@tab user-presenter.js

```js
class UserPresenter {
  constructor(model, view) {
    this.model = model
    this.view = view
  }

  addUser(name) {
    if (!name.trim())
      return // 简单验证
    const updatedUsers = this.model.addUser(name)
    this.view.render(updatedUsers) // 更新视图
  }
}
```

:::

## 优点

* **关注点分离**

  View 只处理 UI，Model 只处理数据，Presenter 负责协调。

* **高可测试性**

  Presenter 可脱离 View 测试（通过 Mock View）。

* **避免框架依赖**

  View 可为原生 DOM 操作，易于替换 UI 库。

* **清晰的代码结构**

  各层职责明确，适合团队协作

## 缺点

* **复杂度增加**

小型项目可能过度设计（需手动绑定事件/更新视图）。

* **Presenter 膨胀风险**

复杂页面可能导致 Presenter 臃肿（需拆分或引入状态管理）。

* **手动更新视图**

相比 MVVM 的自动绑定，需手动调用 `render()` 。

---

---
url: /design-pattern/mvvm/index.md
---
# MVVM
## 什么是 MVVM 模式？

\==MVVM（Model-View-ViewModel）== 是一种用于分离用户界面逻辑与业务逻辑的架构模式，核心是数据驱动视图。
它通过 **ViewModel** 将 **Model** 和 **View** 解耦，实现双向数据绑定：

```mermaid
flowchart TD
  V["`**View**
  *User interface*`"]
  VM["`**View Model**
  *State and Operations*`"]
  M["`**Model**
  *Domain-specific data*`"]

  V -- Data bindings<br>and commands --> VM
  VM -- Updates --> M
  M -- Sends notifications --> VM
  VM -- Sends notifications --> V
```

### Model

数据模型（如 API 数据、业务逻辑）。

### View

用户界面（DOM 元素）。

### ViewModel

连接 Model 和 View 的桥梁，处理数据转换和交互逻辑。

## 实现 MVVM 模式

以 Vue.js 为例，核心机制是响应式系统和模板引擎：

```html
<!-- View (HTML模板) -->
<div id="app">
  <input v-model="message"> <!-- 双向绑定 -->
  <p>{{ message }}</p>     <!-- 数据渲染 -->
</div>
```

```js
// ViewModel (Vue实例)
const vm = new Vue({
  el: '#app',
  data: {
    message: 'Hello MVVM!' // Model数据
  }
})

// 修改Model自动更新View
vm.message = 'Updated!' // <p>内容同步变化
```

## 关键机制

* 双向数据绑定

  View（如输入框）修改 → 自动更新 Model → ViewModel 通知其他依赖视图更新。

* 依赖追踪

  Vue 通过 `Object.defineProperty`/ `Proxy` 监听数据变化，触发视图更新。

* 模板编译

  将模板（如 `{{ message }}`）编译为虚拟 DOM，高效更新真实 DOM。

## 优点

| 优点           | 说明                                               |
| -------------- | -------------------------------------------------- |
| **开发效率高** | 自动同步数据视图，减少手动 DOM 操作（如 jQuery）。 |
| **代码解耦**   | View、ViewModel、Model 职责分离，便于维护。        |
| **可测试性**   | ViewModel 可独立测试（不依赖 UI）。                |
| **数据驱动**   | 聚焦数据变化，而非视图操作。                       |

## 缺点

| 缺点         | 说明                                               |
| ------------ | -------------------------------------------------- |
| **学习曲线** | 需理解响应式原理、虚拟 DOM 等概念。                |
| **性能开销** | 深度监听大对象或频繁更新可能影响性能（需优化）。   |
| **过度绑定** | 滥用双向绑定可能导致数据流混乱（推荐单向数据流）。 |
| **黑箱化**   | 框架封装复杂，调试底层问题较困难。                 |

---

---
url: /design-pattern/observer/index.md
---
# 观察者模式
## 什么是观察者模式？

::: important 《设计模式：可复用面向对象软件的基础》
一个或多个观察者对目标的状态感兴趣，它们通过将自己依附在目标对象上以便注册所感兴趣的内容。
目标状态发生改变并且观察者可能对这些状态感兴趣，就会发送一个通知消息，调用每个观察者的更新方法。
当观察者不在对目标状态感兴趣时，它们可以简单地将自己从中分离。
:::

在 ==观察者模式== 中，一个对象被称为 **被观察者（Subject）** ，它维持着一系列的依赖于它（观察者）的对象，
将有关状态的任何变更自动通知给他们（观察者）。

当一个目标需要告诉观察者发生了什么事情，它会向观察者广播一个通知（可以包括与通知主题相关的特定数据）。

当我们不在希望某个特定的观察者获得其注册目标发出的改变通知时，该目标可以将它从观察者列表中删除。

## 使用 观察者模式

一个 Observer 对象通常包含三个重要组成部分：

* **observers**： 观察者数组，每当特定目标状态发生改变时，观察者会接受到通知。
* **subscribe() / unsubscribe()**： 将 `observer` 添加到 `observers` 列表，或者从 `observers` 列表中移除
* **notify()**： 用于通知所有观察者，目标状态已经发生改变的方法

在 `ES6` 中，我们可以使用 `class` 来实现：

```ts
class Observable {
  constructor() {
    this.observers = []
  }

  subscribe(observer) {
    if (!this.observers.includes(observer))
      this.observers.push(observer)
  }

  unsubscribe(observer) {
    this.observers = this.observers.filter(item => item !== observer)
  }

  notify(context) {
    this.observers.forEach(observer => observer(context))
  }
}
```

我们来通过构建一个简单的程序，以便更直观的了解观察者模式的作用。

该程序仅包含 一个按钮、一个复选框，以及点击次数记录，和 一个日志。

```html
<div id="app">
  <button id="btn" type="button">点击我！</button>
  <label for="checkbox">
    <input type="checkbox" id="checkbox" />
    <span>切换选择状态！</span>
  </label>
  <p>点击次数：<span id="count">0</span></p>
  <div id="logger">
    <h3>日志</h3>
  </div>
</div>
```

期望实现的两个功能：

1. 当用户点击按钮或者复选框时，均在日志中打印相应的信息。
2. 仅点用户点击按钮时，点击次数记录 **+1**。

我们需要将 按钮的点击事件 和 复选框的变化事件 变为可观测的对象，因此，我们需要通过事件监听的
方式，当用户进行交互时使用 `notify()` 通知观察者。

```ts
// 创建可观察对象
const observable = new Observable()

btnEl.addEventListener('click', () => {
  // 点击按钮发送通知
  observable.notify({ type: 'click', message: '点击按钮' })
})

checkboxEl.addEventListener('change', (ev) => {
  // 点击复选框发送通知
  observable.notify({ type: 'checkbox', message: `点击复选框: ${ev.target.checked}` })
})
```

日志接收通知，并打印相关信息：

```ts
const logger = new Logger()
observable.subscribe(({ type, message }) => {
  logger.log(`${type} ${message}`)
})
```

点击次数记录:

```ts
observable.subscribe(({ type }) => {
  if (type === 'click')
    countEl.textContent = Number(countEl.textContent) + 1
})
```

**完整示例：**

:::: demo normal

::: code-tabs

@tab HTML

```html
<div id="app">
  <button id="btn" type="button">点击我！</button>
  <label for="checkbox">
    <input type="checkbox" id="checkbox" />
    <span>切换选择状态！</span>
  </label>
  <p>点击次数：<span id="count">0</span></p>
  <div id="logger">
    <h3>日志</h3>
  </div>
</div>
```

@tab Typescript

```ts
const btnEl = document.getElementById('btn')
const checkboxEl = document.getElementById('checkbox')
const loggerEl = document.getElementById('logger')
const countEl = document.getElementById('count')

class Logger {
  render(type, message) {
    const line = document.createElement('p')
    line.textContent = `${getCurrentDate()} [${type}] ${message}`
    loggerEl.appendChild(line)
  }

  log(message) {
    this.render('log', message)
  }
}

class Observable {
  constructor() {
    this.observers = []
  }

  subscribe(observer) {
    if (!this.observers.includes(observer))
      this.observers.push(observer)
  }

  unsubscribe(observer) {
    this.observers = this.observers.filter(item => item !== observer)
  }

  notify(context) {
    this.observers.forEach(observer => observer(context))
  }
}

const logger = new Logger()
// 创建可观察对象
const observable = new Observable()

// 日志 观察者
observable.subscribe(({ type, message }) => {
  logger.log(`${type} ${message}`)
})

// 点击次数 观察者
observable.subscribe(({ type }) => {
  if (type === 'click')
    countEl.textContent = Number(countEl.textContent) + 1
})

btnEl.addEventListener('click', () => {
  // 点击按钮发送通知
  observable.notify({ type: 'click', message: '点击按钮' })
})

checkboxEl.addEventListener('change', (ev) => {
  // 点击复选框发送通知
  observable.notify({ type: 'checkbox', message: `点击复选框: ${ev.target.checked}` })
})

function getCurrentDate() {
  return new Intl.DateTimeFormat(
    'zh-CN',
    { hour: 'numeric', minute: 'numeric', second: 'numeric', fractionalSecondDigits: 3 },
  ).format(new Date())
}
```

::::

## 优点

使用观察者模式是实现关注点分离和单一职责原则的绝佳方式。
观察者对象与可观察对象之间不存在紧耦合，可以随时进行（解）耦。
可观察对象负责监控事件，而观察者只需处理接收到的数据。

## 缺点

* 观察者并不在乎订阅者的顺序，这可能很难保证应用程序的特定部分是按照我们期望的方式运行。
* 订阅者之间无视彼此的存在，我们很难追踪他们的依赖关系。

## 相关模式

* **发布/订阅模式**

  通常在 JavaScript 里，观察者模式通常会使用 ==Publish/Subscribe== 模式这一变体实现。

* **中介者模式**

  \==中介者模式== 本质上是观察者模式的变体，但中介者模式通过限制对象严格通过中介者进行通信来实现这一目的。

---

---
url: /design-pattern/prototype/index.md
---
# 原型模式
## 什么是原型模式？

\==Prototype(原型)模式== 是一种 创建型设计模式。

其核心思想是通过 **复制现有对象**（原型对象）来创建新对象，而不是通过类实例化。
在 JavaScript 中，由于语言本身的 **基于原型的继承机制**，原型模式天然地与对象的行为和继承紧密结合。

:::tip
原型模式在 JavaScript 中既是设计模式，也是语言核心机制。
它适合高频创建对象和动态扩展的场景，但需警惕共享状态的副作用。
合理利用原型模式，可以显著提升代码复用性和性能，但需结合项目需求权衡是否引入复杂性。
:::

## 实现原型模式

* **原型链继承**：每个 JavaScript 对象都有一个 `[[Prototype]]`（可通过 `__proto__` 或 `Object.getPrototypeOf()` 访问），指向其原型对象。
* **共享属性和方法**：所有实例共享原型对象上的属性和方法，减少重复定义。
* **动态修改**：修改原型对象的属性和方法，会立即反映到所有实例上。

```ts
// 原型对象定义
const carPrototype = {
  wheels: 4,
  drive() {
    console.log('Driving...')
  },
}

// 通过 Object.create() 创建新对象（基于原型）
const myCar = Object.create(carPrototype)
myCar.color = 'red'

console.log(myCar.wheels) // 4（继承自原型）
myCar.drive() // "Driving..."
```

## 优点

* **高效内存利用**

  原型上的方法和属性被所有实例共享，避免重复创建相同功能的方法，节省内存。

* **动态性和灵活性**

  运行时可以动态修改原型，所有实例自动继承变更。

* **避免重复代码**

  通过复用原型，减少冗余代码（例如构造函数中重复绑定方法）。

* **天然支持 JavaScript 继承**

  与 JavaScript 的原型链机制无缝结合，是语言原生特性的直接应用。

## 缺点

* **共享状态的风险**

  如果原型属性是引用类型（如数组、对象），所有实例会共享同一份数据。

* **原型链复杂性**

  深层次的原型链可能导致属性查找性能下降（需逐级向上搜索）。

  多重继承或复杂原型链可能使代码难以维护。

* **覆盖问题**

  实例可以覆盖原型属性，可能导致意外行为：

  ```ts
  const c = Object.create(carPrototype)
  c.wheels = 3 // 覆盖原型属性
  console.log(c.wheels) // 3（实例属性优先于原型）
  ```

## 适用场景

* **需要创建大量相似对象**

  例如游戏中的 NPC 敌人、粒子系统等高频创建的场景，复用原型节省内存。

* **动态扩展对象功能**

  在运行时为所有实例添加/修改功能（如日志功能、监控逻辑）。

* **替代类继承**

  当类继承导致复杂层次结构时，原型模式更轻量灵活。

* **与 `Object.create()` 结合使用**

  明确指定原型对象，避免构造函数和 new 关键字的限制。

## 最佳实践

* **避免共享引用类型属性**：将引用类型属性定义在构造函数中，而非原型。
* **浅拷贝/深拷贝**：需要完全独立对象时，使用 `Object.assign()` 或深拷贝工具。
* **ES6 Class 语法糖**：底层仍基于原型，但提供更清晰的抽象。

---

---
url: /design-pattern/proxy/index.md
---
# 代理模式
## 什么是代理模式？

\==Proxy(代理)模式== 是一种结构型设计模式。

通过创建一个代理对象来控制对另一个对象的访问。
在 JavaScript 中，ES6 的 `Proxy` 对象是代理模式的典型实现，允许你拦截并自定义对象的基本操作（如属性读取、赋值、函数调用等）。

## 实现代理模式

JavaScript 通过 `Proxy` 构造函数实现代理模式，其核心是定义一个 handler 对象，在 handler 对象中，
我们可以根据交互类型定义特定行为。
尽管可以向 Proxy 处理程序添加许多方法，但最常见的两种方法是 `get` 和 `set`

```ts
const target = { name: 'Alice' }

const handler = {
  get(target, prop) {
    console.log(`读取属性 ${prop}`)
    return target[prop] || '属性不存在'
  },
  set(target, prop, value) {
    if (prop === 'age' && value < 0) {
      throw new Error('年龄不能为负数')
    }
    target[prop] = value
    return true // 表示设置成功
  }
}

const proxy = new Proxy(target, handler)

console.log(proxy.name) // 输出: 读取属性 name → Alice
proxy.age = 25 // 正常设置
proxy.age = -5 // 抛出错误: 年龄不能为负数
```

JavaScript提供了一个名为 `Reflect` 的内置对象，它让我们在使用代理时能更方便地操作目标对象。

此前，我们尝试通过在代理中直接使用方括号取值或赋值来修改和访问目标对象的属性。
现在，我们使用 `Reflect` 对象来实现。`Reflect` 对象上的方法与 `handler` 对象上的方法具有相同的名称。

```ts
const handler = {
  get(target, prop) {
    console.log(`读取属性 ${prop}`)
    return Reflect.get(target, prop) || '属性不存在'
  },
  set(target, prop, value) {
    if (prop === 'age' && value < 0) {
      throw new Error('年龄不能为负数')
    }
    Reflect.set(target, prop, value)
    return true // 表示设置成功
  }
}
```

## 优点

* **控制访问**：限制或增强对目标对象的操作（如权限验证、数据校验）。
* **职责分离**：代理对象与目标对象各司其职，符合单一职责原则。
* **延迟初始化（虚拟代理）**：仅在需要时创建开销大的对象。
* **缓存优化**：减少重复计算或网络请求。
* **透明性**：客户端无需感知代理存在，目标对象接口不变。

## 缺点

* **性能开销**：代理的拦截操作会增加调用栈深度，高频操作中可能影响性能。
* **复杂度**：复杂代理逻辑可能使代码难以维护。
* **调试困难**：错误堆栈可能指向代理而非原始对象。

---

---
url: /design-pattern/publish-subscribe/index.md
---
# 发布/订阅模式
\==发布/订阅模式== 是观察者模式的一种变体。

::: info ==发布/订阅模式== 在 JavaScript 中非常常见，比如：

* 浏览器的 [事件监听系统](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget)
* Node.js 中的 [EventEmitter 模块](https://nodejs.org/api/events.html#events_class_eventemitter)
* 自定义事件 [CustomEvent](https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent)
* [WebSocket 消息推送](hhttps://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API)

:::

## 什么是发布/订阅模式？

\==Publish/Subscribe (发布/订阅)模式==，是一种行为型设计模式，用于实现对象间的解耦和事件通知机制。

```mermaid
flowchart TD
  A[Publisher]
  B[Topic/Event Channel]
  C[Subscriber]
  A --> |"Publish topic (event)"| B
  C --> |Subscribe| B
  C --> |Fire Event | B
```

发布/订阅模式使用了一个 主题/事件通道，这个通道介于希望接收到通知（订阅者）的对象和激活时间的对象（发布者）之间。
改时间系统允许代码定义应用程序的特定事件，这些事件可以传递自定义参数，自定义参数包含订阅者所需的值。
其目的是避免订阅者和发布者之间产生依赖关系。

## 实现 发布/订阅模式

在 JavaScript 中，我们可以通过实现一个简单的事件系统，来实现发布/订阅模式。

```ts
class Event {
  constructor() {
    this.listeners = []
  }

  // 订阅
  on(listener) {
    this.listeners.push(listener)
  }

  // 取消订阅
  off(listener) {
    this.listeners = this.listeners.filter(l => l !== listener)
  }

  // 发布
  emit(data) {
    this.listeners.forEach(listener => listener(data))
  }
}
```

在这个简单的事件系统中，订阅者通过 `on()` 方法订阅它们感兴趣的事件，发布者通过 `emit()` 方法发布事件，
订阅者可以通过 `off()` 方法取消订阅。

```ts
const event = new Event()

event.on('click', () => console.log('clicked'))

event.emit('click')
```

## 优点

* **解耦性强**

  发布者和订阅者无直接依赖，发布者不需要知道谁订阅了事件，订阅者也不需要知道事件是谁触发的。

* **可扩展性高**

  动态增减订阅者：通过 `on()` 和 `off()` 方法灵活管理订阅关系。

* **支持广播通信**

  一对多消息传递：一个事件可被多个订阅者同时响应。

* **异步处理能力**

  非阻塞通信：事件发布后，订阅者可异步处理任务。

* **集中化管理**

  事件中心统一调度：所有事件通过中间层（如 EventEmitter）管理，便于监控和调试。

## 缺点

* **难以跟踪事件流**

  隐式调用链：订阅者和发布者没有显式关联，这可能导致调试困难。

* **性能开销**

  大量事件分发：高频事件（如鼠标移动）可能引发性能问题。

* **事件命名冲突**

  全局事件名重复：多人协作时，可能因事件名相同导致意外覆盖。

* **过度使用导致逻辑分散**

  逻辑碎片化：过度依赖事件通信会让业务逻辑分散到多个订阅者中，破坏代码内聚性。

## 适用场景

| **适用场景**                                 | **不适用场景**                              |
| -------------------------------------------- | ------------------------------------------- |
| 跨层级/模块通信（如微前端、跨组件通信）      | 简单父子组件通信（优先用 Props/Events）     |
| 需要广播或一对多通信（如实时通知、日志广播） | 高频、高性能敏感操作（如游戏循环）          |
| 动态插件系统或可扩展架构                     | 强依赖顺序的逻辑（需明确调用链）            |
| 异步任务协调（如文件上传完成后的多步骤处理） | 需要严格类型检查的场景（需结合 TypeScript） |

## 最佳实践

* **严格管理订阅生命周期**
* **使用命名空间或类型约束**：避免事件名冲突
* **控制事件粒度**：避免过度细化或粗粒度的事件设计
* **结合其他模式**：如与观察者模式、状态模式混合使用
* **性能监控**：对高频事件进行性能分析，必要时优化或替换方案

---

---
url: /design-pattern/singleton/index.md
---
# 单例模式
\==Singleton(单例模式)== 是前端领域中最被熟知的模式之一。

## 什么是单例模式？

\==单例模式== 限制了 **类** 的实例化次数只能一次。

从经典意义上来说，单例模式，在该实例不存在时，可以通过一个方法创建一个类来实现创建类的新示例；
如果实例已经存在，它会简单返回该对象的引用。

* **单例** 不同于静态类（或对象），因为可以推迟它的初始化。
* **单例** 可以实现为全局共享的实例，因此它特别适合管理应用中的全局状态。

## 实现单例模式

在 JavaScript 中，实现单例模式的方法有很多, 比如，
实现一个 `Counter` 单例，拥有如下方法：

* `getInstance()`：返回当前实例。
* `getCount()`：返回当前计数器的值。
* `increment()`：增加计数器的值。
* `decrement()`：减少计数器的值。

::: code-tabs#singleton

@tab namespace

```ts
const Counter = (function () {
  let instance // 保存实例

  function init() {
    // 私有变量
    let count = 0
    // 返回公共方法
    return {
      getCount() {
        return count
      },
      increment() {
        count++
      },
      decrement() {
        count--
      },
    }
  }

  return {
    getInstance() {
      // 仅在第一次调用时创建实例
      if (!instance) {
        instance = init()
      }
      return instance
    }
  }
})()

const counter = Counter.getInstance()
```

@tab class

```ts
class Counter {
  private static instance

  private count = 0

  static getInstance() {
    if (!Counter.instance) {
      Counter.instance = new Counter()
    }
    return Counter.instance
  }

  getCount() {
    return this.count
  }

  increment() {
    this.count++
  }

  decrement() {
    this.count--
  }
}

const counter = Counter.getInstance()
```

:::

在上述的实现中，我们通过调用 `Counter.getInstance()` 方法来获取 `Counter` 的实例，
而不是直接创建一个 `Counter` 的实例，这样确保了 `Counter` 只会被实例化一次。

同时，我们也看到， `Counter` 被延迟到了 `getInstance()` 方法被调用时才进行实例化。

**为什么这样做？**

一方面，通过延迟实例化，可以使得**直到我们需要使用实例前，不会产生额外的资源和内存开销**。

另一方面，我们可以有机会在 `getInstance()` 方法中，添加一些额外的逻辑。试想一个场景，我们需要
根据一些外部环境信息，来决定 如何实例化 `Counter`，以适配不同环境的需求。

::: code-tabs#singleton

@tab namespace

```ts
const Counter = (function () {
  let instance // 保存实例

  function baseInit() {
    // do something
    return {}
  }

  function fooInit() {
    return {
      ...baseInit(),
      // do something
    }
  }

  function barInit() {
    return {
      ...baseInit(),
      // do something
    }
  }

  return {
    getInstance() {
      if (!instance) {
        // some conditions
        if (isEnvFoo()) {
          instance = fooInit()
        }
        else {
          instance = barInit()
        }
      }
      return instance
    }
  }
})()

const counter = Counter.getInstance()
```

@tab class

```ts
class Counter {
  private static instance
  static getInstance() {
    if (!Counter.instance) {
      // some conditions
      if (isEnvFoo()) {
        Counter.instance = new FooCounter()
      }
      else {
        Counter.instance = new BarCounter()
      }
    }
    return Counter.instance
  }
  // do something
}

class FooCounter extends Counter {
  // do something
}

class BarCounter extends Counter {
  // do something
}

const counter = Counter.getInstance()
```

:::

在这里，`getInstance()` 变得有些像 **Factory(工厂)**，当访问它时，我们不需要更新代码中的每个访问节点。

## 权衡利弊

\==Singleton(单例)== 很有使用价值。但是，当我们发现在项目中需要它时，则表示我们可能需要重新评估我们的设计。
因为 **Singleton(单例)** 被认为是一个`anti-pattern` （反模式）。

**单例** 的存在往往表明系统中的模块要么是系统紧密耦合的，要么是其逻辑过于分散在代码库的多个部分。
由于一系列的问题：从隐藏的依赖到创建多个实例的难度、底层依赖的难度等等，**单例** 的测试会更加困难。

### 使用常规对象

事实上，在 `ESM` 的 模块化系统中，可以直接使用常规对象，然后通过 `export` 将它暴露出去。

```ts
let count = 0

const counter = {
  getCount() {
    return count
  },
  increment() {
    count++
  },
  decrement() {
    count--
  },
}

export { counter }
```

由于 对象是按引用传递的，因此从 `ESM` 的其他模块中导入的是 `counter` 对象的同一个引用，
任意地改变 `counter` 对象的值，都会对其他模块产生影响。

### 测试

测试依赖单例模式的代码可能会变得棘手。
由于我们无法每次都创建新实例，所有测试都依赖于对前一个测试全局实例的修改。
在这种情况下，测试顺序至关重要，一个小小的改动就可能导致整个测试套件失败。
测试完成后，我们需要重置整个实例以清除测试所做的修改。

### 全局访问

**Singleton(单例)** 通常意味着我们可以在整个应用中访问它，因此可能需要将它放到全局变量中。

但通常来说，全局变量通常被认为是一个糟糕的做法，因为它会导致全局命名空间的污染，可能会导致很多意外的行为。

::: info
在 `ES2015` 中，创建全局变量并不常见，新的 `let` 和 `const` 声明块级作用域，这些变量只会在块级作用域中可见，
从而避免意外的全局变量污染。而模块化开发，使得创建的变量在模块级作用域，通过 `export` 导入，其它模块通过 `import` 访问。
:::

然而，单例模式的常见用途是在整个应用程序中维护某种全局状态。让代码库的多个部分依赖同一个可变对象，可能会导致不可预期的行为。

通常，代码库中的某些部分会修改全局状态中的值，而其他部分则负责使用这些数据。此处的执行顺序至关重要：我们不希望在没有数据可供使用（尚未存在）时，意外地先消费数据！随着应用程序规模扩大，当数十个组件相互依赖时，理解使用全局状态时的数据流会变得极其复杂。

---

---
url: /design-pattern/strategy/index.md
---
# 策略模式
::: tip
策略模式在 JavaScript 中通过函数和对象的灵活性，简洁地实现了算法的动态替换。
它特别适用于需要消除条件分支、支持扩展的场景，但需权衡策略管理的复杂度。
合理使用该模式，可显著提升代码的可维护性和可读性。
:::

## 什么是策略模式？

\==Strategy(策略)模式== 是一种行为设计模式。

它允许定义一系列算法，并将每个算法封装成独立的对象，使得它们可以相互替换。
该模式的核心思想是将算法的使用与实现分离，让客户端动态选择算法，避免代码中冗长的条件判断，提高灵活性和可维护性。

## 实现策略模式

在 JavaScript 中，策略模式通常通过对象或函数实现。以下是两种典型实现方式：

### 对象字面量封装策略

将不同策略封装为对象的方法，通过键名动态调用。

```ts
const strategies = {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b,
  multiply: (a, b) => a * b,
}

function calculate(type, a, b) {
  return strategies[type](a, b)
}

console.log(calculate('add', 5, 3)) // 8
```

### 类结合策略对象

通过上下文类管理策略，支持动态切换策略。

```ts
class PaymentContext {
  constructor(strategy) {
    this.strategy = strategy
  }

  executePayment(amount) {
    return this.strategy(amount)
  }
}

// 定义策略函数
const creditCardStrategy = amount => `支付 ${amount} 元（信用卡）`
const wechatPayStrategy = amount => `支付 ${amount} 元（微信支付）`

// 使用示例
const context = new PaymentContext(creditCardStrategy)
console.log(context.executePayment(100)) // 支付 100 元（信用卡）

context.strategy = wechatPayStrategy
console.log(context.executePayment(200)) // 支付 200 元（微信支付）
```

## 优点

* **避免条件分支**：消除大量 `if-else` 或 `switch-case` 语句。
* **开闭原则**：新增策略无需修改现有代码，只需扩展新策略。
* **高内聚低耦合**：每个策略独立封装，职责明确，易于复用和测试。
* **动态切换**：运行时灵活替换算法逻辑。

## 缺点

* **策略数量爆炸**：策略过多会增加对象或类的数量。
* **客户端需知策略细节**：使用者需要理解不同策略的差异。
* **性能开销**：简单场景可能因对象化策略引入额外开销。

## 适用场景

* **算法需动态切换**：如支付方式、数据验证规则、排序算法等。
* **替代复杂条件判断**：多个分支逻辑相似但实现不同。
* **隐藏算法细节**：隔离复杂逻辑，对外提供统一接口。
* **组合行为**：多个策略可组合使用（如复合表单验证）。

---

---
url: /design-pattern/visitor/index.md
---
# 访问者模式
## 什么是访问者模式？

\==Visitor（访问者）模式== 是一种行为型设计模式。

它允许在不修改现有对象结构的前提下，为对象结构中的元素添加新的操作。

核心思想是将数据操作与数据结构分离，通过“访问者”对象实现对不同元素的操作扩展。

访问者模式主要由以下部分组成：

### Visitor（访问者）

声明访问具体元素的方法（visitElementA, visitElementB）。

### ConcreteVisitor（具体访问者）

实现访问者接口，定义对元素的具体操作逻辑。

### Element（元素）

定义 accept(visitor) 方法，接收访问者对象。

### ConcreteElement（具体元素）

实现 accept() 方法，调用访问者的对应方法。

### ObjectStructure（对象结构）

维护元素集合，提供遍历接口供访问者操作。

## 实现访问者模式

```js
// 1. 定义元素接口
class Shape {
  accept(visitor) {
    throw new Error('Method \'accept()\' must be implemented.')
  }
}

// 2. 具体元素：圆形
class Circle extends Shape {
  constructor(radius) {
    super()
    this.radius = radius
  }

  accept(visitor) {
    visitor.visitCircle(this) // 将自身传递给访问者
  }
}

// 3. 具体元素：矩形
class Rectangle extends Shape {
  constructor(width, height) {
    super()
    this.width = width
    this.height = height
  }

  accept(visitor) {
    visitor.visitRectangle(this)
  }
}

// 4. 访问者接口
class Visitor {
  visitCircle(circle) {}
  visitRectangle(rectangle) {}
}

// 5. 具体访问者：面积计算器
class AreaCalculator extends Visitor {
  visitCircle(circle) {
    const area = Math.PI * circle.radius ** 2
    console.log(`Circle area: ${area.toFixed(2)}`)
  }

  visitRectangle(rectangle) {
    const area = rectangle.width * rectangle.height
    console.log(`Rectangle area: ${area}`)
  }
}

// 6. 具体访问者：周长计算器
class PerimeterCalculator extends Visitor {
  visitCircle(circle) {
    const perimeter = 2 * Math.PI * circle.radius
    console.log(`Circle perimeter: ${perimeter.toFixed(2)}`)
  }

  visitRectangle(rectangle) {
    const perimeter = 2 * (rectangle.width + rectangle.height)
    console.log(`Rectangle perimeter: ${perimeter}`)
  }
}

// 7. 对象结构（管理元素集合）
class Drawing {
  constructor() {
    this.shapes = []
  }

  add(shape) {
    this.shapes.push(shape)
  }

  accept(visitor) {
    this.shapes.forEach(shape => shape.accept(visitor))
  }
}

// 客户端代码
const drawing = new Drawing()
drawing.add(new Circle(5))
drawing.add(new Rectangle(4, 6))

const areaCalculator = new AreaCalculator()
const perimeterCalculator = new PerimeterCalculator()

console.log('--- Area Calculation ---')
drawing.accept(areaCalculator)

console.log('\n--- Perimeter Calculation ---')
drawing.accept(perimeterCalculator)
```

```console
--- Area Calculation ---
Circle area: 78.54
Rectangle area: 24

--- Perimeter Calculation ---
Circle perimeter: 31.42
Rectangle perimeter: 20
```

## 优点

* **开闭原则**：新增操作只需添加访问者，无需修改元素类。
* **单一职责**：将相关操作集中到访问者中，分离数据结构与算法。
* **扩展性好**：可轻松添加新操作（如新增 VolumeCalculator）。
* **状态累积**：访问者可在遍历过程中收集数据（如计算总面积）。

## 缺点

* **破坏封装**：元素需暴露内部状态供访问者操作（如 circle.radius）。
* **增加新元素困难**：新增元素类型需修改所有访问者（违反开闭原则）。
* 不适合元素类频繁变化的场景。
* 可能引入循环依赖（元素与访问者相互依赖）。

## 适用场景

* 对象结构稳定，但需频繁添加新操作。
* 需要对复杂结构（如 AST、DOM 树）执行多种独立操作。
* 避免污染元素类代码（如分离业务逻辑与数据模型）。
* 跨多个类执行统一操作（如报表生成、导出功能）。

## 典型应用案例

* **抽象语法树（AST）处理**：编译器中的类型检查、代码优化。
* **文档处理**：导出 HTML/PDF、拼写检查。
* **UI 组件树**：渲染、布局计算。
* **游戏开发**：角色属性计算、碰撞检测。

---

---
url: /design-pattern/what-is-pattern/index.md
---
# 什么是模式？
## 什么是模式？

模式是一种解决方案，可用于解决软件设计中遇到的常见问题。

::: important 我们每天都在使用 ==模式=={.caution} ！
:::

## 为什么学习模式？

模式主要有三大优点：

* **模式是已验证的解决方案**

  它们为解决软件开发中遇到的问题提供可靠的方法。
  使用已验证的解决方案，这些解决方案体现了开发人员的经验及见解。

* **模式很容易被复用**

  模式通常是一种立即可用的解决方案，可以对其进行修改以满足个人需求。
  该特性是的这些模式的功能非常强大。

* **模式富有表达力**

  看到模式时，通常就表示有一个设置好的结构和表达解决方案的词汇，已帮助我们非常轻松的表达出所实现的解决方案。

::: tip 小提示

模式的作用仅仅是为我们提供一个解决问题的方案。
模式无法解决所有的问题，也无法取代优秀软件设计师的工作，但模式能够为这些工作提供支持。

:::

设计模式的其它优点：

* 复用模式有助于防止在应用程序开发过程中小问题引发大问题。
* 模式可以提供通用的解决方案，并且其记录方式不需要与某个特定问题挂钩。
* 某些模式确实能够通过避免代码复用来减少代码的总体资源占用量。
* 模式添加到开发人员的词汇中，会使沟通更快速。

## 编写设计模式

编写优秀的设计模式是一项具有挑战性的任务。
模式不仅需要为最终用户提供大量的参考资源，还需要能够证明自己为何是必要的。

* **模式的实用性有多少？**

  确保模式描述的事能够解决重复出现的问题的已经验证的解决方案。

* **牢记最佳实践**

  做出的设计决策应该基于通过对最佳实践的理解而获得的原则。

* **设计模式对于用户来说应该是透明的**

  设计模式对于任何类型的用户体验都应是完全透明的。
  它们主要是为使用它们的开发人员提供服务，而不应强制改变用户的行为。

* **要记住独创性在模式设计中不是重点**

  编写模式时，我们不需要是已有解决方案的最初发现者，也不必担心我们的设计有一小部分与其他模式有重叠，
  如果我们的方法很强大，有广泛的适用性，那么它就有可能被认定为是一个有效的模式。

* **模式需要一批有说服力的示例**

  好的模式描述需要伴随着一系列同样强有力的示例，以演示所编写模式的成功应用。

## 反模式

如果我们认为一种模式代表一种最佳实践，那么一种反模式就代表我们已经学到的教训。

反模式是：

* 描述一种针对某个特定问题的不良解决方案，该方案会导致糟糕的情况发生；
* 描述如何摆脱前述的糟糕情况以及如何创造好的解决方案。

::: tip 反模式是一种值得记录的不良设计。
:::

## 设计模式类别

### 创建型设计模式

创建型设计模式专注于处理对象创建机制，以适合给定情况的方式来创建对象。

创建对象的基本方法可能导致项目复杂性增加，而这些模式旨在通过控制创建过程来解决这种问题。

创建型设计模式包括：

* **Constructor** - 构造器
* **Factory** - 工厂
* **Abstract** - 抽象
* **Prototype** - 原型
* **Singleton** - 单例
* **Builder** - 生成器

### 结构型设计模式

结构型模式与对象组合有关，通常可以用于找出在不同对象之间建立关系的简单方法。

这种模式有助于确保在系统某一部分发生变化时，系统的整个结构不需要同时改变。
同时对于不适合因某个特定目的而改变的系统部分，这种模式也能够帮助它们完成重组。

结构型设计模式包括：

* **Decorator** - 装饰器
* **Facade** - 外观
* **Flyweight** - 享元
* **Adapter** - 适配器
* **Proxy** - 代理

### 行为型设计模式

行为模式专注于改善或简化系统中不同对象之间的通信。

行为模式包括：

* **Iterator** - 迭代器
* **Mediator** - 中介者
* **Observer** - 观察者
* **Visitor** - 访问者

---

---
url: /ebooks/index.md
---
# 书籍推荐
## HTML

* 推荐 **`《Head First HTML与CSS（第2版）》`** - 初学者入门

* 推荐 **`《HTML5+JavaScript动画基础》`** - 动画基础入门

* 过时 **`《HTML5权威指南》`** - 初学者入门

* 过时 **`《HTML5与CSS3权威指南》`** - 初学者入门

* 过时 **`《HTML5程序设计》`** - 初学者入门

* 过时 **`《HTML5揭秘》`** - 入门

## CSS

* 推荐 **`《深入解析 CSS》`** - CSS 入门进阶

* 推荐 **`《CSS 揭秘》`** - CSS 进阶

* 推荐 **`《CSS 世界》`** - 包含很多实用技巧和奇淫巧技，但缺少整体性，通读一遍后二次阅读可以挑认为有价值的部分看，对提升CSS水平有很好的帮助

* 过时 **`《精彩绝伦的CSS》`** - 初学者入门

## Javascript

* 必读 **`《JavaScript权威指南（第7版）》`** - 入门经典

* 必读 **`《JavaScript高级程序设计（第4版）》`** - 必读经典

* 推荐 **`《JavaScript语言精粹》`** - 入门进阶

* 推荐 **`《高性能JavaScript》`** - 入门进阶

* 推荐 **`《你不知道的JavaScript》`** - 入门进阶

* 推荐 **`《JavaScript DOM编程艺术 （第2版）》`** - 入门进阶

* 推荐 **`《javascript设计模式》`** - 进阶

* 推荐 **`《JavaScript设计模式与开发实践》`** - 进阶

* [Javascript Guidebook](https://tsejx.github.io/javascript-guidebook/) - Javascript 知识图谱

## Typescript

* [TypeScript 使用手册](https://github.com/zhongsp/TypeScript) - TypeScript 使用手册（中文版）翻译。
* [TypeScript Deep Dive](https://github.com/jkchao/typescript-book-chinese) - TypeScript Deep Dive 中文版

## 算法

* 推荐 **`《算法（第4版）》`**
* 推荐 **`《算法导论》`**
* [awesome-coding-js](https://github.com/ConardLi/awesome-coding-js) - 用JavaScript实现的算法和数据结构

## Rust

* 推荐 [Rust Course](https://course.rs/) - 《Rust 圣经》，非常好的 Rust 入门书籍
* 推荐 [Rust by example](https://rustwiki.org/zh-CN/rust-by-example/) - 跟着例子学习 Rust
* 推荐 [Rusty Book](https://rusty.course.rs/) - 《锈书》，适合Rust新手进阶
* 推荐 [The Rust Programming Language](https://doc.rust-lang.org/book/) - The Rust Programming Language
* 推荐 [Rust 程序设计语言](https://kaisery.github.io/trpl-zh-cn/) - Rust 程序设计语言 中文版
* 推荐 [Rust 程序设计语言](https://rustwiki.org/zh-CN/book/) - Rust 程序设计语言 中文(翻译版)
* 推荐 [Rust 标准库](https://rustwiki.org/zh-CN/std/) - Rust 标准库 中文版
* 推荐 [Rust秘典](https://doc.rust-lang.org/nomicon/index.html) - Unsafe Rust 的黑魔法指南。它有时被称作“死灵书”。
* 推荐 [Rust秘典](https://nomicon.purewhite.io/) - Rust秘典 中文版
*

## Go

* 推荐 [Go语言圣经（中文版）](https://golang-china.github.io/gopl-zh/) - 入门
* 推荐 [Go语言高级编程](https://chai2010.cn/advanced-go-programming-book/) - 进阶

## 计算机网络

* 推荐 **`《HTTP权威指南》`** - 工具书
* 推荐 **`《图解HTTP》`** - 入门

---

---
url: /fe-oss/index.md
---
# 前端开源库指南

---

---
url: /fe-oss/ajv/index.md
---
# ajv
&#x20;

## 概述

[**Ajv** 官方文档](https://ajv.js.org){.read-more}

\==Ajv（Another JSON Schema Validator）== 是一个高性能的 Node.js JSON Schema 验证库，支持 **JSON Schema 草案（Draft-06/07/2019-09）** 和 **JSON Type Definition（JTD）**。
它以编译模式将 Schema 转换为高效的 JavaScript 验证函数，显著提升验证速度。

## 安装

::: npm-to

```sh
npm install ajv ajv-formats ajv-i18n  # 核心库及常用插件
```

:::

## 使用

### 基础验证

```ts
const Ajv = require('ajv')
const ajv = new Ajv({ allErrors: true }) // 返回所有错误
ajv.addFormat('email', /^[^\s@]+@[^\s@]+\.[^\s@]+$/) // 自定义格式

const schema = {
  type: 'object',
  properties: {
    name: { type: 'string', minLength: 3 },
    age: { type: 'integer', minimum: 18 },
    email: { type: 'string', format: 'email' }
  },
  required: ['name', 'age']
}
const data = { name: 'Alice', age: 20, email: 'alice@example.com' }
const valid = ajv.validate(schema, data)
if (!valid)
  console.log(ajv.errors)
```

### 扩展验证

```ts
import Ajv from 'ajv'
import addFormats from 'ajv-formats'

const ajv = new Ajv()
// 添加内置格式验证
addFormats(ajv)

// 自定义格式验证
ajv.addFormat('identifier', /^a-z\$_[a-zA-Z$_0-9]*$/)
```

### 预编译

```ts
import fs from 'node:fs'
import path from 'node:path'
import Ajv from 'ajv'
import standaloneCode from 'ajv/dist/standalone'

const schemaFoo = {
  $id: '#/definitions/Foo',
  $schema: 'http://json-schema.org/draft-07/schema#',
  type: 'object',
  properties: {
    foo: { $ref: '#/definitions/Bar' }
  }
}
const schemaBar = {
  $id: '#/definitions/Bar',
  $schema: 'http://json-schema.org/draft-07/schema#',
  type: 'object',
  properties: {
    bar: { type: 'string' },
  },
  required: ['bar']
}

// For ESM, the export name needs to be a valid export name, it can not be `export const #/definitions/Foo = ...;` so we
// need to provide a mapping between a valid name and the $id field. Below will generate
// `export const Foo = ...;export const Bar = ...;`
// This mapping would not have been needed if the `$ids` was just `Bar` and `Foo` instead of `#/definitions/Foo`
// and `#/definitions/Bar` respectfully
const ajv = new Ajv({ schemas: [schemaFoo, schemaBar], code: { source: true, esm: true } })
let moduleCode = standaloneCode(ajv, {
  Foo: '#/definitions/Foo',
  Bar: '#/definitions/Bar'
})

// Now you can write the module code to file
fs.writeFileSync(path.join(__dirname, './validate-esm.mjs'), moduleCode)
```

```ts
import { Bar, Foo } from './validate-esm.mjs'

const fooPass = {
  foo: {
    bar: 'something'
  }
}

const fooFail = {
  foo: {
    // bar: "something" // bar: "something" <= empty properties
  }
}

let validateFoo = Foo
if (!validateFoo(fooPass))
  console.log('ERRORS 1:', validateFoo.errors) // Never reaches here because valid

if (!validateFoo(fooFail))
  console.log('ERRORS 2:', validateFoo.errors) // Errors array gets logged
```

## 使用场景

* API 请求验证

  在 Koa/Express 中间件中校验请求体：

  ```ts
  app.post('/user', (ctx) => {
    if (!validate(ctx.request.body))
      ctx.throw(400, { errors: validate.errors })
  })
  ```

* 配置文件校验

  确保 JSON/YAML 配置文件符合预期结构。

* 表单数据处理

  结合前端框架验证表单字段（需配合浏览器打包）。

---

---
url: /fe-oss/ansis/index.md
---
# ansis
&#x20; &#x20;

## 概述

适用于终端、CI 环境及基于 Chromium 浏览器的ANSI色彩库。

Ansis 注重小巧体积与高速性能，同时提供丰富功能并妥善处理各类边界情况。

## 推荐

相对于 [picocolors](./picocolors.md)，ansis 的功能更加全面，而且支持 链式调用，这在一些日志格式化输出时非常有用。

## 安装

::: npm-to tabs="npm,pnpm,yarn,deno,bun"

```sh
npm install ansis
```

:::

## 使用

```ts
import ansis, { bold, fg, hex, red, rgb } from 'ansis'

console.log(ansis.bold('file.txt'))
console.log(red`Error: ${bold.cyan(file)} not found!`)
console.log(bold.bgRed`ERROR`) // 链式调用，组合文本格式
console.log(fg(208)`Orange`)
console.log(rgb(224, 17, 95)`Ruby`)
console.log(hex('#FF75D1').bold.underline('Pink'))

console.log(ansis.strip(red('Text'))) // 输出纯文本，不包含ANSI代码
```

![ansis](https://github.com/webdiscus/ansis/raw/master/docs/img/ansis-demo.png)

---

---
url: /fe-oss/axios/index.md
---
# axios
&#x20;

## 概述

\==Axios== 是一个基于 Promise 的异步 HTTP 客户端库，专为浏览器和 Node.js 设计。

::: tip Axios 以简洁的 API 设计、健壮的错误处理和多环境支持，成为现代 Web 开发中异步通信的标杆。
:::

### 特性

* 从浏览器创建 XMLHttpRequests
* 从 node.js 创建 http 请求
* 支持 Promise API
* 拦截请求和响应
* 转换请求和响应数据
* 取消请求
* 超时处理
* 查询参数序列化支持嵌套项处理
* 自动将请求体序列化为：
  * JSON (`application/json`)
  * Multipart / FormData (`multipart/form-data`)
  * URL encoded form (`application/x-www-form-urlencoded`)
* 将 HTML Form 转换成 JSON 进行请求
* 自动转换 JSON 数据
* 获取浏览器和 node.js 的请求进度，并提供额外的信息（速度、剩余时间）
  为 node.js 设置带宽限制
* 兼容符合规范的 `FormData` 和 `Blob`（包括 node.js）
* 客户端支持防御 `XSRF`

## 安装

::: npm-to

```sh
npm install axios
```

:::

从 CDN 加载:

```html
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
```

```html
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
```

## 使用

### 基础示例

GET 请求

```ts
axios.get('/user', {
  params: { id: 123 } // 参数自动转为 ?id=123
}).then(({ data }) => {
  console.log(data)
})
```

POST 请求

```ts
axios.post('/login', {
  username: 'admin',
  password: 'securePassword' // 自动序列化为 JSON
})
```

### 拦截器

```ts
// 添加请求拦截器
axios.interceptors.request.use((config) => {
  // 在发送请求之前做些什么
  return config
}, (error) => {
  // 对请求错误做些什么
  return Promise.reject(error)
})

// 添加响应拦截器
axios.interceptors.response.use((response) => {
  // 2xx 范围内的状态码都会触发该函数。
  // 对响应数据做点什么
  return response
}, (error) => {
  // 超出 2xx 范围的状态码都会触发该函数。
  // 对响应错误做点什么
  return Promise.reject(error)
})
```

### 取消请求

```ts
const controller = new AbortController()

axios.get('/foo/bar', {
  signal: controller.signal
}).then((response) => {
  // ...
})
// 取消请求
controller.abort()
```

## 使用场景

* 各种类型的前端应用均适用
* Node.js 服务端通信

---

---
url: /fe-oss/better-sqlite3/index.md
---
# better-sqlite3
## 概述

[**better-sqlite3** 官方文档](https://github.com/WiseLibs/better-sqlite3/blob/HEAD/docs/api.md){.read-more}

\==better-sqlite3== 是 Node.js 中一个高性能、同步操作的 SQLite3 数据库驱动库，
以其卓越的执行效率和简洁的 API 设计成为轻量级应用本地存储的首选

针对 Node.js 中原生 `sqlite3` 库的异步回调复杂性及性能瓶颈，`better-sqlite3` 通过 `C++` 扩展直接调用 `SQLite3 API`，规避了 JavaScript 异步模型带来的上下文切换开销，实现了同步API下的更高并发性能。

### 优势

* **性能**：基准测试显示，其查询速度可达原生 `sqlite3` 的 **11–24 倍**（如单行查询快 11.7 倍，事务写入快 15.6 倍）
* **同步**：同步 API 避免回调地狱，更适合 Koa 等中间件模型，提升代码可读性

## 安装

::: npm-to

```sh
npm install better-sqlite3
```

:::

## 使用

```ts
import db from 'better-sqlite3'

// 建表
db.exec(`CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)`)
// 插入数据
const insert = db.prepare('INSERT INTO users (name) VALUES (?)')
insert.run('Bob')
// 查询
const row = db.prepare('SELECT * FROM users WHERE id = ?').get(1)
console.log(row.name) // 输出: Bob
```

### 预编译语句

```ts
const stmt = db.prepare('INSERT INTO users (name, email) VALUES (?, ?)')
stmt.run('Alice', 'alice@example.com') // 复用编译结果，防 SQL 注入
```

### 事务

```ts
const trans = db.transaction((users) => {
  for (const user of users) {
    db.prepare('INSERT ...').run(user)
  }
})
trans(users) // 自动提交或回滚
```

## 适用场景

* 轻量级应用（Electron 桌面应用、IoT 设备）
* 高读低写业务（如配置管理、日志存储）
* 需加密的本地数据（通过扩展 better-sqlite3-multiple-ciphers 支持 AES 等算法）

---

---
url: /fe-oss/cac/index.md
---
# cac
## 概述

[**cac** 官方文档](https://github.com/egoist/cac){.read-more}

\==cac== 是一个轻量级 Node.js 库，用于快速构建命令行工具（CLI）。
它提供 简化命令解析、参数处理和子命令管理，同时保持 API 简洁易用。
支持 TypeScript 原生类型推断。

![cac](https://user-images.githubusercontent.com/8784712/28623641-373450f4-7249-11e7-854d-1b076dab274d.png)

## 特性

1. **链式 API 设计**：支持流畅的链式调用（如 `.command().option().action()`），提升代码可读性。
2. **智能参数解析**：
   * 用 `<必选参数>` 和 `[可选参数]` 声明参数，支持展开参数（如 `[...files]`）。
   * 自动生成 `--help` 文档，包含命令描述和示例。
3. **异步操作支持**：`action()` 回调支持 `async/await`，方便处理异步任务。
4. **事件驱动**：继承 `EventEmitter`，可通过 `on()` 监听命令执行事件。
5. **嵌套命令与选项**：支持多级子命令和全局/局部选项，适合复杂 CLI 场景。

## 安装

::: npm-to

```bash
npm install cac
```

:::

## 使用示例

### 基础用法

```ts
import cac from 'cac'

const cli = cac('my-cli')

// 注册全局选项
cli.option('--config <path>', '配置文件路径', { default: './config.json' })

// 定义命令
cli
  .command('build <entry>', '构建项目')
  .option('--minify', '压缩输出文件') // 命令专属选项
  .action((entry, options) => {
    console.log(`构建入口：${entry}`)
    if (options.minify)
      console.log('启用压缩')
  })

// 默认命令（无命令名时触发）
cli.command('').action(() => cli.outputHelp())

cli.parse()
```

### 子命令与异步操作

```ts
cli
  .command('deploy <env>', '部署到环境')
  .option('--force', '强制覆盖')
  .action(async (env, options) => {
    console.log(`部署到 ${env}`)
    if (options.force) {
      await simulateDeployment() // 模拟异步部署
      console.log('部署完成！')
    }
  })

async function simulateDeployment() {
  return new Promise(resolve => setTimeout(resolve, 1000))
}
```

### 错误处理与帮助文档

```ts
cli
  .command('rm <dir>', '删除目录')
  .example('rm dist --recursive') // 自定义示例
  .action((dir, options) => {
    if (!options.recursive)
      throw new Error('需使用 --recursive 标志')
    console.log(`删除目录：${dir}`)
  })

// 捕获未知命令
cli.on('command:not-found', (name) => {
  console.error(`未知命令：${name}`)
  cli.outputHelp()
})
```

## 使用场景

* **脚手架工具**：结合 `inquirer.js` 实现交互式问答（如项目初始化）：

  ```ts
  import inquirer from 'inquirer'
  cli.command('init').action(async () => {
    const answers = await inquirer.prompt([{ type: 'input', name: 'project' }])
    console.log(`创建项目：${answers.project}`)
  })
  ```

* **构建脚本**：定义 `build`、`watch` 等命令，集成 Rollup/Vite 等工具。

* **自动化工具**：如批量文件处理（`lint [...files]`）或部署流程（`deploy production`）。

---

---
url: /fe-oss/chalk/index.md
---
# chalk
::: center
![chalk](https://github.com/chalk/chalk/raw/main/media/logo.svg)
:::

&#x20;

## 概述

终端字符串样式设置正确。

**Chalk** 的体积更大，但这有其原因。

它提供了更友好的 API、完善的类型文档、支持数百万种颜色，并涵盖了小型替代方案无法处理的边界情况。
**Chalk** 成熟可靠，是为持久运行而构建的。

`Chalk` 被超过 **12 万个** 项目依赖，在你不知道如何选择时，使用它是不会错的。

## 安装

::: npm-to

```sh
npm install chalk
```

:::

## 使用

```ts
import chalk from 'chalk'

const log = console.log

// Combine styled and normal strings
log(`${chalk.blue('Hello')} World${chalk.red('!')}`)

// Compose multiple styles using the chainable API
log(chalk.blue.bgRed.bold('Hello world!'))

// Pass in multiple arguments
log(chalk.blue('Hello', 'World!', 'Foo', 'bar', 'biz', 'baz'))

// Nest styles
log(chalk.red('Hello', `${chalk.underline.bgBlue('world')}!`))

// Nest styles of the same type even (color, underline, background)
log(chalk.green(
  `I am a green line ${
    chalk.blue.underline.bold('with a blue substring')
  } that becomes green again!`
))

// ES2015 template literal
log(`
CPU: ${chalk.red('90%')}
RAM: ${chalk.green('40%')}
DISK: ${chalk.yellow('70%')}
`)

// Use RGB colors in terminal emulators that support it.
log(chalk.rgb(123, 45, 67).underline('Underlined reddish color'))
log(chalk.hex('#DEADED').bold('Bold gray!'))
```

![chalk](https://github.com/chalk/chalk/raw/main/media/screenshot.png)

## 文本颜色

* `black`
* `red`
* `green`
* `yellow`
* `blue`
* `magenta`
* `cyan`
* `white`
* `blackBright` (alias: `gray`, `grey`)
* `redBright`
* `greenBright`
* `yellowBright`
* `blueBright`
* `magentaBright`
* `cyanBright`
* `whiteBright`

## 背景颜色

* `bgBlack`
* `bgRed`
* `bgGreen`
* `bgYellow`
* `bgBlue`
* `bgMagenta`
* `bgCyan`
* `bgWhite`
* `bgBlackBright` (alias: `bgGray`, `bgGrey`)
* `bgRedBright`
* `bgGreenBright`
* `bgYellowBright`
* `bgBlueBright`
* `bgMagentaBright`
* `bgCyanBright`
* `bgWhiteBright`

## 文本修饰

* `reset` - 重置当前样式。
* `bold` - 将文本设置为粗体。
* `dim` - 降低文本不透明度（变暗）。
* `italic` - 将文本设置为斜体。*（支持不广泛）*
* `underline` - 在文本下方添加水平线（下划线）。*（支持不广泛）*
* `overline` - 在文本上方添加水平线（上划线）。*（支持不广泛）*
* `inverse` - 反转背景色与前景色。
* `hidden` - 打印文本但使其不可见（隐藏）。
* `strikethrough` - 在文本中央添加水平线（删除线）。*（支持不广泛）*
* `visible` - 仅当Chalk颜色级别大于零时显示文本。适用于纯装饰性内容。

## 256色与彩色支持

Chalk在兼容的终端应用中支持256色及[真彩色](https://github.com/termstandard/colors)（1600万色）。

色彩会从1600万种RGB值向下采样为终端模拟器支持的ANSI色彩格式（或通过指定Chalk选项如`{level: n}`实现）。例如，当Chalk配置为运行在级别1（基础色彩支持）时，会将RGB值#FF0000（红色）下采样为31（ANSI红色转义码）。

使用示例：

* `chalk.hex('#DEADED').underline('你好，世界！')`
* `chalk.rgb(15, 100, 204).inverse('你好！')`

背景色版本需添加`bg`前缀并首字母大写（例如前景色用`hex`，背景色则用`bgHex`）。

* `chalk.bgHex('#DEADED').underline('你好，世界！')`
* `chalk.bgRgb(15, 100, 204).inverse('你好！')`

可用色彩模型包括：

* [`rgb`](https://en.wikipedia.org/wiki/RGB_color_model) - 示例：`chalk.rgb(255, 136, 0).bold('橙色！')`
* [`hex`](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet) - 示例：`chalk.hex('#FF8800').bold('橙色！')`
* [`ansi256`](https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit) - 示例：`chalk.bgAnsi256(194)('蜜露色，大致如此')`

---

---
url: /fe-oss/chokidar/index.md
---
# chokidar
::: note 注释

优秀的好用的 文件监听 相关开源项目, 就目前而言只有 `chokidar` 是我用过最好用的。

如果你有其它不错的文件监听开源项目推荐，欢迎评论留言。
:::

## 概述

[**chokidar** 官方文档](https://github.com/paulmillr/chokidar){.read-more}

跨平台的简洁高效文件监控库。

### 原因

选择 Chokidar 而非原生 `fs.watch/fs.watchFile` 的诸多优势：

* 事件触发机制更可靠
  * macOS系统能准确上报文件名
  * 杜绝重复事件通知
  * 将变更分类为新增/修改/删除，而非无意义的"重命名"提示
* 支持原子写入操作（通过atomic选项）
  * 某些文件编辑器会采用此方式
* 支持分块写入检测（通过awaitWriteFinish选项）
  * 大文件通常采用分块写入方式
* 支持文件/目录过滤
* 完整支持符号链接
* 始终提供递归监控功能（原生事件仅部分支持）
* 可自定义递归监控深度

Chokidar 依赖于 Node.js 核心的 `fs` 模块，但在使用 `fs.watch` 和 `fs.watchFile` 进行监听时，会对接收的事件进行标准化处理，
通常通过获取文件状态和目录内容来验证事件真实性。
默认采用基于 `fs.watch` 的实现方案，该方案避免了轮询机制，能有效降低 CPU 占用率。
请注意，chokidar 会递归地为指定路径范围内的所有内容初始化监听器，因此需谨慎设置监听范围，
避免因监控过多不必要内容而浪费系统资源。在某些情况下会改用 `fs.watchFile` 方案，该方案采用轮询机制，会消耗更多系统资源。

::: important `chokidar` 现在最新版本是 **v4** , 它与旧的版本，在使用上的差异比较大，本文所有的示例都是基于 **v4** 的版本。
:::

## 安装

::: npm-to

```sh
npm install chokidar
```

:::

## 使用

```ts
import { watch } from 'chokidar'
```

### 监听单个文件

```ts
const watcher = watch('./foo.txt')

// 文件的任何变更都会触发
watcher.on('all', (event, path) => {
  console.log(event, path)
})

// 关闭监听
watcher.close()
```

### 监听多个文件

```ts
const watcher = watch(['./foo.txt', './bar.txt'])

// 文件修改
watcher.on('change', (path) => {
  console.log(path)
})

// 向监听器添加新的监听文件
watcher.add('./baz.txt')
watcher.add(['./foz.txt', './bab.txt'])

// 从监听器中移除监听文件
watcher.unwatch('./foo.txt')
```

### 监听文件夹

```ts
// 监听 foo 目录下的所有文件，递归地监听子文件夹
const watcher = watch('/foo/')

// 新增文件
watcher.on('add', path => console.log(path))
// 删除文件
watcher.on('unlink', path => console.log(path))
// 文件修改
watcher.on('change', path => console.log(path))

// 监听多个文件夹
watch(['/foo', '/bar'])
```

需要注意的是，监听文件夹会递归的监听子文件夹，如果文件夹下的文件很多，子目录深度过深可能会导致性能问题。
因此，通常需要配合 `ignored` 参数来限制监听范围，避免递归监听不必要的文件夹。

`ignored` : `string | RegExp | (string | RegExp)[] | (path, stats) => boolean`

**注意，不支持 glob 模式匹配！**

```ts
// 监听 foo 目录下的所有 `.js` 文件
const watcher = watch('/foo/', {
  // 忽略所有非 `.js` 文件
  ignored: (path, stats) => Boolean(stats?.isFile()) && !path.endsWith('.js'),
  ignoreInitial: true
})
```

### 当前工作目录

`cwd` : `string`

```ts
// 监听 foo 目录下的所有文件
const watcher = watch('.', {
  cwd: path.join(process.cwd(), 'foo'),
  ignoreInitial: true,
  // path 参数是绝对路径
  ignored: (path, stats) => Boolean(stats?.isFile())
})

watcher.on('add', (path) => {
  console.log(path) // path 是相对于 `cwd` 的路径
})
```

---

---
url: /fe-oss/clack-prompts/index.md
---
# @clack/prompts
## 概述

`@clack/prompts` 是一个轻量级、美观且用户友好的命令行交互工具库。
它提供了现代化的 CLI 提示组件，支持 TypeScript 类型安全，具有动画效果和直观的交互体验，适用于创建脚手架工具、配置向导等 CLI 应用。

## 特性

* **类型安全**：完整的 TypeScript 支持，提供精准的类型推断
* **丰富的组件**：支持文本输入、选择器、确认框、多选等交互元素
* **现代化 UI**：动态加载状态、彩色高亮、动画过渡效果
* **取消处理**：内置 `Esc`/`Ctrl+C` 取消操作的处理逻辑
* **输入验证**：内置验证器，支持自定义验证规则
* **主题定制**：允许自定义颜色和样式
* **无障碍支持**：优化键盘导航体验

![cac](https://github.com/bombshell-dev/clack/raw/main/.github/assets/clack-demo.gif)

## 安装

::: npm-to

```bash
npm install @clack/prompts
```

:::

## 使用

### 基础示例

```ts
import {
  cancel,
  confirm,
  isCancel,
  select,
  text
} from '@clack/prompts'

// 处理取消操作的通用函数
function handleCancel(value: unknown) {
  if (isCancel(value)) {
    cancel('Operation cancelled.')
    process.exit(0)
  }
}

(async () => {
  // 文本输入
  const name = await text({
    message: 'What is your name?',
    placeholder: 'Anonymous',
    validate: (value) => {
      if (value.trim().length === 0)
        return 'Name is required!'
    }
  })
  handleCancel(name)

  // 选择器
  const framework = await select({
    message: 'Choose a framework',
    options: [
      { value: 'react', label: 'React' },
      { value: 'vue', label: 'Vue.js', hint: 'recommended' },
      { value: 'svelte', label: 'Svelte' },
    ]
  })
  handleCancel(framework)

  // 确认框
  const installDeps = await confirm({
    message: 'Install dependencies?'
  })
  handleCancel(installDeps)

  console.log({
    name,
    framework,
    installDeps
  })
})()
```

### 多选组件

```ts
import { multiselect } from '@clack/prompts'

const tools = await multiselect({
  message: 'Select tools:',
  options: [
    { value: 'eslint', label: 'ESLint' },
    { value: 'prettier', label: 'Prettier', selected: true },
    { value: 'typescript', label: 'TypeScript' },
  ],
  required: true
})
handleCancel(tools)
```

### 密码输入

```ts
import { password } from '@clack/prompts'

const secret = await password({
  message: 'Enter API key:',
  mask: '*'
})
handleCancel(secret)
```

### 自定义主题

```ts
import { setTheme, text } from '@clack/prompts'

setTheme({
  color: {
    primary: '#8B5CF6', // 紫色
    error: '#EF4444' // 红色
  },
  symbols: {
    pointer: '👉'
  }
})

const themeDemo = await text({
  message: 'Custom themed input'
})
```

## 使用场景

* **脚手架工具**

  创建项目初始化工具（如 `create-react-app`），交互式配置项目选项

* **CLI 配置向导**

  引导用户完成复杂工具的配置过程（如数据库连接设置）

* **自动化脚本**

  在部署脚本中确认关键操作（如生产环境部署确认）

---

---
url: /fe-oss/commander/index.md
---
# commander
## 概述

[**commander** 官方文档](https://github.com/tj/commander.js){.read-more}

`commander` 是一个轻量级、功能强大的 Node.js 命令行接口（CLI）开发工具库。

它简化了命令行参数解析、命令定义和帮助文档生成的过程，被广泛应用于构建专业的命令行工具（如 Vue CLI、React Native CLI 等）。

## 特性

* **声明式命令定义**：通过链式 API 直观定义命令、子命令和选项
* **自动生成帮助文档**：基于定义的命令结构自动生成 `--help` 说明
* **灵活的选项解析**：支持短选项（`-v`）、长选项（`--verbose`）、必填/可选参数和默认值
* **智能参数验证**：内置类型检查（字符串、数字、布尔值等）和自定义验证逻辑
* **命令分层结构**：支持多级子命令（如 `git remote add`）
* **交互式提示**：可与 `inquirer.js` 等库集成实现用户交互
* **自动化错误处理**：自动捕获并格式化参数错误
* **插件生态系统**：支持通过插件扩展功能（如 `commander-inquirer`）

## 安装

::: npm-to

```sh
npm install commander
```

:::

## 使用

### 基础示例

```ts
import { Command } from 'commander'
const program = new Command()

program
  .name('file-util')
  .description('文件操作工具')
  .version('1.0.0')

program.command('split')
  .description('拆分文件')
  .argument('<file>', '要拆分的文件')
  .option('-s, --size <bytes>', '分块大小', '1024')
  .action((file, options) => {
    console.log(`拆分文件: ${file}, 分块大小: ${options.size}字节`)
  })

program.parse(process.argv)
```

### 选项配置

```ts
program
  .option('-d, --debug', '启用调试模式', false)
  .option('-c, --count <number>', '重复次数', Number.parseInt, 1)
  .option('-l, --list <items>', '项目列表', val => val.split(','))
  .option('--no-color', '禁用颜色输出')
```

### 高级功能

**自定义验证**：

```ts
program
  .argument('<port>', '端口号', (val) => {
    const port = Number.parseInt(val)
    if (Number.isNaN(port))
      throw new Error('无效端口')
    return port
  })
```

**异步操作**：

```ts
program
  .command('download')
  .action(async () => {
    await fetchData()
    console.log('下载完成!')
  })
```

## 使用场景

* **开发脚手架工具**

  快速创建项目模板（如 `create-react-app` 风格工具）

  ```bash
  my-cli create <project-name> --template vue
  ```

* **构建运维脚本**

  封装服务器部署、日志分析等操作

  ```sh
  deploy-tool --env production --rollback-on-error
  ```

* **创建交互式 CLI 应用**

  结合 `inquirer` 实现问卷式配置生成

  ```bash
  config-generator init
  ```

---

---
url: /fe-oss/consola/index.md
---
# consola
&#x20;

## 概述

::: center
优雅的控制台包装器

![consola](https://github.com/unjs/consola/assets/904724/0e511ee6-2543-43ab-9eda-152f07134d94)
:::

`Consola` 是一个由 `Nuxt.js` 团队开发的现代化、高性能的 Node.js 日志管理库，专为简化开发和生产环境中的日志记录而设计。
它结合了美观的输出格式、灵活的配置和轻量级架构，成为 Node.js 生态中流行的日志解决方案。

## 使用场景

* 开发环境下的日志输出
* 构建部署时的日志输出
* 在 CI/CD 环境下的日志输出
* 命令行工具的日志输出

如果你的应用服务需要日志输出库，推荐使用 [pino](./pino.md) 作为日志输出库，
因为它更适合高性能的日志记录，同时还支持多种输出渠道，如文件、控制台、远程日志服务等。

## 安装

:::npm-to

```sh
npm install consola
```

:::

## 使用

```ts
import consola from 'consola'

// 不同级别日志
consola.info('启动服务')
consola.success('操作完成！')
consola.error(new Error('文件未找到'))

// 带标签的日志
const dbLogger = consola.withTag('Database')
dbLogger.debug('连接池初始化')
```

---

---
url: /fe-oss/cosmiconfig/index.md
---
# cosmiconfig
## 概述

\==cosmiconfig== 是一个专为 Node.js 生态设计的智能化配置解析库，旨在解决 JavaScript 工具链中碎片化的配置文件管理问题。
它通过统一、灵活的加载机制，支持包括 JSON、YAML、JS 模块等在内的多种格式，显著简化了开发者对配置文件的查找、解析与集成流程。

::: tip `eslint` / `stylelint` / `prettier` / `webpack` 等知名开源项目，均使用 `cosmiconfig` 进行配置文件解析
:::

## 配置文件查找过程

默认情况下，cosmiconfig 会检查当前目录中是否存在以下配置：

1. `package.json` 文件中的特定属性
2. 无扩展名的 JSON/YAML 格式 "rc文件"
3. 扩展名为 `.json` / `.yaml` / `.yml` / `.js` / `.ts` / `.mjs` / `.cjs` 的 "rc文件"
4. 上述两种文件在 `.config` 子目录中的存在形式
5. `.config.js` / `.config.ts` / `.config.mjs` / `.config.cjs` 格式的配置文件

## 安装

::: npm-to

```sh
npm install cosmiconfig
```

:::

## 使用

### 基本用法

```ts
import cosmiconfig from 'cosmiconfig'

const explorer = cosmiconfig('myapp')

explorer.search().then((result) => {
  console.log(result.config) // 配置内容
})
```

在这个例子中，`cosmiconfig` 按以下顺序查找配置文件：

```txt
package.json 中的 `myapp` 字段
.myapprc
.myapprc.json
.myapprc.{yaml,yml}
.myapprc.{js,ts,mjs,cjs}
.config/.myapprc
.config/.myapprc.json
.config/.myapprc.{yaml,yml}
.config/.myapprc.{js,ts,mjs,cjs}
myapp.config.{js,ts,mjs,cjs}
```

### 自定义搜索路径

```ts
import cosmiconfig from 'cosmiconfig'

const explorer = cosmiconfig('myapp', {
  searchPlaces: ['.myapprc', 'config/myapp.json'], // 自定义搜索路径
})

explorer.search().then((result) => {
  console.log(result.config) // 配置内容
})
```

### 自定义加载器

```ts
const cosmiconfig = require('cosmiconfig')
const explorer = cosmiconfig('myapp', {
  searchPlaces: ['myapp.toml'], // 自定义搜索路径
  loaders: { '.toml': customTOMLParser } // 扩展自定义格式解析
})

// 异步搜索当前目录及祖先目录
explorer.search().then((result) => {
  if (result)
    console.log('配置内容:', result.config)
})
```

---

---
url: /fe-oss/dotenv/index.md
---
# dotenv
## 概述

\==dotenv== 是 Node.js 生态中广泛使用的环境变量管理工具，旨在通过 .env 文件安全、灵活地管理配置信息。

## 安装

::: npm-to

```sh
npm install dotenv
```

:::

## 使用

`dotenv` 读取项目根目录下的 `.env` 文件，并将其加载到 `process.env` 对象中。

```sh title=".env"
API_KEY=abcdefg
DB_HOST=localhost
```

在代码中调用：

```ts title="index.ts"
import dotenv from 'dotenv'

dotenv.config()
```

### 自定义路径

```ts title="index.ts"
import dotenv from 'dotenv'

dotenv.config({ path: '.env.production' })
```

### 加载多个文件

```ts title="index.ts"
import dotenv from 'dotenv'

// 加载 .env.local 和 .env
// 默认优先加载 `.env.local` 中的值，`.env` 中的同名变量不会生效
// 此时的优先级顺序是数组从左到右
dotenv.config({ path: ['.env.local', '.env'] })

// 设置 `override` 为 `true` 时，会覆盖已存在的环境变量
// 此时的优先级顺序是数组从右到左
dotenv.config({ path: ['.env.local', '.env'], override: true })
```

## 最佳实践

* 使用 `.env.local` 存储本地配置，并将其添加到 `.gitignore` 中
* 根据不同的环境加载不同的配置文件 `.env.development` / `.env.production` 等，根据情况决定是否添加至 `.gitignore`

```ts
import dotenv from 'dotenv'

dotenv.config({ path: ['.env.local', `.env.${process.env.NODE_ENV}`] })
```

---

---
url: /fe-oss/eruda/index.md
---
# eruda
## 概述

[**eruda** 官方文档](https://eruda.liriliri.io/zh/docs/){.read-more}

与 [vconsole](./vconsole.md) 类似，在页面中注入控制面板，适合在移动设备调试网页时使用。

![eruda](https://camo.githubusercontent.com/d0f6d8eb7aa3c04da21dde1b137049ad3439a7ca17bac6628aa4166a42551dba/68747470733a2f2f65727564612e6c6972696c6972692e696f2f73637265656e73686f742e6a7067)

## 场景

在移动端设备中调试网页是一件比较麻烦的事情，因为缺少了浏览器的调试面板，我们很难直观的看到代码执行发生了
什么错误。

eruda 旨在解决这个问题，它在页面中注入了一个面板，模拟了浏览器的调试面板，让你可以直观的看到网页的执行情况。
比如 元素、网络请求、日志输出等等。

## 安装

::: npm-to

```bash
npm install eruda
```

:::

## 使用

```html
<script src="node_modules/eruda/eruda.js"></script>
<script>eruda.init();</script>
```

或者使用动态引入：

```ts
if (import.meta.env.MODE === 'development') {
  import('eruda').then(eruda => eruda.default.init())
}
```

## 预览

::: center

<https://eruda.liriliri.io/>

![preview](https://eruda.liriliri.io/qrcode.png)
:::

## 对比

与 [vconsole](./vconsole.md) 相同，都是在页面中注入控制面板，支持在移动设备调试网页。

eruda 还可以通过插件添加更多的功能，比如添加 `vue` 调试面板，当有个性的需求时，eruda 是个更好的选择。

---

---
url: /fe-oss/fast-glob/index.md
---
# fast-glob
## 概述

[**fast-glob** 官方文档](https://github.com/mrmlnc/fast-glob){.read-more}

这是一个非常快速高效的Node.js glob 库。

## 安装

:::npm-to

```sh
npm install fast-glob
```

:::

## 使用

```ts
import { glob, globStream, globSync } from 'fast-glob'
```

```ts
// 异步模式
const entries = await glob(['.editorconfig', '**/index.js'], { dot: true })

// 同步模式
const entries = globSync(['.editorconfig', '**/index.js'], { dot: true })

// 流模式
const stream = globStream(['.editorconfig', '**/index.js'], { dot: true })

for await (const entry of stream) {
  // .editorconfig
  // services/index.js
}
```

---

---
url: /fe-oss/fdir/index.md
---
# fdir
## 概述

NodeJS 最快的目录遍历与通配符匹配工具

:::important 在需要高性能场景下读取大目录文件时，使用 `fdir` 是一个不错的选择。
最快速度：在NodeJS领域，尚无任何同类工具能在速度上与fdir匹敌。它能轻松在不到1秒内遍历包含100万个文件的目录。
:::

## 安装

:::npm-to

```sh
npm install fdir
```

:::

## 使用

[**fdir** 官方文档](https://github.com/thecodrr/fdir/blob/HEAD/documentation.md){.read-more}

```ts
import { fdir } from 'fdir'
```

```ts
import { fdir as Fdir } from 'fdir'

const crawler = new Fdir()
const files = crawler.crawl('/path/to/dir').sync()
```

---

---
url: /fe-oss/fs-glob/index.md
---
# fs.glob
&#x20;

## 概述

`NodeJS` 在 22.0.0 版本新增的试验性 API。

根据模式，查找匹配的文件和目录。

## 使用方法

### 回调模式

```ts
import { glob } from 'node:fs'

glob('**/*.js', (err, matches) => {
  if (err)
    throw err
  console.log(matches) // 文件或目录 路径列表
})
```

### 同步阻塞查找

```ts
import { globSync } from 'node:fs'

const matches = globSync('**/*.js')

console.log(matches) // 文件或目录 路径列表
```

### 异步查找

```ts
import { glob } from 'node:fs/promises'

for await (const entry of glob('**/*.js'))
  console.log(entry)
```

## API

### `fs.glob(pattern[, options], callback)`

* `pattern`: `string | string[]` 匹配模式
* `options`: `object` 选项
  * `cwd`: `string` 当前工作目录。默认值：process.cwd()
  * `exclude`: `Function | string[]` 用于过滤文件/目录或要排除的 glob 模式列表的函数。如果提供了函数，则返回 `true` 以排除该项目，返回 false 以包含它。默认值：undefined。
  * `withFileTypes`: `boolean` 如果 glob 应将路径返回为 `Dirents`，则为 `true`，否则为 `false`。默认值：false。
* `callback`: `(err, matches) => void` 回调函数

```ts
import { glob } from 'node:fs'

glob('**/*.js', (err, matches) => {
  if (err)
    throw err
  console.log(matches)
})
```

### `fs.globSync(pattern[, options])`

* `pattern`: `string | string[]` 匹配模式
* `options`: `object` 选项
  * `cwd`: `string` 当前工作目录。默认值：process.cwd()
  * `exclude`: `Function | string[]` 用于过滤文件/目录或要排除的 glob 模式列表的函数。如果提供了函数，则返回 `true` 以排除该项目，返回 false 以包含它。默认值：undefined。
  * `withFileTypes`: `boolean` 如果 glob 应将路径返回为 `Dirents`，则为 `true`，否则为 `false`。默认值：false。

```ts
import { globSync } from 'node:fs'

const matches = globSync('**/*.js')

console.log(matches)
```

### `fs.promises.glob(pattern[, options])`

* `pattern`: `string | string[]` 匹配模式
* `options`: `object` 选项
  * `cwd`: `string` 当前工作目录。默认值：process.cwd()
  * `exclude`: `Function | string[]` 用于过滤文件/目录或要排除的 glob 模式列表的函数。如果提供了函数，则返回 `true` 以排除该项目，返回 false 以包含它。默认值：undefined。
  * `withFileTypes`: `boolean` 如果 glob 应将路径返回为 `Dirents`，则为 `true`，否则为 `false`。默认值：false。

```ts
import { glob } from 'node:fs/promises'

for await (const entry of glob('**/*.js'))
  console.log(entry)
```

---

---
url: /fe-oss/globby/index.md
---
# globby
## 概述

[**globby** 官方文档](https://github.com/sindresorhus/globby){.read-more}

基于 [fast-glob](./fast-glob.md)，但添加了许多有用的功能。

## 特性

* Promise API
* 多种模式支持
* 否定模式：`['foo*', '!foobar']`
* 自动展开目录：`foo → foo/**/*`
* 兼容 `.gitignore` 及同类忽略配置文件
* 支持 `URL` 作为 `cwd`

## 安装

:::npm-to

```sh
npm install globby
```

:::

## 使用

```ts
import { globby, globbyStream, globbySync } from 'globby'
```

```ts
// 异步模式
const paths = await globby(['*', '!cake'])

console.log(paths)
// => ['unicorn', 'rainbow']
```

```ts
// 同步模式
const paths = globbySync(['*', '!cake'])

console.log(paths)
// => ['unicorn', 'rainbow']
```

```ts
// 流模式
import { globbyStream } from 'globby'

for await (const path of globbyStream('*.tmp')) {
  console.log(path)
}
```

---

---
url: /fe-oss/got/index.md
---
# got
## 概述

Got 是一个轻量级、功能丰富且基于 Promise 的 Node.js HTTP 客户端库，旨在简化 HTTP 请求的处理过程。

与 Node.js 原生 http 模块或其他流行库（如 axios）相比，Got 提供了更简洁的 API、自动重试机制、流式支持和高度的可定制性。

### 特性

* **自动重试**：在网络波动或服务不可用时自动重试请求，提升鲁棒性。
* **Promise 原生支持**：完美适配 async/await 语法，避免回调地狱。
* **流式处理**：通过 got.stream 支持大文件下载或实时数据流处理。
* **高度可定制**：可修改请求头、超时时间、查询参数等，并支持钩子（hooks）扩展。
* **内置 JSON 处理**：自动解析响应为 JSON 对象，简化数据消费流程。

## 安装

::: npm-to

```sh
npm install got
```

:::

## 使用

### 基础示例

GET 请求

```ts
import got from 'got'

// 获取 JSON 数据
const response = await got('https://jsonplaceholder.typicode.com/posts/1')
console.log(JSON.parse(response.body))
```

POST 请求

```ts
const response = await got.post('https://api.example.com/login', {
  json: { username: 'foo', password: 'bar' },
  responseType: 'json' // 自动解析响应为 JSON
})
console.log(response.body.token)
```

### 自定义请求配置

```ts
await got('https://api.example.com/data', {
  headers: { 'User-Agent': 'MyApp/1.0' },
  searchParams: { page: 2 }, // 添加查询参数 ?page=2
  timeout: { request: 5000 } // 5 秒超时
})
```

### 流式下载文件

```ts
import fs from 'node:fs'
import got from 'got'

const downloadStream = got.stream('https://example.com/large-file.zip')
const fileWriter = fs.createWriteStream('file.zip')
downloadStream.pipe(fileWriter)

fileWriter.on('finish', () => console.log('下载完成！'))
```

## 适用场景

* 高频 API 调用

  适合需频繁调用外部 API 的服务（如微服务架构）。自动重试和超时管理保障了请求的可靠性

* 数据爬取与流处理

  流式支持使其高效处理大规模数据下载（如爬虫场景），避免内存溢出

* 服务器端通信

  在 BFF（Backend for Frontend）层中，Got 可聚合多个下游服务的数据，并通过统一的错误处理简化逻辑

---

---
url: /fe-oss/inquirer/index.md
---
# @inquirer/prompts
## 概述

\==@inquirer/prompts== 是一个用于 Node.js 的交互式命令行界面（CLI）库，旨在简化用户输入收集过程。
它支持多种问题类型（如输入框、选择列表、确认框等），并通过 Promise 或回调返回结构化答案，极大提升了命令行工具的交互体验

## 特性

* 问题类型

  支持 input（文本输入）、confirm（是/否）、list（单选列表）、checkbox（多选）、password（密码隐藏输入）等 12 种交互类型

* 异步验证与过滤

  通过 `validate` 函数实时校验输入合法性，`filter` 函数格式化答案

* 条件式提问

  使用 `when` 属性根据前置答案动态跳过问题，实现逻辑分支

* 跨平台兼容

  支持 Windows（CMD/PowerShell）、macOS（Terminal/iTerm）和 Linux（GNOME/Konsole）等终端

## 安装

::: npm-to

```sh
npm install @inquirer/prompts
```

:::

## 示例

### 基础用法

```ts
import { input } from '@inquirer/prompts'

const answer = await input({ message: 'Enter your name' })
```

### 以对象形式获取

```ts
import { confirm, input } from '@inquirer/prompts'

const answers = {
  firstName: await input({ message: 'What\'s your first name?' }),
  allowEmail: await confirm({ message: 'Do you allow us to send you email?' }),
}

console.log(answers.firstName)
```

### 条件式提问

```ts
import { confirm, input } from '@inquirer/prompts'

const allowEmail = await confirm({ message: 'Do you allow us to send you email?' })

let email
if (allowEmail) {
  email = await input({ message: 'What is your email address' })
}
```

### 超时返回默认值

```ts
import { input } from '@inquirer/prompts'

const answer = await input(
  { message: 'Enter a value (timing out in 5 seconds)' },
  { signal: AbortSignal.timeout(5000) },
).catch((error) => {
  if (error.name === 'AbortPromptError') {
    return 'Default value'
  }

  throw error
})
```

## 使用场景

* 脚手架工具
* 命令行配置向导
* 自动化脚本

---

---
url: /fe-oss/intro/index.md
---
# 前端开源库指南
## 概述

本指南罗列一系列在前端开发过程中经常使用到的开源库，这些库应用在前端领域的方方面面。

当你需要开发某项功能，但是不知道该使用哪些开源库时，可以先看下这些开源库，有没有适合你的需求。

---

---
url: /fe-oss/joi/index.md
---
# joi
&#x20;

## 概述

[**Joi** 官方文档](https://joi.dev){.read-more}

\==Joi== 由 **Hapi.js** 团队开发，是一个强大的 JavaScript 数据验证库，专注于为 Node.js 和浏览器环境提供声明式的对象模式描述与验证能力。

## 特性

* 声明式 Schema 定义

  Joi 通过链式 API 定义数据模式（Schema），以简洁的语法描述数据结构与规则。例如：

  ```ts
  const schema = Joi.object({
    username: Joi.string().alphanum().min(3).max(30).required(),
    email: Joi.string().email().required(),
    password: Joi.string().regex(/^[a-zA-Z0-9]{3,30}$/),
    birthdate: Joi.date().min('1900-01-01').max('now'),
    address: Joi.object({
      street: Joi.string().required(),
      city: Joi.string().required()
    })
  })
  ```

  * **类型支持**：覆盖 `string`, `number`, `boolean`, `date`, `array`, `object`, `binary` 等基础与复合类型
  * **链式规则**：如 `.min()`, `.max()`, `.regex()`, `.email()`, `.required()` 等，可组合使用

* 嵌套结构与复杂验证

  * 支持多级对象嵌套（如 `address.city`）
  * 条件验证：通过 `Joi.when()` 实现动态规则（如当性别为男性时要求填写 `maleSpecificField`）

    ```ts
    const schema = Joi.object({
      sex: Joi.number().valid(0, 1),
      name2: Joi.when('sex', { is: 1, then: Joi.string().required() })
    })
    ```

* 字段依赖与互斥

  * `.with('fieldA', 'fieldB')`：若 `fieldA` 存在，则 `fieldB` 必填。
  * `.without('fieldA', 'fieldB')`：`fieldA` 和 `fieldB` 不能同时存在

* 数据清洗与转换

  * 自动格式化数据（如字符串转日期、数字转字符串）
  * 移除非法字段（`strip()`）或设置默认值（`.default('value')`）

* 错误处理

  * 返回详细错误信息（包括错误字段、类型及原因），支持自定义错误消息（`.error(new Error('自定义消息'))`）
  * 控制错误报告策略：`abortEarly: false` 可收集所有错误而非在首次失败时终止

## 安装

::: npm-to

```sh
npm install joi
```

:::

## 使用

```ts
import joi from 'joi'

// 定义 Schema
const schema = Joi.object({
  username: Joi.string().min(3).required(),
  age: Joi.number().integer().min(18).default(20),
  hobbies: Joi.array().items(Joi.string()).min(1)
})

// 验证数据
const data = { username: 'Tom', age: 25 }
const { error, value } = schema.validate(data, { abortEarly: false })

if (error) {
  console.error(error.details) // 输出所有错误详情
}
else {
  console.log(value) // 输出清洗后数据（包含默认值）
}
```

## 使用场景

* API 请求验证
* 配置文件校验
* 表单与用户输入
* 数据库模型验证

---

---
url: /fe-oss/keyv/index.md
---
# keyv
## 概述

\==keyv== 通过存储适配器为多种后端提供了一个统一的键值存储接口。
它支持基于TTL（生存时间）的过期机制，因此非常适合用作缓存或持久化的键值存储系统。

## 安装

::: npm-to

```sh
npm install keyv
```

:::

各种适配器支持：

::: npm-to

```sh
npm install @keyv/redis
npm install @keyv/valkey
npm install @keyv/mongo
npm install @keyv/sqlite
npm install @keyv/postgres
npm install @keyv/mysql
npm install @keyv/etcd
npm install @keyv/memcache
```

:::

## 使用

```ts
import Keyv from 'keyv'

const keyv = new Keyv()
```

```ts
// Redis
import KeyvRedis from '@keyv/redis'
import Keyv from 'keyv'

const keyvRedis = new KeyvRedis('redis://user:pass@localhost:6379')
const keyv = new Keyv({ store: keyvRedis })
```

```ts
// sqlite
import KeyvSqlite from '@keyv/sqlite'
import Keyv from 'keyv'

const keyvSqlite = new KeyvSqlite('sqlite://path/to/database.sqlite')
const keyv = new Keyv({ store: keyvSqlite, ttl: 5000 })
```

### 命名空间隔离

```ts
import KeyvRedis from '@keyv/redis'
import Keyv from 'keyv'

const users = new Keyv(new KeyvRedis('redis://user:pass@localhost:6379'), { namespace: 'users' })
const cache = new Keyv(new KeyvRedis('redis://user:pass@localhost:6379'), { namespace: 'cache' })
```

### Method

```ts
const Keyv = require('keyv')
const keyv = new Keyv() // 默认使用内存存储

// 写入数据（含 TTL）
await keyv.set('config', { theme: 'dark', lang: 'zh' }, 5000)

// 读取数据
const config = await keyv.get('config')
console.log(config) // { theme: 'dark', lang: 'zh' }

// 删除数据
await keyv.delete('config')

// 清空当前命名空间数据
await keyv.clear()
```

## 适用场景

* API 响应缓存

  缓存外部接口，减少重复请求，提升响应速度。

* 会话状态管理（Session）

  结合 Redis 适配器实现多服务实例共享会话数据6。

* 分布式任务队列

  存储任务状态，通过 Redis 保证多节点一致性。

* 配置参数存储

  使用 SQLite 适配器持久化应用配置，支持动态更新。

---

---
url: /fe-oss/level/index.md
---
# level
&#x20;

## 概述

[**level** 官方文档](https://github.com/Level/abstract-level){.read-more}

LevelDB 是由 Google 开发的高性能键值存储引擎，而 level 是其在 Node.js 环境中的开源实现，通过 JavaScript 封装提供轻量级 NoSQL 数据库解决方案。

## 安装

::: npm-to

```sh
npm install level
```

:::

## 使用

```ts
import { Level } from 'level'

// 创建数据库
const db = new Level('example', { valueEncoding: 'json' })

// 设置值
await db.put('a', 1)

// 批量操作
await db.batch([{ type: 'put', key: 'b', value: 2 }])

// 获取值
const value = await db.get('a')

// 遍历键大于'a'的条目
for await (const [key, value] of db.iterator({ gt: 'a' })) {
  console.log(value) // 2
}
```

## 适用场景

* **高频写入**：日志收集、实时监控数据（LSM-Tree 写优化）
* **嵌入式存储**：本地化数据缓存

---

---
url: /fe-oss/lowdb/index.md
---
# lowdb
&#x20;&#x20;

## 概述

lowdb 是一个轻量级的本地 JSON 数据库。

利用 JSON 文件作为持久化存储介质，通过 JavaScript 原生 API 操作数据，无需依赖外部数据库服务。

## 安装

::: npm-to

```sh
npm install lowdb
```

:::

## 使用

```ts
import { JSONFilePreset } from 'lowdb/node'

// 读取或创建 db.json
const defaultData = { posts: [] }
const db = await JSONFilePreset('db.json', defaultData)

// 更新 db.json
await db.update(({ posts }) => posts.push('hello world'))

// 也可以稍后显式调用 db.write()
// 将数据写入 db.json
db.data.posts.push('hello world')
await db.write()
```

### Lodash

通过 `Lodash` 实现链式调用

```ts
import lodash from 'lodash'
import { Low } from 'lowdb'
import { JSONFile } from 'lowdb/node'

interface Post {
  id: number
  title: string
}

interface Data {
  posts: Post[]
}

// Extend Low class with a new `chain` field
class LowWithLodash<T> extends Low<T> {
  chain: lodash.ExpChain<this['data']> = lodash.chain(this).get('data')
}

const defaultData: Data = {
  posts: [],
}
const adapter = new JSONFile<Data>('db.json', defaultData)

const db = new LowWithLodash(adapter)
await db.read()

// 使用 db.chain 而非 db.data 来访问 lodash API
const post = db.chain.get('posts').find({ id: 1 }).value() // 重要提示：必须调用value()以执行链式操作
```

## 适用场景

* **小型工具/CLI**：配置文件、临时数据存储
* **Electron 桌面应用**：本地数据持久化（如用户设置）

## 缺点

* **性能瓶颈**：数据量 >10MB 时，全量读写导致延迟显著上升。
* **并发能力弱**：无锁机制，不适用高并发场景。
* **功能简化**：缺乏事务、索引、关联查询等高级数据库特性。

---

---
url: /fe-oss/lru-cache/index.md
---
# lru-cache
## 概述

一个高性能、功能丰富的 **Least Recently Used (LRU) 缓存** 实现库，专为 Node.js 环境设计。

**LRU (最近最少使用)**：当缓存达到设定的容量上限时，它会自动淘汰那些最近最少被访问的项，为新数据腾出空间。
这是管理有限内存资源的有效策略。

## 特性

* **LRU 缓存**：

  * 存储键值对 (`key` -> `value`)。
  * 当添加新项导致缓存大小超过 `max` 或 `maxSize` 限制时，自动淘汰最近最少使用的项。
  * 高效的 `get` (获取)、`set` (设置/更新)、`delete` (删除)、`has` (检查存在) 操作。

* **容量限制**：

  * `max`: 设置缓存允许存储的最大 条目数量。最常用的限制方式。

  * `maxSize`: 设置缓存允许使用的 最大总大小（字节数或其他单位）。需要配合 `sizeCalculation` 函数使用。

  * `sizeCalculation`: 一个函数，用于计算每个缓存项的大小（除了其键所占的内存）。
    例如，可以用来计算存储对象或字符串的实际内存占用。这对于精确控制内存使用至关重要。

* **条目过期 (TTL - Time To Live)**：

  * `ttl`: 设置全局默认的条目存活时间（毫秒）。超过此时间未访问的条目会被视为过期。

  * `ttlAutopurge`: 是否在读取 (`get`) 时自动删除已过期的条目 (默认 `true`)。

  * `allowStale`: 允许在读取 (`get`) 时返回已过期但尚未被淘汰的条目 (默认 `false`)。

  * `updateAgeOnGet`: 在读取 (`get`) 时是否重置条目的“年龄”，将其视为新访问，从而延长它在缓存中的生存时间 (默认 `false`)。如果为 `true`，频繁访问的条目几乎不会过期。

  * `noDeleteOnStaleGet`: 当 `allowStale` 为 `true` 时，读取过期条目是否不触发异步后台删除 (默认 `false`，即会触发删除)。

  * `ttlResolution`: 过期检查的时间间隔精度（毫秒）。为了性能，内部不会实时检查每个条目，而是按此间隔批量检查 (默认 `0 ms`，表示尽可能精确，但实际受事件循环影响)。

  * **在 `set` 时指定 TTL**: 可以单独为每个 `set` 操作设置该条目的特定 TTL，覆盖全局 `ttl`。

* **获取与更新**：

  * `fetchMethod`: 当尝试 `get` 一个不存在（或允许过期且已过期）的键时，可以用这个函数去异步获取数据。
    它会防止对同一个键的重复并发请求（类似 Single Flight），只发出一个请求并将结果返回给所有等待者。
    极大简化了 **“缓存未命中则加载”** 的模式。`async (key, staleValue, { options, signal, context }) => {}`。
  * `noDeleteOnFetchRejection`: 如果 `fetchMethod` 拒绝 (`reject`)，是否不删除该键（默认 `false`，即会删除占位符）。
  * `allowStaleOnFetchRejection`: 如果 `fetchMethod` 拒绝 (`reject`) 且 `allowStale` 为 `true`，
    是否返回过期的旧值（如果有） (默认 `false`)。

## 安装

::: npm-to

```sh
npm install lru-cache
```

:::

## 使用

```ts
import { LRUCache } from 'lru-cache'

const cache = new LRUCache({
  max: 500, // 最大缓存条数

  // maxSize 和 sizeCalculation 配合使用
  maxSize: 5000, // 最大缓存大小
  sizeCalculation: (value, key) => value.length, // 计算每个缓存项的大小

  ttl: 1000 * 60 * 5, // 存活时间，单位毫秒

  allowStale: false, // 在从缓存中移除之前返回过期项？

  updateAgeOnGet: false,
  updateAgeOnHas: false,

  /// 用于cache.fetch()的异步方法，实现
  // 类似stale-while-revalidate（后台更新缓存）的行为模式
  fetchMethod: async (
    key,
    staleValue,
    { options, signal, context }
  ) => {},
})

// 设置值
cache.set('key', 'value')
// 获取值
cache.get('key') // "value"
// 检查是否存在
cache.has('key') // true
// 删除
cache.delete('key')

// 非字符串键名完全支持
// 但需注意必须是同一个对象，而非
// 仅结构等效的JSON对象
let someObject = { a: 1 }
cache.set(someObject, 'a value')

cache.clear() // 清空缓存
```

## 性能

* **高度优化**： 使用纯 JavaScript 实现，针对 V8 引擎做了优化。
* **零依赖**： 不依赖任何其他 npm 包，体积小，安全性高，安装快速。
* **O(1) 操作**： get, set, delete, has 等核心操作的时间复杂度都是常数级，非常高效。

## 适用场景

* **数据库查询缓存**： 缓存频繁查询的数据库结果。
* **API 响应缓存**： 缓存外部 API 调用的结果。
* **计算/渲染结果缓存**： 缓存耗时的计算结果、模板渲染结果。
* **会话存储 (Session Storage)**： 在内存中存储用户会话信息（注意持久化和分布式问题）。
* **速率限制**： 存储请求计数。
* 任何需要内存中快速键值存储且有容量限制和淘汰策略的地方。

---

---
url: /fe-oss/memfs/index.md
---
# memfs
&#x20;

## 概述

`memfs` 是一个在 Node.js 和浏览器环境中模拟内存文件系统的开源库，它完整实现了 Node.js 原生 fs 模块的 API，但所有操作均在内存中完成，无需物理磁盘交互。

## 特性

1. **完整文件系统模拟**
   * 支持基础操作：文件/目录的创建（`writeFileSync`）、读取（`readFileSync`）、删除（`unlink`）、重命名（`rename`）等。
   * 路径兼容性：无缝处理 Windows 和 Unix 风格的路径格式（如 `/data/file.txt` 或 `C:\data\file.txt`）。
   * 数据存储机制：使用 JavaScript 对象树结构管理文件数据，响应速度极快，但需注意内存占用量。

2. **Node.js API 兼容性**
   * 与 `fs` 模块接口一致，可直接替换现有代码中的文件操作模块，无需重写逻辑。
   * 同时提供同步（如 `writeFileSync`）和异步（如 `fs.promises.writeFile`）方法。

3. **跨环境支持**
   * **Node.js 环境**：通过 npm 安装即可使用。
   * **浏览器环境**：支持 Origin Private File System (OPFS)，允许在浏览器中操作“虚拟文件”，并可持久化到本地存储。

4. **高级扩展能力**
   * **unionfs**：合并多个文件系统实例（如 memfs + 物理磁盘），构建分层存储结构。
   * **crudfs/casfs**：实现 CRUD 风格抽象和内容寻址存储，适合版本控制、增量备份等场景。

## 安装

::: npm-to

```sh
npm install memfs
```

:::

## 使用

```ts
const { fs, vol } = require('memfs')

// 写入文件
fs.writeFileSync('/demo.txt', 'Hello memfs!')

// 读取文件
console.log(fs.readFileSync('/demo.txt', 'utf8')) // 输出: Hello memfs!

// 初始化预置文件结构
vol.fromJSON({
  '/config/settings.json': '{"theme": "dark"}',
  '/data/logs.txt': 'Log entry...'
}, '/virtual-root')
```

## 应用场景

1. **单元测试（避免污染真实磁盘）**

   ```ts
   import { fs, vol } from 'memfs'

   vol.fromJSON({ '/test/file.txt': 'mock data' })

   // 测试函数：检查文件是否存在
   test('check file existence', () => {
     expect(fs.existsSync('/test/file.txt')).toBe(true)
   })
   vol.reset() // 清理状态
   ```

2. **前端工具链优化**
   * 用于 Webpack 等构建工具，将编译产物暂存内存，避免磁盘 I/O 瓶颈，提速构建过程。

3. **临时数据沙盒**

   ```ts
   // 安全处理用户上传的临时文件
   fs.writeFileSync('/tmp/user-upload.jpg', buffer)
   processImage('/tmp/user-upload.jpg')
   // 进程退出后自动清除，无残留
   ```

## 生态系统与集成

1. **与测试框架结合**

   * **Jest/Vitest**：通过 `vi.mock` 替换 `fs` 模块，精准控制测试环境：

     ```ts
     vi.mock('fs', () => ({ default: memfs.fs }))
     vi.mock('fs/promises', () => memfs.fs.promises)
     ```

2. **扩展工具链**
   * **unionfs**：合并物理磁盘与内存文件系统，实现混合存储策略。
   * **fs-monkey**：动态劫持 Node.js 原生 `fs` 调用，重定向到 memfs（慎用于生产环境）。

## 注意事项

1. **内存管理**
   * 避免操作超大文件（如 GB 级），防止内存溢出（OOM）。
   * 使用 `vol.reset()` 及时清理测试残留数据。

2. **测试覆盖率提升技巧**

   * 使用 `vol.toJSON()` 导出内存文件结构，验证复杂操作结果：

     ```js
     expect(vol.toJSON()).toEqual({ '/result.json': '{"status": "success"}' })
     ```

3. **生产环境适用性**
   * 适用于**短期数据处理**（如请求级临时文件），但**不可替代持久化存储**。

---

---
url: /fe-oss/micromatch/index.md
---
# micromatch
## 概述

针对 **JavaScript/Node.js** 的 glob 匹配工具。作为 minimatch 和 multimatch 的更快速替代方案。

## 场景

* 检查当前文件的路径是否符合特定模式
* 当需要从一个文件列表中 过滤/排除 出符合特定模式的文件集合

## 安装

:::npm-to

```sh
npm install micromatch
```

:::

## 使用

```ts
import micromatch from 'micromatch'

// 返回匹配的列表
console.log(micromatch(['foo', 'bar', 'baz', 'qux'], ['f*', 'b*'])) // => ['foo', 'bar', 'baz']
console.log(micromatch(['foo', 'bar', 'baz', 'qux'], ['*', '!b*'])) // => ['foo', 'qux']

// 检查是否匹配
console.log(micromatch.isMatch('foo', 'f*')) // => true
console.log(micromatch.isMatch('foo', ['b*', 'f*'])) // => true

// 根据模式返回一个匹配函数
const isMatch = mm.matcher('*.!(*a)')
console.log(isMatch('a.a')) // => false
console.log(isMatch('a.b')) // => true
```

---

---
url: /fe-oss/minimatch/index.md
---
# minimatch
## 概述

一个极简的匹配工具。

这是 **npm** 内部使用的匹配库。

其工作原理是将 glob 表达式转换为 JavaScript 正则表达式对象。

## 场景

* 检查当前文件的路径是否符合特定模式
* 当需要从一个文件列表中 过滤/排除 出符合特定模式的文件集合

## 安装

:::npm-to

```sh
npm install minimatch
```

:::

## 使用

## 基础用法

```ts
import { minimatch } from 'minimatch'

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
```

## 从文件列表中过滤

`minimatch.filter(pattern)` 返回一个用于测试其输入参数的函数，适合与 `Array.filter` 一起使用

```ts
import { minimatch } from 'minimatch'

const filtered = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
```

---

---
url: /fe-oss/minimist/index.md
---
# minimist
## 概述

**minimist** 是一个轻量级的 Node.js 命令行参数解析库。

它专注于将 `process.argv` 中的原始参数转换为结构化对象，支持短选项（如 `-a`）、长选项（如 `--debug`）、类型自动转换（布尔值、数字）、别名配置等特性。

## 特性

* **灵活的选项解析**

  * **短选项/长选项**：支持 `-a 1` 和 `--option=value` 格式。
  * **无值选项自动转布尔值**：例如 `--debug` 解析为 `{ debug: true }`。
  * **带值选项**：如 `--port 8080` 解析为 `{ port: 8080 }`。

* **类型控制**

  * **`boolean` 选项**：强制参数为布尔类型（如 `{ boolean: ['verbose'] }`），避免歧义。
  * **`string` 选项**：强制参数为字符串（如 `{ string: ['file'] }`），空值转为空字符串 `""`。
  * **数字自动转换**：若值为数字字符串（如 `--port "8080"`），自动转为数字类型。

* **高级配置**

  * **别名（`alias`）**：例如 `{ alias: { h: 'help' } }`，使 `-h` 和 `--help` 等效。
  * **默认值（`default`）**：为未提供参数设置默认值。
  * **特殊符号 `--`**：`--` 后的参数存入 `_` 数组（如 `node app.js -- file1` → `{ _: ['file1'] }`）。

* **轻量高效**
  无外部依赖，代码精简，适合嵌入小型工具或学习源码设计。

## 安装

通过 npm 安装：

::: npm-to

```sh
npm install minimist
```

:::

## 使用

### 基础解析

```ts
const args = minimist(process.argv.slice(2))
console.log(args)
```

运行命令及输出：

```bash
$ node app.js --name=foo -x 1 --verbose
{ _: [], name: 'foo', x: 1, verbose: true }
```

### 类型强制与别名

```ts
const args = minimist(process.argv.slice(2), {
  boolean: ['debug'], // 强制 debug 为布尔值
  string: ['config'], // 强制 config 为字符串
  alias: { d: 'debug' }, // -d 等价于 --debug
  default: { debug: false } // 默认值
})
```

```bash
$ node app.js -d --config=path/to/file
{ _: [], debug: true, config: 'path/to/file', d: true }
```

### 处理歧义场景

当参数可能被误解析为值时，通过 `boolean` 或 `string` 明确类型：

```sh
node app.js -r value
```

* **默认**：`{ r: 'value' }`
* **`{ boolean: ['r'] }`**：`{ r: true, _: ['value'] }`。

## 使用场景

* **CLI 工具开发**
  * 快速解析用户输入，如 Vue CLI 用其校验参数数量：

    ```ts
    if (minimist(process.argv.slice(3))._.length > 1) {
      console.log('提示：仅首个参数被用作应用名称')
    }
    ```

* **自动化脚本**

  * 在 Gulp 等构建工具中处理自定义参数（如 `gulp build --env=prod`）。

* **轻量级配置管理**

  * 替代复杂配置库，适用于一次性脚本或简单应用。

---

---
url: /fe-oss/node-fs/index.md
---
# node:fs
## 概述

对文件进行操作，包括读取、写入、删除、重命名等操作。

`node:fs` 模块从 `v20` ，其表现已足够覆盖大多数文件操作的需求，无需再依赖其他的文件系统模块。

[**node:fs** 官方文档](https://nodejs.org/docs/latest/api/fs.html){.read-more}

## 其它可代替方案

* [fs-extra](https://github.com/jprichardson/node-fs-extra)
* [graceful-fs](https://github.com/isaacs/node-graceful-fs)

## 读取文件

### 同步阻塞读取

```ts
import { readFileSync } from 'node:fs'

const data = readFileSync('path/to/file', 'utf8')
```

### 异步读取

```ts
import { readFile } from 'node:fs/promises'

const data = await readFile('path/to/file', 'utf8')
```

### 读取目录下所有文件

```ts
import { readdir, readFile } from 'node:fs/promises'

// `recursive: true` 递归读取
const files = await readdir('path/to/directory', { recursive: true })

const data = {}
for (const file of files) {
  data[file] = await readFile(file, 'utf8')
}
```

## 写入文件

### 同步阻塞写入

```ts
import { writeFileSync } from 'node:fs'

writeFileSync('path/to/file', 'hello world', 'utf8')
```

### 异步写入

```ts
import { writeFile } from 'node:fs/promises'

await writeFile('path/to/file', 'hello world', 'utf8')
```

### 写入检查

```ts
import { mkdir, writeFile } from 'node:fs/promises'
import path from 'node:path'

// 确保目录存在
// recursive: true 递归创建
await mkdir(path.dirname('path/to/file'), { recursive: true })
await writeFile('path/to/file', 'hello world', 'utf8')
```

## 检查文件是否存在

```ts
import { existsSync } from 'node:fs'

if (existsSync('path/to/file')) {
  // do something
}
```

:::warning 注意
在对文件进行读写时，并不需要使用 `existsSync` 检查文件是否存在，而应该直接读写，通过 `try-catch` 捕获错误。

读写前检查文件是否存在通常被认为是一种 ==反模式=={.danger} 。
:::

## 删除文件

```ts
import { unlink } from 'node:fs/promises'

await unlink('path/to/file')
```

## 删除目录

```ts
import { rm } from 'node:fs/promises'

// `recursive: true` 递归删除
await rm('path/to/directory', { recursive: true })
```

## 复制文件

```ts
import { copyFile } from 'node:fs/promises'

await copyFile('source/file', 'destination/file')
```

## 复制目录

```ts
import { cp } from 'node:fs/promises'

// `recursive: true` 递归复制
await cp('source/directory', 'destination/directory', { recursive: true })
```

---

---
url: /fe-oss/node-glob/index.md
---
# glob
## 概述

[**glob** 官方文档](https://github.com/isaacs/node-glob){.read-more}

使用 shell 的模式来匹配文件。

这是 JavaScript 中最正确且第二快的 glob 实现。

![glob](https://github.com/isaacs/node-glob/raw/main/logo/glob.png)

## 安装

:::npm-to

```sh
npm install glob
```

:::

## 使用

```ts
import { glob, Glob, globStream, globStreamSync, globSync } from 'glob'
```

```ts
// 所有js文件，但不要查看node_modules
const jsfiles = await glob('**/*.js', { ignore: 'node_modules/**' })

// 支持多种模式
const images = await glob(['css/*.{png,jpeg}', 'public/*.{png,jpeg}'])

// 使用同步模式
const imagesAlt = globSync('{css,public}/*.{png,jpeg}')

// 使用流模式
const filesStream = globStream(['**/*.dat', 'logs/**/*.log'])

const g = new Glob('**/foo', {})
// glob 对象是异步迭代器，也可以执行 globIterate() 或
// g.iterate()，效果相同
for await (const file of g) {
  console.log('found a foo file:', file)
}
```

```ts
// 自定义忽略规则可以这样设置，例如通过以下方式：
// 这将忽略所有markdown文件以及名为'docs'的文件夹
const customIgnoreResults = await glob('**', {
  ignore: {
    ignored: p => /\.md$/.test(p.name),
    childrenIgnored: p => p.isNamed('docs'),
  },
})
```

---

---
url: /fe-oss/ofetch/index.md
---
# ofetch
&#x20;&#x20;

## 概述

ofetch 是由 UnJS 团队开发的增强版 Fetch API 库，基于 TypeScript 实现，兼容 Node.js、浏览器和 Web Workers 环境。
它在原生 fetch 的基础上引入了 **智能响应处理**、**错误自动抛出**、**请求拦截** 等特性，同时保留了轻量级（约 4KB）和类型安全的优势。

### 特性

* 智能响应解析：自动处理 JSON、文本、二进制等响应类型，无需手动调用 .json() 等方法
* 全局拦截器：支持 onRequest、onResponse 和 onError 拦截器，用于统一添加请求头、处理错误或日志
* 自动错误处理：非 2xx 响应状态码自动抛出错误，并附带结构化错误信息（如 error.data 和 error.status）
* TypeScript 原生支持：提供完整的类型定义，支持请求/响应类型推断
* 多环境兼容：在 Node.js 中基于 node-fetch-native 实现，浏览器端复用原生 Fetch API

## 安装

::: npm-to

```sh
npm install ofetch
```

:::

## 使用

### 基础示例

```ts
import { ofetch } from 'ofetch'

// 自动解析 JSON 响应
const data = await ofetch('https://api.example.com/users')

// 处理二进制数据（如图片）
const imageBlob = await ofetch('/api/avatar', {
  responseType: 'blob'
})
```

### 全局配置与拦截器

```ts
const customFetch = ofetch.create({
  baseURL: 'https://api.example.com',
  headers: { Authorization: 'Bearer TOKEN' },
  timeout: 5000, // 5 秒超时
  retry: 2, // 自动重试次数
  onRequest({ options }) {
    // 请求前添加逻辑
    options.headers.set('X-Request-Source', 'browser')
  }
})
```

### 错误处理

```ts
try {
  await ofetch('https://api.example.com/invalid')
}
catch (error) {
  console.error(`Status: ${error.status}`) // 输出状态码（如 404）
  console.error(`Data: ${error.data}`) // 输出错误响应体
}
```

## 使用场景

* Nuxt.js 应用：

  ofetch 是 Nuxt 的默认 HTTP 客户端（通过 $fetch）。可通过插件注入全局配置：

  ```ts
  // plugins/fetch.js
  export default defineNuxtPlugin(() => {
    const { apiToken } = useRuntimeConfig().public
    globalThis.$fetch = ofetch.create({
      headers: { Authorization: `Bearer ${apiToken}` }
    })
  })
  ```

* 全栈 JavaScript 项目：

  在 Node.js 后端服务中替代 axios 或 node-fetch，实现前后端请求逻辑统一

* 轻量级前端应用：

  对包体积敏感的项目，ofetch 的轻量化优势明显

---

---
url: /fe-oss/ora/index.md
---
# ora
## 概述

:::center

优雅的终端加载 spinner

![ora spinner](https://github.com/sindresorhus/ora/raw/main/screenshot.svg)
:::

当你的任务需要进行长时间的等待其完成时，给出一个 loading spinner 就很有用了。

## 安装

::: npm-to

```sh
npm install ora
```

:::

## 使用

```ts
import ora from 'ora'

// 创建一个 spinner，注意需要调用 start() 才会显示
const spinner = ora('Loading unicorns').start()

// 可以在任何时候更改 spinner 的状态
setTimeout(() => {
  spinner.color = 'yellow'
  spinner.text = 'Loading rainbows'
}, 1000)

// 当你的长任务完成时
// 如果 成功
spinner.succeed()
// 如果 失败
spinner.fail('fail')
// 中断并输出信息
spinner.info('info')
// 中断并输出警告
spinner.warn('warn')
// 直接中断
spinner.stop()

// 清理 spinner
spinner.clear()
```

::: center
![ora](https://github.com/sindresorhus/ora/raw/main/screenshot-2.gif){style="max-width:320px"}
:::

---

---
url: /fe-oss/path-to-regexp/index.md
---
# path-to-regexp
## 概述

[**path-to-regexp** 官方文档](https://github.com/pillarjs/path-to-regexp){.read-more}

将路径字符串，如 `/user/:name`，转换为正则表达式。

此模块是 `Express` 的基础依赖，可以用于 Node.js 中的路由匹配等场景。

## 安装

::: npm-to

```sh
npm install path-to-regexp
```

:::

## 路径规则

::: warning `v6` 和 `v8`
最新的 `v8` 版本和 旧版本 `v6` 在路径规则上差异较大，废弃了很多参数规则。

此处仅介绍 `v8` 的路径规则
:::

### 参数

在 `/user/:name` 中， `:name` 表示为一个参数，它可以匹配 `/user/mark` 这样的路径。
被匹配的参数可以通过 `params` 获取到，解析为 `{ params: { name: 'mark' } }`

`/:foo/:bar` 表示两个参数，可以匹配 `/foo/bar` 这样的路径，解析为 `{ params: { foo: 'foo', bar: 'bar' } }`

### 通配符

通配符参数可匹配跨多个段的一个或多个字符。其定义方式与常规参数相同，但需以星号（\*foo）作为前缀。

比如 `/*splat` 可以匹配 `/foo/bar` 这样的路径，解析为 `{ params: { splat: ['foo', 'bar'] } }`

通常情况下，通配符参数应该在最后，因为匹配结果的优先级是从左到右的。

### 可选部分

大括号可用于定义路径中可选的部分。

**可选部分不只指参数可选，路径中的任何部分都可以被定义为可选。**

比如 `/user{/:id}/delete` 可以匹配 `/user/delete` 和 `/user/123/delete` 这样的路径:

* `/user/delete` 解析为 `{ params: {} }`
* `/user/123/delete` 解析为 `{ params: { id: '123' } }`

## 使用

```ts
import { compile, match, parse, pathToRegexp, stringify } from 'path-to-regexp'
```

### 路径匹配

```ts
// 创建匹配函数
const matchFn = match('/user/:id')

matchFn('/user/123') // { path: '/user/:id', params: { id: '123' }

matchFn('/u/abc') // 不匹配则返回 false
```

### 路径正则表达式

```ts
const { regexp, keys } = pathToRegexp('/user/:id')

const result = regexp.exec('/user/123') // // ['/user/123', '123']
// 执行正则表达式，匹配参数顺序保存在 keys 中
console.log(keys) // [{ type: 'param', name: 'id' }]
```

### compiler

`compiler(path)` 是反向的 `pathToRegexp`，可以将 路径规则 + 参数 转换为路径字符串

```ts
const toPath = compile('/user/:id')

toPath({ id: 'name' }) // => "/user/name"
```

---

---
url: /fe-oss/pathe/index.md
---
# pathe
## 概述

由于历史原因，Windows系统沿袭了MS-DOS的传统，采用反斜杠作为路径分隔符，而非macOS、Linux等Posix操作系统使用的正斜杠。
如今 Windows 系统已同时支持正斜杠与反斜杠的路径表示。
Node.js 内置的 `path` 模块在默认操作时会根据运行的操作系统采用不同处理方式——当运行于Windows系统时，该模块会默认采用Windows风格的路径处理逻辑，这导致了Windows与POSIX系统间的代码行为差异。

与流行的 [upath](./upath.md) 相比，pathe 在提供与 Node.js 完全兼容的API导出的同时，实现了所有操作结果的路径标准化。该库采用现代ESM/TypeScript 编写，且不依赖 Node.js 运行时环境！

本包可作为 Node.js 原生 `path` 模块的无缝替代方案，始终将路径标准化为正斜杠 `/` 格式，并确保在包括 Node.js 在内的各类环境中稳定运行。

::: tip `pathe` 可直接作为 `node:path` 的直接替代方案
:::

## 安装

::: npm-to

```sh
npm install pathe
```

:::

## 使用

```ts
// ESM / Typescript
import { matchesGlob, resolve } from 'pathe'
```

## API

与 `node:path` API 完全兼容。

[**`node:path` API 文档**](https://nodejs.org/api/path.html){.read-more}

---

---
url: /fe-oss/picocolors/index.md
---
# picocolors
&#x20;

## 概述

`picocolors` 号称是 ==最小最快的 ANSI 终端色彩输出格式化库== 。

它可以帮助我们在控制台中进行日志格式化输出时，对文本进行彩色高亮。

## 安装

::: npm-to

```sh
npm install picocolors
```

:::

## 使用

在项目中导入 `picocolors`

```ts
import pc from 'picocolors'
```

然后使用它:

```ts
console.log(`I see a ${pc.red('red door')} and I want it painted ${pc.black('black')}`)
```

## 文本颜色

`black`, `red`, `green`, `yellow`, `blue`, `magenta`, `cyan`, `white`, `gray`

::: flex center

```ts
console.log(pc.black('black'))
console.log(pc.red('red'))
console.log(pc.green('green'))
console.log(pc.yellow('yellow'))
console.log(pc.blue('blue'))
console.log(pc.magenta('magenta'))
console.log(pc.cyan('cyan'))
console.log(pc.white('white'))
console.log(pc.gray('gray'))
```

![picocolors text colors](./assets/picocolors-1.png){.flex-img style="width:90px"}
:::

`blackBright`, `redBright`, `greenBright`, `yellowBright`, `blueBright`, `magentaBright`, `cyanBright`, `whiteBright`

::: flex center

```ts
console.log(pc.blackBright('black'))
console.log(pc.redBright('red'))
console.log(pc.greenBright('green'))
console.log(pc.yellowBright('yellow'))
console.log(pc.blueBright('blue'))
console.log(pc.magentaBright('magenta'))
console.log(pc.cyanBright('cyan'))
console.log(pc.whiteBright('white'))
```

![picocolors text colors](./assets/picocolors-2.png){.flex-img style="width:90px"}
:::

## 背景颜色

`bgBlack`, `bgRed`, `bgGreen`, `bgYellow`, `bgBlue`, `bgMagenta`, `bgCyan`, `bgWhite`

::: flex center

```ts
console.log(pc.bgBlack('black'))
console.log(pc.bgRed('red'))
console.log(pc.bgGreen('green'))
console.log(pc.bgYellow('yellow'))
console.log(pc.bgBlue('blue'))
console.log(pc.bgMagenta('magenta'))
console.log(pc.bgCyan('cyan'))
console.log(pc.bgWhite('white'))
```

![picocolors bg colors](./assets/picocolors-3.png){.flex-img style="width:90px"}
:::

`bgBlackBright`, `bgRedBright`, `bgGreenBright`, `bgYellowBright`, `bgBlueBright`, `bgMagentaBright`, `bgCyanBright`, `bgWhiteBright`

::: flex center

```ts
console.log(pc.bgBlackBright('black'))
console.log(pc.bgRedBright('red'))
console.log(pc.bgGreenBright('green'))
console.log(pc.bgYellowBright('yellow'))
console.log(pc.bgBlueBright('blue'))
console.log(pc.bgMagentaBright('magenta'))
console.log(pc.bgCyanBright('cyan'))
console.log(pc.bgWhiteBright('white'))
```

![picocolors bg colors](./assets/picocolors-4.png){.flex-img style="width:90px"}
:::

## 文本修饰

`dim`, `bold`, `hidden`, `italic`, `underline`, `strikethrough`, `reset`, `inverse`

::: flex center

```ts
console.log(pc.dim('dim'))
console.log(pc.bold('bold'))
console.log(pc.hidden('hidden'))
console.log(pc.italic('italic'))
console.log(pc.underline('underline'))
console.log(pc.strikethrough('strikethrough'))
console.log(pc.reset('reset'))
console.log(pc.inverse('inverse'))
```

![picocolors bg colors](./assets/picocolors-5.png){.flex-img style="width:110px"}
:::

## 组合使用

::: flex center

```ts
console.log(pc.red(pc.bold('red')))
console.log(pc.bgRed(pc.bold('red')))
console.log(pc.cyan(pc.underline('cyan')))
```

![picocolors bg colors](./assets/picocolors-6.png){.flex-img style="width:110px"}
:::

---

---
url: /fe-oss/picomatch/index.md
---
# picomatch
## 概述

一款基于 JavaScript 编写的极速且精准的全局模式匹配工具。

无第三方依赖，完整支持标准及扩展的Bash通配功能，包括花括号扩展、扩展通配符、POSIX字符集以及正则表达式。

## 场景

* 检查当前文件的路径是否符合特定模式
* 当需要从一个文件列表中 过滤/排除 出符合特定模式的文件集合

## 安装

:::npm-to

```sh
npm install picomatch
```

:::

## 使用

```ts
import pm from 'picomatch'

const isMatch = pm('*.js')

console.log(isMatch('abcd')) // => false
console.log(isMatch('a.js')) // => true
console.log(isMatch('a.md')) // => false
console.log(isMatch('a/b.js')) // => false
```

---

---
url: /fe-oss/pino/index.md
---
# pino
&#x20;

## 概述

非常低开销的 Node.js 日志库。

[**pino** 官方文档](https://getpino.io/#/){.read-more}

## 使用场景

如果你正在进行、或有如下的需求的：

* 正在开发 Node.js 服务，比如 基于 `fastify` / `express` / `koa` 等框架。
* 需要在 Node.js 服务中进行日志记录，对输出格式有要求。
* 需要将日志输出到文件，或者输出到其他的远程日志服务中。
* 对日志输出有非常高的性能要求。
* 需要根据不同的模块区分日志，或者进行不同的日志级别的控制。

## 安装

:::npm-to

```sh
npm install pino
```

:::

## 使用

### 基础使用

```ts
import pino from 'pino'

const logger = pino()

logger.info('Hello, world!')
```

```console title="日志输出"
{"level":30,"time":1720260263252,"pid":76688,"hostname":"username-xxx.local","message":"Hello, world!"}
```

### 子模块日志

```ts
import pino from 'pino'

const logger = pino()

const childLogger = logger.child({ module: 'auth' })

childLogger.info('Hello, world!')
```

```console title="日志输出"
{"level":30,"time":1720260347150,"pid":76859,"hostname":"username-xxx.local","module":"auth","msg":"Hello, world!"}
```

### 输出到文件

```ts
// destination param may be in first position when no options:
const fileLogger = require('pino')(pino.destination('/log/path'))

// use the stderr file handle to log to stderr:
const opts = { name: 'my-logger' }
const stderrLogger = require('pino')(opts, pino.destination(2))

// automatic wrapping in pino.destination
const fileLogger = require('pino')('/log/path')

// Asynchronous logging
const fileLogger = pino(pino.destination({ dest: '/log/path', sync: false }))
```

## 美化输出

::: warning 建议只在开发模式下使用
:::

:::npm-to

```sh
npm install pino-pretty
```

:::

```ts
import pino from 'pino'

const logger = pino({
  transport: {
    target: 'pino-pretty',
    options: {
      colorize: true
    }
  }
})

logger.info('Hello, world!')
```

```console title="日志输出"
[22:33:41.351] INFO (77187): Hello World
```

## 框架集成

### fastify

Fastify 默认集成了Pino日志工具，只需将 Fastify 的 `logger` 选项设为 `true` ，
并通过 `request.log` 或 `reply.log` 记录与每个请求对应的日志信息：

```ts
const fastify = require('fastify')({
  logger: true
})

fastify.get('/', async (request, reply) => {
  request.log.info('something')
  return { hello: 'world' }
})

fastify.listen({ port: 3000 }, (err) => {
  if (err) {
    fastify.log.error(err)
    process.exit(1)
  }
})
```

### express

:::npm-to

```sh
npm install pino-http
```

:::

```ts
const app = require('express')()
const pino = require('pino-http')()

app.use(pino)

app.get('/', (req, res) => {
  req.log.info('something')
  res.send('hello world')
})

app.listen(3000)
```

### koa

:::npm-to

```sh
npm install koa-pino-logger
```

:::

```ts
const Koa = require('koa')
const app = new Koa()
const pino = require('koa-pino-logger')()

app.use(pino)

app.use((ctx) => {
  ctx.log.info('something else')
  ctx.body = 'hello world'
})

app.listen(3000)
```

### h3

:::npm-to

```sh
npm install pino-http
```

:::

```ts
import { createApp, createRouter, eventHandler, fromNodeMiddleware } from 'h3'
import pino from 'pino-http'

export const app = createApp()

const router = createRouter()
app.use(router)
app.use(fromNodeMiddleware(pino()))

app.use(eventHandler((event) => {
  event.node.req.log.info('something')
  return 'hello world'
}))

router.get(
  '/',
  eventHandler((event) => {
    return { path: event.path, message: 'Hello World!' }
  }),
)
```

### Nestjs

:::npm-to

```sh
npm install nestjs-pino
```

:::

```ts
import { Controller, Get, Module } from '@nestjs/common'
import { NestFactory } from '@nestjs/core'
import { Logger, LoggerModule } from 'nestjs-pino'

@Controller()
export class AppController {
  constructor(private readonly logger: Logger) {}

  @Get()
  getHello() {
    this.logger.log('something')
    return `Hello world`
  }
}

@Module({
  controllers: [AppController],
  imports: [LoggerModule.forRoot()]
})
class MyModule {}

async function bootstrap() {
  const app = await NestFactory.create(MyModule)
  await app.listen(3000)
}
bootstrap()
```

---

---
url: /fe-oss/quick-lru/index.md
---
# quick-lru
&#x20;

## 概述

一个轻量级、高性能的 \*\*最近最少使用（LRU）\*\*缓存库，专为 Node.js 和现代浏览器设计。
通过灵活的内存管理和高效的数据淘汰策略，广泛应用于需要优化资源占用的场景。

## 安装

::: npm-to

```sh
npm install quick-lru
```

:::

## 使用

```ts
import QuickLRU from 'quick-lru'

// 初始化缓存（最大100条，条目存活10秒）
const lru = new QuickLRU({ maxSize: 100, maxAge: 10000 })

// 写入数据
lru.set('user1', { name: 'Alice' })

// 读取数据
lru.get('user1') // => { name: 'Alice' }

// 查看数据，不更新访问时间
lru.peek('user1') // => { name: 'Alice' }

// 检查是否存在
lru.has('user1') // => true

// 删除数据
lru.delete('user1')

// 清空缓存
lru.clear()
```

## 适用场景

* 中小型应用，小规模的缓存，需要优化内存占用
* **数据库查询缓存**：减少重复查询，如缓存用户信息2。
* **API 响应缓存**：存储第三方 API 结果，降低调用频率（需注意数据时效性）
* **前端资源缓存**：预加载图片或计算密集型操作结果

---

---
url: /fe-oss/superagent/index.md
---
# superagent
&#x20;

## 概述

Superagent 是一个轻量级、渐进式的JavaScript HTTP客户端库，适用于Node.js和浏览器环境。它由TJ Holowaychuk创建，以链式语法设计为核心，提供灵活、可读性强的API，大幅简化HTTP请求处理流程。

### 特性

* 跨平台支持：在Node.js（基于HTTP模块）和浏览器（基于XMLHttpRequest）中保持一致的API设计
* 轻量与高性能：无冗余依赖，压缩后仅约6KB，支持Promise、async/await和回调函数等多种异步模式
* 插件生态：可通过中间件扩展功能（如缓存控制、请求重试）
* 自动化数据处理：内置对JSON、表单数据、文件上传（multipart/form-data）的序列化与解析，支持自定义内容类型

## 安装

::: npm-to

```sh
npm install superagent
```

:::

## 使用

### 基础示例

GET 请求

```ts
import superagent from 'superagent'

// 链式写法
superagent
  .get('https://api.example.com/data')
  .query({ page: 2, limit: 10 }) // 生成URL: ?page=2&limit=10
  .set('User-Agent', 'MyApp/1.0')
  .then(res => console.log(res.body))
  .catch(err => console.error(err))
```

POST 请求

```ts
superagent
  .post('https://api.example.com/users')
  .send({ name: 'Alice', age: 30 }) // 自动序列化为JSON
  .set('Content-Type', 'application/json')
  .end((err, res) => {
    if (err)
      throw err
    console.log(res.status, res.body)
  })
```

### 表单提交

```ts
superagent
  .post('/login')
  .type('form') // 设置Content-Type为application/x-www-form-urlencoded
  .send({ user: 'admin', password: 'secret' }) // 编码为: user=admin&password=secret
  .then(res => console.log(res.text))
```

### 文件上传

```ts
import fs from 'node:fs'

superagent
  .post('/upload')
  .attach('file', fs.readFileSync('./image.png'), 'image.png')
  .then(res => console.log(res.body))
```

### 流式处理

```ts
const request = superagent.post('/api')
fs.createReadStream('largefile.zip').pipe(request)
```

### 错误处理和超时

```ts
superagent
  .get('/api')
  .timeout(5000) // 5秒超时
  .then((res) => { /* ... */ })
  .catch((err) => {
    if (err.timeout)
      console.error('请求超时')
    else console.error('服务器错误')
  })
```

## 使用场景

* 爬虫开发：

  * 模拟浏览器请求头（如User-Agent、Referer）绕过反爬机制，爬取动态网页内容。
  * 链式查询参数拼接与响应解析（HTML/JSON）简化数据提取

* 前后端API交互

* 微服务通信：服务间轻量级HTTP调用，支持文件流传输降低内存占用

---

---
url: /fe-oss/tiny-glob/index.md
---
# tiny-glob
## 概述

[**tiny-glob** 官方文档](https://github.com/terkelg/tiny-glob){.read-more}

微型且极速的文件与文件夹匹配库，支持使用通配符模式。

**比 [glob](./glob.md) 快约 350%！** **比 [fast-glob](./fast-glob.md) 快约 230%！**

## 安装

:::npm-to

```sh
npm install tiny-glob
```

:::

## 使用

```ts
import glob from 'tiny-glob'

let files = await glob('src/*/*.{js,md}')
```

---

---
url: /fe-oss/tinyglobby/index.md
---
# tinyglobby
## 概述

[**tinyglobby** 官方文档](https://github.com/SuperchupuDev/tinyglobby){.read-more}

一个快速且极简的替代方案，旨在与 `globby` 和 `fast-glob` 保持相同行为。

## 安装

:::npm-to

```sh
npm install tinyglobby
```

:::

## 使用

```ts
import { glob, globSync } from 'tinyglobby'

await glob(['files/*.ts', '!**/*.d.ts'], { cwd: 'src' })
globSync(['src/**/*.ts'], { ignore: ['**/*.d.ts'] })
```

---

---
url: /fe-oss/unconfig/index.md
---
# unconfig
## 概述

\==unconfig== 是一个轻量级、高度灵活的 Node.js 开源工具库，专注于简化配置文件读取的过程。
它由 Vue 和 Vite 核心团队成员 Anthony Fu 开发，旨在解决工具库和框架中多格式配置文件的兼容性问题。

**unconfig 默认支持 `ts`, `mjs`, `js`, `json`**

## 安装

::: npm-to

```sh
npm install unconfig
```

:::

## 使用

```ts
import { loadConfig } from 'unconfig'

const { config, sources } = await loadConfig({
  sources: [
    // const `my.config.xx` 加载
    {
      files: 'my.config',
      // 默认扩展
      extensions: ['ts', 'mts', 'cts', 'js', 'mjs', 'cjs', 'json', ''],
    },
    // 如果在上述配置文件中未找到，则加载`package.json`中的`my`字段
    {
      files: 'package.json',
      extensions: [],
      rewrite(config) {
        return config?.my
      },
    },
    // 从 `vite.config` 加载内联配置
    {
      files: 'vite.config',
      async rewrite(config) {
        const resolved = await (typeof config === 'function' ? config() : config)
        return resolved?.my
      },
    },
    // ...
  ],
  // 如果为false，则仅加载第一个匹配项
  // 如果为true，将加载所有匹配项并进行深度合并
  merge: false,
})
```

---

---
url: /fe-oss/undici/index.md
---
# undici
## 概述

[**undici** 官方文档](https://undici.nodejs.org/){.read-more}

\==undici== 是由 Node.js 官方团队开发的高性能 HTTP/1.1 客户端库。

它旨在解决 Node.js 原生 HTTP 模块的设计瓶颈，通过底层优化实现显著的性能提升，并支持 HTTP/2 和代理等高级特性

::: tip Node.js 自 v18 版本起内置了基于 `undici` 实现的 `fetch()` 功能。
:::

## 安装

::: npm-to

```sh
npm install undici
```

:::

## 使用

### 基础请求

使用 `fetch`:

```ts
import { fetch } from 'undici'

const response = await fetch('http://localhost:3000/api', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ account: 'test', password: '123456' })
})
const data = await response.json()
```

使用 `request`:

```ts
import { request } from 'undici'

const { statusCode, body } = await request('http://localhost:3000/api')
for await (const chunk of body) {
  console.log(chunk.toString()) // 流式处理响应
}
```

### 连接复用

创建持久化客户端实例，提升重复请求效率：

```ts
import { Client } from 'undici'

const client = new Client('http://localhost:3000')
const { body } = await client.request({ path: '/api', method: 'GET' })
body.on('data', console.log) // 事件监听数据流
```

### 代理转发

```ts
import { createServer } from 'node:http'
import { Client } from 'undici'

const client = new Client('http://upstream-server')
createServer((req, res) => {
  client.stream({ path: req.url, opaque: res }, ({ opaque }) => opaque)
}).listen(3010)
```

### 文件下载

```ts
import fs from 'node:fs'
import { stream } from 'undici'

const out = fs.createWriteStream('./image.jpg')
stream('https://example.com/image.jpg', { opaque: out }, ({ opaque }) => opaque)
```

### 全局代理配置

```ts
import { ProxyAgent, setGlobalDispatcher } from 'undici'

// HTTP 代理
setGlobalDispatcher(new ProxyAgent({ uri: 'http://127.0.0.1:7890' }))

// SOCKS5 代理
setGlobalDispatcher(new ProxyAgent({ uri: 'socks5://127.0.0.1:1080' }))

// 此后所有 fetch 请求均通过代理
fetch('https://httpbin.org/ip').then(res => res.json()).then(console.log)
```

### 请求中断

```ts
import AbortController from 'abort-controller'
import { request } from 'undici'

const controller = new AbortController()
request('http://localhost:3000', { signal: controller.signal })
  .catch(err => console.error(err.name)) // 捕获 RequestAbortedError

controller.abort() // 主动中断
```

## 使用场景

* **高性能后端服务**

  * **API 网关/微服务**：高并发下保持低延迟，连接池复用降低资源消耗
  * **实时数据处理**：流式响应支持即时处理大文件或持续数据流（如日志分析）

* **爬虫与数据抓取**

  * **批量请求优化**：管道化（Pipeline）模式显著提升网页抓取效率

* **代理与中间件**

  * **全局代理**：通过 ProxyAgent 统一管理出口流量，无需修改业务代码

* **资源受限环境**

  * **低内存占用**：适合 IoT 设备或嵌入式系统

---

---
url: /fe-oss/upath/index.md
---
# upath
::: warning 该库上次更新为 `2020-11-07`
:::

## 概述

[**upath** 文档](https://github.com/anodynos/upath){.read-more}

一个可无缝替代/代理 Node.js `path` 模块的工具，具备以下特性：

* 将所有字符串参数和返回结果中的Windows反斜杠 `\` 替换为 Unix 斜杠 `/` 。

* 新增文件扩展名处理函数：
  * addExt - 添加扩展名
  * trimExt - 修剪扩展名
  * removeExt - 移除扩展名
  * changeExt - 更改扩展名
  * defaultExt - 设置默认扩展名

* 扩展标准化功能：
  * normalizeSafe - 保留有意义的起始`./`路径标记
  * normalizeTrim - 在normalizeSafe基础上额外去除冗余的末尾`/`

* 提供辅助函数toUnix：简单实现 `\` 到 `/` 的转换并合并重复斜杠

## 安装

::: npm-to

```sh
npm install upath
```

:::

## 使用

```ts
import upath from 'upath'

upath.normalize('path/to/file')
upath.join('path', 'to', 'file')
```

## API

与 `node:path` API 完全兼容。

[**`node:path` API 文档**](https://nodejs.org/api/path.html){.read-more}

---

---
url: /fe-oss/validator/index.md
---
# validator
&#x20;

## 概述

[**validator** 官方文档](https://github.com/validatorjs/validator.js){.read-more}

`validator` 是一个功能强大的 JavaScript 字符串验证库和过滤工具，专为 Node.js 和浏览器环境设计。
它提供了超过 100 种验证器和清理器（sanitizers），用于处理表单数据、API输入等字符串验证场景。

::: important 此库仅验证并清理字符串。
:::

## 安装

::: npm-to

```sh
npm install validator
```

:::

## 使用

```ts
import { isEmail, /* ... */ } from 'validator'
```

### 基础示例

```ts
// 验证邮箱
isEmail('test@example.com') // true

// 清理邮箱格式
normalizeEmail('TEST@GMAIL.COM') // 输出：'test@gmail.com'
```

## 表单验证

```ts
function validateUser(data) {
  const errors = []
  if (isEmpty(data.username))
    errors.push('用户名不能为空')
  if (!isEmail(data.email))
    errors.push('邮箱无效')
  return errors.length ? { errors } : data
}
```

## 使用场景

* **后端验证**：在 Node.js 中校验API请求参数。
* **前端表单**：结合 React/Vue 实时验证用户输入。
* **数据清洗**：过滤用户输入的 XSS 风险字符（如 `escape()`）。
* **自动化测试**：验证数据格式是否符合预期。

---

---
url: /fe-oss/vconsole/index.md
---
# vconsole
&#x20;

## 概述

一个轻量、可拓展、针对手机网页的前端开发者调试面板。

vConsole 是框架无关的，可以在 Vue、React 或其他任何框架中使用。

现在 vConsole 是微信小程序的官方调试工具。

## 场景

在移动端设备中调试网页是一件比较麻烦的事情，因为缺少了浏览器的调试面板，我们很难直观的看到代码执行发生了
什么错误。

vConsole 旨在解决这个问题，它在页面中注入了一个面板，模拟了浏览器的调试面板，让你可以直观的看到网页的执行情况。
比如 元素、网络请求、日志输出等等。

## 安装

::: npm-to

```sh
npm install vconsole
```

:::

## 使用

```ts
import VConsole from 'vconsole'

const vConsole = new VConsole()
// 或者使用配置参数来初始化，详情见文档
const vConsole = new VConsole({ theme: 'dark' })

// 接下来即可照常使用 `console` 等方法
console.log('Hello world')

// 结束调试后，可移除掉
vConsole.destroy()
```

## 从 CDN 加载

```html
<script src="https://unpkg.com/vconsole@latest/dist/vconsole.min.js"></script>
<script>
  // VConsole 默认会挂载到 `window.VConsole` 上
  var vConsole = new window.VConsole();
</script>
```

可用的 CDN：

* <https://unpkg.com/vconsole@latest/dist/vconsole.min.js>
* <https://cdn.jsdelivr.net/npm/vconsole@latest/dist/vconsole.min.js>

## 手机预览

:::center
<http://wechatfe.github.io/vconsole/demo.html>

![qrcode](https://github.com/Tencent/vConsole/raw/dev/doc/screenshot/qrcode.png)
:::

## 效果图

日志输出：

![vconsole 1](https://github.com/Tencent/vConsole/raw/dev/doc/screenshot/overview_light.jpg)

![vconsole 2](https://github.com/Tencent/vConsole/raw/dev/doc/screenshot/plugin_log_types.jpg)

网络请求：

![vconsole 3](https://github.com/Tencent/vConsole/raw/dev/doc/screenshot/plugin_network.jpg)

元素：

![vconsole 4](https://github.com/Tencent/vConsole/raw/dev/doc/screenshot/plugin_element.jpg)

---

---
url: /fe-oss/yargs-parser/index.md
---
# yargs-parser
&#x20;&#x20;

## 概述

\==yargs-parser== 是一个轻量级、高性能的 Node.js 命令行参数解析库，专注于将原始命令行输入（如 `process.argv`）转换为结构化的 JavaScript 对象。作为流行框架 `yargs` 的核心解析引擎，它提供了高度可定制的解析能力，适合直接集成或作为底层工具使用。

## 特性

* **参数结构化解析**

  将命令行输入（如 `--name=foo -abc 100`）解析为键值对对象，支持：

  * **布尔标志**：`-a` 解析为 `{ a: true }`
  * **键值参数**：`--file config.txt` 解析为 `{ file: "config.txt" }`
  * **数组与嵌套对象**：`--file a.txt --file b.txt` 生成数组 `{ file: ["a.txt", "b.txt"] }`；
    `--db.host localhost` 生成嵌套对象 { `db: { host: "localhost" }` }
  * **位置参数**：未标记的参数保存在 `_` 属性中（如 `node app.js run` → `{ _: ["run"] }`）

* **解析配置**

  * **类型自动转换**：启用 `parse-numbers` 后，`--port 8080` 自动转为数字（而非字符串）
  * **别名系统**：`alias: { n: "name" }` 使 `-n foo` 等效于 `--name foo`
  * **默认值**：`default: { env: "dev" }` 确保未提供参数时使用默认值
  * **驼峰转换**：`camel-case-expansion` 配置将 `--my-option` 转为 `myOption`

## 安装

::: npm-to

```sh
npm install yargs-parser
```

:::

## 使用

```ts title="example.js"
import parse from 'yargs-parser'

const argv = parse(process.argv.slice(2))
console.log(argv)
```

```sh
node example.js --foo=33 --bar hello
{ _: [], foo: 33, bar: 'hello' }
```

## 适用场景

* CLI 工具开发

---

---
url: /fe-oss/yargs/index.md
---
&#x20;

## 概述

[**yargs** 官方文档](https://github.com/yargs/yargs){.read-more}

\==yargs== 是 Node.js 生态中广泛使用的命令行参数解析库，专注于简化 CLI 工具的开发。

## 特性

* 参数解析与类型转换

  自动解析命令行参数，支持字符串、数字、布尔值、数组等类型转换。

* 命令与子命令系统

  支持多级嵌套命令（如 `cli serve start`），每个命令可独立配置参数和逻辑。

  ```ts
  yargs.command('serve [port]', '启动服务', (yargs) => {
    yargs.positional('port', { default: 5000 })
  }, (argv) => { /* 业务逻辑 */ })
  ```

* 自动化文档生成

  * 基于参数描述（`describe`）和用法示例（`usage`）自动生成帮助菜单（`--help`）。
  * 支持添加脚注（`epilog`）和示例（`example`）

## 安装

::: npm-to

```sh
npm install yargs
```

:::

## 使用

```ts
#!/usr/bin/env node

import yargs from 'yargs'
import { hideBin } from 'yargs/helpers'
const argv = yargs(hideBin(process.argv)).parse()

if (argv.ships > 3 && argv.distance < 53.5) {
  console.log('Plunder more riffiwobbles!')
}
else {
  console.log('Retreat from the xupptumblers!')
}
```

```sh
$ ./plunder.js --ships=4 --distance=22
Plunder more riffiwobbles!

$ ./plunder.js --ships 12 --distance 98.7
Retreat from the xupptumblers!
```

### 示例

```ts
#!/usr/bin/env node

import yargs from 'yargs'
import { hideBin } from 'yargs/helpers'

yargs(hideBin(process.argv)) // hideBin 是 process.argv.slice(2) 的简写形式
  // 添加命令
  .command('serve [port]', 'start the server', (yargs) => {
    return yargs
      .positional('port', {
        describe: 'port to bind on',
        default: 5000
      })
  }, (argv) => {
    if (argv.verbose)
      console.info(`start server on :${argv.port}`)
    serve(argv.port)
  })
  .option('verbose', {
    alias: 'v',
    type: 'boolean',
    description: 'Run with verbose logging'
  })
  .parse()
```

## 适用场景

* 脚手架工具
* 运维自动化脚本
* 交互式 CLI 工具
* 配置动态注入

---

---
url: /fe-oss/zod/index.md
---
# zod
&#x20;&#x20;

::: important 相比于 `ajv` / `joi` ，更推荐使用 `zod`
:::

## 概述

[**Zod** 官方文档](https://zod.dev){.read-more}

Zod 是一个以 **TypeScript 优先** 的运行时数据验证库，专为 Node.js 和浏览器环境设计。
它通过声明式模式（Schema）实现数据校验，并自动推断静态 TypeScript 类型，解决了类型声明与运行时验证的重复问题。

## 特性

* **TypeScript 优先**

  Zod 的核心优势在于将 **模式定义与类型推断无缝结合**。
  开发者只需定义一次验证规则，即可自动生成对应的 TypeScript 类型，无需手动维护类型声明。

  ```ts
  const UserSchema = z.object({
    username: z.string(),
    age: z.number().min(0)
  })
  type User = z.infer<typeof UserSchema> // 自动推断为 { username: string; age: number }
  ```

* **轻量与零依赖**

  * 核心库体积仅 **8 KB**（gzip 后约 2 KB），无第三方依赖。
  * 支持 Node.js、浏览器（含 IE11）及 Deno 环境

* **不可变性与链式 API**

  Zod 的 API 设计遵循 **函数式编程** 原则，所有方法（如 **.optional()**、**.array()**）均返回新实例，支持链式调用：

  ```ts
  const PasswordSchema = z.string().min(8).max(32).nonempty()
  ```

## 安装

::: npm-to

```sh
npm install zod
```

:::

## 使用

### 基本用法

```ts
import * as z from 'zod/v4'

const User = z.object({
  name: z.string(),
})

// some untrusted data...
const input = { /* stuff */ }

// the parsed result is validated and type safe!
const data = User.parse(input)

// so you can use it with confidence :)
console.log(data.name)
```

### 处理错误

```ts
try {
  Player.parse({ username: 42, xp: '100' })
}
catch (error) {
  if (error instanceof z.ZodError) {
    error.issues
    /* [
      {
        expected: 'string',
        code: 'invalid_type',
        path: [ 'username' ],
        message: 'Invalid input: expected string'
      },
      {
        expected: 'number',
        code: 'invalid_type',
        path: [ 'xp' ],
        message: 'Invalid input: expected number'
      }
    ] */
  }
}
```

```ts
const result = Player.safeParse({ username: 42, xp: '100' })
if (!result.success) {
  result.error // ZodError instance
}
else {
  result.data // { username: string; xp: number }
}
```

### 类型推断

```ts
const Player = z.object({
  username: z.string(),
  xp: z.number()
})

// extract the inferred type
type Player = z.infer<typeof Player>

// use it in your code
const player: Player = { username: 'billie', xp: 100 }
```

```ts
const mySchema = z.string().transform(val => val.length)

type MySchemaIn = z.input<typeof mySchema>
// => string

type MySchemaOut = z.output<typeof mySchema> // equivalent to z.infer<typeof mySchema>
// number
```

## 使用场景

* API 请求验证
* 表单集成
* 配置文件校验

---

---
url: /interview-question/index.md
---
# 面试题解析
### 说明

本笔记主要用于整理、记录，从个人角度尝试回答 可能会遇到的、跟其他人讨论过的 面试题目。

但本笔记 所收集的面试题， 主要是在 前端的范畴中，不涉及其他。

如果你准备找工作，想刷刷面试题，可以 以此作为参考，
但请不要作为标准答案，因为这些仅仅是我收集资料后的个人的理解，
并不一定百分百正确。

::: tip
如果这篇笔记对你有帮助，你有遇到不错的面试题，希望可以在本笔记的评论区提交你遇到的面试题与我分享，我不胜感激！

如果你发现本笔记中有哪些错误，欢迎指出，我将虚心受教！
:::

---

---
url: /interview-question/1416a8f5/index.md
---
# 浅拷贝和深拷贝
::: tip 提问

1. 什么是 浅/深拷贝？
2. 如何实现？

:::

## 浅拷贝

浅拷贝是 创建一个新的对象，这个对象有着原始对象属性值的一份精确拷贝。

如果属性是基本类型，拷贝的就是基本类型的值。

如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。

## 深拷贝

从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响。

## 浅拷贝的实现方式

* `Object.assign()`
* 展开运算符 `...`
* `Array.prototype.concat()`
* `Array.prototype.slice()`
* 第三方库，如 `lodash.clone()`

## 深拷贝的实现方式

* `JSON.parse(JSON.stringify(plainObj)))`:
  该方法仅能处理原始对象的属性不包括 函数和正则的对象。

* 第三方库，如 `lodash.deepClone()`

* 对原始对象进行 递归克隆，根据属性值的数据类型进行递归拷贝。

## 手写深拷贝实现

```js
function checkType(target) {
  return Object.prototype.toString.call(target).slice(8, -1)
}

function deepClone(target) {
  let result
  const type = checkType(target)
  if (type === 'Object') {
    result = {}
  }
  else if (type === 'Array') {
    result = []
  }
  else {
    return target
  }
  for (const key in target) {
    const value = target[key]
    const type = checkType(value)
    if (type === 'Array' || type === 'Object') {
      result[key] = deepClone(value, map)
    }
    else {
      result[key] = value
    }
  }
  return result
}
```

但是上述代码存在以下问题：

* 未解决循环引用问题
* 如果对象的属性是 Symbol 类型， for...in 不会获取到
* 拷贝对象的原型可能发生改变

所以需要进行如下改造：

```js
function deepClone(obj) {
  // 使用 WeakMap<target, result> 数据结构保存对象的引用
  // 使用WeakMap的好处是及时被垃圾回收
  const map = new WeakMap()
  function check(val) {
    return Object.prototype.toString.call(val).slice(8, -1)
  }
  function clone(target) {
    let result
    const type = check(target)
    if (type === 'Object') {
      // 从目标的构造函数上的原型创建一个新的对象
      result = Object.create(target.constructor.prototype)
    }
    else if (type === 'Array') {
      result = []
    }
    else {
      return target
    }
    // 判断是否有循环引用
    if (map.has(target)) {
      return map.get(target)
    }
    else {
      map.set(target, result)
    }
    // 获取目标对象所有的属性，包括 Symbol类型
    ;[...Object.keys(target), ...Object.getOwnPropertySymbols(target)].forEach((key) => {
      const value = target[key]
      const type = check(value)
      if (type === 'Object' || type === 'Array') {
        result[key] = clone(value)
      }
      else {
        result[key] = value
      }
    })
    return result
  }
  return clone(obj)
}
```

---

---
url: /interview-question/1917jrv3/index.md
---
# UDP协议
::: tip 提问

1. UDP

:::

## UDP协议

UDP 是一个无连接，不可靠的床数层协议。它只提供了传输层需要实现的最低限度的功能。
除了复用/分解功能和少量的差错检测外，几乎没有对IP增加其他东西。

UDP协议适用于对实时性要求高的应用场景。

### 特性

* 通信双方没有握手的过程，不需要建立连接，不需要在端系统中保存链接的状态。

* 不保证数据的可靠交付。

* 发送速率没有限制。

  没有拥塞控制和流量控制的机制。

* 支持 一对一，一对多，多对一的交互通信

* 首部只有8个字节

---

---
url: /interview-question/1cx7kiuy/index.md
---
# keep-alive
::: tip 提问
keep-alive 组件有什么作用？
:::

`keep-alive` 组件包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。

主要用于保留组件状态或避免重新渲染。

---

---
url: /interview-question/1ryrldbc/index.md
---
# 组件通信方式
[![vue@2](https://img.shields.io/badge/vue-%402-brightgreen)](https://cn.vuejs.org/)

::: tip 提问
vue2 有多少种组件通信方式？
:::

## 组件通信方式

在 vue中，组件通信的类型，大致可以分为以下几种：

* 父子组件间通信
* 兄弟组件间通信
* 隔代组件间通信

### 1. props/$emit

父组件通过 `props` 将数据传给子组件， 子组件通过 `$emit` 将数据更新通知给父组件。

适用场景：

* 父子组件间通信

### 2. Event Bus

通过 事件总线，通过事件派发将数据更新通知给添加了对应的事件监听的组件。

如，使用一个 空的 Vue实例，通过 `vm.$on` 注册事件监听，通过 `vm.$emit` 触发事件;
或者 自定义实现一个 `EventEmitter`

适用场景：

* 父子组件间通信
* 兄弟组件间通信
* 隔代组件间通信

### 3. provide/inject

通过 在一个祖先组件上 使用 `provide` 为其所有后代组件注入依赖， 在其所有后代组件中，都可以使用 `inject` 来获取到对应的数据。

但 `provide/inject` 的绑定并不是可响应的，可以通过 `Vue.observer` 来优化并提供响应对象

`provide/inject` 需要配合使用。

适用场景：

* 父子组件间通信
* 隔代组件间通信

### 4. $attr / $listener

`$attr` 包含了父作用域中所有不被 props 识别的特性绑定，这些特性可以通过 `v-bind="$attr"` 传入内部组件，
通常配合组件的 `inheritAttrs` 选项一起使用

`$listener` 包含了父作用域中的 `v-on`的事件侦听器（不包含 `.native` 修饰的）。
它可以通过 `v-on="$listener"` 传入内部组件

适用场景：

* 父子组件间通信
* 隔代组件间通信 （多级嵌套的场景）

### 5. $parent / $children / ref

* `ref`: 如果是普通DOM元素上使用，引用指向DOM元素，如果是用在子组件，则引用指向子组件实例
* `parent/$children` 访问父/子 实例

这种方式可以直接拿到 父/子 实例，即可以对 `父/子` 进行任意操作。

（虽然可以用于通信，除非父子组件明确是强耦合的，否则不建议使用)

适用场景：

* 父子组件间通信

### 6. Vuex

Vuex 实现了单向数据流，通过在 全局维护一个 根状态来存放数据。
组件可以通过 `getters` 获取状态数据， 通过 `dispatch` 调用 `action` 触发 `mutation` 更新状态数据。
可以将状态根据某种维度划分为各个模块

适用场景：

* 父子组件间通信
* 兄弟组件间间通信
* 隔代组件间通信

---

---
url: /interview-question/2aywn2ah/index.md
---
# http缓存
请 [查看此文档](/article/c3ez957l/)

---

---
url: /interview-question/2o905emj/index.md
---
# vue2和vue3的区别
::: tip 提问
vue2和vue3的区别
:::

## 区别

* 响应式原理

  vue2 通过 `Object.defineProperties()` 实现数据劫持，结合 发布/订阅模式，将数据变更通知给Watcher，实现响应式。
  vue3 通过 `Proxy` 做数据劫持，实现响应式对象，同时也保留了 `getter/setter` 实现 `ref()`。

* 使用 工厂函数 `createApp()` 代替 构造函数 `new Vue()` 创建应用实例

* 使用 `app.config.globalProperties` 代替 `Vue.prototype` 用于添加全局属性

* 移除了 `Vue.extend`

* `v-model` 使用 `modelValue/emit` 代替了 `value/input` 的实现

* `key` 现在不需要添加在 `v-if` `v-else` `v-else-if` 上，Vue会自己生成，且可以添加在 `<template>` 上。

* `v-if` 的优先级总是高于`v-for` （vue2是反过来的）

* 移除了 `filter` 过滤器

* 自定义指令使用了全新的生命周期

* 移除了 `$children`

* 将 `$listener` 合并到了 `$attrs` 中, `$attrs` 也包含了 `class` 和 `style`

* 使用 `beforeUnmount` 和 `unmounted` 代替 `beforeDestroy` 和 `destroyed`

* 新增了 `setup()` 以及 组合式API

* 新增内置组件 `<Teleport>` 和 `<Suspense>`

---

---
url: /interview-question/2whxs493/index.md
---
# DOCTYPE
::: tip 提问

1. 什么是DOCTYPE？
2. DOCTYPE的作用是什么？
3. 标准模式和兼容模式
4. HTML5 `<!DOCTYPE HTML>`
5. 什么是 DTD？

:::

## 什么是DOCTYPE

`DOCTYPE` 是 文档类型， 用于声明当前文档使用哪种文档模式进行解析和渲染。

## DOCTYPE的作用是什么？

`<!DOCTYPE>` 声明一般位于文档的第一行，它的作用是告知浏览器以哪种模式进行解析文档。
一般指定之后，会使用标准模式进行文档解析，否则就以兼容模式进行解析。

## 标准模式和兼容模式

* 标准模式 是指 浏览器以该浏览器支持的最高标准进行文档解析和渲染，包括JS引擎。
* 兼容模式 是指 文档以宽松的向后兼容的方式渲染，模拟老式浏览器的行为以防止站点无法工作。

## HTML5的DOCTYPE声明

HTML5的 不需要对 DTD 进行引用。但是需要 DOCTYPE 来规范浏览器的行为。
所以HTML的DOCTYPE 声明为

```html
<!doctype html>
```

## 什么是 DTD？

DTD 全称： `Document Type Definition (文档类型定义)`，是一组机器可读的规则。

DTD 定义了 XML 或者 HTML 的特定版本中所有允许元素和它们的属性和层级关系的定义。
解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。

---

---
url: /interview-question/3eodsvo4/index.md
---
# 节流与防抖
::: tip 提问

1. 什么是 节流与防抖？
2. 如何实现 节流与防抖？

:::

## 节流与防抖

* 函数防抖： 在事件被触发的 N秒后再执行回调，如果在这N秒内事件又被触发，则重新计时。

* 函数节流：在一个规定的单位时间内，只能有一次触发事件的回调函数执行，如果在单位时间内事件被触发多次，只有一次生效。

## 实现

### 函数防抖

```js
function debounce(fn, wait) {
  let timer = null
  return function (...args) {
    let ctx = this

    if (timer) {
      clearTimeout(timer)
      timer = null
    }
    timer = setTimeout(() => {
      fn.apply(ctx, args)
    }, wait)
  }
}
```

### 函数节流

```js
function throttle(fn, delay) {
  let preTime = Date.now()
  return function (...args) {
    let ctx = this
    let nowTime = Date.now()
    if (nowTime - preTime >= delay) {
      preTime = Date.now()
      return fn.apply(ctx, args)
    }
  }
}
```

---

---
url: /interview-question/3hdch7z2/index.md
---
# git-hook
::: tip 提问

1. 有用过 git hooks吗？
2. 有哪些 git hooks？
3. 如何在前端项目中使用 git hooks？

:::

## git-hook

git-hook 是 git 提供的，能够在git的某些动作发生时触发的钩子，这些钩子可以通过脚本进行自定义。

默认所有的 hook 都在 当前项目根目录的 `.git/hooks` 目录下。

git 提供了 包括客户端的、服务端的各种钩子。常用的有如下：

* pre-commit 在执行 git commit 前 执行
* commit-msg 在执行 git commit 前 执行，晚于 pre-commit, 可以对 commit msg 进行校验
* pre-merge-commit 在执行 git merge 前执行
* pre-rebase-commit 在执行 git rebase 前执行
* pre-push 在执行 git push 前执行

## 在前端项目中使用

在前端项目中可以 安装 `husky`库，以及 `lint-staged` 库，来进行适合于 前端开发人员配置的 git hook配置。

---

---
url: /interview-question/3y2a3ptn/index.md
---
# v-model
[![vue@3](https://img.shields.io/badge/vue-%403-brightgreen)](https://staging-cn.vuejs.org/)

::: tip 提问
v-model 的原理
:::

## v-model

`v-model` 本质是一个语法糖，可以看成是 input + value 的语法糖。

可以通过 model属性的 prop 和 event 属性来进行自定义。

默认的 `v-model` ，会根据标签的不同生成不同的事件和和属性。

* `input[type="text"]` 和 `textarea` 元素 使用 value 属性 和 input 事件
* `checkbox` 和 `radio` 元素 使用 check 属性 和 change 事件
* `select` 元素 使用 value 属性 和 change 事件

```vue
<script>
export default {
  props: ['modelValue'],
  emits: ['update:modelValue'],
}
</script>

<!-- 等价于 -->
<template>
  <input v-model="value" type="text">
</template>

<template>
  <input type="text" :value="modelValue" @input="$emit('update:modelValue', $event.target.value)" />
</template>
```

---

---
url: /interview-question/45rxs5yv/index.md
---
# v-if和v-for优先级
::: tip 提问

1. vue3 中 `v-if` 和 `v-for` 哪个优先级高？
2. 两个同时使用时，该如何优化？

:::

## 优先级

当 `v-if` 和 `v-for` 同时使用时， `v-if` 的优先级总是 高于 `v-for`。

这是 vue3 和 vue2 的其中一个重要的区别点。

在 vue3 中，最好不要同时使用 `v-if` 和 `v-for`。

## 优化

同时使用时，由于优先级的原因，总是先执行判断，确认条件为 true是，才进行渲染和执行循环。

如果需要对 列表中的每一项做条件判断：

* 在 `v-if` 所在的列表项外部包裹 一个 `<template>`， 在 `template` 上定义 `v-for` 和 `key`
* 提前使用 computed 属性 过滤掉不需要的列表项，避免在模板渲染中不必要的判断和渲染

---

---
url: /interview-question/5l8aw7ss/index.md
---
# 快速排序
::: tip 提问

1. 快速排序
2. 实现

:::

## 快速排序

通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

### 描述

* 从数列中挑出一个元素，称为 “基准”（pivot）；
* 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
* 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

## 实现

```js
function quickSort(arr, left, right) {
  if (!Array.isArray(arr) || arr.length <= 1 || left > right)
    return arr
  const len = arr.length
  left = typeof left === 'number' ? left : 0
  right = typeof right === 'number' ? right : len - 1
  const index = partition(arr, left, right)
  quickSort(arr, left, index - 1)
  quickSort(arr, index + 1, right)
  return arr
}

function partition(arr, left, right) {
  const pivot = arr[left]
  while (left < right) {
    while (arr[right] >= pivot && left < right) {
      right--
    }
    arr[left] = arr[right]
    while (arr[left] < pivot && left < right) {
      left++
    }
    arr[right] = arr[left]
  }
  arr[left] = pivot
  return left
}
```

---

---
url: /interview-question/5q9qyu3q/index.md
---
# 指令
[![vue@3](https://img.shields.io/badge/vue-%403-brightgreen)](https://staging-cn.vuejs.org/)

::: tip 提问

1. 什么是指令？
2. 如何自定义指令？

:::

## 指令

指令是用于 封装对于底层DOM元素的操作。

## 自定义指令

使用 `app.directive` 注册全局指令， 或者 组件实例的 `directives` 注册局部指令。

::: warning 提示
自定义指令的钩子， vue3 和 vue2 是完全不同的。
:::

指令提供了七个钩子函数：

* `created` 在绑定元素的 attribute 前
* `beforeMount` 在元素被插入到 DOM 前调用
* `mounted` 在绑定元素的父组件 及他自己的所有子节点都挂载完成后调用
* `beforeUpdate` 绑定元素的父组件更新前调用
* `updated` 在绑定元素的父组件 及他自己的所有子节点都更新后调用
* `beforeUnmount` 绑定元素的父组件卸载前调用
* `unmounted` 绑定元素的父组件卸载后调用

---

---
url: /interview-question/5vkp8w1l/index.md
---
# 垃圾回收机制
::: tip 提问

1. 简单介绍一下 垃圾回收
2. 介绍一些标记清除法
3. V8引擎的垃圾回收机制

:::

## 垃圾回收

垃圾回收是一种自动内存管理机制。

当计算机上的动态内存不再需要时，就应该予以释放，让出内存。
（程勋是运行在内存里的，当声明一个变量，定义一个函数时，都会占用内存。内存的容量是有限的，对于不再使用的变量、函数等，
应该予以释放。）

垃圾回收方法：

1. 引用计数法 （低版本IE采用的方法）
2. 标记-清除法 （现代浏览器使用的方法）

## 标记清除法

标记清除法会 在 垃圾回收期、定期的从 全局对象window开始，找所有从这个对象开始引用的对象，再找这些对象引用的对象，
对这些活着的对象进行标记，这是标记阶段。

在清除阶段，清除那些没有被标记的对象。

## V8引擎的垃圾回收机制

V8的垃圾回收策略基于分代回收机制，该机制又基于 世代假说。该假说有两个特点：

* 大部分新生代倾向于早死；
* 不死的对象，会活得更久。

基于这个理论，现代垃圾回收算法根据对象的存活时间将内存进行了分代，并对不同分代的内存采用不同的高效算法进行垃圾回收。

* 新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。
* 老生代：对象的存活时间较长。经历过一次或多次垃圾回收的对象。

新生代被分为`From` 和 `To` 两个空间。 `To`一般是闲置的。当`From` 空间满了的时候，就会执行`Scavenge`算法进行
垃圾回收。当执行垃圾回收算法的时候应用逻辑就会停止，等垃圾回收结束后再继续执行。这个算法分为三步：

1. 检查`From` 空间的存活对象，如果对象存活则判断对象对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。
   如果不满足条件则移动`To`空间。
2. 如果对象不存活，则释放对象的空间。
3. 最后将`From`空间和`To`空间校色进行交换。

新生代对象晋升老生代有两个条件：

1. 判断对象是否已经经过一次 `Scavenge`回收。若经历过，则将对象从`From`空间复制到老生代中；
   若没有经历，则复制到 `To`空间；
2. `To`空间的内存使用占比是否超过限制。当对象从`From`空间复制到`To`空间时，若`To`空间使用超过 25%，
   则对象直接晋升到老生代中。设置25%的原因主要是因为算法结束后，两个空间结束后会交换位置，
   如果`To`空间的内存太小，会影响后续的内存分配。

老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉哪些没有标记的对象。
由于标记清除后会造成很多内存碎片，不便于后面的内存分配。所以为了解决内存碎片的问题引入了标记压缩法。

由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，
但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。
为了解决这个问题，V8引入了增量标记的方法，将一次停顿进行的过程分为了多步，
每次执行完一小步就让运行逻辑执行一会，就这样交替运行。

---

---
url: /interview-question/5yfvcq8k/index.md
---
# CSS浮动
::: tip 提问

* 什么是 CSS 浮动？
* 浮动元素会带来哪些影响？
* 如何清除浮动？ 各自的优点？

:::

## 什么是 CSS 浮动（float）

一开始 引入 float 属性是为了让 开发人员实现简单的布局，在一列文本中浮动的图像，文字环绕在它的左边或者右边。

但 开发人员意识到，任何东西都可以浮动，而不仅仅是图像，所以浮动的使用范围扩大了。

在早期，浮动可以用来实现整个网站的页面布局， 因为浮动使得元素可以横向并列。

## 浮动元素带来哪些影响？

* 包裹性，自适应性；

  * 如果浮动元素父元素宽度为300px，浮动元素不声明宽度，浮动元素子元素是一个200px的图片，则此时浮动元素的宽度表现为包裹，
    宽度就是子元素图片的宽度200px；

  * 如果浮动元素子元素还包括大串文本内容，父元素不足以一行放下所有文本内容，则此时浮动元素则自适应父元素的宽度，宽度为父元素宽度。

* 块级化并格式化上下文

  * 当一个元素的float属性值不为node，则其display计算值就是block或者table。
  * 同时，该浮动元素也会产生一个格式化上下文

* 破坏文档

  浮动元素会让其父元素的高度塌陷。在大多数场景下，这个特性会影响到 正常的布局。

* 没有任何margin合并

## 清除浮动

### clear属性

clear 属性的官方解释是： 元素盒子的边不能和前面的浮动元素相邻。

用法：

```
clear: none | left | right | both;
```

使用：

* 在浮动元素后面插入空白块级元素，并声明 clear属性

  ```html
  <style>
    .float {
      float: left;
    }
    .clear {
      clear: both;
    }
  </style>
  <div>
    <div class="float">float</div>
    <div class="clear"></div>
  </div>
  ```

* 使用伪类元素，并声明clear属性

  ```html
  <style>
    .float {
      float: left;
    }
    .clear::after {
      content: '';
      display: block;
      clear: both;
    }
  </style>
  <div class="clear">
    <div class="float">float</div>
  </div>
  ```

### 创建BFC包裹浮动元素

创建BFC的方式比如：

* 浮动元素父元素设置 float 属性
* 浮动元素父元素设置 overflow 属性，且值为 auto、scroll 或 hidden
* 浮动元素父元素设置 position 属性，且值不为 relative或 static
* 浮动元素父元素设置 display 属性，且值为 inline-block、table-cell 或 table-caption

::: tip 说明
float 属性，一开始的设计目的，仅仅是为 文字和图片服务的， 是为了实现文字的环绕效果。
但是由于当年可用的布局手段很少，想要实现复杂的排版，大都依然`<table>`布局，后来发现给元素浮动后，
可以像垒房子一样，把元素变成一块块砖搭建页面，float也被开发人员变成了一种网页布局手段。

在当下，网页可用的布局方式已经越来越丰富，比如 `flex`布局、`Gird`布局等，都比用float属性进行布局要更加强大。
所以在当下，不推荐继续使用 float进行布局。
:::

---

---
url: /interview-question/5z48vy52/index.md
---
# 选择排序
::: tip 提问

1. 选择排序
2. 实现

:::

## 选择排序

选择排序，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

## 实现

```js
function selectSort(arr) {
  if (!Array.isArray(arr) || arr.length <= 1)
    return arr
  const len = arr.length
  for (let i = 0; i < len - 1; i++) {
    let minIndex = i
    for (let j = i + 1; j < len; j++) {
      if (arr[minIndex] > arr[j]) {
        minIndex = j
      }
    }
    ;[arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]
  }
  return arr
}
```

---

---
url: /interview-question/5z5tyxb9/index.md
---
# 浏览器解析过程
::: tip 提问

1. 什么是文档预解析？
2. CSS如何阻塞文档解析
3. 渲染过程遇到 JS文件怎么处理？
4. `<script>` 的 `async` 和 `defer` 属性有什么作用？区别是什么？

:::

## 文档预解析

当执行 Javascript 脚本时，另一个线程会解析剩下的文档，并加载后面需要通过网络加载的资源。
这种方式可以使资源并行加载从而使整体速度更快。

预解析并不改变DOM树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表和图片。

Webkit和Firefox 都做了这个优化。

## CSS如何阻塞文档解析

虽然样式表不改变DOM树，看起来没有必要停下文档的解析等待它们。
但是这里存在一个问题，Javascript 脚本执行时可能在文档的解析过程中请求样式信息，
如果样式还没有加载和解析，脚本将得到错误的值，显然会导致很多问题。

所以如果浏览器尚未完成 CSSOM 的下载和构建，但却在此时运行脚本，那么浏览器将延迟Javascript脚本执行和文档的解析,
直至其完成 CSSOM 的下载和构建。

在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行，最后再继续文档的解析。

## 渲染过程遇到 JS文件

Javascript 的加载、解析和执行会阻塞文档的解析。
在构建 DOM时，HTML解析器若遇到了 Javascript，那么会暂时停止文档的解析，将控制权移交给 Javascript引擎，
等 Javascript引擎运行完毕，浏览器在从中断的地方恢复继续解析文档。

所以为了首屏渲染的速度更快，不应该在首屏就加载JS文档，这也是建议将 script 标签放在 body标签底部的原因。
但在现在，因为 script 标签有了 async 和 defer属性，也不一定需要放在body标签底部了。

## `<script>` 的 `async` 和 `defer` 属性

* `async` 属性 表示 异步执行引入的 javascript 脚本。

  当前 javascript 加载时不会阻塞HTML文档的解析，加载完成后立即执行脚本。
  即加载过程不阻塞HTML文档解析，但是加载完成开始执行仍然会阻塞HTML文档解析。
  多个脚本的执行顺序无法保证。

* `defer` 属性 表示 延迟执行引入的 javascript 脚本。

  当前 javascript 加载时不会阻塞HTML文档的解析，这两个过程是并行的。
  当整个HTML解析完毕后在执行脚本文件。
  并在 DOMContentLoaded事件触发之前完成执行脚本文件，多个脚本按顺序执行。

---

---
url: /interview-question/69vboeiz/index.md
---
# 严格模式
::: tip 提问

1. 什么是严格模式？
2. 严格模式有什么作用？

:::

## 严格模式

严格模式 是 ECMAScript5 添加的 严格运行模式，这种模式使得 javascript 在更严格的条件下运行。

```js
'use strict'
```

### 目的

* 消除 javascript 语法的一些不合理，不严谨之处，减少一些怪异行为；
* 消除代码运行的一些不安全之处，保证代码运行的安全；
* 提高编译效率，增加运行速度；
* 为未来新版本的 javascript做好铺垫。

## 区别

* 禁止使用 with 语句
* 禁止 this 关键字指向全局对象
* 对象不能有重名的属性

---

---
url: /interview-question/6lud0xnd/index.md
---
# watch-watchEffect
::: tip 提问

1. watch 是什么？
2. watchEffect 是什么？
3. watch 和 watchEffect 有什么异同？

:::

## 分析

本题考查对 vue 中 watch 和 watchEffect 的理解，实现原理等。

### 回答策略

1. 两个的定义
2. 使用场景的差异
3. 简述原理

## 回答

1. `watchEffect` 立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。
2. `watch` 侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。
3. `watch` 和 `watchEffect` 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：
   1. `watch` 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。watch 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。
   2. `watchEffect`，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。
   3. 从实现上看，`watchEffect(fn, options)` 相当于 `watch(fn, null, options)`

---

---
url: /interview-question/6pdcf9h0/index.md
---
# http协议
::: tip 提问

1. http协议
2. http 状态码
3. https 协议
4. post和get区别？
5. options请求有什么用？

:::

## http协议

http 是超文本传输协议，定义了客户端和服务器之间交换报文的格式和方式。
http使用TCP作为传输层协议，保证了数据传输的可靠性。
http是一个无状态协议，http服务器不会保存关于客户的任何信息。

http报文有两种：

* 请求报文，包括 请求行和 首部行 和实体主体。请求行包括了请求方法和 URL字段等。
* 响应报文，包括 状态行和首部航和实体主体。 状态行包括了 状态码 和 状态信息 等。

## http 状态码

http 状态吗 是由三个十进制的数字组成，可以分为五类。

* `1**` 信息响应，服务器接受到请求，需要请求者继续执行操作
* `2**` 成功响应，操作被成功接收并处理
* `3**` 重定向，需要进一步的操作以完成请求
* `4**` 客户端错误，请求包含语法错误或无法完成请求
* `5**` 服务器错误，服务器在处理请求的过程中发生了错误

常见的状态码

* `200` 请求成功
* `204` 无内容。请求成功，服务器成功处理，但未返回内容
* `304` 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。
* `400` 客户端请求语法错误，服务器无法理解
* `401` 请求要求用户的身份认证
* `403` 服务器拒绝执行请求
* `404` 服务器无法根据客户端的请求找到资源

## HTTPS 协议

https 是超文本传输安全协议，是基于HTTP协议的，使用 TLS/SSL来对数据加密。

## Post 和 Get 的区别

* 从应用场景上来说，GET请求是一个幂等请求，一般GET请求用于对服务器资源不会产生影响的场景，比如说请求一个网页。
  而POST请求不是一个幂等请求，一般用于对服务器资源会产生影响的请求。比如注册用户等操作。

* 由于不同的应用场景，浏览器一般会对 GET请求缓存，但很少对POST请求缓存

* 从发送的报文格式来说，GET请求的报文实体不为空，POST请求的报文实体部分一般为向服务器发送的数据

* GET 请求的请求参数一般是放入到URL中想服务器发送，POST请求一般是在请求实体中发送数据

## OPTIONS 请求的作用

一般是用于客户端 请求服务端返回该资源所支持的所有HTTP请求方法。

该方法会用 `*` 来代替资源名称，向服务器发送OPTIONS请求，测试服务器功能是否可用。

JS的XMLHttpRequest对象进行 CORS 跨域资源共享时，对复杂请求，会使用OPTIONS方法发送嗅探请求，判断是否有对指定资源的访问权限。

---

---
url: /interview-question/6tzvt9fs/index.md
---
# IFC,GFC,FFC
::: tip 提问

1. IFC
2. GFC
3. FFC

:::

::: details 不用看
很少会在面试中问这几个问题就是了。大多数时候 BFC 才是关注点。
这几个有了解就行，实际情况存在感挺低的...
:::

## IFC

`IFC` 即 `(Inline Formatting Context)` 内联格式上下文。

* 行级上下文内部的盒子会在水平方向，一个接一个地放置。
* 当一行不够的时候会自动切换到下一行。
* 行级上下文的高度由内部最高的内联盒子的高度决定。

## GFC

`GFC` 即 `(GrideLayout Formatting Context)` 网格布局格式上下文

* `display` 属性声明为 `gird` 的元素会获得一个独立的渲染区域。
* 元素内的子元素会以网格的形式进行布局，元素称为 网格容器。

## FFC

`FFC` 即 `(Flex Formatting Context)` 弹性格式上下文

* `display` 属性声明为 `flex` 的元素会获得一个弹性盒子。
* 盒子内的子元素称为项目
* 项目以一条主轴方向进行排列
* 每个项目都可根据规则进行弹性缩放。

---

---
url: /interview-question/6x9ta62c/index.md
---
# 路由
[![vue@2](https://img.shields.io/badge/vue-%403-brightgreen)](https://cn.vuejs.org/)

[![vue-router@3](https://img.shields.io/badge/vue--router-%404-brightgreen)](https://v3.router.vuejs.org/zh/)

::: tip 提问

1. `vue-route@4` 和 `vue-router@3`有什么区别？

:::

## 区别

以下是主要变化：

* 使用 `createRouter()` 代替 `new Router()`

*

* 使用 `history` 配置 代替 `mode` 配置

  使用 `createHashHistory()` 代替 `hash` ，使用 `createWebHistory()` 代替 `history`;
  新增了 `createMemoryHistory()` 用于非浏览器环境（如SSR时）。

* 新增 组合式API

  * `useRouter()` 获取路由实例
  * `useRoute()` 获取当前路由地址
  * `onBeforeRouteUpdate()` 导航守卫，在当前位置即将更新时触发
  * `onBeforeRouteLeave()` 导航守卫，在即将离开当前位置时触发

---

---
url: /interview-question/73zv8wla/index.md
---
# pm2
::: tip 提问

1. 什么是 pm2 ?

:::

## pm2

`pm2` 是 node 进程管理工具，可以用它来管理 node应用和运行持久服务。

`pm2` 提供了很多功能，如 性能监控、自动重启、负载均衡等。

---

---
url: /interview-question/7fmfc0hi/index.md
---
# axios
[axios](https://github.com/axios/axios)

::: tip 提问

1. 简单介绍一下 axios
2. axios拦截器是如何实现的？

:::

## axios

axios 是一个基于 promise 的 HTTP库，可以在浏览器和nodejs中使用。

### 特性

* 从浏览器中创建 XMLHttpRequests
* 从 nodejs 创建 http 请求
* 支持 Promise API
* 拦截请求和响应
* 转换请求数据和响应数据
* 取消请求
* 自动转换JSON数据
* 客户端支持防御 XSRF

## 拦截器实现

axios的拦截器分为 请求体拦截器 和 响应体拦截器，

* 请求体拦截器： 在请求发送前，进行拦截，在拦截的回调中可以对请求体数据进行 同步或异步处理，
  并返回一个处理后的 请求体数据 或者 由 promise 包装的 请求体数据。

* 响应体拦截器： 在请求成功收到响应后，进入响应回调前，进行拦截，在拦截的回调中可以响应体数据进行同步或异步处理，
  并返回一个处理后的响应体数据或者 由 promise 包装的响应期数据

两个拦截器的实现思路是相同的。本质上是定义了一个拦截器队列 `handlers`，当使用 `use()` 方法时，

`use()` 方法接受两个参数： `fulfilled` 和 `rejected` 函数，
参数以 `{ fulfilled, rejected }` 的形式推送到 `handlers` 的尾部。

```js
class Interceptor {
  constructor() {
    this.handlers = []
  }

  use(fulfilled, rejected) {
    this.handlers.push({ fulfilled, rejected })
    return this.handlers.length - 1
  }
}
```

在发起请求前，初始化一个 promise, 并直接返回 请求体数据`requestConfig`,
同时以 请求对象实例，初始化一个 promise 队列 `[dispatchRequest, undefined]`

```js
let promise = Promise.resolve(requestConfig)
// dispatchRequest，即一个 实例化后封装的 XMLHttpRequests，返回一个 promise.resolve(response)
const chain = [dispatchRequest, undefined]
```

然后将 请求拦截器 的 `handlers` 按顺序，以 `fulfilled, rejected` 添加到 `chain` 的头部，
将 响应拦截器 的 `handlers` 按顺序，以 `fulfilled, rejected` 添加到 `chain` 的尾部。

最后将得到 chain 数组，作为参数，循环传入 promise.then 的链式调用中,

```js
while (chain.length) {
  promise = promise.then(chain.shift(), chain.shift())
}
```

即， 拦截器的本质上是在 请求实例的 promise 上，在其前后添加 promise实例，然后依次，将上一个promise的结果
作为参数，传入到下一个promise中。 这也是 拦截器 为什么支持 同步函数和异步函数的原因。

---

---
url: /interview-question/7vkp68sw/index.md
---
# HTML语义化的理解
::: tip 提问
说说你对HTML语义化的理解。
:::

HTML标签语义化是指，使用合适的标签做合适的事情，使文档的内容结构清晰，易于理解。

语义化的好处：

* 有利于开发者的维护和理解；
* 有利于机器对文档内容进行正确的解读；
* 有利于搜索引擎爬虫正确的读取内容，优化SEO；
* 有利于即使样式表丢失，网页仍能维持基本的内容供给用户阅读；

---

---
url: /interview-question/7xxy6of5/index.md
---
# 执行上下文和执行栈
::: tip 提问

1. 什么是执行上下文
2. 什么是执行栈

:::

## 执行上下文

执行上下文就是当前 `JavaScript` 代码被解析和执行时所在环境的抽象概念，
`JavaScript` 中运行任何的代码都是在执行上下文中运行。

### 类型

* 全局执行上下文

  最基础的执行上下文，不在任何函数中的代码都位于全局执行上下中。
  全局执行上下文有两个特性：1. 创建一个全局对象，如 window；2. 将this指向这个全局对象。
  一个程序只能有一个全局上下文。

* 函数执行上下文

  每次调用函数时，都会为该函数创建一个新的执行上下文。
  每个函数都拥有自己的执行上下文，但只有被调用时才会被创建。

* eval函数执行上下文

  运行在eval函数里中的代码有自己的执行上下文

### 生命周期

* 创建阶段

  * 创建变量对象
  * 创建作用域链
  * 确定this指向

* 执行阶段

* 回收阶段

## 执行栈

执行栈指 执行上下文栈（Execute Context Stack）。

执行栈 是一个存储函数调用的栈结构，遵循 先进后出 的规则。

* javascript 执行在单线程中，所有代码都是排队执行
* 执行全局代码时，创建全局执行上下文并压入执行栈的顶部
* 每当进入一个函数的执行就创建一个函数执行上下文，并压入执行栈的顶部，当前函数执行完后，当前函数的执行上下文出栈，等待垃圾回收
* 浏览器的JS引擎总是访问执行栈顶部的执行上下文
* 全局执行上下文总是只有一个，它在浏览器关闭时出栈。

---

---
url: /interview-question/7y6d3oqt/index.md
---
# 事件循环
::: tip 提问

1. 什么是事件循环？
2. 什么是宏任务和微任务？
3. 事件循环的执行步骤？

:::

参阅 [Event Loop 浏览器端的事件循环](/article/browser-event-loop)

## 什么是 Event-Loop ？

Event-Loop 是一个执行模型，在 [html5规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops) 中进行了浏览器端的 Event-Loop 的明确定义。

## 宏任务与微任务

javascript 有两种异步任务，分别是`宏任务`和`微任务`

### 宏任务

宏任务，`macro task`，也叫 `tasks`，一些异步任务的回调会依次进入 `macro task queue`，等待后续被调用。

这些异步任务包括：

* setTimeout
* setInterval
* setImmediate (Node独有)
* requestAnimationFrame (浏览器独有)
* I/O
* UI rendering

### 微任务

微任务， `micro task`, 也叫 `jobs`，另一些异步任务的回调会依次进入`micro task queue`，等待后续被调用。

这些异步任务包括：

* process.nextTick(Node独有)
* Promise
* Object.observe
* MutationObserver

## 事件循环 Event Loop

1. 执行全局 `script` 代码，这些代码有一些是同步语句，有一些是异步语句（如： setTimeout）；
2. 全局`script`同步代码执行完毕后，调用栈Stack会清空；
3. 从微任务`micro task queue` 中取出位于队首的任务，放入调用栈Stack中执行，执行完后`micro task queue`长度减一；
4. 继续取出微任务`micro task queue`位于队首的任务，放入调用栈Stack中执行，
   以此类推，直到把`micro task queue`中的所有任务都执行完毕。**注意，如果在执行micro task的过程中，产生了`micro task`那么会加入到队列的末尾，也会在这个周期被调用执行**；
5. `micro task`中的所有无人都执行完毕，此时 `micro task queue` 为空队列，调用栈Stack也为空；
6. 取出宏队列 `macro task queue` 中位于队首的任务，放入Stack中执行；
7. 执行完毕后，调用栈Stack为空；
8. 重复第3-7个步骤；
9. 以此继续循环重复；

::: important 重点

1. 宏任务`marco task` 一次只从队列中取出一个任务执行，执行后就去执行微任务队列中的任务；
2. 微任务队列中所有的任务都会依次取出来执行，直到`micro task queue`为空，
   且当前微任务执行过程中产生新的`micro task`，也会加入到当前`micro task queue`;
3. `UI Rendering`由浏览器自定判断决定执行节点。但是只要执行`UI Rendering`，它的节点是在执行完所有
   `micro task`之后，下一个`macro task`之前，紧跟着执行`UI Rendering`

:::

---

---
url: /interview-question/87vd50ex/index.md
---
# 浏览器存储
::: tip 提问

1. 浏览器有哪些存储方式？
2. 什么是 cookie ？
3. 什么是 本地存储？
4. 什么是 indexedDB ?
5. 它们之间有什么区别？

:::

## 浏览器存储技术

* cookie
* Web Storage
* IndexedDB

## cookie

cookie 指网站为了辨别用户身份而存储在用户本地终端的数据，通常该数据经过加密。

cookie 是服务端生成的，在客户端进行维护和存储，存储在内存或磁盘中。

cookie 可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态维护。比如维护用户登录态等。

cookie 使基于无状态的HTTP协议记录稳定的状态信息成为了可能。

## Web Storage

Web Storage 提供了存储机制。通过该机制，，浏览器可以安全的存储键值对，比使用cookie更加直观。

Web Storage 提供了两种存储机制：

* sessionStorage: 会话级别的存储。浏览器为每一个给定的源维持了一个独立的存储区域，
  该存储区域在页面会话期间可用。
* localStorage: 跟 sessionStorage同样的功能，但提供了长期存储机制，
  即浏览器关闭后重新打开，数据仍然存在。

## IndexedDB

IndexedDB 用于在客户端存储大量的结构化数据。

IndexedDB 是基于 javascript的面向对象数据库，允许存储和检索用键索引的对象。

特点：

* 键值对存储
* 支持事务
* 异步
* 同源限制
* 存储空间大
* 支持二进制存储

## 区别

| 特性         | cookie                             | localStorage             | sessionStorage   | indexedBD                |
| ------------ | ---------------------------------- | ------------------------ | ---------------- | ------------------------ |
| 数据生命周期 | 一般由服务器生成，可以设置过期时间 | 除非被清理，否则一直存在 | 页面被关闭就清理 | 除非被清理，否则一直存在 |
| 数据存储大小 | 4k                                 | 5M                       | 5M               | 没有限制                 |
| 与服务端通信 | 每次都会携带在headers中            | 不参与                   | 不参与           | 不参与                   |

---

---
url: /interview-question/8dyy8lg6/index.md
---
# HTML5新特性
::: tip 提问

1. HTML5有哪些新特性？
2. 如何处理HTML5新标签的浏览器兼容?
   :::

## 新特性

* 媒介 video和 audio 元素
* 绘画 canvas
* 本地离线存储 localStorage、sessionStorage
* 语义化标签：article,footer,header,nav,section,aside,表单控件等
* Web Worker
* Web Socket

等

## HTML5 新标签的浏览器兼容方案

在 IE 6/7/8 中，支持通过 `document.createElement` 方法产生标签，可以利用这个特性
让这些浏览器支持 hTML5标签，同时还需要为标签添加默认样式。

---

---
url: /interview-question/8hujc044/index.md
---
# jenkins
::: tip 提问
简单介绍一下 jenkins
:::

jenkins 是一个基于java开发的 持续集成工具。提供了大量的插件来支持软件的构建、部署、自动化等。

jenkins 提供了多种方式用于 CI\&CD 。

其中比较常用的是 流水线 pipeline。

pipeline将软件的版本迭代时所需要经历的各个阶段，抽象为一个个 stage， 而每个stag有多个step步骤。
软件变更，通过启动流水线，自动按顺序执行每个stage。

stage 比如，build、test、deploy等。

step 比如 一段shell命令等。

---

---
url: /interview-question/94077huq/index.md
---
# 像素
::: tip 提问
设备像素，css像素， dpr， ppi
:::

* 设备像素： 物理像素。 设备像素决定了设备的分辨率。

* css像素： css像素是相对于设备像素的，当用户为进行缩放操作，那么css像素跟设备像素重叠。
  如果进行了缩放操作，那么 css像素会等比例于设备像素。
  css像素也被称为 设备独立像素。

* dpr：设备像素和设备独立像素的比值。

* ppi: 每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。

---

---
url: /interview-question/9m3js49s/index.md
---
# 数据类型转换
::: tip 提问

1. 显式类型转换 （强制类型转换）
2. 隐式类型转换

:::

## 显示类型转换

### 转换为 String 类型

* `toString` 方法，除了 null、undefined，其他数据类型几乎都有 `toString`方法，
  该方法不转换值本身，而是将返回转换后的结果

* `String()`函数

### 转换为 Number 类型

* `Number()` 函数
* `parseInt` 、`parseFloat()` 函数

### 转换为 Boolean 类型

* `Boolean()` 函数

## 隐式类型转换

* 算术运算符 `- * /` 跟非Number类型进行运算时，会将这些值转换为 Number类型后进行运算
* 运算符 `+`，当 左右两边均非String类型时，会转换为 Number类型进行运算
* 运算符 `+`，当 左右两边有一个或两个String类型时，非String类型会转换为String类型后进行运算
* 条件运算时，空字符串、null、undefined、+0， -0 和 NaN 被转为布尔型 false，其他都是true

---

---
url: /interview-question/9mbb0ngo/index.md
---
# 浏览器渲染过程
::: tip 提问

1. 如果优化关键渲染路径？
2. 渲染页面时常会出现哪些不好的现象？

:::

## 渲染页面常见问题

* 无样式内容闪烁

  由于浏览器的渲染机制，在CSS加载之前，先呈现了HTML，就会导致展示出无样式的内容，然后样式突然呈现的现象。
  这个问题出现的原因是由于CSS加载时间过长，或者CSS被放在了文档的底部。

* 白屏

  有些浏览器渲染机制要先构建DOM树和 CSSOM树，构建完成后在进行渲染，如果CSS部分放在HTML尾部，由于CSS加载未完成，
  浏览器迟迟未渲染，从而导致白屏；也可能是把JS文件放在头部，脚本的加载会阻塞后面文档的内容解析，从而页面迟迟未
  渲染出来，导致了白屏问题。

## 优化关键渲染路径

优化关键渲染路径，首要是尽快完成首次渲染。要达到这个目的，就需要尽快让 文档解析完成并渲染。

所以需要最大限度的减小以下三种可变因素：

1. 关键资源数量
2. 关键路径长度
3. 关键字节数量

* 关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越少，对CPU以及其他资源的占用也越少。
* 关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响，某些资源只能在上一个资源处理完毕后才能开始下载，
  并且资源越大，下载所需要的往返次数就越多。
* 浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。
  要减少字节数，可以减少资源数（将它们删除或者设为非关键资源），此外还需要压缩和优化各项资源，确保最大限度减少
  传输大小。

优化关键路径的常规步骤如下：

* 对关键路径进行分析和特性描述：资源数、字节数、长度。
* 最大限度减少关键资源的数量：删除、延迟下载，标记为异步等。
* 优化关键字节数以缩短下载时间（往返次数）
* 优化其余关键资源的加载顺序。

---

---
url: /interview-question/9zwkibho/index.md
---
# 路由
[![vue@2](https://img.shields.io/badge/vue-%402-brightgreen)](https://cn.vuejs.org/)

[![vue-router@3](https://img.shields.io/badge/vue--router-%403-brightgreen)](https://v3.router.vuejs.org/zh/)

::: tip

1. 路由的历史模式有哪些？有什么不同？
2. 路由的导航守卫
3. 导航守卫的解析流程（执行顺序）

:::

## 历史模式

1. Hash 模式

   使用 URL 的 `hash` 来模拟一个完整的 URL， 当 `hash` 改变时，页面不会重新加载

2. History 模式

   使用 `history.pushState` API 来完成 URL 而无需页面重新加载。

   History 模式需要后端服务器进行配置以提供支持。通过特定的规则，将路径重定向到 一个特定的页面路径。

## 导航守卫

路由的导航守卫 主要是用来 通过跳转和取消的方式守卫导航。

导航守卫 包括：

* `beforeEach`

  全局前置守卫。 在导航被确认之前调用。

* `beforeResolve`

  全局解析守卫。 在导航被确认之前，同时所有组件内守卫和异步路由组件被解析之后 调用。

* `afterEach`

  全局后置钩子. 在导航被确认之后调用。

* 路由独享守卫

  在路由配置上定义 `beforeEnter`。 在进入当前路由之前被调用。

* 组件内守卫

  * `beforeRouteEnter` 渲染该组件的对应路由被 confirm 前调用
  * `beforeRouteUpdate` 当前路由改变，但是该组件被复用时调用
  * `beforeRouteLeave` 导航离开该组件的对应路由时调用

## 导航守卫的解析流程

1. 导航被触发。
2. 在失活的组件里调用 beforeRouteLeave 守卫。
3. 调用全局的 beforeEach 守卫。
4. 在重用的组件里调用 beforeRouteUpdate 守卫。
5. 在路由配置里调用 beforeEnter。
6. 解析异步路由组件。
7. 在被激活的组件里调用 beforeRouteEnter。
8. 调用全局的 beforeResolve 守卫。
9. 导航被确认。
10. 调用全局的 afterEach 钩子。
11. 触发 DOM 更新。
12. 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。

---

---
url: /interview-question/a6txp0c3/index.md
---
# TCP协议
::: tip 提问

1. TCP协议
2. 三次握手

:::

## TCP协议

TCP协议是面向链接的，提供可靠数据传输服务的传输层协议

### 特性

* 在通信前，通信双方需要通过三次握手建立链接，并在端系统中维护双方链接的状态信息
* 通过序号、确认好、定时重传、检验和等机制，提供可靠的数据传输服务
* 点对点服务。提供的是 单个发送方和单个接收方之间的连接
* 全双工服务。连接成功的双方都能够向对方发送和接收数据
* 拥塞控制机制。在网络用色是会控制发送数据的速率，减少数据包丢失概率和减轻网络拥塞程度
* 流量控制机制。保证通信双方的发送和接收速率相同。

### 三次握手过程

1. 第一次握手，客户端向服务端发送一个`SYN`链接请求报文段。
2. 第二次握手，服务端接收到客户端发送的`SYN`链接请求报文段后，会为该连接分配缓存和变量，
   然后向客户端发送 `SYN ACK` 报文段。
3. 第三次握手，客户端接收到服务端的肯定应答后，会为这次TCP连接分配缓存和变量，
   同时向服务器发送一个对服务端的报文段的确认。

::: info 说明
简单来说，

* 第一次握手就是 客户端对服务端说：你好，我是 A。
* 第二次握手就是 服务端对客户端说：你好，我是 B。
* 第三次握手就是 客户端对服务端说：那现在我们认识了。

:::

### 四次挥手过程

1. 第一次挥手，客户端认为没有数据要再发送给服务端，向服务端发送一个 `FIN` 报文段，申请断开客户端到服务端的连接状态。
2. 第二次挥手，服务端收到客户端断开连接的请求后，向客户端发送一个确认报文段，
   表示已经接收到了客户端释放连接的请求，以后不再接收来自客户端的数据。
3. 第三次挥手，服务器发送完所有数据后，向客户端发送 `FIN` 报文段，申请断开服务器到客户端的连接状态。
4. 第四次挥手，客户端收到服务器的 `FIN` 后，像服务器发送一个确认应答，等待一段时间后，确认服务器没有重发请求。
   服务器收到客户端的确认应答。 双方没有重发请求，那么TCP连接就完成了释放。

::: info 说明
简单来说，

* 第一次挥手： 客户端对服务端说：没啥事，我准备撤了
* 第二次挥手： 服务端对客户端说：好的，知道了
* 第三次挥手： 服务端对客户端说：那我也准备撤了
* 第四次挥手： 客户端对服务端说：那一起撤吧

:::

---

---
url: /interview-question/a895fu8f/index.md
---
# promise
::: tip 提问

1. 简单介绍一下 promise
2. 说一下 Promise A+ 规范

:::

参阅 [详解promise](/article/q40nq4hv)

## promise

promise 是一个 异步编程解决方案，提供了一种 链式调用的方法，以一种更为扁平的方式处理复杂异步编程场景。
在早期使用 异步回调函数时，经常容易出现 在异步回调中写异步回调的回调嵌套地域，导致代码拥冗难以阅读。

`Promise`是一个构造函数，用于创建一个新的 Promise 对象，该构造函数主要用于包装还没添加 promise支持的函数。

### 状态

promise创建后，必然出于一下三种状态之一：

* `pending` 待定状态
* `fulfilled` 操作成功
* `rejected` 操作失败

当状态从 `pending` 更新到另外一种状态后，就再也不能变更为其他状态。

### 实例方法

* `.then()` 接受两个函数参数 ，状态从 pending 更新到另一个状态时触发
* `.cache()` 接受一个函数参数，状态从 pending 更新到 rejected 时触发
* `.finally()` 只要状态发生变化，所有 then() 和 catch() 执行完成后，最后执行 finally

### 静态方法

* `resolve(value)` 返回一个 状态为给定的value决定的 promise实例
* `reject(reason)` 返回一个状态为失败的 promise 实例
* `all()` 传入一组promise实例并返回一个新的promise实例，当传入的promises状态均更新为成功时触发
  返回实例的状态更新为成功，否则更新为失败
* `allSettled()` 传入一组promise实例并返回一个新的promise实例，当传入的promises状态均更新到最终状态，
  触发返回实例promise的状态更新
* `race()` 传入一组promise实例并返回一个新的promise实例，只要传入的promises有一个状态更新的熬最终状态，
  触发返回实例promise的状态更新

## Promise A+ 规范

Promise A+ 规范 是 一个开放、健全且通用的 Javascript Promise标准。

规范不设计如何创建、解决和拒绝promise，而是专注于提供一个通用的then方法。

---

---
url: /interview-question/aalt1m8q/index.md
---
# 闭包
::: tip 提问

1. 什么是闭包？
2. 闭包有什么作用？

:::

## 闭包

闭包是指有权访问另一个函数作用域中变量的函数。

创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

闭包的本质就是作用域链的一个特殊应用，只要了解作用域链的创建过程，就能够理解闭包的实现原理。

## 作用

* 闭包可以使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，
  从而在外部访问到函数内部的变量，可以用这种方法来创建私有变量。

* 闭包可以使已经结束运行的函数上下文中的半两对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，
  所以这个变量对象不会被回收。

---

---
url: /interview-question/alfe37yd/index.md
---
# 希尔排序
::: tip 提问

1. 希尔排序
2. 实现

:::

## 希尔排序

把数组按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的元 素越来越多，当增量减至1时，整个数组恰被分成一组，算法便终止。

## 实现

```js
function hillSort(arr) {
  if (!Array.isArray(arr) || arr.length <= 1)
    return arr
  const len = arr.length
  if (!Array.isArray(arr) || len <= 1)
    return
  for (let gap = Number.parseInt(len >> 1); gap >= 1; gap = Number.parseInt(gap >> 1)) {
    for (let i = gap; i < len; i++) {
      let temp = arr[i]
      let j = i

      while (j - gap >= 0 && arr[j - gap] > temp) {
        arr[j] = arr[j - gap]
        j -= gap
      }
      arr[j] = temp
    }
  }
  return arr
}
```

---

---
url: /interview-question/at4kz32a/index.md
---
# 插入排序
::: tip 提问

1. 插入排序
2. 实现

:::

## 插入排序

一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

### 过程

1. 从第一个元素开始，该元素可以认为已经被排序；
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5. 将新元素插入到该位置后；
6. 重复步骤2~5。

## 实现

```js
function insertSort(arr) {
  if (!Array.isArray(arr) || arr.length <= 1)
    return arr
  const len = arr.length
  for (let i = 1; i < len; i++) {
    let tmp = arr[i]
    let j = i
    while (j - 1 >= 0 && arr[j - 1] > tmp) {
      arr[j] = arr[j - 1]
      j--
    }
    arr[j] = tmp
  }
  return arr
}
```

---

---
url: /interview-question/bnjq8wxb/index.md
---
# 外边距合并
::: tip 提问

* 什么是外边距合并？
* 什么情况下会发生外边距合并？

:::

## 外边距合并

块元素的上外边距和下外边距有时候会发生合并，其大小取其中绝对值最大的值，这种行为叫做外边距合并。

## 发生外边距合并的场景

**浮动元素** 和 **绝对定位元素** 的外边距不会发生合并。这是因为触发了 **块格式化上下文** 。

1. 相邻元素之间的外边距会发生合并（如果后一个元素需要清除前面的浮动，则不一定发生合并）。
2. 父元素与其第一个子元素之间不存在边框、内边距、行内内容、没有创建 **块格式化上下文**、没有清除浮动；或者父元素与其最后一个子元素之间不存在边框、内边距、行内内容、heigh、min-height、max-height，那么子元素的外边距会溢出到父元素外面。
3. 如果一个块级元素不包含任何内容，并且在不存在边框、内边距、行内内容、heigh、min-height，则该元素的上下外边距会发生合并。

三种情况的外边距合并是可以组合产生更加复杂的外边距合并情况的。

*如果外边距合并的值都是负值，则合并的值为最小的外边距的值。*

*如果发生外边距合并的值包含负值，则合并后的值为最大的正外边距与最小的负外边距之和。*

---

---
url: /interview-question/bu32tzua/index.md
---
# 元素的分类
::: tip 提问

1. 行内元素和块级元素
2. HTML5元素的分类
3. 空元素的定义

:::

## 行内元素和块级元素

在 HTML4 中，元素被分为两大类， inline（内联元素）和 block（块级元素）

1. 内联元素

   内联元素 只占据它对应的标签的边框所包含的空间。

   常见的内联元素有： `<a>`, `<span>`, `<img>`, `<button>`, `<input>`, `strong`, `<label>`,
   `<select>`, `<textarea>` 等

2. 块级元素

   块级元素占据其父元素（容器）的整个宽度，创建了一个`块`。

   常见的块级元素有： `<div>`, `<ul>`, `<ol>`, `<li>`, `<h1>`, `<h2>`, `<h3>`, `<h4>`, `<h5>`,
   `<h6>`, `<p>` 等

## HTML5元素的分类

由于 CSS 属性 `display` 可以直接声明 元素是 `block` 或 `inline` 或`inline-block` 等，
所以简单的将 元素分类为 内联元素和块级元素已不再符合需求。

在HTML5中，元素主要分为 7 类， 并且每个元素可以归属于一个或多个类型：

* Metadata 元数据元素

  `<base>`, `<link>`, `<link>`, `<meta>`, `<script>`, `<noscript>`, `<style>`, `<title>`

* Flow 流式元素

  `<a>`, `<abbr>`, `<address>`, `<article>`, `<aside>`, `<audio>`, `<br>`, `<button>`,
  `<blockquote>`, `<canvas>`, `<div>`, `<footer>`, `<form>`, `<h1>`, `<h2>`, `<h3>`,
  `<h4>`, `<h5>`,`<h6>`, `<p>` 等

* Sectioning 章节元素

  `<article>`, `<aside>`, `<nav>`, `<section>` 等

* Heading 标题元素

  `<h1>`, `<h2>`, `<h3>`, `<h4>`, `<h5>`,`<h6>`, `<hgroup>`等

* Phrasing 短语元素

  `<abbr>`, `<br>`, `<button>`, `<canvas>`, `<code>`, `<img>`, `<i>`, `<strong>`, `<iframe>`,
  `<input>`, `<small>`, `<select>` 等

* Embedded 嵌入元素

  `<audio>`, `<video>`, `<canvas>`, `<iframe>`, `<img>`, `<embed>`, `<svg>` 等

* Interactive 交互元素

  `<a>`, `<button>`, `<details>`, `<embed>`, `<iframe>`, `<label>`, `<textarea>`, `<select>`

## 空元素的定义

标签内没有内容的 HTML 标签被称为空元素。

空元素是在开始标签中关闭的，也称 自闭合元素。

`<br>`, `<hr>`, `<img>`, `<input>`, `<link>`, `<meta>`

---

---
url: /interview-question/bvx4d2u5/index.md
---
# css三角形原理
::: tip 提问

1. 如何用css画一个 三角形
2. 原理是什么？

:::

## 原理

由于 CSS 对于元素的边框，其相邻的边框的连接处，采用的是均分的处理方式，我们可以利用这个特性，
使用元素的边框，画一个三角形。

* 将元素的display属性设置为 block 或 inline-block；
* 宽高均设置为0；
* 设置border-width为大于 1px 的值，border-style为 solid；
* 设置 border-color， 仅保留一条边的颜色，其他边的颜色为透明

```css
.demo {
  display: block;
  width: 0;
  height: 0;
  border-width: 30px;
  border-style: solid;
  border-color: transparent transparent blue transparent;
}
```

:::: demo title="CSS三角形"
::: code-tabs

@tab HTML

```html
<div class="triangle-demo"></div>
```

@tab CSS

```css
.triangle-demo {
  display: block;
  width: 0;
  height: 0;
  border-width: 30px;
  border-style: solid;
  border-color: transparent transparent cyan transparent;
}
```

:::
::::

---

---
url: /interview-question/bww4boap/index.md
---
# 事件
::: tip 提问

1. 什么是事件？
2. 标准事件模型
3. 什么是事件委托？

:::

## 事件

事件是 在浏览器窗口中被触发并且通常被绑定在窗口内部的特定部分。
可能是一个元素、一系列元素、被加载到这个窗口的HTML代码，或者整个浏览器窗口。

比如：

* 用户对页面进行的操作，如 点击鼠标或悬停光标、按下键盘某个按键、调整浏览器的大小
* 网页停止加载
* 提交表达
* 发生错误

## 标准事件模型

DOM标准事件模型指的是 DOM2事件模型。

在标准事件模型中，一次事件的发生有三个阶段：

1. 事件捕获阶段。事件从window对象自上而下向目标节点传播的阶段；
2. 目标阶段。 真正的目标节点正在处理事件的阶段；
3. 冒泡阶段：事件从目标节点自下而上向window对象传播的阶段。

## 事件委托

事件委托本质上是利用浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，
并且父节点可以通过事件对象获取到目标节点，因此可以吧子节点的监听函数定义在父节点上，
由父节点的监听函数统一处理多个子元素的事件，这种方式称为 事件代理 或者 事件委托。

使用事件委托，就可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。
并且使用事件委托，可以实现事件的动态绑定，比如新增了一个子节点，就不需要单独地为它添加一个监听事件，
节点发生的事件会交给父元素中的监听函数来处理。

---

---
url: /interview-question/chnx193c/index.md
---
# new操作符
::: tip 提问

1. `new` 操作符 具体做了什么？
2. 如果实现 `new`？

:::

## new 操作符

1. 首先创建了一个空对象
2. 设置原型，将对象的原型指向函数的原型
3. 让函数的 `this` 指向这个对象的原型，并执行构造函数的代码
4. 判断函数的返回值类型，如果是值类型，返回创建的对象，如果是引用类型，返回这个引用类型的对象。

## 实现

```js
function newFactory(constructor, ...args) {
  if (typeof constructor !== 'function') {
    throw new TypeError('constructor must be a function')
  }

  const object = Object.create(constructor.prototype)
  const result = constructor.apply(object, args)

  if (result && (typeof result === 'object' || typeof result === 'function')) {
    return result
  }
  else {
    return object
  }
}
```

---

---
url: /interview-question/cipqku16/index.md
---
# 排序算法总结
| 排序方法 | 时间复杂度（平均） | 时间复杂度（最坏） | 时间复杂度 （最好） |  空间复杂度   | 稳定性 |
| :------: | :----------------: | :----------------: | :-----------------: | :-----------: | :----: |
| 冒泡排序 |     *O(n^2^)*      |     *O(n^2^)*      |       *O(n)*        |    *O(1)*     |  稳定  |
| 选择排序 |     *O(n^2^)*      |     *O(n^2^)*      |      *O(n^2^)*      |    *O(1)*     | 不稳定 |
| 插入排序 |     *O(n^2^)*      |     *O(n^2^)*      |       *O(n)*        |    *O(1)*     |  稳定  |
| 希尔排序 |    *O(n^1.3^)*     |     *O(n^2^)*      |       *O(n)*        |    *O(1)*     | 不稳定 |
| 归并排序 |   *O(nlog~2~n)*    |   *O(nlog~2~n)*    |    *O(nlog~2~n)*    |    *O(1)*     |  稳定  |
| 快速排序 |   *O(nlog~2~n)*    |     *O(n^2^)*      |    *O(nlog~2~n)*    | *O(nlog~2~n)* | 不稳定 |

---

---
url: /interview-question/cl8r03ok/index.md
---
# CSP内容安全策略
::: tip 提问
什么是 CSP？
:::

CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。

我们只需要配置规则，如何拦截由浏览器自己来实现。

通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式

```html
<meta http-equiv="Content-Security-Policy" />
```

---

---
url: /interview-question/dmtwgwoc/index.md
---
# 原型和原型链
::: tip 提问

1. 什么是原型
2. 什么是原型链
3. 原型链与继承

:::

## 原型

Javascript 是一种基于原型的语言，同时，javascript只有一种结构：对象。
每个实例对象都有一个私有属性 `__proto__`指向它的构造函数的原型对象`prototype`

## 原型链

原型对象`prototype`也有自己的原型对象`__proto__`，层层向上，直到有一个的原型对象为null。根据定义，null没有原型，并作为这个原型链的最后一个环节。

## 原型链与继承

`javascript` 对象是动态的属性"包裹"（指自身的属性）。同时，对象还有一个指向一个原型对象的链。
当访问一个对象的属性时，不仅会在该对象上查找，也会在该对象的原型上查找，进而在该对象的原型的原型上查找，
依次层层向上查找，直到找到匹配的属性，或者到达原型链的末尾。

当继承的函数被调用时，`this`指向的是当前继承的对象，而不是继承的函数所在的原型对象。

## 获取原型的方法

* `someObj.__proto__`
* `someObj.constructor.prototype`
* `Object.getPrototypeOf(someObj)`

---

---
url: /interview-question/dr6sis13/index.md
---
# 浏览器内核
::: tip 提问

1. 说说你对浏览器内核的理解。
2. 常见的浏览器内核有哪些？
3. 浏览器内核的比较。

:::

## 浏览器内核

浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分的，一是渲染引擎，另一个是JS引擎。

* 渲染引擎 的职责是渲染，即在浏览器窗口中显示所请求的内容。
* JS引擎：解析和执行 javascript 来实现网页的动态效果。

早期时候渲染引擎和JS引擎并没有明确的区分，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。

## 常见的浏览器内核

| 内核           | 浏览器        | 描述                                                                |
| -------------- | ------------- | ------------------------------------------------------------------- |
| Trident        | IE            | IE浏览器内核                                                        |
| Chromium/Blink | Chrome、Opera | Chrome浏览器内核，以前是 WebKit内核，现在是 Blink内核（Webkit分支） |
| Gecko          | Firefox       | Firefox 浏览器的内核                                                |
| Webkit         | Safari、Opera | Webkit内核                                                          |
| Presto         | Opera         | Opera浏览器使用过的内核，但Opera已转向 Webkit/Blink                 |

## 浏览器内核比较

* Trident内核： IE系列浏览器所用的内核，但由于微软长期没有更新 Trident内核，导致与W3C标准脱节，且存在大量bug等
  安全问题没有解决，导致很多用户转向其他浏览器。

* Gecko内核：Firefox使用的内核，优点是功能强大、丰富，可以支持很多复杂的网页效果和浏览器扩展接口，
  但是代价是需要消耗很多资源，比如内存资源等。

* Presto内核：Opera曾经采用的内核，被称为公认的浏览网页速度最快的内核。但缺点是为了达到很快的速度，
  而丢掉了一部分网页兼容性。

* WebKit内核：Safari采用的内核，优点是网页浏览速度较快，虽然不及Presto，但快于 Trident和Gecko，
  缺点是对网页代码的容错性不高，也就是对网页代码的兼容性较低。

* Blink内核：Chrome采用的内核，是从 Webkit上独立出来的分支，由谷歌和Opera共同研发。

---

---
url: /interview-question/dyfx0oo9/index.md
---
# 函数柯里化
## 函数柯里化

函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。

函数柯里化的目的是参数复用。本质上是降低通用性，提高适用性。

实现：

```js
function curry(fn, ...args) {
  return fn.length < args.length ? fn(...args) : curry.bind(null, fn, ...args)
}
```

---

---
url: /interview-question/e2tpl1sq/index.md
---
# webpack
::: tip 提问

1. 对webpack的了解
2. webpack的工作原理
3. loader和plugin？ 有什么区别？
4. 做过哪些webpack优化？

:::

::: info 说明
一般来说， 面试中问及的webpack相关知识，如果是面向招写业务代码的，
能了解个webpack的原理和能做什么，就差不多够了。如果是面向招做基础设施的，
那么还需要了解 loader、 plugin等相关内容，以及如何写一个 loader/plugin，
还有就是如何做webpack优化这些，但做招基础设施又不仅仅只考擦webpack，更多还是对构建工具的整体理解。
:::

## webpack

webpack是一个用于 现代javascript应用程序的静态模块打包工具。

## 工作原理

1. 读取 `webpack` 的配置参数；
2. 启动 `webpack` , 创建 `compiler` 对象，开始解析项目；
3. 从入口文件 `entry` 开始解析，并找到其导入的**依赖模块**，递归遍历分析，形成**依赖关系树**；
4. 对不同的文件类型资源的依赖模块文件，使用对应的 `Loader` 进行转换，最终转为 webpack的有效模块；
5. 在编译过程中， `webpack` 通过 发布订阅模式，向外抛出一些 `hooks` ，`webpack` 的 `Plugin` 通过监听各个 `hooks` ，
   执行插件任务，扩展 `webpack` 的功能，干预输出结果。
6. 根据 输出配置 `output` ，将打包构建好的资源文件 输出。

## loader

将其他类型的资源文件转换为 webpack能够处理的有效模块。

## plugin

plugin是webpack的核心功能，其目的是在于解决loader无法解决的其他事上。

plugin可以在webpack访问到webpack的整个生命周期，并且可以访问到compile对象，以及当前编译过程对象 compilation, 这使得plugin拥有非常强大的能力。

## loader和plugin的区别

loader仅能对其关联的模块类型进行解析转换，不能访问到webpack的整个生命周期

plugin是对webpack的扩展，可以访问到webpack整个生命周期。

## webpack 优化

以下内容是针对 webpack@5 的优化方向建议：

### 构建流程分析

在进行优化前，首先要搞清楚有哪些地方出现了痛点，需要进行优化。

* 编译速度分析

  借助 `speed-measure-webpack-plugin` 插件，可以帮助我们获取插件、loader的耗时。
  消耗时间比较长的，认为可以优化的，则放到优化计划中。

* 打包体积分析

  借助 `webpack-bundle-analyzer` 插件，可以帮助我们获取打包后生成的bundle的体积中，各个模块的位置、体积等信息。

### 编译速度优化

1. 配置缓存方案。

   在webpack的配置文件中 声明 配置： `{ cache: { type: 'filesystem } }`,来启用对模块和chunk的持久缓存。
   可以大幅度优化 二次启动构建速度、打包速度等。

2. 对使用的 loader，根据其作用，指定 include 或者 exclude，减少 loader的应用范围。

3. 管理资源

   使用 webpack5 内置的 `asset/resource` 代替 `assets loader`(如， url-loader、file-loader、raw-loader)。

4. 多进程打包编译

   使用 `thread-loader`将耗时长的loader进行包装，放到其他的线程中进行处理。

### 打包体积优化

重复多次出现的模块，可以抽到共享chunk中，非首屏加载必须的模块，可以抽到异步chunk中。

（还有对各种资源进行压缩等）

---

---
url: /interview-question/e3adhfty/index.md
---
# nextTick
::: tip 提问

1. nextTick 是什么？
2. nextTick 的实现原理？
3. nextTick 的作用？

:::

## 分析

此题考查 对 `vue` 异步更新队列的理解。

## 回答

> **官方定义：**
>
> 当你在 Vue 中更改响应式状态时，最终的 DOM 更新并不是同步生效的，而是由 Vue 将它们缓存在一个队列中，直到下一个“tick”才一起执行。这样是为了确保每个组件无论发生多少状态改变，都仅执行一次更新。
>
> nextTick() 可以在状态改变后立即使用，以等待 DOM 更新完成。你可以传递一个回调函数作为参数，或者 await 返回的 Promise。

1. nextTick是Vue提供的一个全局API，由于vue的异步更新策略导致我们对数据的修改不会立刻体现在dom变化上，此时如果想要立即获取更新后的dom状态，就需要使用这个方法。

2. 当你在 Vue 中更改响应式状态时，最终的 DOM 更新并不是同步生效的，而是由 Vue 将它们缓存在一个队列中，
   直到下一个“tick”才一起执行。这样是为了确保每个组件无论发生多少状态改变，都仅执行一次更新。
   本质上， nextTick 会被添加到 队列的最后再执行，而如果队列为空，则 nextTick 就是一个 普通的 promise 。

3. 当需要在数据发生变更后，立即获取更新后的dom状态、修改dom时，可以使用 nextTick() 方法。

---

---
url: /interview-question/e78132ku/index.md
---
# 冒泡排序
::: tip 提问

1. 冒泡排序
2. 实现

:::

## 冒泡排序

冒泡排序是指， 对相邻的元素进行两两比较，顺序相反则进行交换。 这样每次都会将最小或者最大的元素 "浮" 到顶端，最终达到完全有序。

冒泡排序的平均时间复杂度为 O(n²) ，最坏时间复杂度为 O(n²) ，空间复杂度为 O(1) ，是稳定排序。

### 优化

* 外层循环优化，记录当前循环中是否发生了交换，如果没有发生交换，则说明该序列已经为有序序列了。 因此我们不需要再执行之后的外层循环，此时可以直接结束。
* 内层循环的优化，记录当前循环中最后一次元素交换的位置，该位置以后的序列都是已排好的序列，因此下 一轮循环中无需再去比较。

优化后的冒泡排序，当排序序列为已排序序列时，为最好的时间复杂度为 O(n)。

## 实现

```js
function bubbleSort(arr) {
  if (!Array.isArray(arr) || arr.length <= 1)
    return arr
  let lastIndex = arr.length - 1
  while (lastIndex > 0) {
    let flag = true
    const k = lastIndex
    for (let j = 0; j < k; j++) {
      if (arr[j] > arr[j + 1]) {
        flag = false
        lastIndex = j
        ;[arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
      }
    }
    if (flag)
      break
  }
  return arr
}
```

---

---
url: /interview-question/eftuz9uz/index.md
---
# SQL注入攻击
::: tip 提问

1. 什么是SQL注入攻击

:::

SQL 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 SQL 代码，
服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构造，
破坏原有 SQL 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。

---

---
url: /interview-question/enq4k5mb/index.md
---
# 设计模式
::: tip 提问

1. javascript 有哪些常用的设计模式？
2. 简单说一下你知道的设计模式

:::

## 常用的设计模式如

* 单例模式
* 工厂模式
* 策略模式
* 代理模式
* 中介者模式
* 装饰者模式
* 观察者模式

## 单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

实现方法是，先判断实例是否存在，如果不存在就创建后返回，如果存在就直接返回。

## 工厂模式

工厂模式是一种创建型的模式，主要是 提供一个通用的接口来创建对象。

适用于 当对象或组件设置涉及搞复杂性，或者需要根据所在的不同环境生层对象的不同实例，
或者处理很多共享相同属性的小型对象或组件 等场景。

## 策略模式

将方法的实现和方法的调用分离开来，其中方法的实现是可互相替换的，可以通过相同的方式进行调用。

## 代理模式

为一个对象提供一个代用品或占位符，以便控制对它的访问。

比如说常见的事件代理。

## 中介者模式

多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。

## 装饰者模式

在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法。

适用于：
原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求；
函数的解耦，将函数拆分成多个可复用的函数，再将拆分出来的函数挂载到某个函数上，实现相同的效果但增强了复用性。

## 观察者模式

一个被称作被观察者的对象，维护一组被称为观察者的对象，这些对象依赖于被观察者，被观察者自动将自身的状态的任何变化通知给观察者。

当一个被观察者需要将一些变化通知给观察者的时候，它将采用广播的方式，这条广播可能包含特定于这条通知的一些数据。

当特定的观察者不再需要接受来自于它所注册的被观察者的通知的时候，被观察者可以将其从所维护的组中删除。

---

---
url: /interview-question/f4snyn2e/index.md
---
# 重绘与回流
::: tip 提问

1. 什么是重绘和回流
2. 哪些属性会引起重绘和回流
3. 如何减少回流

:::

## 重绘和回流

* 重绘

  当渲染树中的一些元素需要更新属性，而这些属性只影响元素的外观、风格，而不会影响布局的操作，称之为重绘

* 回流

  当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，
  称之为回流。

回流必定会发生重绘，重绘不一定会引起回流。

回流所需的成本比重绘高得多，改变父节点里的子节点可能会导致父节点的一系列回流。

### 常见引起重绘的属性

`border-styl` , `border-radius` , `border-color` , `color`,
, `background` , `background-image` , `background-position` , `background-repeat` ,
, `visibility` , `outline` , `box-shadow`, `text-decoration` 等

### 常见引起回流的方式

* 页面首次渲染

* 浏览器窗口大小发生改变

* 元素尺寸或位置发生改变

* 元素内容发生变化

* 元素字体大小变化

* 添加或删除可见的DOM元素

* 激活 CSS 伪类

* 查询某些属性或者调用某些方法

* `width`, `height`, `margin`, `padding`, `display`, `border`, `position`, `overflow`,

* `clientWidth`, `clientHeight`, `clientTop`, `clientLeft`,

* `offsetWidth`, `offsetHeight`,`offsetLeft`, `offsetTop`,

* `scrollWidth`, `scrollHeight`, `scrollTop`, `scrollLeft`,

* `scrollIntoView()`, `scrollIntoViewIfNeeded()`,

* `getComputedStyle()`

* `getBoundingClientRect()`

* `scrollTo()`

## 减少回流的方式

* 避免使用 table 布局，因为可能一个很小的改变，都会造成整个 table 的重新布局
* 避免一条一条的修改DOM样式，可以采用预定义的css的class，或者将所有修改都保存起来，再一次性修改
* 避免设置多层内联样式
* 避免频繁的操作DOM
* 避免频繁读取会引发回流的属性
* 对具有复杂动画的元素，将其脱离文档流

---

---
url: /interview-question/f6unprhu/index.md
---
# 点击劫持
::: tip 提问

1. 什么是点击劫持？
2. 如何防护？

:::

## 点击劫持

点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。

## 防护

我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特
定的一些情况才能作为 iframe 来使用。

---

---
url: /interview-question/ffvuo8ul/index.md
---
# 生命周期
[![vue@3](https://img.shields.io/badge/vue-%403-brightgreen)](https://staging-cn.vuejs.org/)

::: tip 提问
简述一下 vue3 的组件生命周期
:::

## 生命周期

### 选项式

1. `beforeCreate` 在组件实例初始化完成之后立即调用。
2. `created` 在组件实例处理完所有与状态相关的选项后调用。
3. `beforeMount` 在组件被挂载之前调用。
4. `mounted` 在组件被挂载之后调用。
5. `beforeUpdate` 在组件即将因为一个响应式状态变更而更新其 DOM 树之前调用。
6. `updated` 在组件即将因为一个响应式状态变更而更新其 DOM 树之后调用。
7. `beforeUnmount` 在一个组件实例被卸载之前调用。
8. `unmounted` 在一个组件实例被卸载之后调用。
9. `errorCaptured` 在捕获了后代组件传递的错误时调用。

### 组合式

1. `onMounted()` 注册一个在组件挂载完成后执行的回调函数。
2. `onUpdated()` 注册一个回调函数，在组件由于响应性状态改变而更新了 DOM 树后调用。
3. `onUnmounted()` 注册一个要在组件卸载后调用的回调。
4. `onBeforeMount()` 注册一个钩子在组件被挂载之前被调用。
5. `onBeforeUpdate()` 注册一个钩子，在组件因为响应式状态改变而要更新 DOM 树之前调用
6. `onBeforeUnmount()` 注册一个钩子，在组件实例被卸载之前调用。
7. `onErrorCaptured()` 注册一个钩子，当从下级组件抛上来的错误被捕获时被调用。

---

---
url: /interview-question/fq0fou9z/index.md
---
# 模块加载器原理
::: tip 提问

1. AMD 模块加载器原理？
2. CMD 模块加载器原理？
3. CommonJS 模块加载器原理？

:::

::: tip 说明
虽然各个规范有所差异，但其最基本的一些原理原则还是相似的，
这里主要讲 AMD规范的模块加载器的原理，其他规范的差异部分再补充说明。
:::

1. **模块ID**, ID即路径原则。

2. **脚本加载**， 使用 `createElement('script') && appendChild` 请求加载模块。

   一般需要给 script设置一个属性用于标识模块ID。

3. **document.currentScript**，通过该属性获取当前模块的基本信息

文件的路径等信息，对于匿名模块非常有用。

4. 依赖分析

   模块被define后并不是马上可用了，在执行factory方法生产的 export 之前，需要保证它的依赖是可用的，
   需要先把依赖分析出来。

5. 递归加载

分析出模块依赖后，需要递归加载依赖模块。

在 CommonJs规范的nodeJS实现中，一个简化的实现例子如下：

```js
function require(path) {
  if (require.cache[path]) {
    return require.cache[path].exports
  }
  let src = fs.readFileSync(path)
  let code = new Function('exports, module', src)
  let module = { exports: {} }
  code(module.exports, module)
  require.cache[path] = module
  return module.exports
}
require.cache = Object.create(null)
```

---

---
url: /interview-question/gojlegqf/index.md
---
# 写一个通用事件侦听器
::: tip 提问
写一个通用事件侦听器
:::

一个通用事件侦听器 需要考虑到 浏览器的兼容问题，
在旧浏览器、IE浏览器、现代浏览器中，事件侦听的绑定和移除均有所差别，而且 event 也有差别。

```js
const DomEvent = {
  add(el, type, handler) {
    if (el.addEventListener) {
      el.addEventListener(type, handle, false)
    }
    else if (el.attachEvent) {
      el.attachEvent(`on${type}`, handler)
    }
    else {
      el[`on${type}`] = handler
    }
  },
  remove(el, type, handler) {
    if (el.removeEventListener) {
      el.removeEventListener(type, handler, false)
    }
    else if (el.detachEvent) {
      el.detachEvent(`on${type}`, handler)
    }
    else {
      el[`on${type}`] = null
    }
  },
  getTarget(event) {
    return event.target || event.srcElement
  },
  getEvent(event) {
    return event || window.event
  },
  stopPropagation(event) {
    if (event.stopPropagation) {
      event.stopPropagation()
    }
    else {
      event.cancelBubble = true
    }
  },
  preventDefault(event) {
    if (event.preventDefault) {
      event.preventDefault()
    }
    else {
      event.returnValue = false
    }
  }
}
```

---

---
url: /interview-question/h4casm3q/index.md
---
# 归并排序
::: tip 提问

1. 归并排序
2. 实现

:::

## 归并排序

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。

### 描述

* 把长度为n的输入序列分成两个长度为n/2的子序列；
* 对这两个子序列分别采用归并排序；
* 将两个排序好的子序列合并成一个最终的排序序列。

## 实现

```js
function mergeSort(arr) {
  if (!Array.isArray(arr) || arr.length <= 1)
    return arr
  const len = arr.length
  const middle = Number.parseInt(len >> 1)
  const left = arr.slice(0, middle)
  const right = arr.slice(middle, len)
  return merge(mergeSort(left), mergeSort(right))
}

function merge(left, right) {
  const result = []
  const leftLen = left.length
  const rightLen = right.length
  let il = 0
  let ir = 0

  while (il < leftLen && ir < rightLen) {
    if (left[il] < right[ir]) {
      result.push(left[il++])
    }
    else {
      result.push(right[ir++])
    }
  }

  while (il < leftLen) {
    result.push(left[il++])
  }

  while (ir < rightLen) {
    result.push(right[ir++])
  }
  return result
}
```

---

---
url: /interview-question/jdk3bh3a/index.md
---
# 函数与箭头函数
::: tip 提问

1. 箭头函数相比函数有什么区别？

:::

1. 箭头函数总是匿名的
2. 绑定this

   在箭头函数出现之前，每个新函数都重新定义了自己的 `this` 值，在ES6之前，通过把this的值赋值给一个变量来保存

   ```js
   function demo() {
     let that = this
     that.count = 0
     // eslint-disable-next-line prefer-arrow-callback
     setTimeout(function () {
       that.count++
       console.log(that.count)
     }, 0)
   }
   ```

   箭头函数可以捕捉闭包上下文的`this`值，所以可以改写成：

   ```js
   function demo() {
     this.count = 0
     setTimeout(() => {
       this.count++
       console.log(this.count)
     })
   }
   ```

---

---
url: /interview-question/jilzuxpt/index.md
---
# NaN
::: tip 提问

1. typeof NaN的结果是什么？
2. isNaN() 和 Number.isNaN() 有什么区别？

:::

## typeof NaN

`NaN` 表示不是一个数字 （not a number），NaN 是一个警戒值，用于指出数字类型中的错误情况，
即 执行数字预算没有成功，这是失败后返回的结果。

```js
typeof Number.NaN // "number"
```

NaN 作为一个特殊值， 它和自身是不相等的，是唯一个非自反的值，即

```js
// eslint-disable-next-line no-self-compare, use-isnan
Number.NaN === Number.NaN // false
```

## isNaN() 和 Number.isNaN()

`isNaN()` 接受参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的值都会返回true，因此非数字值传入也会
返回 true，影响 NaN 的判断。

`Number.isNaN()` 会首先判断传入的参数是否为数字，如果是数字再继续判断是否为 NaN, 这种方法对NaN的判断更为准确。

---

---
url: /interview-question/jzx0jvhn/index.md
---
# 前端性能优化
::: tip 提问
如何做前端性能优化？
:::

前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。

为了能够提高页面的加载速度，就需要从资源的数量、大小、加载方式、加载时间等方面去优化，包括：

* 资源压缩与合并

  对HTML、CSS、JS进行压缩和文件合并； 对图片进行压缩、使用雪碧图等；

  资源压缩后可以减少资源的大小，从而提高加载速度；

  而对文件进行合并，可以减少网站http请求的次数，让更多的资源能够并发完成加载。

* 对非核心代码使用异步加载。

  对于首屏渲染不需要使用到的代码，使用异步加载的方式，等待首屏渲染完成后，再进行加载。
  可以使用 defer、 async 属性，或者动态脚本的方式进行脚本的异步加载。

* 避免使用 `@import` 加载 CSS资源

* 使用CDN服务，对内容进行分发，提高用户对资源请求的相应速度。

  还可以更细致的将 js、css资源放在一个CDN域名，将图片资源放在另一个CDN域名，
  通过多个域名并发加载更多的资源，以减少最终等待时间。

* 利用 浏览器/HTTP 缓存

  对 JS、CSS、图片等资源，使用强缓存策略，使用打包工具对这些资源文件进行哈希重命名。
  强缓存过的资源，二次访问时不会再发起网络请求，而是直接从浏览器缓存区读取。

* 服务器开启 GZip/Brotli 压缩，进一步减少请求文件大小

---

---
url: /interview-question/k8vcpo28/index.md
---
# 对vuex的理解
::: tip 提问

1. 简单说说你对 `vuex` 的理解

:::

## 分析

此题考察实践能力，对 `vuex` 的设计理念和实现原理的解读。

### 回答策略

1. 说明 `vuex` 的定义
2. `vuex` 解决了什么问题
3. 什么时候需要 `vuex`
4. 具体用法
5. 简述原理，优缺点等

## 回答

> **官网定义:**
>
> Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

1. `vuex` 是 `vue` 官方开源并维护的状态管理库，它以 **全局的方式集中管理应用状态**，并保证应用状态变更的可预测性。
2. `vuex` 主要解决的问题是多组件之间状态共享的问题，利用各种组件通信方式，我们虽然能够做到状态共享，但是往往需要在多个组件之间保持状态的一致性，这种模式很容易出现问题，也会使程序逻辑变得复杂。 `vuex` 通过把组件的共享状态抽取出来，以全局单例模式管理，这样任何组件都能用一致的方式获取和修改状态，响应式的数据也能够保证简洁的单向数据流动，我们的代码将变得更结构化且易维护。
3. `vuex` 并非必须的，它帮我们管理共享状态，但却带来更多的概念和框架。
   如果我们不打算开发大型单页应用或者我们的应用并没有大量全局的状态需要维护，完全没有使用 `vuex` 的必要。
   一个简单的 `store` 模式就足够了。反之， `vuex` 将会成为自然而然的选择。
   引用 `Redux` 的作者 `Dan Abramov` 的话说就是：Flux 架构就像眼镜：您自会知道什么时候需要它。
4. 我在使用 `vuex` 过程中有如下理解：首先是对核心概念的理解和运用，将全局状态放入 `state` 对象中，
   它本身一棵状态树，组件中使用 `store` 实例的state访问这些状态；
   然后有配套的 `mutation` 方法修改这些状态，并且只能用 `mutation` 修改状态，
   在组件中调用 `commit` 方法提交 `mutation` ；如果应用中有异步操作或者复杂逻辑组合，
   我们需要编写 `action` ，执行结束如果有状态修改仍然需要提交 `mutation` ，
   组件中调用这些 `action` 使用 `dispatch` 方法派发。最后是模块化，
   通过 `modules` 选项组织拆分出去的各个子模块，在访问状态时注意添加子模块的名称，
   如果子模块有设置 `namespace` ，那么在提交 `mutation` 和派发 `action` 时还需要额外的命名空间前缀。
5. `vuex` 在实现单项数据流时需要做到数据的响应式，通过源码的学习发现是借用了 `vue` 的数据响应化特性实现的，它会利用Vue将 `state` 作为 `data` 对其进行响应化处理，从而使得这些状态发生变化时，能够通知组件重新渲染。

---

---
url: /interview-question/kby2ggwi/index.md
---
# 异步请求
::: tip 提问

1. ajax
2. Fetch API
3. jsonp

:::

## ajax

ajax（Asynchronous JavaScript and XML）是指通过 javascript的异步通信，从服务端获取XML文档，
从中提取数据，再将数据更新到当前网页的对应部分，而不需要刷新网页。

一般来说，ajax 包括以下几个步骤：

* 通过 XMLHttpRequest 对象创建一个异步调用对象；
* 创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息
* 设置响应HTTP请求状态变化的函数
* 发送HTTP请求
* 获取异步调用返回的数据
* 使用javascript和 DOM 实现局部更新

## Fetch API

Fetch API 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应。它还提供了一个全局 fetch() 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。

## jsonp

jsonp 是一种利用 `<script>` 标签 来实现的 支持跨域的异步通信方案。

前端将函数名作为参数传递到后端服务，后端服务在函数中注入需要返回的数据后，作为动态脚本返回给前端，
前端通过 script 标签加载这个动态脚本后，调用该函数，获取到返回的数据。

---

---
url: /interview-question/kfthgdn7/index.md
---
# 跨域
::: tip 提问

1. 什么是跨域？
2. 浏览器的同源策略
3. 跨域解决方案？

:::

## 跨域

当 协议、 子域名、 主域名、 端口号 中任意一个不相同是，都算作不同域。
不同域之间相互请求资源，就被认为是 **跨域**。

## 浏览器的同源策略

同源策略是一种约定，它是浏览器最核心也是最基本的安全功能。

同源策略是指： `协议 + 域名 + 端口` 三者相同，即使两个不同的域名指向同一个IP地址，也非同源。

同源策略限制的内容有：

* Cookie、LocalStorage、IndexedDB 等存储性内容
* DOM节点
* AJAX 请求

有三个标签允许跨域加载资源：

* `<img>`
* `<link>`
* `<script>`

## 跨域解决方案

跨域问题并不是前端开发人员仅依靠浏览器和javascript就能够解决的，常常需要跟服务器、后端技术人员进行配合，
才能解决。

### jsonp

利用`<script>` 标签没有跨域限制的特点，网页可以得到从其他来源动态产生的 JSON 数据。
JSONP请求一定需要对方的服务器做支持才可以。

### cors

cors方案需要浏览器和后端同时支持。

服务端需要设置 `Access-Control-Allow-Origin` 就可以开启cors。

该属性表示哪些域名可以访问资源，如果设置了通配符则表示所有网站都可以访问资源。

浏览器端会自动进行CORS通信。

### 代理转发

* 通过 nginx 配置一个代理服务器，反向代理 非同源域名的接口到当前域名。
* 服务器 中间代理。通过 服务器 代理转发非同源域名的接口。
*

### 其他

以下方法仅能解决部分场景下的跨域问题，并不是一种通用的，合适的解决方案。

* postMessage
* websocket
* window.name + iframe
* location.hash + iframe
* document.domain + iframe

::: tip 说明
在工作中最常用的跨域解决方案是 CORS 和 服务器代理转发。
这两种方法是最合适和最通用的解决方案。
:::

---

---
url: /interview-question/kqeizag0/index.md
---
# 变量
::: tip 提问

1. 声明变量的方式
2. 有什么区别

:::

## 声明变量

声明变量的方式有三种，分别是`var`、`let`、`const`。

其中`let`、`const`是`es6`新增的变量声明方式。

`var`声明的变量的作用域是它当前执行的上下文中，并且存在变量提升

```js
function fn() {
  console.log(a)
  var a = 1
  console.log(a)
}
fn()
```

相当于

```js
function fn() {
  let a
  console.log(a) // undefined
  a = 1
  console.log(a) // 1
}
fn()
```

并且在可以重复声明同一变量，在该声明的上下文中不会丢失其值。通过var声明的全局变量会作为窗口对象的属性。

`let` 声明的变量是块级作用域，不存在变量提升，并存在暂时死区，不允许在同一块级作用域重复声明。

```js
function fn() {
  console.log(a) // ReferenceError: a is not defined
  let a = 1
  let a = 2 // TypeError thrown
  console.log(a)
}
fn()
```

## 区别

`const` 声明一个常量，其作用域可以是全局或者是本地声明的块级作用域，与`var`变量不同，全局常量不会变为窗口对象的属性。

常量必须在声明的同时初始化。同时声明创建的值是一个只读引用，但不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。

如果引用内容是对象的情况下，则可以改变对象内容，除非使用`Object.freeze()`方法冻结对象。`const`声明常量同样存在暂时死区。

---

---
url: /interview-question/kr0wd3xk/index.md
---
# 数组和对象
::: tip 提问

1. 对象有哪些原生方法？
2. 数组有哪些原生方法？
3. 什么是类数组？

:::

## 对象的原生方法

* `Object.assign()` 通过复制一个或多个对象来创建一个新的对象
* `Object.create()` 使用指定的原型对象和属性创建一个新对象
* `Object.defineProperty()` 给对象添加一个属性并指定该属性的配置
* `Object.defineProperties()` 给对象添加多个属性并分别指定它们的配置
* `Object.entries()` 返回给定对象自身可枚举属性的`[key, value]` 数组
* `Object.freeze()` 冻结对象，其他代码不能删除或更改任何属性
* `Object.getOwnPropertyNames()` 返回一个包含了指定对象所有可枚举或不可枚举的属性名的数组
* `Object.getOwnPropertySymbols()` 返回一个包含了指定对象自身所有的符号属性
* `Object.getPrototypeOf()` 返回指定对象的原型对象
* `Object.is()` 比较两个值是否相同。(所有 NaN值都相等。)
* `Object.keys()` 返回一个包含所有给定对象自身可枚举属性名称的数组
* `Object.preventExtensions()` 防止对象的任何扩展
* `Object.seal()` 防止其他代码删除对象的属性
* `Object.values()` 返回给定对象自身可枚举值的数组

## 数组的原生方法

### 静态方法

* `Array.from()` 从类数组对象或可迭代对象中创建一个新的数组实例
* `Array.isArray()` 判断某个变量是否是一个数组对象
* `Array.of()` 根据一组参数来创建新的数组实例

### 实例方法

* `Array.prototype.concat()` 合并两个或多个数组，并返回一个新的数组
* `Array.prototype.copyWithin` 浅复制数组的一部分到同一数组的另一个返回，并返回它，不会改变原数组的长度
* `Array.prototype.entries()` 返回一个新的`Array Iterator`对象，对象包含数组中的每个索引的键值对
* `Array.prototype.every()` 测试一个数组组内的所有元素是否都能通过某个指定函数的测试，并返回一个布尔值
* `Array.prototype.fill()` 用一个固定值填充一个数组中的全部元素
* `Array.prototype.filter()` 创建一个新数组，包含通过所提供的函数实现的测试的所有元素
* `Array.prototype.find()` 返回数组中满足提供的测试函数的第一个元素，否则返回 undefined
* `Array.prototype.findIndex()` 返回数组中满足提供的测试函数的第一个元素的索引，否则返回 -1
* `Array.prototype.flat()` 按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回
* `Array.prototype.flatMap()` 使用映射函数映射每一个元素，然后将结果压缩成一个新数组
* `Array.prototype.forEach()` 对数组的每一个元素执行一次给定的函数
* `Array.prototype.includes()` 判断一个数组是否包含一个指定的值，返回一个布尔值
* `Array.prototype.indexOf()` 返回在数组中可以找到一个给定元素的第一个索引，不存在则返回 -1
* `Array.prototype.join()` 将一个数组的所有元素链接成一个字符串并返回
* `Array.prototype.keys()` 返回一个包含数组中每个索引建的 `Array Iterator`对象
* `Array.prototype.lastIndexOf()` 返回指定元素在数组中的最后一个索引，不存在则返回 -1
* `Array.prototype.map()` 返回一个数组，其结果是该数组的每个元素是调用一次提供的函数后的返回值
* `Array.prototype.pop()` 从数组中删除最后一个元素，并返回该元素的值
* `Array.prototype.push()` 将一个或多个元素添加到数组的末尾，并返回该数组的新长度
* `Array.prototype.reduce()` 对数组中的每个元素指定一个指定的reducer函数（从左向右），将其结果汇总为单个返回值
* `Array.prototype.reduceRight()` 类似于 `reduce()`，但是是从右向左
* `Array.prototype.reverse()` 将数组中元素的位置颠倒，并返回该数组。该方法会改变原数组
* `Array.prototype.shift()` 从数组中删除第一个元素，并返回该元素的值
* `Array.prototype.slice()` 提取原数组的一部分并返回一个新数组
* `Array.prototype.some()` 测试数组中是不是至少有一个元素通过了提供的测试函数
* `Array.prototype.sort()` 对数组元素进行原地排序并返回此数组
* `Array.prototype.splice()` 通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容
* `Array.prototype.unshift()` 将一个或多个元素添加到数组的头部，并返回该数组的新长度
* `Array.prototype.values()` 返回一个新的`Array Iterator` 对象，该对象包含数组每个索引的值。

### 类数组

类数组是指 一个拥有 `length` 属性 和 若干索引属性的对象。

类数组对象和数组类似，但不能调用数组的方法。

常见的类数组有， `arguments` 和 DOM方法返回的结果

---

---
url: /interview-question/ku3jvbnj/index.md
---
# git
::: tip 提问

1. git 是什么？
2. git和 svn 有什么区别？
3. git pull 和 git fetch有什么区别？
4. git merge 和 git rebase 有什么区别？
5. git-flow 是什么？

:::

## 什么是 git

git是目前使用最广泛的软件版本管理系统。

git是分布式版本管理工具。

## git和svn的区别

* git是分布式的，而svn是集中式的
* svn的分支是整个版本库的复制的一份完整目录，而git的分支是指针指向某次提交。因此git的分支创建更快，开销更小，
  并且分支上的变化不会影响到其他人。svn的分支变化会影响到所有人。

## git pull 和 git fetch 的区别

* git fetch 用于将远程仓库的变化下载到本地，但不与本地分支合并，主要用于同步远程仓库的变更到本地仓库
* git pull 用于将远程仓库的变下下载并和当前分支进行合并。

## git merge 和 git rebase 的区别

两个命令都是用于 分支合并，区别在于 commit 记录的处理有所不同

* git merge 会新建一个 合并 commit， 然后两个分支以前的commit记录都指向这个新的合并 commit 记录。
  这种方法会保留之前每个分支的commit历史

* git rebase 会先找到两个分支的第一个共同 commit 祖先记录，然后提取当前分支之后的所有commit记录，然后将

* 这个commit记录添加到目标分支的最新提交后面。经过合并后，两个分支合并后的commit记录就变为了线性记录。

如果想要一个干净的，没有 merge commit 的线性历史，那么可以选择 git rebase，
如果想要保留完整的历史记录，并且避免重写 commit history的风险，那么应该选择 git merge。

个人认为在团队协作中，如果团队成员对 git 的掌握一般，并不了解 rebase黄金法则，同时想要把控所有成员完整的提交历史，
建议选择使用 git merge，能够更好的追踪所有成员提交记录。

## git-flow

git-flow 是git的一种工作流，一种git分支管理方案。

git-flow 分支规范：

* master ：主分支，存储项目正式发布历史。
* develop: 开发分支，用作 feature 分支的 集合分支。
* feature/\*: 从开发分支拉取的 功能分支，开发完成后推送到 开发分支，不跟 主分支产生交互
* release： 发布分支，当开发分支累计了一定量的发布功能，就从开发分支分离一条 release分支，
  此时 develop分支不再添加新的功能，仅能做一些修复、文档相关的面向发布的任务。
* hotfix： 紧急修复分支，用于发布产品的补丁，从master分支分离，发布完成后应该马上合并回master分支，
  并合并到 develop或release分支。然后主分支马上被打上新版本的tag

团队是否使用 git-flow 的完整工作流程，见仁见智，对于项目比较大，涉及人数较多，git-flow 是个不错的选择；
如果人数较少，那么可以在这个基础上，选择简化工作流。

---

---
url: /interview-question/leu2g17b/index.md
---
# UI框架
常用的 UI框架有包括：

* element-ui (vue@2)
* element-plus (vue@3)
* ant-design (react)
* iView
* vant-ui
* vuefity
* navie-ui

---

---
url: /interview-question/lkriz1wa/index.md
---
# 响应式原理
[![vue@3](https://img.shields.io/badge/vue-%403-brightgreen)](https://staging-cn.vuejs.org/)

::: tip 提问

1. 简单介绍一下Vue的响应式原理
2. vue2 和 vue3 的响应式对象有什么区别？

:::

## Vue 响应式原理

在 javascript 中，有两种劫持属性访问的方式： `getter/setter` 和 `Proxies`。
在`Vue3` 中，使用了 `Proxy` 来创建响应式对象。

* 在 Vue中，跟数据关联的其他操作行为，被称为`副作用 effect`，Vue内部会维护一个使用 `WeakMap` 定义的副作用队列，
  将副作用订阅都存储在其中。

  ```ts
  WeakMap<target, Map<key, Set<effect>>>
  ```

* 在 数据的 `getter` 方法中，使用 `track` 函数检查是否有正在运行的副作用，然后将这个副作用添加到该数据的订阅者 `Set` 中。

* 在数据的 `setter` 方法中，当数据发生改变，则找到该数据的所有订阅的副作用，然后一一执行这些副作用。

* 对于组件实例，将DOM渲染也认为是副作用的一种，数据更新时，同样会去执行这个副作用。

## Vue3 和 Vue2 实现响应式原理的区别

* 相比于 Vue2， Vue3的由于采用了 `Proxy`的方式来实现响应式对象，
  响应式数据能够检测到响应式对象的属性的添加和删除

* 使用`WeakMap`数据结构来保存响应式对象的副作用，在响应式对象没有再被引用时，能够及时的被垃圾回收，减少内存开销。

---

---
url: /interview-question/lzbk7vkc/index.md
---
# 数据类型
::: tip 提问

1. javascript有哪些数据类型？
2. 什么是基本数据类型？
3. 什么是引用数据类型？
4. 如何做数据类型判断？

:::

## 数据类型

javascript 有两种数据类型，分别是 基本数据类型 和 引用数据类型。

## 基本数据类型

javascript一共有7中基本数据类型，包括：
`undefined`, `null`, `Boolean`, `Number`,
`String`, `BigInt`, `Symbol`。

特性：

* 存放在栈区
* 进行值比较时，`==` 只进行值的比较，会进行数据类型转换， `===` 不仅进行值的比较，还要进行数据类型的比较。

## 引用数据类型

引用数据类型指 Object 类型， 所有其他的如 Array、Date、Function等类型都可以理解为Object类型的子类。

特性：

* 同时保存在栈内存和堆内存中。解释器寻找引用值是，会首先检索它在栈中的地址，取得地址后从堆中获得实体。
* 比较时是引用的比较

## 数据类型判断

### typeof

`typeof` 返回一个表示数据类型的字符串，可以用来判断 `number`, `boolean`, `string`,`symbol`,`object`,
`undefined`, `function` 等7种数据类型，但不能判断 `null`，`Object`的子类等。

### instanceof

`instanceof` 用来判断 A是否为B的实例。 一般用于判断引用类型。但在 类的原型继承中，结果不一定准确。

### constructor

`constructor` 和 `instanceof` 类似， 但还可以处理除了 null、undefined 之外的基本数据类型的检测。

`constructor`不是稳定的，如果把类的原型重写，可能会把之前的`constructor`给覆盖了。

### Object.prototype.toString.call(someObj)

最准确也是最常用的数据类型检测方式。 该方法会将数据类型的检测结果以`[object <type>]` 的形式返回。

### 其他

除了上述的方式，一些数据类型也提供了方法进行数据类型判断，如：

* Array.isArray()
* Number.isNaN()

---

---
url: /interview-question/m9iifxl4/index.md
---
# 生命周期
[![vue@2](https://img.shields.io/badge/vue-%402-brightgreen)](https://cn.vuejs.org/)

::: tip 提问

1. 简述下vue组件的生命周期

:::

## 生命周期

1. `beforeCreate` 在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用。

2. `created` 在实例创建完成后被立即同步调用。

   实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。

3. `beforeMount` 在挂载开始之前被调用：相关的 render 函数首次被调用。

4. `mounted` 实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。

   `mounted` 不会保证所有的子组件也都被挂载完成。

5. `beforeUpdate` 在数据发生改变后，DOM 被更新之前被调用。

6. `updated` 在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。

7. `activated` 被 keep-alive 缓存的组件激活时调用。

8. `deactivated` 被 keep-alive 缓存的组件失活时调用。

9. `beforeDestroy` 实例销毁之前调用。在这一步，实例仍然完全可用。

10. `destroyed` 实例销毁后调用。

11. `errorCaptured` 在捕获一个来自后代组件的错误时被调用。

---

---
url: /interview-question/mp8b8qeh/index.md
---
# 内存泄露
::: tip 提问
哪些操作会造成内存泄露？
:::

1. 意外的全局变量

   由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。

2. 被遗忘的计数器或回调函数

   设置了`setInterval`定时器时，忘记取消它。如果循环函数有对外部变量的引用，那么这个变量会一直被留在内存中无法被回收。

3. 脱离DOM的引用

   在获取一个DOM的元素引用后，这个元素被删除，由于保留了对这个元素的引用，所以也无法被回收。

4. 闭包

   不合理的使用闭包，从而导致某些变量一直留在内存中无法被回收。

---

---
url: /interview-question/mvcgg9uz/index.md
---
# XSS攻击
::: tip 提问

1. 什么是XSS攻击？
2. 如何防范 XSS攻击？

:::

## XSS攻击

XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。
攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。

XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，
浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。

## 防范XSS攻击

* 对存入数据库的数据都进行的转义处理
* 对需要插入到 HTML 中的代码做好充分的转义
* 使用 CSP
* cookie 使用 http-only

---

---
url: /interview-question/nj8az302/index.md
---
# 栈和堆
::: tip 提问

1. 什么是栈？
2. 什么是堆？
3. 有什么区别和联系？

:::

栈和堆的概念存在于数据结构中和操作系统内存中。

在数据结构中，栈中的数据的存取方式是先进后出。
而堆是一个优先队列，按优先级来进行排序的，优先级可以按照大小来规定。

在操作系统中，内存被分为栈区和堆区。

栈区内存由变意思自动分配释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。

堆区内存一般有程序员分配释放，若不手动释放，程序结束时可能有垃圾回收机制回收。

在javascript中，由于 javascript的 GC机制，开发人员很少需要关注 栈和堆。

一般都是了解 基本数据类型是存放在 栈中，而引用数据类型的实体存放在堆中，然后在栈中保存该数据在堆中的地址。

---

---
url: /interview-question/nx0xqyp5/index.md
---
# v-if和v-show的区别
::: tip 提问

1. `v-if` 和 `v-show` 有什么共同点？
2. 有什么区别？
3. 该如何选择使用哪个？

:::

## 共同点

* 都是 Vue的内置指令
* 都能控制元素的 显示和隐藏

## 区别

* `v-show` 是通过控制 元素 的 `display`， 通过设置为 `none` 来实现元素的隐藏，
  初始值无论是true或false，都会进行编译，且只会编译一次，后续状态变更仅改变 `display`的值。
  频繁切换开销比较小。

* `v-if` 是 动态的向 DOM树中插入和删除DOM元素，若初始值为 false，则跳过编译。
  后续状态变更，每次都会重新向 DOM树中插入或删除DOM元素。
  频繁切换开销比较大。

## 选择

* 对于不需要频繁切换状态的，选择使用 `v-if`
* 对于频繁切换状态的，选择使用 `v-show`。

---

---
url: /interview-question/oc3hgg0h/index.md
---
# 作用域和作用域链
::: tip 提问

1. 什么是javascript的作用域？
2. 什么是 javascript的作用域链？

:::

## 作用域

作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。

作用域决定了代码区块中变量和其他资源的可见性。

### 全局作用域

在代码中任意地方都能访问到的对象拥有全局作用域。

### 函数作用域

声明在函数内部的变量，仅能在当前函数内部访问到的，拥有函数作用域

### 块级作用域

通过 `let` 或 `const` ，在 函数内部，或者在一队花括号 里声明的变量，拥有块级作用域

块级作用域 特性：

* 声明的变量不会提升到当前作用域顶部
* 禁止重复声明

## 作用域链

作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。

作用域链本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。
作用域链的前端使用都是当前执行上下文的变量对象。全局执行上下文的变量对象始终是作用域链的最后一个对象。

当我们查找一个变量时，如果当前执行环境中没有找到，会沿着作用域链向后查找。

作用域链的创建过程跟执行上下文的建立有关。

---

---
url: /interview-question/oi8seb1b/index.md
---
# 集合对象
集合对象是指： `Set`、 `Map` 、`WeakSet`、 `WeakMap`

::: tip 提问
简单介绍一下 `Set`、 `Map` 、`WeakSet`、 `WeakMap`
:::

## Set

`Set` 对象是 值的集合，Set中的元素只会出现一次，即 Set 中的元素值是唯一的。

* `Set.prototype.add()` 在当前实例的尾部添加一个元素，并返回当前Set实例
* `Set.prototype.clear()` 移除当前实例的所有元素
* `Set.prototype.delete()` 移除当前实例中的指定的元素
* `Set.prototype.has()` 判断当前实例中是否存在指定的元素
* `Set.prototype.entries()` 返回一个迭代器对象，该对象包含按照插入顺序排列所有元素的 `[value, value]`数组
* `Set.prototype.keys()` 同 `values()` 方法
* `Set.prototype.values()` 返回一个迭代器对象，该对象包含按照插入顺序排列的所有元素的值

## Map

`Map` 对象保存键值对，并且能够记住键的原始插入顺序。任何值都可以作为一个键或一个值。

* `Map.prototype.set()` 在当前实例添加或更新一个指定的键和值的键值对
* `Map.prototype.get()` 返回当前实例中的一个指定元素
* `Map.prototype.has()` 判断当前实例中是否存在指定元素，返回 布尔值
* `Map.prototype.delete()` 移除当前实例中指定元素
* `Map.prototype.clear()` 移除当前实例所有元素
* `Map.prototype.entries()` 返回一个迭代器对象，该对象包含按照插入顺序排列所有元素的 `[key, value]`数组
* `Map.prototype.keys()` 返回一个迭代器对象，该对象包含按照插入顺序排列的所有元素的键
* `Map.prototype.values()` 返回一个迭代器对象，该对象包含按照插入顺序排列的所有元素的值

## WeakSet

`WeakSet` 对象是一些对象值的集合，并且其中的每个对象值都只能出现一次，在集合中是唯一的。

`WeakSet` 和 `Set` 的区别：

* 与`Set` 相比，`WeakSet`只能是对象的集合，而不能是任何类型的任意值

* `WeakSet`集合中的对象的引用为弱引用。如果没有其他的对`WeakSet`中的对象的引用，那么这些对象会被当成垃圾回收掉。

* `WeakSet` 是不可枚举的。

* `WeakSet.prototype.add()` 在当前实例的尾部添加一个元素，并返回当前Set实例

* `WeakSet.prototype.delete()` 移除当前实例中的指定的元素

* `WeakSet.prototype.has()` 判断当前实例中是否存在指定的元素

## WeakMap

`WeakMap` 对象是一组 键值对 的集合，其中的键是弱引用的，且键必须是对象，而值可以是任意的。

`WeakMap` 和 `Map` 的区别

* `WeakMap` 的键必须是对象，值可以使任意的。

* 由于键是弱引用的，所以当键所指对象没有其他地方引用的时候，它会被GC回收掉。

* `WeakMap` 是不可枚举的。

* `WeakMap.prototype.set()` 在当前实例添加或更新一个指定的键和值的键值对

* `WeakMap.prototype.get()` 返回当前实例中的一个指定元素

* `WeakMap.prototype.has()` 判断当前实例中是否存在指定元素，返回 布尔值

* `WeakMap.prototype.delete()` 移除当前实例中指定元素

---

---
url: /interview-question/os6hn2b8/index.md
---
# CDN
::: tip 提问
CDN是什么？
:::

CDN是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域，不同运营商的服务器，
向用户提供资源就近访问的功能。

用户的请求不直接发送到原网站，而是发送给CDN服务器，由CDN服务器将请求定位到最近的含有该资源的服务器上去请求。

有利于提高网站的访问速度，同时也减轻了源服务器的访问压力。

---

---
url: /interview-question/ouqcf733/index.md
---
# 前端SEO
1. 设置合适`title`、`description`、`keywords`，搜索引擎对这三项的权重逐步减小。
   title值强调重点，不同页面title要不同；重要关键词不要出现超过2次，且必须靠前；
   description概括页面内容，长度不宜过长。

2. 语义化的html代码，符合W3C规范。

3. 重要内容HTML代码放在最前，搜索引擎爬取HTML顺序是从上到下，尽可能保证重要内容能够提前被抓取。

4. 图片必须设置 alt属性值

5. 提高网站访问速度，网站速度是搜索引擎排序的重要指标

6. 准备一个 robot.text 文件，给搜索引擎爬取

7. 为网站生成 sitemap，方便搜索引擎爬取网站需要被收录的页面。

---

---
url: /interview-question/ov7st17l/index.md
---
# 负载均衡
::: tip 提问

1. 什么是负载均衡
2. 如何实现？

:::

## 负载均衡

负载均衡指， 将负载（即工作任务）进行平衡，分摊到多个操作单元上执行。

## 负载均衡实现

1. 反向代理服务器
2. DNS

---

---
url: /interview-question/p1gn97x5/index.md
---
# BFC块级格式化上下文
::: tip 提问

* 什么是 BFC ?
* 如何创建BFC ?
* BFC有什么作用 ？

:::

## 什么是 BFC

BFC, Block Formatting Context。是 W3C CSS2.1规范中的一个概念。 是页面中的一块块级渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和作用。

具有BFC特性的元素，可以看做是一个被隔离了的独立容器，容器内的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性。

## 创建BFC的方式

1. 根元素（html）
2. 浮动元素，即 float值不为 none。
3. 绝对定位元素， 元素的 position 为 absolute 或者 fixed
4. 行内块元素， 元素的 display 为 inline-block
5. 表格单元格， 元素的 display 为 table-cell。 （HTML表格单元格默认为该值）
6. 表格标题， 元素的display为table-caption。 （HTML表格标题默认为该值）
7. 匿名表格单元格元素， 元素的display为 table、table-row、table-row-group、
   table-header-group、table-footer-group 。 （分别是 HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table。
8. overflow计算值不为visible的块元素
9. display值为 flow-root的元素
10. contain值为 layout、content、paint的元素
11. 弹性元素，display为 flex、inline-flex元素的直接子元素
12. 网格元素， display为gird、inline-gird元素的直接子元素
13. 多列容器，元素的column-count或column-width不为 auto， 包括column-count不为1
14. colum-span为all的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中。

## 作用

1. 同一个BFC的外边距会发生折叠（合并）， 通过将其放在不同的BFC中规避折叠。
2. BFC可以包含浮动元素，即清除浮动。
3. BFC可以阻止元素被浮动元素覆盖。

---

---
url: /interview-question/qm07ep25/index.md
---
# CSRF攻击
::: tip 提问

1. 什么是CSRF攻击？
2. 如何防范CSRF攻击？

:::

## CSRF攻击

CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。

如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

## 防护CSRF攻击

* 同源检测的方法。

  服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。

* 使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。

  这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，
  我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。
  还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，
  但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。

* 使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。

  使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。

* 使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。

  Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。

---

---
url: /interview-question/r3evwwd7/index.md
---
# 元素垂直居中
::: tip 提问

* 在 某某场景下，如何让某某元素垂直居中？
* 有哪些方式可以实现元素的垂直居中？

:::

**设立一个场景：在一个宽高不固定的容器中，实现一个宽高不固定的内容盒子，并垂直水平居中。**

```html
<!-- 假设 warpper、container 宽高不固定 实现container相对于wrapper垂直水平居中-->
<div class="wrapper">
  <div class="container"></div>
</div>
```

**方法一：** 使用 flex 布局

```css
.wrapper {
  display: flex;
}
.container {
  margin: auto;
}
```

适用于支持 flex布局的浏览器（IE11以上，其他现代浏览器）。这里是利用flex弹性布局的特性，弹性容器改变了其子元素填充可用空间的方式，子元素默认从容器左上角开始排列，在不设置宽高时，子元素填充空间由`flex`声明，默认值为`0 1 auto`,即
`flex-grow: 0;flex-shrink: 1;flex-basis: auto`; 其中 `flex-basis`定义了子元素的宽和高的尺寸大小，`auto`值表示自动尺寸，根据子元素内容计算宽高，在子元素上设置`margin: auto`，这是利用`auto`平均分配水平或垂直方向上的额外的空间，从而达到目的。（此方法实现的结果是“真正的”垂直水平居中）

或者

```css
.wrapper {
  display: flex;
  justify-content: center;
  align-content: center;
}
```

**方法二：** 使用 table 布局

```css
.wrapper {
  display: table-cell;
  vertical-align: middle;
}
.container {
  margin: auto;
}
```

利用的是table布局的特性，不过该方法有个缺点就是，`display: table-cell`元素的宽高设置百分比数值是“无效的”，原因是父元素非`table`元素或`display: table`元素，`display: table-cell`元素的宽高百分比数字是相对于`table`计算的。

**方法三：** `position` + `transform`

```css
.wrapper {
  position: relative;
}
.container {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```

该方法与前面两个方法的作用机理有很大的不同，首先第一点是`container`脱离了文档流，
并且`container`自身的宽高发生了坍塌，在不设置宽高属性下，尺寸由内容撑开，
`container`相对`wrapper`元素进行绝对定位，水平方向与垂直方向上，
`container`的左上角顶点偏移到`wrapper`中点，`container`的`transform`是相对于自身的，
`translate(-50%, -50%)`相对于自身，将左上角顶点做左上偏移自身的一半，从而实现了目的。

*有一些面试者给出了`container`元素上设置`margin-left: -50%; margin-top: -50%`的答案，然而，margin的百分比值，是相对于其父元素计算的。*

**方法四：** 使用 行内块元素

```css
.wrapper {
  text-align: center;
}
.wrapper:after {
  content: '';
  display: inline-block;
  vertical-align: middle;
  height: 100%;
}
.container {
  display: inline-block;
  vertical-align: middle;
  text-align: left;
}
```

该方法实现的垂直水平居中其实是一个近似垂直水平居中，兼容IE7以上的浏览器。
水平方向上`.wrapper`设置`text-align: center;`实现了水平居中；垂直方向上，
给定`container`声明行内块元素，并`vertical-align: middle`，但由于`container`高度不确定，
无法声明具体的行高，所以借助了父元素的伪类元素，创建了一个宽度为0高度为100%的行内块元素，
从而使`container`元素在垂直方向上实现了居中。
但由于`vertical-align: middle`是元素的中线与字符X的中心点对齐，大多数字体设计字体的中心点偏下，
也导致了实现的垂直居中并不是绝对的垂直居中。而要实现绝对的垂直居中，需要添加一下属性：

```css
.wrapper {
  font-size: 0;
  white-space: nowrap;
}
.container {
  font-size: 14px; /* 重置回默认字体大小 */
  white-space: normal;
}
```

---

---
url: /interview-question/rh7yy89s/index.md
---
# lodash
lodash 是一个 工具库，提供了一系列 对于 字符串、数组、对象、集合 等数据结构的工具函数

支持在项目引入整个lodash，也支持在项目中仅引入某个工具函数。

---

---
url: /interview-question/rumwg3ew/index.md
---
# data为什么必须是函数
[![vue@2](https://img.shields.io/badge/vue-%402-brightgreen)](https://cn.vuejs.org/)

::: tip 提问
在vue2的组件中，data为什么必须是一个函数
:::

## data

因为一个组件可能会产生多个组件实例，而每个组件实例都应该拥有私有的数据空间，
也就是说每个组件实例的data应该是相互独立的。

将 `data` 使用函数的形式返回一个对象，这样每个组件实例都会获取一个新的 数据对象。

---

---
url: /interview-question/sfnusib9/index.md
---
# 盒模型
::: tip 提问

* 请简述 CSS 盒模型。
* 盒模型有哪些类型？有什么区别？

:::

盒模型是CSS规范定义的模块，它规定了一个矩形盒子（标准盒模型），描述任意元素在文档树中占据的空间区域。每个盒子有四个边：

* `外边距边（margin edge or outer edge）`
* `边框边（border edge）`
* `内填充边（padding edge）`
* `内容边（content edge or inner edge）`

可以划分四个区域：

* `外边距区域（margin area）`
* `边框区域（border area）`
* `内填充区域（padding area）`
* `内容区域（content area）`

![css box model](https://drafts.csswg.org/css-box-3/images/box.png)

为什么会有盒模型类型，严格来说，多数浏览器都按照规范实现了标准盒模型，而盒模型的类型主要是来自于不同浏览器对元素宽高的方式不同而导致，IE浏览器认为元素的`width/height`应该是由元素的`内容+内填充+边框`组成，而W3C规定的元素的`width/height`应该是元素的`内容`，从而衍生了不同的盒子模型。到`CSS3`，添加了`box-sizing`属性，用于更改用于计算元素宽高的默认盒子模型，并将IE浏览器和W3C规范纳入了实现中。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行为。

*注：`width/height`最终并不能完全决定元素的实际占用宽高。*

```css
/* 关键字值 */
box-sizing: border-box; /* 默认值 */
box-sizing: content-box;
/* 全局值 */
box-sizing: inherit;
box-sizing: initial;
box-sizing: unset;
```

`border-box`规定了元素的`width`由`内容+内填充+边框`组成，即IE浏览器的实现。 元素的实际占据宽度由 width属性+外边距。内容宽度为`width - padding - border`。

`content-box`规定了元素的`width`即`内容宽度`, W3C规范的标准。元素的实际占据宽度由`widht + padding + border + margin`。内容宽度为`width`。

`box-sizing`还有一个待废除的值`padding-box`，`width` 和 `height` 属性包括内容和内边距，但是不包括边框和外边距。只有Firefox实现了这个值，它在Firefox 50中被删除。

在高度计算上以上规则同样适用，但对非替换行内元素，尽管内容周围存在内边距与边框，但其占用空间受到`line-height`属性影响。

---

---
url: /interview-question/sx71rqqx/index.md
---
# 浏览器渲染原理
::: tip 提问

1. 说说 浏览器的渲染原理

:::

1. 解析收到的文档， 根据文档定义构建一棵 DOM 树， DOM 树是由DOM元素及属性节点组成的。

2. 对CSS进行解析，生成 CSSOM（CSS Object Model） 规则树。

3. 根据DOM树和CSSOM规则树构建 渲染树。 渲染树的节点被称为渲染对象，渲染对象是一个包含颜色和大小等属性的矩形，
   渲染对象和DOM元素相对应，但并非一对一的对应关系，不可见的DOM元素不会被插入渲染树。
   还有一些元素对应几个可见对象，它们一般是具有复杂结构的元素，无法用一个矩形来描述。

4. 当渲染对象被创建并添加到渲染树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，
   就会根据渲染树来进行布局（也可以叫回流）。这一阶段浏览器要做的事情是确定各个节点在页面中的位置和大小。
   通常这个行为也被称为`自动重排`。

5. 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，
   绘制使用UI基础组件。

这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等所有的html都解析
完成之后再去构建和布局渲染树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

---

---
url: /interview-question/ud3m8zxg/index.md
---
# MVC/MVP/MVVM
::: tip 提问

1. MVC
2. MVP
3. MVVM
4. 区别

:::

::: info 说明
以上架构设计模式，仅限于在前端领域内进行说明
:::

## Model\&View

* `Model` 是用于封装应用程序的业务逻辑的相关数据以及对数据的处理方法。

* `View` 作为视图层，主要负责数据的展示。

## MVC

`C` 是指 `Controller`。负责监听 `View` 的用户事件，得到数据后后 `Controller` 做一些处理，然后渲染 `View`。

`MVC` 通过分离 `Model`、`View` 和 `Controller` 的方式来组织代码结构。
`View` 和 `Model` 应用了观察者模式，当 `Model` 层发生改变的时候它会通知有关 View 层更新页面。
`Controller` 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，
`Controller` 中的事件触发器就开始工作了，通过调用 `Model` 层，来完成对 `Model` 的修改，然后 `Model` 层再去通知 View 层更新。

## MVP

`P` 是指 `Presenter`。`Presenter`会调用View层提供的接口去渲染Model。

`MVP` 模式中，View 层的接口暴露给了 `Presenter`，
因此可以在 `Presenter` 中将 `Model` 的变化和 `View` 的变化绑定在一起，以此来实现 `View` 和 Model 的同步更新。
这样就实现了对 `View` 和 `Model` 的解耦，`Presenter` 还包含了其他的响应逻辑。

## MVVM

`VM` 是指 `ViewModel`。

`MVVM` 在`VM`中构建一组状态数据（state data），作为`View`状态的抽象。
然后通过 **双向数据绑定（data binding）** 使`VM`中的 **状态数据（state data）** 与`View`中的 **显示状态（screen state）** 保持一致。
这样，`VM`中的展示逻辑只需要修改对应的状态数据，就可以控制`View`的状态，从而避免在`View`上开发大量的接口。

---

---
url: /interview-question/uvtzbz89/index.md
---
# 模块化
::: tip 提问

1. 什么是前端的模块化？
2. 模块化的规范
3. `AMD`、`CMD`、`CommonJs`， `ES Module` 有什么区别？

:::

参阅 [javascript模块化](/article/javascript-modules/)

---

---
url: /interview-question/uyl99uql/index.md
---
# 代理
::: tip 提问

1. 什么是正向代理？
2. 什么是反向代理？

:::

## 正向代理

正向代理指 客户端请求的服务，都被代理服务器代替来请求。

它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁。

## 反向代理

反向代理指， 客户端请求的服务，都会被代理服务器转发到真实的服务器。

反向代理隐藏了真实的服务端，当请求一个网站的时候，背后可能有成千上万台服务器在提供服务，但具体是哪一台，并不需要关注，客户端只需要知道反向代理服务器就可以了。

反向代理一般用来实现负载均衡。

---

---
url: /interview-question/w122van2/index.md
---
# Virtual DOM
::: tip 提问

1. 什么是 Virtual DOM?
2. Virtual DOM 比 原生DOM快在哪里？

:::

## Virtual DOM

本质上，`Virtual DOM` 是一个普通的javascript对象。
我们将需要需要插入的文档的DOM树结构进行解析，使用一个对象结构进行表述，
比如一个元素对象，包含了 `TagName` , `props` , `attribute` ,`children` 等属性，
然后我们将这个对象结构保存起来，最后再将DOM片段插入到文档中。

当页面的状态发生变化，需要对页面的DOM结构进行调整的时候，首先根据变更的状态，重新构建一颗对象树，
然后将新的对象数和旧的对象数进行对比，记录下两颗树的差异，最后将有差异的地方应用到DOM树中，视图就实现了更新。

## Virtual DOM 比 原生DOM快在哪里？

首先，`Virtual DOM` 本身并没有比原生DOM直接操作DOM要快，但是 `Virtual DOM` 这种方法对于需要进行大量的DOM操作，
操作颗粒比较细、多、复杂的场景下，能够很好的提高操作效率。

通过在操作DOM前，通过 Diff 算法对比新旧两个`Virtual DOM`，我们可以 确定最小的更新范围，尽可能的减少DOM操作带来的回流和重绘的影响。

其目的是是提高了我们的开发时的可维护性，在任意情况下，都能保证在 `Virtual DOM` 带来的尽量小的性能消耗操作DOM。

## DOM 树的比较

两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。

算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。

在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。

---

---
url: /interview-question/w4yx9kq0/index.md
---
# Flex弹性布局
::: tip 提问
描述一下 Flex box
:::

## Flex Box

Flex Box 即 弹性盒布局模型。

任何一个容器都可以指定为Flex布局。

采用Flex布局的元素，称为Flex容器，简称容器。它的所有子元素自动成为容器成员。

在容器上，可以设置以下属性：

* `flex-direction`: 主轴的方向， 默认值是 row
* `flex-wrap` : 一条轴线排不下时，如何换行，默认值是 nowrap
* `flex-flow` : flex-direction 和 flex-wrap 的简写形式，默认值是 row nowrap
* `justify-content` 定义容器成员在主轴上的对齐方式
* `align-items` 定义项目成员在交叉轴上的对齐方式
* `align-content` 定义多跟轴线的对齐方式，如果容器成员只有一根轴线，该属性不起作用

在项目成员上，可以设置以下属性：

* `order` 定义成员的排列顺序。数值越小，排列越靠前，默认为 0
* `flex-grow` 定义成员的放大比例，默认为 0
* `flex-shrink` 定义成员的缩小比例，默认为 1
* `flex-basis` 定义在分配多余空间之前，成员占据的主轴空间，默认为 auto
* `flex` flex-grow, flex-shrink , flex-basis 的简写，默认为 0 1 auto
* `align-self` 定义单个成员的对齐方式

## 总结

flex布局是css3新增的布局方式，可以通过将一个元素的display属性声明为 flex 从而使元素成为 flex容器。

一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴，可以声明主轴的方向、定义容器成员的主轴上的对齐方式，
交叉轴的对齐方式、换行方式等。对容器成员，可以定义排列顺序、空间利用方式、对齐方式等。

---

---
url: /interview-question/w6mai9ic/index.md
---
# v-if和v-for优先级
[![vue@2](https://img.shields.io/badge/vue-%402-brightgreen)](https://cn.vuejs.org/)

::: tip 提问

1. vue2中 `v-if` 和 `v-for` 哪个优先级高？
2. 当需要同时使用时，该如何进行优化？

:::

## 优先级

* 当两个指令位于同一个DOM时，`v-for` 的优先级总是 高于 `v-if`。

## 优化

同时使用时，由于优先级的原因， 每次渲染总会先执行循环再执行 `v-if`, 无论如何，循环都不可避免。
对于这类情况：

* 如果是需要控制 由 `v-for` 执行生成元素列表的判断，可在 `v-for` 的外层嵌套一个 `template` 标签，
  在 `template` 标签上进行 `v-if`的判断

* 如果是需要控制 由 `v-for` 执行生成的元素列表的特定子项的判断，可以先使用 计算属性提前过滤 不需要的 项。

---

---
url: /interview-question/wdcjym47/index.md
---
# this对象
::: tip 提问
谈谈你对 this 对象的理解
:::

`this` 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象，
在实际开发中，this的指向可以通过四种调用模式来判断。

* 函数调用模式。当一个函数不是一个对象的属性时，直接作为函数来调用，this指向全局对象。
* 方法调用模式。如果一个函数作为一个对象的方法来调用时，this指向这个对象。
* 构造器调用模式。如果一个函数用new调用时，函数执行前会新创建一个对象，this指向这个新创建的对象。
* apply、call、bind调用模式，这三个方法都可以显式的指向调用函数的this指向。
  * `apply` 方法接受两个参数，一个是this绑定的对象，一个是参数数组。
  * `call` 方法接受的参数，第一个参数是this绑定的对象，后面其余的参数是传入函数执行的参数。
  * `bind` 方法通过传入一个对象，返回一个this绑定了传入对象的函数。

---

---
url: /interview-question/wnuvm4t1/index.md
---
# 字符串
::: tip 提问
String有哪些原始方法？
:::

## 静态方法

* `String.fromCharCode()` 返回一个由指定的 UTF-16 代码单元序列创建的字符串

## 实例方法

* `String.prototype.charAt()` 从一个字符串中返回指定的字符
* `String.prototype.charCodeAt()` 返回 0 到 65535 之间的整数，表示给定索引处的UTF-16代码单元
* `String.prototype.concat()` 将一个或多个字符串与原字符串连接合并成一个新的字符串并返回
  （不建议使用，使用赋值操作符 `+`， `+=` 代替）
* `String.prototype.endsWith()` 判断当前字符串是否是以给定的字符串结尾的，并返回布尔值
* `String.prototype.includes()` 判断一个字符串中是否包含另一个字符串，并返回布尔值
* `String.prototype.indexOf()` 返回当前字符串中第一次出现指定值的索引，不存在则返回 -1
* `String.prototype.lastIndexOf()` 返回当前字符串中最后一次出现指定值的索引，不存在则返回 -1
* `String.prototype.match()` 检索返回一个字符串匹配正则表达式的结果
* `String.prototype.matchAll()` 返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器
* `String.prototype.padEnd()` 用一个字符串填充当前字符串，返回填充后达到指定长度的字符串，从末尾开始填充
* `String.prototype.padStart()` 用一个字符串填充当前字符串，返回填充后达到指定长度的字符串，从左侧开始填充
* `String.prototype.repeat()` 构造并返回一个新字符串，该字符串包含被链接在一起的制定数量的字符串。
* `String.prototype.replace()` 返回一个由替换字符串替换部分或所有的模式匹配项后的新字符串。
* `String.prototype.replaceAll()` 返回一个新字符串，新字符串所有满足模式匹配和被替换部分字符串都被替换
* `String.prototype.search()` 执行正则表达式和 字符串之间一个搜索匹配。
* `String.prototype.slice()` 提取某个字符串的一部分，并返回一个新的字符串
* `String.prototype.split()` 使用指定的分隔符字符串将一个字符串分割成子字符串数组，并返回。
* `String.prototype.startsWith()` 判断当前字符串是否以给定的字符串开头，并返回布尔值
* `String.prototype.substring()` 返回当前字符串从开始索引到结束索引之间的子集。
* `String.prototype.toLocaleLowerCase()` 根据任何指定区域语言环境设置的大小写映射，返回当前字符串被转换为小写格式的新字符串
* `String.prototype.toLocaleUpperCase()` 根据任何指定区域语言环境设置的大小写映射，返回当前字符串被转换为答谢格式的新字符串
* `String.prototype.toLowerCase()` 将当前字符串转为小写形式并返回
* `String.prototype.toUpperCase()` 将当前字符串转为大写形式并返回
* `String.prototype.trim()` 删除当前字符串两端的空白字符，并返回新的字符串
* `String.prototype.trimEnd()` 删除当前字符串末端的空白字符
* `String.prototype.trimStart()` 删除当前字符串开头的空白字符

---

---
url: /interview-question/y0d1fb60/index.md
---
# 模块打包器
::: tip 提问

1. 什么是模块打包器？
2. 有哪些常用的模块打包器？

:::

## 模块打包器

一个完整的前端项目，由各种各样的资源组成，包括 html文件、css文件、javascript文件、图片文件等等。
我们可以认为这些资源文件就是一个个的模块。
模块打包器可以通过分析入口文件引用了哪些模块，这些模块又引用了哪些模块，通过模块之间的相互引用，获得模块依赖关系图。
通过模块依赖关系图，将这些模块进行合并，打包，执行输出，形成一个完整的可执行的前端项目资源包。

## 常用的模块打包器

* webpack
* rollup
* parcel
* esbuild
* vite
* snowpack

---

---
url: /interview-question/y0fs63f1/index.md
---
# 在浏览器输入URL按下回车后发生了什么？
::: tip 提问

1. 在浏览器的地址栏输入一个 网址URL，并按下回车后，发生了什么？

:::

1. 首先对 URL地址进行解析，分析所需要使用的传输协议和请求的资源路径。如果输入的URL不合法，则认为不是一个有效的URL，
   按下enter时会将输入的内容传给搜索引擎；如果输入的URL合法，浏览器检查URL是否出现了非法字符，
   如果存在则对非法字符进行转译，然后进入到下个过程。

2. 浏览器判断当前URL所请求的资源是否在缓存里，如果有缓存且缓存没有失效，则直接返回缓存的资源，否则向服务器发起新的请求。

3. 向服务器发起请求前，需要获取当前域名的IP地址，首先先判断本地DNS缓存是否有该域名的DNS缓存，如果有则使用，如果没有，
   则向DNS服务器发起请求，获取域名的IP地址，然后把IP地址返回给浏览器。

4. 浏览器获得IP地址后，通过TCP协议进行建立连接的三次握手，成功后，浏览器与服务端建立连接。
   如果是HTTPS协议，还需要进行TSL四次握手，建立安全连接。

5. 浏览器发起的URL请求成功抵达服务器，服务器返回一个html文件作为响应。浏览器接收到html文件后，开始对html文件进行解析。

6. 浏览器首先根据html文件进行解析，构建DOM树，遇到 link标签发现CSS资源请求时，停止html解析，
   请求CSS资源并解析为 CSSOM树后，继续解析html文件。

7. 如果遇到 script 标签，则判断是否有声明 defer或async属性，如果都没有，则script的加载和执行都会阻塞html文档的解析，
   如果声明了defer属性，则并行加载javascript资源后等待html解析完成再执行；
   如果声明了async属性，则并行加载javascript资源，加载完成后立即执行并阻塞html文档解析。

8. 当 DOM树和CSSOM树都解析建立完成，浏览器根据它们构建渲染树，渲染树构建完成后，根据渲染树进行布局。

9. 浏览器布局完成后，使用浏览器的UI接口对网页进行绘制，此时整个页面就显示出来了。

10. 最后退出网页后， TCP开始断开连接的四次挥手过程。

---

---
url: /interview-question/y5w6l1js/index.md
---
# DOM节点操作
::: tip 提问
如何添加、移除、移动、复制、创建、查找节点？
:::

## 创建节点

* `document.createDocumentFragment(node)` 创建一个虚拟节点对象
* `document.createElement(node)` 创建一个新的元素
* `document.createTextNode(text)` 创建一个文本节点

## 添加、移除、替换、插入

* `appendChild(node)` 在元素的末尾插入一个子元素
* `removeChild(node)` 删除元素中的指定的元素
* `replaceChild(newNode, oldNode)` 使用 newNode 替换 oldNode
* `insertBefore(newNode, node)` 在 node元素之前插入一个 newNode

## 查找

* `getElementById(id)`
* `getElementsByName(name)`
* `getElementsByTagName(tagName)`
* `getElementsByClassName(className)`
* `querySelector(selector)`
* `querySelectorAll(selector)`

## 属性操作

* `getAttribute(key)`
* `setAttribute(key, value)`
* `hasAttribute(key)`
* `removeAttribute(key)`

---

---
url: /interview-question/y6r9lfa3/index.md
---
# computed和watch
::: tip 提问
`computed` 和 `watch` 的区别
:::

## 区别

* `computed` 是 计算一个新的属性，并将该属性挂载到 组件实例上。
* `watch` 是 监听已经存在且挂载在 组件实例上的数据， watch通过可以监听 计算属性。
* `computed` 是一个惰性求值的观察者，具有缓存性，只有第一次访问 computed属性,或者当依赖发生变化，，才会计算新的值。
* `watch` 是当监听的数据发生变化后，就会执行监听函数

---

---
url: /interview-question/yiutzl7y/index.md
---
# http2
::: tip 提问

1. http/2
2. http2有什么特性？

:::

## HTTP/2

HTTP/2 是对HTTP/1.1的升级，对HTTP/1.1做了优化。

## 特性

* 二进制协议

  在http/1.1 版中，报文的头信息必须是文本，数据体可是是文本或者二进制。
  而在HTTP/2中，头信息和数据体都是二进制，并且统称为`帧`。

* 多路复用

  HTTP/2 复用TCP连接，客户端和服务器都可以同一个TCP连接中并发请求或响应，且之间互不干扰。

* 数据流

  每个请求或响应的所有数据包，称为一个数据流。

* 头信息压缩

  头信息使用 gzip或 compress 压缩后再发送；客户端和服务器会同时维护一张头信息表，所有字段都会存入这张表，并生成
  一个索引号，对于相同字段，只发送索引号。

* 服务器推送

  允许服务器未经请求，主动向客户端发送资源。

---

---
url: /interview-question/ynqkgvbf/index.md
---
# 响应式原理
[![vue@2](https://img.shields.io/badge/vue-%402-brightgreen)](https://cn.vuejs.org/)

::: tip 提问

1. 简单介绍一下Vue2的响应式原理

:::

* Vue会将传入`data` 选项的普通javascript对象，对它的所有 `property` 进行遍历，
  并使用 `Object.defineProperty` 把这些 `property` 全部转换为 `getter/setter`。

* Vue 通过 `getter/setter` 来实现监听数据的变化，通过 `getter` 进行依赖收集，通过`setter`观察数据变化。

* Vue 的每个组件实例，都对应一个 `Watcher` 实例，`Watcher` 会在组件渲染过程中，把 "接触" 过的数据 property
  记录为依赖，当依赖项的 `setter` 触发时，会通知 `Watcher` ,使关联的组件重新渲染。

* Vue 更新 DOM 是异步的，Vue 会开启一个队列，在同一个事件循环中，Vue会缓冲所有数据变更，
  如果同一个 `Watcher` 被触发多次，只会被推入到队列一次。在下一个事件循环`tick`中，
  Vue刷新队列并执行实际的工作。这种异步方式，可以去除重复的数据，可以避免不必要的计算和DOM的操作。

由于 Vue2 是通过 `Object.defineProperty` 实现的 数据劫持，

* 无法检测对象是否有新增和删除 `property`

  需要通过 `this.$set` 来添加为对象添加新的`property`，或者重新进行变量的对象赋值。

* 无法检测通过数组下标进行的赋值操作，无法检测 通过 `length` 修改数组长度

  需要通过 `this.$set` 为数组的子元素重新赋值，或者用 splice 方法替换子元素

* 需要对数组的方法进行重写，实现对数组的数据监听

---

---
url: /interview-question/yrfvyyod/index.md
---
# 组件通信方式
[![vue@3](https://img.shields.io/badge/vue-%403-brightgreen)](https://staging-cn.vuejs.org/)

::: tip 提问
vue3 有哪几种组件通信方式？
:::

在vue2 中能够使用的 组件通信方式，在 vue3 中同样的都能够使用，但有部分有区别，同时，还扩展了其他的通信方式

[vue2 组件通信方式](/interview-question/1ryrldbc/)

## 组件通信方式

::: info
仅列出跟vue2有区别的部分，以及新增的方式
:::

### $parent / refs / expose

相比于 vue3 ，vue2 删除了 `$children` ，可以使用 `refs` 获取子组件的实例。

子组件还可以通过 `expose` 选项 控制允许哪些内容暴露给父组件

适用场景：

* 父子组件通信

### $attr

在 vue3 中， 已经移除了 `$listener`， 并将其合并到了 `$attr` 中，所以可以直接使用 `attr`向后代组件传递数据

### 共享响应式对象

使用 `reactive` 创建一个响应式对象，并在不同组件中导入它。

这种方式可以创建一个简单的共享状态管理， 但由于任何导入它的组件都可以对其进行修改，这种做法不好维护。
而且仅适用于纯客户端前端页面，如果需要使用 `SSR`，那么这种方式可能会导致 **跨请求状态污染**

适用场景：

* 父子组件通信
* 兄弟组件通信
* 隔代组件通信

这种方式虽然可以进行各种组件间关系的通信，但不适合用于有复杂变更状态的场景。

### Pinia

一个 替代 `Vuex` 的 状态管理库。

---

---
url: /interview-question/z7aq1w36/index.md
---
# 代码检查工具
::: tip 提问

1. eslint
2. prettier
3. stylelint

:::

## eslint

eslint 是一个 javascript 代码风格检查工具，提供了完全插件化的模式，允许自定义各种各样的规则。

比较通用的开源配置有：

* eslint-config-standard
* eslint-config-airbnb
* eslint-config-vue
* eslint-config-prettier

## prettier

prettier 是一个代码格式化工具，支持多数编程语言，prettier自身提供了一种通用代码风格，并仅支持少量的配置。
这样做的好处是，当选择prettier时，就已经选择了使用它的代码风格，避免了团队成员再去纠结代码风格的某些规则。

## stylelint

stylelint 是一个 类似于 eslint 的专注于 css 代码风格检查工具。

同时还支持对 LESS、 SCSS 的代码风格检查

## 使用

过去在使用 以上的 代码风格工具时，比如在 使用 webpack作为构建工具的项目中，会通过 webpack plugin 或 loader，将
代码风格工具内置到 开发时进行实时检查，每次对代码的修改，都会通过 webpack plugin 或 loader 调用 工具进行代码检查。

但是这样做带来了不必要的开发时时间开销。

目前个人在使用时，不再 通过 webpack plugin 去添加 代码风格检查支持。 而是借助于 编辑器插件，已经 git hook。

比如，在 VSCode 中安装 eslint、prettier、stylelint 插件，并设置在文件修改时对当前文件进行检查。
这样的好处是，不影响 webpack的开发时编译速度，更好的利用 VSCode相关插件的错误提示支持。

再利用 git hook，在 pre-commit 阶段启动 代码风格检查工具，对整个项目进行检查，通过后再提交和推送。

---

---
url: /interview-question/z7vgfuwo/index.md
---
# 指令
[![vue@2](https://img.shields.io/badge/vue-%402-brightgreen)](https://cn.vuejs.org/)

::: tip 提问

1. 什么是指令？
2. 如何自定义指令？

:::

## 指令

指令是用于 封装对于底层DOM元素的操作。

## 自定义指令

使用 `Vue.directive()` 注册全局自定义指令，也可以在 组件示例的 directives 注册局部自定义指令。

指令提供了五个钩子函数

* `bind` 指令第一次绑定到元素时调用
* `inserted` 被绑定元素第一次插入到父节点时调用
* `update` 所在组件的 VNode 更新时调用
* `componentUpdated` 指令所在组件的VNode及其子VNode全部更新后调用
* `unbind` 指令与元素解绑时调用，只调用一次。

---

---
url: /interview-question/zs2xi1mk/index.md
---
# 对浏览器的理解
::: tip 提问

1. 说说你对浏览器的理解

:::

浏览器的主要功能是将用户选择的web资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，
资源的格式通常是 HTML， 也包括 PDF、image 以及其他格式，
用户使用 URI（Uniform Resource Identifier 统一资源标志符）来制定请求资源的位置。

HTML 和 CSS 规范中规定了浏览器解释html文档的方式，由W3C组织对这些规范进行维护，
W3C是负责制定web标准的组织。

但是浏览器厂商 对规范的遵循并不完善，且有各自的扩展和补充，这为web开发带来了严重的兼容性问题。

浏览器可以分为两个部分，shell 和 内核。

* shell 指浏览器的外壳，例如菜单、工具栏等。
  主要是给用户提供用户界面操作，参数设置等，它是调用内核来实现各种功能的。

* 内核 是浏览器的核心。内核是基于标记语言显示内容的程序或模块。

也有一些浏览器并不区分外壳和内核，从 mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。

---

---
url: /learn-rust/index.md
---
# rust学习简记
阅读 `《Rust Course》`， 以及 `《Rusty Book》` 所做的简要笔记。

> [Rust Course](https://course.rs/basic/variable.html)
>
> [Rusty Book](https://rusty.rs/about.html)

---

---
url: /learn-rust/array/index.md
---
# 数组
在 Rust 中， 常用的数组有两种：

* `array` 速度很快但长度固定
* `Vector` 可动态增长但有性能损耗

## array

将多个类型相同的元素依次组合在一起，就是一个数组。

* 长度固定
* 元素必须具有相同的类型
* 依次线性排列

*这里说的数组是 Rust 的基本类型，是固定长度的，这点与其他编程语言不同，其它编程语言的数组往往是可变长度的，与 Rust 中的动态数组 `Vector` 类似。*

### 创建数组

```rust
fn main() {
  let arr1 = [1, 2, 3, 4];
  // 创建一个长度为 3，每个元素都为 1 的数组
  let arr2 = [1; 3];
  // 声明数组类型， 格式 [type; length]
  let arr3: [i32; 3] = [1, 2, 3];
}
```

### 访问数组

使用 `arr[index]` 下标，访问数组元素

```rust
fn main() {
  let arr = [1, 2, 3, 4];
  let a = arr[0]; // 1
  let b = arr[3]; // 4
}
```

数组不允许 **越界访问** ，如果发生越界，Rust会出现 **panic** 。

### 数组切片

**数组切片** 是对数组的部分引用。

```rust
fn main() {
  let arr: [i32; 5] = [1, 2, 3, 4, 5];
  let slice1: &[i32] = &arr[1..3]; // 创建已有数组的切片
  let slice2: &[i32; 3] = &[1, 2, 3]; // 创建固定长度数组切片
  let slice3: &[i32] = &[1, 2, 3, 4];  // 创建长度不固定的数组切片
}
```

* 切片的长度可以与数组不同，并不是固定的，而是取决于你使用时指定的起始和结束位置
* 创建切片的代价非常小，因为切片只是针对底层数组的一个引用
* 切片类型 `[T]` 拥有不固定的大小，而切片引用类型`&[T]`则具有固定的大小，因为 `Rust` 很多时候都需要固定大小数据类型，因此`&[T]`更有用,`&str`字符串切片也同理

---

---
url: /learn-rust/base-type/index.md
---
# 基本类型
**基本类型** 指一个最小化原子类型，无法解构为其他类型(一般意义上)，包括：

* 数字类型
  有符号整数 (`i8`, `i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`)
* 字符串
  字符串字面量和字符串切片 `&str`
* 布尔类型
  `true` 和`false`
* 字符类型
  表示单个 Unicode 字符，存储为 4 个字节
* 单元类型
  即 `()`  ，其唯一的值也是 `()`

---

---
url: /learn-rust/borrowing/index.md
---
# 引用与借用
## 借用

借用（borrowing） 是指，获取变量的引用。

## 引用与解引用

在Rust中，通过 `&` 进行引用， 通过 `*` 进行解引用。

```rust
fn main() {
  let x = 5;
  let y = &x; // 此时 y 是一个 引用

  assert_eq!(5, x);
  // 对引用类型进行解引用运算，访问y所指向的整数类型
  // 如果不进行解引用，则会得到编译错误
  assert_eq!(5, *y);
}
```

## 不可变引用

不可变引用 仅允许使用值，但不获取所有权。

当引用离开作用域后，其指向的值也不会被丢弃。

```rust
fn main() {
  let s1 = String::from("aa");

  let len = get_str_len(&s1);

  println!("the length of '{}' is {}", s1, len);
}

fn get_str_len(s: &String) -> usize {
  s.len()
} // 在这里 s 离开了作用域，但它不拥有引用值的所有权，所以什么也不会发生
```

## 可变引用

可变引用通过 `&mut` 声明：

```rust
fn main() {
  let mut s = String::from("hello"); // 创建一个可变字符串

  change_str(&mut s); // 传入一个可变引用

  println!("{}", s);
}

fn change_str(s: &mut String) { // s 是一个 可变引用
  s.push_str(", world"); // 插入新的字符串切片
}
```

* 同一个作用域，特定数据只能有一个可变引用
* 同一个值的可变引用和不可变引用不可以同时存在
* 引用必须总是有效的 （即不能引用已经被释放的值）

---

---
url: /learn-rust/cargo/index.md
---
# Cargo
## 包管理器

`cargo` 是 `rust` 的包管理工具。在安装 `rustup` 时已经一并安装完成，可直接使用。
`cargo` 提供了一系列的工具，从项目的建立、构建、测试、运行、到部署，为 `rust` 项目提供了尽可能完善的工具。

## Cargo.toml

`Cargo.toml` 是 `cargo` 特有的项目数据描述文件。它存储了项目的所有元配置信息，如果 `Rust` 开发者希望 `Rust` 项目能够按照期望的方式进行构建、测试和运行，那么，必须按照合理的方式构建 `Cargo.toml`。

### package 配置

package 中记录了项目的描述信息

```toml
[package]
name = "package_name" # 项目名称
version = "0.1.0" # 版本号
edition = "2021" # rust 版本
```

### 项目依赖

在 `Cargo.toml` 中，主要通过各种依赖段落来描述该项目的各种依赖项：
基于 Rust 官方仓库 [crates.io](https://crates.io)，通过版本说明来描述
基于项目源代码的 git 仓库地址，通过 URL 来描述
基于本地项目的绝对路径或者相对路径，通过类 Unix 模式的路径来描述

```toml
[dependencies]
rand = "0.3"
hammer = { version = "0.5.0" }
color = { git = "https://github.com/bjz/color-rs" }
geometry = { path = "crates/geometry" }
```

## Cargo.lock

`Cargo.lock` 文件是 `cargo` 工具根据同一项目的 toml文件生成的项目依赖详细清单，因此我们一般不用修改它

## 常用命令

[官方文档](https://doc.rust-lang.org/stable/cargo/commands/index.html)

### `cargo new <package-name>  [options]`

创建一个新的 rust 项目。

`package-name` ： 包名

`options`:

* `--bin` 创建一个 bin 类型的可运行的项目，默认类型
* `--lib` 创建一个 lib 类型的依赖库项目
* `--edition [eidtion]` 指定要使用的 rust 版本，默认为 2021。可选值包括：2015, 2018, 2021
* `--name [name]` 设置项目名称。默认为 目录名
* `--vcs [vcs]` 设置使用的版本管理工具，默认为 git。可选值为：git, hg, pijul, fossil
* `--registory [registory]` 设置源

**示例:**

```sh
cargo new new_package
```

### `cargo init [options]`

与 `cargo new` 命令类似，但是是在当前目录中初始化创建一个 `rust` 项目。

`options` 与 `cargo new` 命令相同。

### `cargo run [options] [— args]`

运行一个 `bin` 类型或 `example` 的本地 `rust package`。

`run` 命令是编译速度优先，不会对代码进行优化，牺牲了运行速度，换取 package 尽快编译完成然后启动，适合在开发时进行调试时使用。

`--` ： 分隔命令行参数，`—` 后面的参数会传递给当前运行的 `package`

`options` (常用):

* `--release, -r` 编译为`release`版本
* `--profile [name]` 获取调试信息

### `cargo build`

编译 当前 `package，以及它的所有依赖库` 。

### `cargo check`

快速检查当前代码是否能够编译通过

### cargo add

添加新的 依赖库 到 `Cargo.toml manifest file`

* `cargo add [options] crate...` 从 [crate.io](https://crate.io) 安装指定的依赖库
* `crate@version` 添加指定版本的 依赖库
* `cargo add [options] --path path` 从指定的 `path` 安装依赖库
* `cargo add [options] --git git` 从 指定的 `git` 地址 安装依赖库

---

---
url: /learn-rust/char-bool/index.md
---
# 字符,布尔,单元类型
## 字符

Rust 中的 字符 只能通过 `''` 来表示。

> `""` 是Rust中用于表示 字符串的。和 `''` 二者不能混用。

Rust 的字符不仅仅是 `ASCII` ，所有的 `Unicode` 值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型。`Unicode` 值的范围从 `U+0000 ~ U+D7FF` 和 `U+E000 ~ U+10FFFF`。

由于 `Unicode` 都是 4 个字节编码，因此字符类型也是占用 4 个字节：

```rust
fn main() {
  let x = 'x';
  let y = '人';
  let z = '😻';
}
```

## 布尔

Rust 中的布尔类型有两个可能的值：`true` 和 `false` ， 布尔值占用内存的大小为 `1` 个字节。

```rust
fn main() {
  let truely = true;
  let falsely: bool = false;
}
```

## 单元

单元类型就是 `()` ， 其唯一的值也是 `()` 。

函数 `main` 的返回值就是 `()`

单元的作用，比如： `()` 可以作为 map 的值，表示不关注 map 的值，只关注 key。它作为值的占位，但不会占用内存。

---

---
url: /learn-rust/compound-type/index.md
---
# 复合类型
复合类型指，由其他类型组合而成的类型，如：

* 结构体 Struct
* 枚举 enum
* 数组 array
* 字符串 String

---

---
url: /learn-rust/editor-extension/index.md
---
# 编辑器扩展
推荐使用 vs code 编辑器，
并安装 [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer) 扩展。

---

---
url: /learn-rust/enum/index.md
---
# 枚举
枚举(enum 或 enumeration)允许你通过列举可能的成员来定义一个**枚举类型。**

```rust
enum PokerSuit {
  Clubs,
  Spades,
  Diamonds,
  Hearts,
}
```

**枚举类型是一个类型，它会包含所有可能的枚举成员, 而枚举值是该类型中的具体某个成员的实例。**

## 枚举成员实例

通过 `::` 操作符访问具体成员

```rust
let clubs = PokerSuit::Clubs;
```

## 枚举值

声明枚举值类型

```rust
enum PokerSuit {
  Clubs(u8),
  Spades(u8),
  Diamonds(u8),
  Hearts(u8),
}

let clubs_8 = PokerSuit::Clubs(8);
```

**任何类型的数据都可以放入枚举成员中** : 例如字符串、数值、结构体甚至另一个枚举。

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let m1 = Message::Quit;
    let m2 = Message::Move{x:1,y:1};
    let m3 = Message::ChangeColor(255,255,0);
}
```

## 枚举泛型

泛型参数 `T` ，声明该枚举成员类型为 `T`， `T` 可以是任意类型

```rust
enum AnyWay<T> {
  Any(T),
  Nothing,
}

fn main() {
  let any: AnyWay<i32> = AnyWay::Any(8);
}
```

## Option 枚举

```rust
enum Option<T> {
  Some(T), // 表示含有值
  None, // 表示没有值
}
```

可用于处理 没有有效值 的场景。

---

---
url: /learn-rust/function/index.md
---
# 函数
```rust
fn add(i: i32, j: i32) -> i32 {
  i + j
 }
```

::: center
![Untitled](/images/rust-untitled.png)
:::

## 函数要点

* 函数名和变量名使用 **蛇形命名法** 例如 `fn add_two() -> {}`
* 函数的位置可以随便放，rust不关心我们在哪里定义了函数
* 每个函数参数都需要标注类型

## 函数返回

* 函数的返回值就是函数的最后一条 **表达式** 的返回值
* 也可以使用 `return` 提前返回

**特殊返回类型:**

* 无返回值 `()`
  函数没有返回值，那么返回一个 `()`
  通过 `;` 结尾的表达式返回 `()`

---

---
url: /learn-rust/install/index.md
---
## 在 Linux或 MacOS 上安装

终端中输入如下命令：

```sh
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
```

这个命令将会下载一个脚本，并开始安装最新版本的 `rustup` 工具。

安装成功，将有如下提示：

```sh
Rust is installed now. Great!
```

### 安装C编译器（非必须）

`rust` 依赖 `libc` 和 链接器 `linker` 。如果遇到提示链接器无法执行的错误，需要再手动安装一个C语言编译器：

**MacOS下**：

```sh
xcode-select --install
```

**Linux下**：

根据Linux的发行版来安装 GCC 或 Clang

## 在 windows上安装

windows 上安装需要 `C++` 环境：

1. 先安装 [Microsoft C++ Build Tools](https://visualstudio.microsoft.com/zh-hans/visual-cpp-build-tools/) ，勾选 `C++` 环境即可；

2. 安装完成后，Rust 所需的 `msvc` 命令行程序需要手动添加到环境变量中，
   否则安装 Rust 时 `rustup-init` 会提示未安装 Microsoft C++ Build Tools，
   其位于：`%Visual Studio 安装位置%\VC\Tools\MSVC\%version%\bin\Hostx64\x64`（请自行替换其中的 `%Visual Studio 安装位置%`、`%version%` 字段）下。

   如果你不想这么做，可以选择安装 **Microsoft C++ Build Tools** 新增的“定制”终端
   `Developer Command Prompt for %Visual Studio version%` 或 `Developer PowerShell for %Visual Studio version%` ，在其中运行 `rustup-init.exe` 。

3. 在 [RUSTUP-INIT](https://www.rust-lang.org/learn/get-started) 下载系统相对应的 Rust 安装程序，一路默认即可

## 检查安装是否成功

在终端中输入以下命令：

```bash
rustc -V
# rustc 1.64.0 (a55dd71d5 2022-09-19)
cargo -V
# cargo 1.64.0 (387270bc7 2022-09-16)
```

## 卸载

在终端中执行以下命令：

```sh
rustup self uninstall
```

---

---
url: /learn-rust/number-type/index.md
---
# 数字类型
在Rust 中， 数字类型主要分为 **整数类型** 和 **浮点类型。**

* 类型定义的形式： **有无符号** + **类型大小(位数)**
* **无符号数** 只能取正数， **有符号数** 既可以取正数也可以取负数

## 整数类型

整数是指没有小数部分的数字。在Rust中，内置了如下的整数类型：

| 长度       | 有符号类型 | 无符号类型 |
| ---------- | ---------- | ---------- |
| 8位        | i8         | u8         |
| 16位       | i16        | u16        |
| 32位       | i32        | u32        |
| 64位       | i64        | u64        |
| 128位      | i128       | u128       |
| 视架构而定 | isize      | usize      |

* 每个有符号类型规定的数字，取值范围为 : $-(2^{n-1})$ ~ $2^{n-1} -1$ ，其中 `n` 为位长度。
  如 `i8` 可存储数字范围为 **-128 ~ 127**
* 每个无符号类型规定的数字，取值范围为 0 ~ $2^n-1$ ，其中 `n` 为位长度。
  如 `u8` 可存储数字范围为 **0 ~ 255**
* `isize` 和 `usize` 取决于程序运行的计算机CPU类型：若CPU是 32位 的，则这两个类型的位数是 32位，同理，如CPU是64位，这两个类型位数为 64位
* 在Rust中，整型默认使用的类型是 `i32`

**整型字面量书写形式:**

| 数字字面量    | 示例        |
| ------------- | ----------- |
| 十进制        | 95\_232      |
| 十六进制      | 0xff        |
| 八进制        | 0o76        |
| 二进制        | 0b1111\_0000 |
| 字节(仅限 u8) | b’A'        |

### 整型溢出

如果一个 `u8` 类型的变量，被修改为超过了 **0 ~ 255** 范围的值，比如 256， 那么就会发生 **整型溢出**。

* debug模式下，Rust在编译时， 会检查整型溢出，若存在这个问题，则会导致程序在编译时崩溃（panic)
* release模式下，Rust在编译时，不检测溢出。当检查出溢出时，Rust 会按照补码循环溢出的规则处理：大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 `u8`的情况下，256 变成 0，257 变成 1，依此类推。
  程序不会被 panic ，但是该变量的值可能不是期望的值。

## 浮点类型

**浮点类型数字** 即 带小数点的数字。

在 Rust 中，浮点类型有两种基本类型： `f32` 和 `f64` 。

浮点数根据 `IEEE-754` 标准实现。`f32` 类型是单精度浮点型，`f64` 为双精度。

### NaN

对于数学上未定义的结果，例如对负数取平方根 `-42.1.sqrt()`  ，会产生一个特殊的结果：Rust 的浮点数类型使用 `NaN`  (not a number)来处理这些情况。

**所有跟 `NaN` 交互的操作，都会返回一个 `NaN` 。**

## 序列

Rust提供了一种简洁的方式，用于生成连续的数值：

`1..5` 表示 生成 `1, 2, 3, 4` 的数字

`1..=5` 表示 生成 `1, 2, 3, 4, 5` 的 数字。

序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，
字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。

---

---
url: /learn-rust/ownership/index.md
---
# 所有权
## 所有权原则

* Rust中每一个值都被一个变量所拥有，该变量被称为值的所有者
* 一个值只能同时被一个变量所拥有，或者说一个值只能有一个拥有者
* 当所有者（变量）离开作用域时，这个值将被抛弃（drop）

## 所有权转移

```rust
let s1 = String::from("hello");
let s2 = s1;
```

**当 `s1` 赋予 `s2` 后，Rust 认为 `s1` 不再有效，因此也无需在 `s1` 离开作用域后 `drop` 任何东西，这就是把所有权从 `s1` 转移给了 `s2`，`s1` 在被赋予 `s2` 后就马上失效了**。

---

---
url: /learn-rust/statement/index.md
---
# 语句和表达式
## 语句和表达式

Rust 中，函数体是由一系列 **语句** 组成，最后由一个 **表达式** 来返回值。

> 在 Rust 语言中，基于 **语句(statement)** 和 **表达式(expression)** 的方式是非常重要的，需要明确区分这两个概念。

```rust
fn main() {
  let a = 1; // 语句
  a + 2      // 表达式
}
```

## 语句

**语句** 指： **完成了某一个具体的操作，但不会产生返回值**

示例：

```rust
let a = 1;
let v: Vec<i32> = Vec::new();
let (b, c) = ("Mark", false);
```

## 表达式

* **表达式** 总是要返回值
* **表达式** 不能包含 **分号**

**表达式** 例子：

* 调用 **函数**
* 调用 **宏** 一个表达
* 用花括号包括最终返回一个值的语句块

示例

```rust
fn main() {
  let x = 1;
  // { ... } 语句块是表达式
  let y = {
    let z = 2;
    x * z
  };
  // add(y, 2) 是表达式
  let s = add(y, 2);
  // 用 if 语句块，类似于三元运算， 是表达式
  let g = if s % 2 === 1 { "odd" } else { "even" };
}

fn add(a: i32, b:i32) -> i32 {
  a + b
}
```

---

---
url: /learn-rust/string-slice/index.md
---
# 字符串与切片
## 切片

**切片** 是对集合中的部分引用 。

**字符串切片** 即是 对字符串类型的部分引用

**字符串字面量** 即 **字符串切片**

```rust
fn main() {
  let s: &str = "hello world"; // 字符串字面量即字符串切片，类型为 &str

  let s1 = String::from("hello world");
  let s2: &str = &s1[0..5]; // 切片通过 Range序列 引用
  let s3: &str = &s1[..5]; // 如果起始位是 0，可以省略
  let s4: &str = &s1[6..]; // 如果结尾是字符串结尾，可以省略

  println!("s2: {}, s3: {}, s4: {}", s2, s3, s4);
}
```

## 字符串

字符串是由字符组成的连续集合。

**Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)**，这样有助于大幅降低字符串所占用的内存空间。

Rust 在语言级别，只有一种字符串类型： `str`，它通常是以引用类型出现 `&str`，也就是上文提到的字符串切片。虽然语言级别只有上述的 `str` 类型，但是在标准库里，还有多种不同用途的字符串类型，其中使用最广的即是 `String` 类型。

`str` 类型是硬编码进可执行文件，也无法被修改，但是 `String` 则是一个可增长、可改变且具有所有权的 UTF-8 编码字符串，**当 Rust 用户提到字符串时，往往指的就是 `String` 类型和 `&str` 字符串切片类型，这两个类型都是 UTF-8 编码**。

---

---
url: /learn-rust/struct/index.md
---
# 结构体
## 定义

* 通过关键词 `struct` 定义
* 一个清晰明确的结构体 **名称**
* 几个有名字的结构体 **字段**

```rust
struct User {
  name: String,
  age: u8,
  email: String,
}
```

## 创建实例

```rust
let user1 = User {
  name: String::from("zhangsan"),
  age: 20,
  email: String::from("zhangsan@email.com"),
};
```

* 初始化实例时，每个字段都需要进行初始化
* 初始化实例时，字段顺序不需要和结构体定义时保持一致

## 访问结构体实例

通过 `.` 操作符访问实例：

```rust
let mut user1 = User {
  name: String::from("zhangsan"),
  age: 20,
  email: String::from("zhangsan@email.com"),
};
user1.name = String::from("lisi");
```

* 必须要将结构体实例声明为可变的，才能修改实例的字段
* 不支持将结构体实例的某个字段单独声明为可变的

## 更新结构体实例

可以通过 **结构体更新语法** 进行更新

```rust
let user2 = User {
  name: String::from("wangwu"),
  ..user1  // 注意末尾不需要加 逗号
};
```

`..` 语法表明了 当前实例未被显式声明的字段，都从 `user1` 中获取。

`..` 语法必须放在 结构体的尾部

## 元组结构体

结构体必须要有名称，但是结构体的字段可以没有名称，这种结构体长得很像元组，因此被称为元组结构体

```rust
struct Point(i32, i32, i32);
struct Color(i32, i32, i32);

fn main() {
  let point = Ponit(0, 0, 0);
  let color = Color(0, 0, 0);
}
```

## 单元结构体

类似于 **单元类型** 。定义一个类型，但是不关心该类型的内容, 只关心它的行为时，就可以使用 `单元结构体`

```rust
struct AlwaysEqual;

let subject = AlwaysEqual;

// 我们不关心 AlwaysEqual 的字段数据，只关心它的行为，因此将它声明为单元结构体，然后再为它实现某个特征
impl SomeTrait for AlwaysEqual {

}
```

---

---
url: /learn-rust/tuple/index.md
---
# 元组
元组是由多种类型组合到一起形成的，因此它是复合类型，元组的长度是固定的，元组中元素的顺序也是固定的。

```rust
fn main() {
  let tup: (i32, u32, String) = (10, 20, String::from("hello"));
  println!("{:?}", tup);
}
```

### 模式匹配解构元组

```rust
fn main() {
  let tup: (i32, u32, String) = (10, 20, String::from("hello"));
  let (x, y, s) = tup;
  println!("{}, {}, {}", x, y, s);
}
```

### 用 `.` 访问元组

```rust
fn main() {
  let tup: (i32, u32, String) = (10, 20, String::from("hello"));
  println!("{}, {}, {}", tup.0, tup.1, tup.2);
}
```

---

---
url: /learn-rust/type-inference/index.md
---
# 类型推导
Rust 是一门 静态类型语言。

编译器必须在编译器知道我们所有变量的类型，但这并不意味着需要为每个变量指定类型。

因为 **Rust 编译器很聪明，它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型**
，同时编译器也不够聪明，在某些情况下，它无法推导出变量类型，需要手动去给予一个类型标注。

---

---
url: /learn-rust/variable/index.md
---
# 变量
## 声明变量

在 Rust 中， 通过 `let` 关键字声明变量。

## 变量命名

在命名方面，与其他语言没有区别，但是需要遵循 [Rust 命名规范](https://www.notion.so/d6508ec305c44193b2d36fd0ce5e84bb)

## 变量绑定

在其他语言， `var a = 'hello'` 表示将 字符串 `hello` 赋值给了变量 `a` 。

在 Rust中， `let a = 'hello'` ，这个过程被称为 变量绑定。

使用 **绑定** 而不是 **赋值** ,是因为涉及了 Rust 的核心原则 —— **所有权** 。

::: tip 所有权
简单来说，任何内存对象都是有主人的，而且一般情况下完全属于它的主人，绑定就是把这个对象绑定给一个变量，让这个变量成为它的主人。
:::

## 变量可变性

Rust 的变量默认是 **不可变** 的。 这是 Rust 的特性之一，让我们编写的代码更安全、性能也更好。

如果变量 `a` 是不可变的，那么它一旦被绑定值，那么就不能再被修改

但也可以通过 关键字 `mut` 使变量变为 **可变的** 。

**示例1**：不可变变量

```rust
let a = 5;
println!("a: {}", a);
a = 6;
println!("a: {}", a);
```

使用 `cargo run` 运行，将会抛出一个 **cannot assign twice to immutable variable `a` \`** 的错误提示。

**示例2**：可变变量

```rust
let mut a = 5;
println!("a: {}", a);
a = 6;
println!("a: {}", a);
```

运行程序将得到以下结果：

```sh
a: 5
a: 6
```

## 使用下划线开头忽略未使用变量

如果创建了一个变量，但是却没有使用它，Rust会给出一个警告，因为这可能是一个Bug。

但有时候创建未使用的变量可能是有用的，这时你希望Rust不要警告未使用的变量，那么可以 **使用下划线作为变量名开头** ：

```rust
fn main() {
  let x = 1;
  let _y = 2;
}
```

这时，Rust 只会警告 变量 `x` 未被使用，而不会警告变量 `_y` 未被使用。

## 变量结构

`let` 表达式不仅可以用于 变量绑定，还可以用于复杂的变量解构。

**变量结构** 是指，从一个相对复杂的变量中，匹配出变量的一部分内容。

```rust
let (a, mut b): (bool, bool) = (true, false);
// a 不可变， b 可变
println!("a: {:?}, b: {:?}", a, b);
```

### 解构式赋值

赋值语句左边可以使用 **元组**， **切片** ， **结构体模式** 。

```rust
let (a, b, c, d, e);
(a, b) = (1, 2); // 元组
[c, .., d, _] = (1, 2, 3, 4, 5); // 切片

struct Struct {
 e: i32
}
Struct { e, .. } = Struct { e: 5 }; // 结构体模式

println!("{:?} {:?} {:?} {:?} {:?}", a, b, c, d, e)
// 1 2 1 4 5
```

## 常量

在 Rust 中，通过 `const` 声明常量。

并且常量的必须标注值的类型。

## 变量遮蔽

Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的变量：

```rust
fn main() {
  let x = 1;
  // 在 之前的 x 进行变量遮蔽
  let x = x + 2; // 遮蔽前可以使用 之前的变量 x 的值
  // x 值为 3
  {
    let x = x + 2; // 在块级作用域内对 之前的 x 进行遮蔽
    // x 值为 5
  }
}
```

变量遮蔽不同于使用 `mut` 声明的可变变量，第二个 `let` 声明生成的是完全不同的变量，只是拥有相同的变量名，是一次内存对象的再分配，而 `mut` 声明的变量，修改的是同一个内存地址上的值，并不会发生内存对象的再分配。

变量遮蔽的用处在于，如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。

---

---
url: /memorandum/index.md
---
# 备忘录

---

---
url: /memorandum/cargo/index.md
---
```sh :no-line-numbers
# 显示版本信息以确认 Cargo 已安装
cargo version
# 创建新项目 二进制程序

cargo new --bin
# 创建新项目 库
cargo new --lib

# 在项目中运行单元测试
cargo test
# 快速编译项目，无需生成二进制文件来检查错误
cargo check
# 自动格式化代码
cargo fmt
# 编译一个项目
cargo build
# 一步编译和运行项目
cargo run
# Linter 检查错误
cargo clippy --all-targets -- --D warnings
# 检查代码覆盖率
cargo tarpaulin --ignore-tests
```

## 安装/升级

适用于 Linux 和  MacOS

```sh :no-line-numbers
curl -sSf https://static.rust-lang.org/rustup.sh | sh
```

在 Windows 中，下载 [rustup-init.exe](https://win.rustup.rs/) 并运行。

## 切换源

配置文件： `~/.cargo/config`

```toml
[source.crates-io]
registry = "https://github.com/rust-lang/crates.io-index"
replace-with = 'tuna' # 👈 如果需要提交包注释配置源

[source.tuna]
registry = "https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git"
# registry = "git://mirrors.ustc.edu.cn/crates.io-index"
```

切换源需要删除缓存目录

```sh :no-line-numbers
rm -rf ~/.cargo/.package-cache   # ⚠️ 删除缓存目录内容
```

---

---
url: /memorandum/git/index.md
---
## 分支

```sh :no-line-numbers
# 删除本地存在远程不存在的分支
git remote prune origin

# 删除已经合并到 master 的分支
git branch --merged master | grep -v '^\*\|  master' | xargs -n 1 git branch -d

# 查看远程分支和本地分支的对应关系
git remote show origin
```

## 提交

```sh :no-line-numbers
# 重写最后一次提交信息
git commit --amend -m "new message"

# 修改最新的提交而不更改提交消息
git commit --amend --no-edit
```

## 配置

```sh :no-line-numbers
# 获取配置帮助信息
git help config
# 配置全局用户名
git config --global user.name "name"
# 配置全局邮箱
git config --global user.email "email"
# 配置全局颜色，对 git 输出进行美化
git config --global color.ui auto
# 在文本编辑器中编辑全局配置文件
git config --global --edit
# 删除全局配置
git config --global --unset <entry-name>
# 查看本地 repo 配置
git config --list
```

### 解决中文乱码

```sh :no-line-numbers
git config --global core.quotepath false
```

不再将 文件权限变更 作为改动

```sh :no-line-numbers
git config core.fileMode false
```

### 设置大小写敏感

```sh :no-line-numbers
# 大小写敏感
git config --get core.ignorecase
# 远程有俩相同目录，通过这种方式清除掉，然后提交记录
git rm -r --cached <dirOrFile>
```

### 代理

```sh :no-line-numbers
# 查看代理
git config --global http.proxy
git config --global https.proxy
git config --global socks.proxy

# 设置代理
# 适用于 privoxy 将 socks 协议转为 http 协议的 http 端口
git config --global http.proxy http://127.0.0.1:1080
git config --global https.proxy http://127.0.0.1:1080
git config --global socks.proxy 127.0.0.1:1080

# 取消代理
git config --global --unset http.proxy
git config --global --unset https.proxy
git config --global --unset socks.proxy

# 只对 github.com 设置代理
git config --global http.https://github.com.proxy socks5://127.0.0.1:1080
git config --global https.https://github.com.proxy socks5://127.0.0.1:1080

# 取消 github.com 代理
git config --global --unset http.https://github.com.proxy
git config --global --unset https.https://github.com.proxy
```

## 统计查询

```sh :no-line-numbers
# 提交数统计
git log --oneline | wc -l
# 查看文件内容的提交者
git blame <file-name>
# 仓库总大小
git count-objects -vH
# 仓库大小
git ls-files | xargs -r du -hs
# 在 commit log 中查找内容
git log --all --grep='<given-text>'
```

### 查看 个人代码量

```sh :no-line-numbers
# username 需要修改为 个人用户名
git log --author="username" --pretty=tformat: --numstat | awk \
'{ add += $1; subs += $2; loc += $1 - $2 } END { printf "added lines: %s, removed lines: %s, total lines: %s\n", add, subs, loc }' -
```

### 每人增删行数

```sh :no-line-numbers
git log --format='%aN' | sort -u |\
  while read name; do echo -en "$name\t";\
  git log --author="$name" --pretty=tformat: --numstat | awk \
  '{ add += $1; subs += $2; loc += $1 - $2 } END { printf "added lines: %s, removed lines: %s, total lines: %s\n", add, subs, loc }' -; done
```

### 查看提交者排名

```sh :no-line-numbers
# 取前十个的排名
git log --pretty='%aN' | sort | uniq -c | sort -k1 -n -r | head -n 10
```

## submodule 子模块

```sh :no-line-numbers
# 添加包含子模块的仓库
git clone <repo_url> --recursive
# 查看当前仓库中的子模块
git submodule status

# 添加子模块
git submodule add <repo_url> <submodule_path>

# 初始化子模块
git submodule init

# 更新子模块
git submodule update --remote

# 删除子模块
git submodule deinit <path_to_submodule>
git rm <path_to_submodule>
```

切换到子模块的特定提交

```sh :no-line-numbers
cd <path_to_submodule>
git checkout <commit_hash>
```

切换到父仓库的特定提交，并更新子模块

```sh :no-line-numbers
git submodule update --remote
git checkout <commit_hash>
```

获取并切换子模块的最新标签

```sh :no-line-numbers
cd <path_to_submodule>
git fetch --tags
git checkout $(git describe --tags $(git rev-list --tags --max-count=1))
```

子模块递归

```sh :no-line-numbers
# 添加所有已存在的子模块
git submodule foreach --recursive git submodule add <repo_url>

# 更新所有子模块到最新提交
git submodule foreach --recursive git pull origin master

# 检出特定的子模块路径
git submodule foreach --recursive git checkout <branch_name>

# 获取仓库中的所有子模块变化
git submodule foreach --recursive git fetch

# 获取并合并子模块的远程分支
git submodule foreach --recursive git pull origin <branch_name>

# 将子模块还原到父仓库中的初始提交
git submodule foreach --recursive git checkout .

# 获取子模块的更新并忽略本地修改
git submodule foreach --recursive git fetch --all
git submodule foreach --recursive git reset --hard origin/master
```

---

---
url: /memorandum/git/emoji/index.md
---
# git emoji
## 概述

在 git 提交信息中受支持的 emoji 。

## 使用

**输入：**

```sh
git commit -m "feat: :rocket: add new feature"
```

**输出：**

```txt
feat: 🚀 add new feature
```

## emoji 列表

:::important 数据源 [gitmoji](https://github.com/carloscuesta/gitmoji)
:::

---

---
url: /memorandum/grep/index.md
---
# grep
## 参数

|                 |                                         | 说明                                                                                                 |
| --------------- | --------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| `-a`            | `--text`                                | 不要忽略二进制数据。                                                                                 |
| `-A <显示行数>` | `--after-context=<显示行数>`            | 除了显示符合范本样式的那一行之外，并显示该行之后的内容。                                             |
| `-b`            | `--byte-offset`                         | 在显示符合范本样式的那一行之外，并显示该行之前的内容。                                               |
| `-B <显示行数>` | `--before-context=<显示行数>`           | 除了显示符合样式的那一行之外，并显示该行之前的内容。                                                 |
| `-c`            | `--count`                               | 计算符合范本样式的列数。                                                                             |
| `-C <显示行数>` | `--context=<显示行数>` 或 `-<显示行数>` | 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。                                           |
| `-d<进行动作>`  | `--directories=<动作>`                  | 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。                 |
| `-e <范本样式>` | `--regexp=<范本样式>`                   | 指定字符串作为查找文件内容的范本样式。                                                               |
| `-E`            | `--extended-regexp`                     | 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。                                 |
| `-f <范本文件>` | `--file=<规则文件>`                     | 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。 |
| `-F`            | `--fixed-regexp`                        | 将范本样式视为固定字符串的列表。                                                                     |
| `-G`            | `--basic-regexp`                        | 将范本样式视为普通的表示法来使用。                                                                   |
| `-h`            | `--no-filename`                         | 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。                                           |
| `-H`            | `--with-filename`                       | 在显示符合范本样式的那一列之前，标示该列的文件名称。                                                 |
| `-i`            | `--ignore-case`                         | 忽略字符大小写的差别。                                                                               |
| `-l`            | `--file-with-matches`                   | 列出文件内容符合指定的范本样式的文件名称。                                                           |
| `-L`            | `--files-without-match`                 | 列出文件内容不符合指定的范本样式的文件名称。                                                         |
| `-n`            | `--line-number`                         | 在显示符合范本样式的那一列之前，标示出该列的编号。                                                   |
| `-P`            | `--perl-regexp`                         | PATTERN 是一个 Perl 正则表达式                                                                       |
| `-q`            | `--quiet或--silent`                     | 不显示任何信息。                                                                                     |
| `-R`/`-r`       | `--recursive`                           | 此参数的效果和指定“-d recurse”参数相同。                                                             |
| `-s`            | `--no-messages`                         | 不显示错误信息。                                                                                     |
| `-v`            | `--revert-match`                        | 反转查找。                                                                                           |
| `-V`            | `--version`                             | 显示版本信息。                                                                                       |
| `-w`            | `--word-regexp`                         | 只显示全字符合的列。                                                                                 |
| `-x`            | `--line-regexp`                         | 只显示全列符合的列。                                                                                 |
| `-y`            |                                         | 此参数效果跟“-i”相同。                                                                               |
| `-o`            |                                         | 只输出文件中匹配到的部分。                                                                           |
| `-m <num>`      | `--max-count=<num>`                     | 找到num行结果后停止查找，用来限制匹配行数                                                            |

## 规则表达式

```sh :no-line-numbers
^      # 锚定行的开始 如：'^grep'匹配所有以grep开头的行。
$      # 锚定行的结束 如：'grep$' 匹配所有以grep结尾的行。
.      # 匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。
*      # 匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。
.*     # 一起用代表任意字符。
[]     # 匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。
[^]    # 匹配一个不在指定范围内的字符，如：'[^A-Z]rep' 匹配不包含 A-Z 中的字母开头，紧跟 rep 的行
(..)   # 标记匹配字符，如'(love)'，love被标记为1。
<      # 锚定单词的开始，如:'<grep'匹配包含以grep开头的单词的行。
>      # 锚定单词的结束，如'grep>'匹配包含以grep结尾的单词的行。
x{m}   # 重复字符x，m次，如：'0{5}'匹配包含5个o的行。
x{m,}  # 重复字符x,至少m次，如：'o{5,}'匹配至少有5个o的行。
x{m,n} # 重复字符x，至少m次，不多于n次，如：'o{5,10}'匹配5--10个o的行。
\w     # 匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。
\W     # \w的反置形式，匹配一个或多个非单词字符，如点号句号等。
\b     # 单词锁定符，如: '\bgrep\b'只匹配grep。
```

---

---
url: /memorandum/nginx/index.md
---
## 服务管理

```sh :no-line-numbers
sudo systemctl status nginx  # nginx当前状态
sudo systemctl reload nginx  # 重新加载 nginx
sudo systemctl restart nginx # 重启nginx

sudo nginx -t   # 检查语法
nginx           # 启动
nginx -s reload # 重启
nginx -s stop   # 关闭进程
nginx -s quit   # 平滑关闭nginx
nginx -V        # 查看nginx的安装状态
```

## 全局变量

| 变量                | 说明                                                            |
| ------------------- | --------------------------------------------------------------- |
| `$args`             | 这个变量等于请求行中的参数，同 `$query_string`                  |
| `$remote_port`      | 客户端的端口                                                    |
| `$content_length`   | 请求头中的 `Content-length` 字段                                |
| `$remote_user`      | 已经经过 `Auth Basic Module` 验证的用户名                       |
| `$content_type`     | 请求头中的 `Content-Type` 字段                                  |
| `$request_filename` | 当前请求的文件路径，由 `root` 或alias指令与URI请求生成          |
| `$document_root`    | 当前请求在 `root` 指令中指定的值                                |
| `$scheme`           | HTTP方法（如http，https）                                       |
| `$host`             | 请求主机头字段，否则为服务器名称                                |
| `$hostname`         | 主机名                                                          |
| `$http_user_agent`  | 客户端`agent`信息                                               |
| `$http_cookie`      | 客户端`cookie`信息                                              |
| `$server_protocol`  | 请求使用的协议，通常是`HTTP/1.0`或`HTTP/1.1`                    |
| `$server_addr`      | 服务器地址，在完成一次系统调用后可以确定这个值                  |
| `$server_name`      | 服务器名称                                                      |
| `$server_port`      | 请求到达服务器的端口号                                          |
| `$limit_rate`       | 这个变量可以限制连接速率                                        |
| `$request_method`   | 客户端请求的动作，如 GET/POST                                   |
| `$request_uri`      | 包含请求参数的原始URI，不包含主机名，如：`/foo/bar.php?arg=baz` |
| `$remote_addr`      | 客户端的IP地址                                                  |
| `$uri`              | 不带请求参数的当前URI，`$uri`不包含主机名，如 `/foo/bar.html`   |
| `$document_uri`     | 与 `$uri` 相同                                                  |
| `$nginx_version`    | `nginx` 版本                                                    |

## 监听端口

```nginx :no-line-numbers
server {
  listen 80;      # 标准 HTTP 协议
  listen 443 ssl; # 标准 HTTPS 协议
  listen 443 ssl http2; # 对于 http2
  listen [::]:80; # 使用 IPv6 在 80 上收听
  # 仅收听使用 IPv6
  listen [::]:80 ipv6only=on;
}
```

## 域名 (server\_name)

```nginx :no-line-numbers
server {
  # 监听 example.com
  server_name example.com;
  # 监听多个域
  server_name example.com www.example.com;
  # 监听所有子域
  server_name *.example.com;
  # 监听所有顶级域
  server_name example.*;
  # 监听未指定的主机名（监听 IP 地址本身）
  server_name "";
}
```

## 负载均衡

### 简单实例

```nginx :no-line-numbers
upstream node_js {
  server 0.0.0.0:3000;
  server 0.0.0.0:4000;
  server 127.155.142.421;
}
```

### 权重

```nginx :no-line-numbers
upstream test {
  server localhost:8080 weight=9;
  server localhost:8081 weight=1;
}
```

### ip\_hash

解决负载均衡 `session` 的问题

```nginx:no-line-numbers {2}
upstream test {
  ip_hash;
  server localhost:8080;
  server localhost:8081;
}
```

### fair

响应时间短的优先分配

```nginx:no-line-numbers {2}
upstream backend {
  fair;
  server localhost:8080;
  server localhost:8081;
}
```

### url\_hash

按访问url的hash结果来分配请求

```nginx:no-line-numbers {2,3}
upstream backend {
  hash $request_uri;
  hash_method crc32;
  server localhost:8080;
  server localhost:8081;
}
```

### keepalive

激活缓存以连接到上游服务器

```nginx:no-line-numbers {4}
upstream memcached_backend {
    server 127.0.0.1:11211;
    server 10.0.0.2:11211;
    keepalive 32;
}
```

### server 可选参数

| 参数名         | 说明                             |
| -------------- | -------------------------------- |
| `weight`       | 访问权重数值越高，收到请求越多   |
| `fail_timeout` | 指定的时间内必须提供响应         |
| `max_fails`    | 尝试失败服务器连接的最大次数     |
| `down`         | 标记一个服务器不再接受任何请求   |
| `backup`       | 有服务器宕机，标记的机器接收请求 |

## 反向代理

```nginx :no-line-numbers
server {
  listen 80;
  server_name example.com;

  location / {
    proxy_pass http://0.0.0.0:3000;
    # 其中 0.0.0.0:3000 是绑定在
    # 0.0.0.0端口3000 列表上的 Node.js 服务器
  }
}
```

负载均衡 + 反向代理

```nginx :no-line-numbers
upstream node_js {
  server 0.0.0.0:3000;
  # 其中 0.0.0.0:3000 是绑定在
  # 0.0.0.0端口3000 列表上的 Node.js 服务器
}

server {
  listen 80;
  server_name example.com;

  location / {
    proxy_pass http://node_js;
  }
}
```

升级连接（适用于支持 WebSockets 的应用程序）

```nginx :no-line-numbers
upstream node_js {
  server 0.0.0.0:3000;
}

server {
  listen 80;
  server_name example.com;

  location / {
    proxy_pass http://node_js;
    proxy_redirect off;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;

  }
}
```

## 跨域

```nginx :no-line-numbers
server {
  listen 80;
  server_name api.xxx.com;

  add_header 'Access-Control-Allow-Origin' '*';
  add_header 'Access-Control-Allow-Credentials' 'true';
  add_header 'Access-Control-Allow-Methods' 'GET,POST,HEAD';

  location / {
    proxy_pass http://127.0.0.1:3000;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host  $http_host;
  }
}
```

重定向 URI

```nginx :no-line-numbers
upstream test {
  server 127.0.0.1:8080;
  server localhost:8081;
}
server {
  listen 80;
  server_name api.xxx.com;
  location / {
    root  html;                   # 去请求../html文件夹里的文件
    index  index.html index.htm;  # 首页响应地址
  }
  # 用于拦截请求，匹配任何以 /api/开头的地址，
  # 匹配符合以后，停止往下搜索正则。
  location ^~/api/{
    # 代表重写拦截进来的请求，并且只能对域名后边的除去传递的参数外的字符串起作用
    # 例如www.a.com/api/msg?meth=1&par=2重写，只对/api/msg重写。
    # rewrite后面的参数是一个简单的正则 ^/api/(.*)$，
    # $1代表正则中的第一个()，$2代表第二个()的值，以此类推。
    rewrite ^/api/(.*)$ /$1 break;

    # 把请求代理到其他主机
    # 其中 http://www.b.com/ 写法和 http://www.b.com写法的区别如下
    # 如果你的请求地址是他 http://server/html/test.jsp
    # 配置一： http://www.b.com/ 后面有“/”
    #         将反向代理成 http://www.b.com/html/test.jsp 访问
    # 配置一： http://www.b.com 后面没有有“/”
    #         将反向代理成 http://www.b.com/test.jsp 访问
    proxy_pass http://test;

    # 如果 proxy_pass  URL 是 http://a.xx.com/platform/ 这种情况
    # proxy_cookie_path应该设置成 /platform/ / (注意两个斜杠之间有空格)。
    proxy_cookie_path /platfrom/ /;

    # 设置 Cookie 头通过
    proxy_pass_header Set-Cookie;
  }
}
```

## 屏蔽 IP

```nginx :no-line-numbers
可以放到 http, server, location, limit_except 语句块

include blockip.conf;
在 blockip.conf 里面输入内容，如：

deny 165.91.122.67;

deny IP;            # 屏蔽单个 ip 访问
allow IP;           # 允许单个 ip 访问
deny all;           # 屏蔽所有 ip 访问
allow all;          # 允许所有 ip 访问
deny 123.0.0.0/8;   # 屏蔽整个段即从 123.0.0.1 到 123.255.255.254 访问的命令
deny 124.45.0.0/16; # 屏蔽IP段即从 123.45.0.1 到 123.45.255.254 访问的命令
deny 123.45.6.0/24; # 屏蔽IP段即从 123.45.6.1 到 123.45.6.254 访问的命令

# 如果你想实现这样的应用，除了几个IP外，其他全部拒绝
allow 1.1.1.1;
allow 1.1.1.2;
deny all;
```

## 代理转发重写路径

```nginx :no-line-numbers
location ^~/api/upload {
  rewrite ^/(.*)$ /wfs/v1/upload break;
  proxy_pass http://wfs-api;
}
```

## 图片防盗链

```nginx :no-line-numbers
location ~* \.(gif|jpg|png|swf|flv)$ {
  root html;

  valid_referers none blocked *.nginx.com;

  if ($invalid_referer) {
    rewrite ^/ www.nginx.cn;
    # return 404;
  }
}
```

## 屏蔽文件目录

```nginx :no-line-numbers
通用备份和归档文件

location ~* "\.(old|orig|original|php#|php~|php_bak|save|swo|aspx?|tpl|sh|bash|bak?|cfg|cgi|dll|exe|git|hg|ini|jsp|log|mdb|out|sql|svn|swp|tar|rdf)$" {
    deny all;
}
拒绝访问 .git 和 .svn 目录

location ~ (.git|.svn) {
    deny all;
}
拒绝访问隐藏文件和目录

location ~ /\.(?!well-known\/) {
    deny all;
}
```

## Gzip 配置

```nginx :no-line-numbers
gzip  on;
gzip_buffers 16 8k;
gzip_comp_level 6;
gzip_http_version 1.1;
gzip_min_length 256;
gzip_proxied any;
gzip_vary on;
gzip_types
    text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml
    text/javascript application/javascript application/x-javascript
    text/x-json application/json application/x-web-app-manifest+json
    text/css text/plain text/x-component
    font/opentype application/x-font-ttf application/vnd.ms-fontobject
    image/x-icon;
gzip_disable  "msie6";
```

---

---
url: /memorandum/pm2/index.md
---
## 启动

启动 node 进程

```sh :no-line-numbers
pm2 start app.js

pm2 ping # 确保 pm2 守护进程已经启动
```

启动其它应用程序

```sh :no-line-numbers
pm2 start bash.sh
pm2 start python-app.py --watch
pm2 start binary-file -- --port 1520
```

## 流程管理

```sh :no-line-numbers
pm2 restart app_name # 重启 app_name
pm2 reload app_name  # 重载 app_name
pm2 stop app_name    # 停止 app_name
pm2 delete app_name  # 删除 app_name
```

可以将 `app_name` 替换为：

* `all`: 表示所有进程
* `id`: 指定特定 id 的进程

## 检查状态

列出 PM2 的所有应用状态

```sh :no-line-numbers
pm2 [list|ls|status]

pm2 list        # 显示所有进程状态
pm2 jlist       # 以原始 JSON 格式打印进程列表
pm2 prettylist  # 以美化JSON打印进程列表
pm2 describe 0  # 显示有关特定进程的所有信息
```

## 日志

```sh :no-line-numbers
pm2 logs
pm2 logs --lines 200 # 旧日志
pm2 flush         # 清空所有日志文件
pm2 reloadLogs    # 重新加载所有日志
```

终端仪表板

```sh :no-line-numbers
pm2 monit
```

Web 的仪表板

```sh :no-line-numbers
pm2 plus
```

## 集群模式

```sh :no-line-numbers
# 0 / max 表示根据 CPU 数量启动多个进程
pm2 start app.js -i 0
pm2 start app.js -i max # 等同 0 ，已弃用
```

## 常用命令行参数

```sh :no-line-numbers
--name <app_name> # 指定应用名称
--watch # 监听文件更新并重启应用
--max-memory-restart <200MB> # 设置应用重新加载的最大内存阈值
--log <log_path> # 指定日志路径
--restart-delay <delay in ms> # 自动重启之间的延迟
--time # 带时间前缀的日志
--no-autorestart # 不自动重启
--cron <cron_pattern> # 指定 cron 强制重启
```

## 更新 PM2

```sh :no-line-numbers
npm install pm2@latest -g
pm2 update  # 更新内存中的 pm2
```

---

---
url: /memorandum/ssh/index.md
---
## 配置位置

| 位置                     |           说明 |
| :----------------------- | -------------: |
| `/etc/ssh/ssh_config`    | 系统范围的配置 |
| `~/.ssh/config`          | 用户特定的配置 |
| `~/.ssh/id_{type}`       |           私钥 |
| `~/.ssh/id_{type}.pub`   |           公钥 |
| `~/.ssh/known_hosts`     |       登录主机 |
| `~/.ssh/authorized_keys` |   授权登录密钥 |

## 执行远程命令

```sh :no-line-numbers
ssh root@192.168.1.5 'ls -l'

# 调用本地脚本
ssh root@192.168.1.5 bash < script.sh

# 从服务器压缩和下载
ssh root@192.168.1.5 "tar cvzf - ~/source" > output.tgz
```

## SCP

| 命令          |                      说明 |
| :------------ | ------------------------: |
| `scp -r`      |          递归复制整个目录 |
| `scp -C`      |                  压缩数据 |
| `scp -v`      |              打印详细信息 |
| `scp -P 8080` |              使用特定端口 |
| `scp -B`      | 批处理模式 *（防止密码）* |
| `scp -p`      |            保留时间和模式 |

从远程复制到本地

```sh :no-line-numbers
scp user@server:/dir/file.ext dest/
```

两台服务器之间的副本

```sh :no-line-numbers
scp user@server:/file user@server:/dir
```

从本地复制到远程

```sh :no-line-numbers
scp dest/file.ext user@server:/dir
```

复制整个文件夹

```sh :no-line-numbers
scp -r user@server:/dir dest/
```

复制文件夹中的所有文件

```sh :no-line-numbers
scp user@server:/dir/* dest/
```

从服务器文件夹复制到当前文件夹

```sh :no-line-numbers
scp user@server:/dir/* .
```

## keygen

```sh :no-line-numbers
ssh-keygen -t rsa -b 4096 -C "your@mail.com"
```

* `-t` 指定密钥类型, `rsa | ed25519 | dsa | ecdsa`
* `-b` 指定密钥长度
* `-C` 指定注释

指定文件名

```sh :no-line-numbers
ssh-keygen -f ~/.ssh/filename
```

从私钥生成公钥

```sh :no-line-numbers
ssh-keygen -y -f private.key > public.pub
```

更改私钥密码

```sh :no-line-numbers
ssh-keygen -p -f ~/.ssh/id_rsa
```

从 known\_hosts 搜索

```sh :no-line-numbers
ssh-keygen -F <ip/hostname>
```

从 known\_hosts 中删除

```sh :no-line-numbers
ssh-keygen -R <ip/hostname>
```

---

---
url: /note/vuepress-theme-plume/index.md
---
# vuepress-theme-plume
::: tip
主题说明文档已迁移至 <https://theme-plume.vuejs.press/>。

:::

---

---
url: /projects/index.md
---
# Projects
## 开源项目

### vite-plugin-mock-dev-server

**说明：**

`vite-plugin-mock-dev-server` 专注于在 `Vite` 开发环境下 提供 Mock 服务。
通过 vite 内置的 `http` 和 `http-proxy` 服务，以 `middleware` 的方式，对 `server.proxy` 配置的代理路径
进行二次拦截，命中规则后，返回配置的 `mock data` 。

你可以在 mock配置文件中使用`node` 任意第三方模块。 这表示，你可以使用如 `mockjs` / `faker-js` 等库帮助生成 `mock data`。

插件支持响应多种数据类型包括 `text/json/Buffer/ReadStream`等，还支持设置 headers、cookies。

插件还支持模拟 `WebSocket`，可以轻松的实现在本地开发环境调试 `WebSocket` 服务。

[查看 **vite-plugin-mock-dev-server** 使用文档](https://vite-plugin-mock-dev-server.netlify.app/){.read-more}

***

### vuepress-theme-plume

**说明：**

vuepress-theme-plume 是一个基于 VuePress 的主题。适用于 博客、文档 和 知识笔记 。

与 vuepress 默认主题相比：

* 大幅度优化了界面、交互，更具美观度，更好的用户体验。
* 同时，还添加了大量的丰富实用的功能，如 代码分组、提示容器、任务列表、数学公式、代码演示、 内容搜索、文章评论、加密 等。
* 大幅度简化了配置，更易于使用，同时还保留了丰富灵活的配置项，满足个性化的需求。

plume 主题尽可能的内置你可能需要的功能，以及搭建站点所需要的一般性配置，您无需关注这些细节。 目的是，让您更专注于 内容的创作，更好的表达你的想法，享受 Markdown 增强语法带来的便利。

[查看 **vuepress-theme-plume** 使用文档](https://theme-plume.vuejs.press/){.read-more}

***

### vite-plugin-image-placeholder

**说明：**

在项目开发过程中，为未准备好图片资源的内容区域，生成占位图片。

***

### rspack-plugin-mock

**说明：**

`vite-plugin-mock-dev-server` 对标 `vite-plugin-mock-dev-server` 在 `rspack/rsbuild` 上的实现， 专注于在 `rspack / rsbuild` 开发环境下 提供 Mock 服务。

[查看 **rspack-plugin-mock** 使用文档](https://github.com/pengzhanbo/rspack-plugin-mock){.read-more}

***

### vulcan

**说明：**

基于 vite + vue3 的项目模板，帮助快速创建 Mobile Web 应用。

***

### @any-hooks/solid

**说明：**

一套高质量可靠的 Solidjs Hooks 库。

[使用文档](https://solid-hooks.netlify.app/en-US)

***

### stylelint-define-config

**说明：**

为 `stylelint` 提供 `defineConfig` 配置类型帮助，可以在 `stylelint.config.js` 中配置自定义配置。

***

### @pengzhanbo/utils

**说明：**

一个常用的工具类库, 无依赖， 任何运行时。

[使用文档](http://jsr.io/@pengzhanbo/utils)

***

### geo-pattern-ts

**说明：**

生成漂亮的SVG图案。

[使用文档](https://github.com/pengzhanbo/geo-pattern-ts) | [在线演示](https://geo-pattern.netlify.app)

***

### chinese-simple2traditional

**说明：**

中文繁简体转换。

* 内置字库，零依赖，支持任何运行环境。
* 支持 3077+ 常用简体字 和 4919+ 繁体字/异体字。
* 支持 3577+ 简体短语转繁体的特殊情况。
* 支持 117+ 繁体短语/异体短语 转简体的特殊情况。

[使用文档](https://github.com/pengzhanbo/chinese-simple2traditional) | [在线演示](https://han-convert.netlify.app/)

***

### caniuse-embed

**说明：**

基于 `Astro` 开发的 `caniuse-embed` 组件。

从 [caniuse.com](https://caniuse.com/) 和 [mozilla's browser compat data](https://github.com/mdn/browser-compat-data) 嵌入最新数据。

显示10个主要浏览器多个版本的功能支持数据。可配置、可靠且完全响应。

[使用文档](https://caniuse-embed.vercel.app/zh-CN)

***

### spearjs

**说明：**

一个 低代码平台。使用 vite 构建。前端基于 vue， 后端基于 nestjs。

---

---
url: /sites-collect/index.md
---
# 站点导航
## 代码搜索

[**Grep.app**](https://grep.app/){.readmore}

## Runtime

## Registry

## 库/框架

***

***

***

### 微前端

***

### CSS

### Vue

***

***

### React

***

***

***

***

***

***

### 小程序

## 图标

## 素材

## 桌面应用开发

## 跨平台开发

## 构建工具

### 站点生成工具

## 社区

### 周刊

### 博客

## Git

## 工具

### javascript

### css

***

### 正则

### shell

### 开源

## 服务

## Test

## Chart

## CDN

---

---
url: /type-challenges/index.md
---
# Type Challenges
:::warning 施工中...
:::

## 简介

[type-challenges](https://github.com/type-challenges/type-challenges) 是一个能够让你更好的
了解 `typescript` 类型系统的开源项目。

本笔记整理记录了我个人在解答这个项目中的挑战，所使用的解题思路，回答，以及相关的 `typescript` 知识点。

根据 [type-challenges](https://github.com/type-challenges/type-challenges) 的题目难度，
分为了五个难度：

* `热身`  1 / 1
* `简单`  13 / 13
* `中等`  57 / 103
* `困难`  0 / 43
* `地狱`  0 / 14

请从上到下依次阅读本笔记，以便更好的了解 `type-challenges` 的挑战。

如果你是新手，或者仅想在你的日常工作中用好 `typescript`，那么阅读到 `中等` 难度的题目就足够了。
从 `困难` 难度开始，这些题目可能更适合于 想要深入理解某些库或框架的类型设计，或者想要编写自己的类型工具的开发者。

## VSCode 插件

[VS Code 插件 **Type-Challenges**](https://marketplace.visualstudio.com/items?itemName=YRM.type-challenges){.read-more}

插件提供了开源项目的所有题目，以及测试用例，可以通过在 `VSCode` 中安装该插件，在 `VSCode` 中进行答题，
以获得良好的 编辑器类型检查帮助。

## 说明

在这个项目中，每一个挑战都将作为单独的文章进行编写。其内容包括:

* **题目**：提出的挑战
* **解题思路**
* **答案**
* **验证**：借助 [typescript twoslash](https://theme-plume.vuejs.press/guide/markdown/twoslash/) 的帮助，你可以在这里查看答案中每一处的类型，以及验证结果是否符合预期
* **参考**：列出这个挑战需要使用的 `typescript` 知识点

## 类型工具

在 验证 过程中，将会使用到以下的类型工具：

```ts
/**
 * 类型断言
 */
export type Expect<T extends true> = T
export type ExpectTrue<T extends true> = T
export type ExpectFalse<T extends false> = T
export type IsTrue<T extends true> = T
export type IsFalse<T extends false> = T

/**
 * 比较两个类型是否完全相等
 */
export type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
  ? true
  : false
export type NotEqual<X, Y> = true extends Equal<X, Y> ? false : true

/**
 * 判断类型是否为 `any`
 */
export type IsAny<T> = 0 extends 1 & T ? true : false
export type NotAny<T> = true extends IsAny<T> ? false : true

export type Debug<T> = { [K in keyof T]: T[K] }
export type MergeInsertions<T> = T extends object ? { [K in keyof T]: MergeInsertions<T[K]> } : T

/**
 * 判断两个类型是否相似
 */
export type Alike<X, Y> = Equal<MergeInsertions<X>, MergeInsertions<Y>>

/**
 * 判断一个类型是否继承于另一个类型
 */
export type ExpectExtends<VALUE, EXPECTED> = EXPECTED extends VALUE ? true : false
/**
 * 判断一个函数的参数是否符合预期
 */
export type ExpectValidArgs<
  FUNC extends (...args: any[]) => any,
  ARGS extends any[]
> = ARGS extends Parameters<FUNC> ? true : false

/**
 * 将联合类型转换为交叉类型
 */
export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I
) => void
  ? I
  : never
```

---

---
url: /type-challenges/easy/awaited/index.md
---
# Awaited
## 问题

Github: [Awaited](https://github.com/type-challenges/type-challenges/blob/main/questions/00189-easy-awaited/)

假如我们有一个 `Promise` 对象，这个 Promise 对象会返回一个类型。在 `TS` 中，我们用 `Promise` 中的 `T` 来描述这个 `Promise` 返回的类型。请你实现一个类型，可以获取这个类型。

例如：`Promise<ExampleType>`，请你返回 ExampleType 类型。

```ts
type ExampleType = Promise<string>

type Result = MyAwaited<ExampleType> // string
```

## 解题思路

这个挑战中，需要对类型 `Promise<ExampleType>` 进行展开。

**展开** 指的是，**从一个类型中提取其内部的类型** 。 比如 `Promise<string>` 的展开结果是 `string`。

```ts
type MyAwaited<T> = T extends Promise<string> ? string : T
```

但这样做我们只能处理 `Promise<string>` 这种情况，我们的是可以处理 `T` 为任意类型的 `Promise`。

在 typescript 中，可以通过 **条件类型的类型推断**，将推断结果赋值给 类型参数，这里需要借助 关键词 `infer`。
需要注意的是，条件类型的类型推断，只能在条件分支为 `true` 中可以使用 类型参数。

```ts
type MyAwaited<T> = T extends Promise<infer R> ? R : T
```

同时，我们还需要考虑 `<Promise<Promise<string>>` 等情况。这时候需要运用到 typescript 的 **类型递归**，
直到不能展开为止，这个过程是调用 `MyAwaited` 自身实现。

## 答案

```ts
type MyAwaited<T> = T extends Promise<infer R> ? MyAwaited<R> : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type MyAwaited<T> = T extends Promise<infer R> ? MyAwaited<R> : T

// ---cut---
type StringAwaited = MyAwaited<Promise<string>>
type NumberAwaited = MyAwaited<Promise<number>>
type DeepAwaited = MyAwaited<Promise<Promise<Promise<string>>>>

type cases = [
  Expect<Equal<StringAwaited, string>>,
  Expect<Equal<NumberAwaited, number>>,
  Expect<Equal<DeepAwaited, string>>,
]
```

## 参考

> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
> * [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /type-challenges/easy/concat/index.md
---
# Concat
## 题目

Github: [Concat](https://github.com/type-challenges/type-challenges/blob/main/questions/00533-easy-concat/)

在类型系统里实现 JavaScript 内置的 `Array.concat` 方法，这个类型接受两个参数，
返回的新数组类型应该按照输入参数从左到右的顺序合并为一个新的数组。

```ts
type Result = Concat<[1], [2]> // expected to be [1, 2]
```

## 解题思路

泛型参数 `T` `U` 约束为可变元组类型，通过 数组展开，合并到新的数组中。

## 答案

```ts
type Concat<T extends unknown[], U extends unknown[]> = [...T, ...U]
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type Concat<T extends unknown[], U extends unknown[]> = [...T, ...U]
// ---cut---
type Result = Concat<[1], [2]>

type test = Expect<Equal<Result, [1, 2]>>
```

## 参考

> * [可变元组 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)

---

---
url: /type-challenges/easy/exclude/index.md
---
# 实现 Exclude
## 题目

Github: [Exclude](https://github.com/type-challenges/type-challenges/blob/main/questions/)

实现内置的`Exclude <T, U>`类型，但不能直接使用它本身。

> 从联合类型T中排除U的类型成员，来构造一个新的类型。

```ts
type Result = MyExclude<'a' | 'b' | 'c', 'a'> // 'b' | 'c'
```

## 解题思路

在 typescript 中， 条件类型是 可分配的。

在 `T extends U` 且 `T` 是联合类型时，实际上发生的是 typescript 遍历联合类型 `T` 中的每一个元素，并将条件判断应用到每一个元素上。

所以可以通过这一特性，检查 `T` 的元素是否满足 `U` 的约束，如果是，则跳过。

## 答案

```ts
type MyExclude<T, U> = T extends U ? never : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type MyExclude<T, U> = T extends U ? never : T
// ---cut---
type Result = MyExclude<'a' | 'b' | 'c', 'a'>

type test = Expect<Equal<Result, 'b' | 'c'>>
```

## 参考

> [分配条件类型 Distributive Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)

---

---
url: /type-challenges/easy/first-of-array/index.md
---
# 第一个元素
## 题目

Github: [First of array](https://github.com/type-challenges/type-challenges/blob/main/questions/00014-easy-first/)

实现一个 `First<T>` 泛型，它接受一个数组T并返回它的第一个元素的类型。

```ts
type arr1 = ['a', 'b', 'c']
type arr2 = [3, 2, 1]

type head1 = First<arr1> // 应推导出 'a'
type head2 = First<arr2> // 应推导出 3
```

## 解题思路

获取数组的第一个元素类型，首先想到通过 **索引类型**，通过 `T[0]` 获取类型，
但是这里会有一个临界情况，如果传入的是一个空数组，会导致 `T[0]` 不能正常工作，因为它没有元素。

所以在获取数组的第一个元素类型前，需要检查数组是否为空。
可以通过 **条件类型** 推断数组是否为空，如果为空，则什么都不返回。

## 答案

```ts
type First<T extends any[]> = T extends [] ? never : T[0]
```

## 验证

```ts twoslash
// @errors: 2540
import type { Equal, Expect } from '~/tc-utils'
type First<T extends any[]> = T extends [] ? never : T[0]
// ---cut---
type cases = [
  Expect<Equal<First<[]>, never>>,
  Expect<Equal<First<['a', 'b', 'c']>, 'a'>>,
  Expect<Equal<First<[3, 2, 1]>, 3>>
]
```

## 参考

> * [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)

---

---
url: /type-challenges/easy/if/index.md
---
# If
## 题目

Github: [If](https://github.com/type-challenges/type-challenges/blob/main/questions/00268-easy-if/)

实现一个 `IF` 类型，它接收一个条件类型 `C` ，一个判断为真时的返回类型 `T` ，以及一个判断为假时的返回类型 `F`。
`C` 只能是 `true` 或者 `false`， `T` 和 `F` 可以是任意类型。

```ts
type A = If<true, 'a', 'b'> // expected to be 'a'
type B = If<false, 'a', 'b'> // expected to be 'b'
```

## 解题思路

通过泛型类型约束 `C` 为 `boolean` , 条件类型推断 `C` 计算结果是否为 `true` 。

## 答案

```ts
type If<C extends boolean, T, F> = C extends true ? T : F
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type If<C extends boolean, T, F> = C extends true ? T : F
// ---cut---
type a = If<true, 'a', 'b'>
type b = If<false, 'a', 'b'>

type cases = [
  Expect<Equal<a, 'a'>>,
  Expect<Equal<b, 'b'>>,
]
```

## 参考

> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)

---

---
url: /type-challenges/easy/includes/index.md
---
# Includes
## 题目

Github: [Includes](https://github.com/type-challenges/type-challenges/blob/main/questions/00898-easy-includes/)

在类型系统里实现 JavaScript 的 Array.includes 方法，这个类型接受两个参数，返回的类型要么是 true 要么是 false。

```ts
type isPillarMen = Includes<['Kars', 'Esidisi', 'Wamuu', 'Santana'], 'Dio'> // expected to be `false`
```

::: note
这个挑战归类于 “简单” , 是欠妥的，它的难点在于，如果判断两个类型是 **全等** 的，但它的难度远比这个挑战本身要大得多。
:::

## 解题思路

本题解题的关键难点在于， 如何判断类型`U` 全等于 数组类型 `T` 中的某个成员。比如 `1` 虽然是 `number` 类型，但是
类型 `1`是继承 `number` 类型，而不是全等关系，因此 `1` 不能被认为是 `[number]` 数组的成员。

在 `TS` 类型系统中，实现 **全等判断**，需要通过 `extends` 关键词，以及 函数的返回值类型，才能正确的判断两个类型是否完全一致。

假设需要对比泛型参数 `<X, Y>` 是否全等，需要通过构造函数类型 `<T>() => T extends X ? 1 : 2`， 以及函数类型
`<T>() => T extends Y ? 1 : 2`，再通过 `extends` 关键词做条件类型，判断两个函数类型是否具有继承关系，即可间接推断
出类型 `X` 是否全等于类型`Y`。

```ts
type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
  ? true
  : false
```

有了 `Equal<X, Y>` 类型工具，继续进一步的通过类型递归的方式，遍历数组类型`T`中的每一个成员，是否全等于类型`U`，
即可实现 `includes`。

通过构造 `T extends [infer F, ...infer O]` 条件类型推断，在条件为真时，使用 `infer F`取出数组的第一个元素
与 类型`U` 进行 `Equal`。如果对比为 `false` ，则继续将 `infer O` 获取的数组`T`剩余成员，继续传入 `Includes` 类型中递归对比。

## 答案

```ts
type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
  ? true
  : false

type Includes<T extends readonly any[], U> = T extends [infer F, ...infer O]
  ? Equal<F, U> extends true
    ? true
    : Includes<O, U>
  : false
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type Includes<T extends readonly any[], U> = T extends [infer F, ...infer O]
  ? Equal<F, U> extends true
    ? true
    : Includes<O, U>
  : false

// ---cut---
type cases = [
  Expect<Equal<Includes<['Kars', 'Esidisi', 'Wamuu', 'Santana'], 'Kars'>, true>>,
  Expect<Equal<Includes<['Kars', 'Esidisi', 'Wamuu', 'Santana'], 'Dio'>, false>>,
  Expect<Equal<Includes<[1, 2, 3, 5, 6, 7], 7>, true>>,
  Expect<Equal<Includes<[1, 2, 3, 5, 6, 7], 4>, false>>,

  Expect<Equal<Includes<[{}], { a: 'A' }>, false>>,
  Expect<Equal<Includes<[boolean, 2, 3, 5, 6, 7], false>, false>>,
  Expect<Equal<Includes<[true, 2, 3, 5, 6, 7], boolean>, false>>,
  Expect<Equal<Includes<[false, 2, 3, 5, 6, 7], false>, true>>,
  Expect<Equal<Includes<[{ a: 'A' }], { readonly a: 'A' }>, false>>,
  Expect<Equal<Includes<[{ readonly a: 'A' }], { a: 'A' }>, false>>,
  Expect<Equal<Includes<[1], 1 | 2>, false>>,
  Expect<Equal<Includes<[1 | 2], 1>, false>>,
  Expect<Equal<Includes<[null], undefined>, false>>,
  Expect<Equal<Includes<[undefined], null>, false>>,
]
```

## 参考

> * [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
> * [泛型约束 Generics Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
> * [条件类型分支 Distributive Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)
> * [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /type-challenges/easy/length-of-tuple/index.md
---
# 获取元组长度
## 题目

Github: [length of tuple](https://github.com/type-challenges/type-challenges/blob/main/questions/00018-easy-tuple-length/)

创建一个 `Length` 泛型，这个泛型接受一个只读的元组，返回这个元组的长度。

```ts
type tesla = ['tesla', 'model 3', 'model X', 'model Y']
type spaceX = ['FALCON 9', 'FALCON HEAVY', 'DRAGON', 'STARSHIP', 'HUMAN SPACEFLIGHT']

type teslaLength = Length<tesla> // expected 4
type spaceXLength = Length<spaceX> // expected 5
```

## 解题思路

在 javascript 中， 通过 `length` 属性获取数组的长度，在类型上，也同样可以通过 `length` 获取数组的长度。
同时，需要约束 `T` 的类型为 只读数组。

## 答案

```ts
type Length<T extends readonly any[]> = T['length']
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type Length<T extends readonly any[]> = T['length']
// ---cut---
type tesla = Length<['tesla', 'model 3', 'model X', 'model Y']>
type spaceX = Length<['FALCON 9', 'FALCON HEAVY', 'DRAGON', 'STARSHIP', 'HUMAN SPACEFLIGHT']>

type cases = [
  Expect<Equal<tesla, 4>>,
  Expect<Equal<spaceX, 5>>,
]
```

## 参考

> * [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /type-challenges/easy/parameters/index.md
---
# Parameters
## 题目

Github: [Parameters](https://github.com/type-challenges/type-challenges/blob/main/questions/03312-easy-parameters/)

实现内置的 `Parameters<T>` 类型，而不是直接使用它，可参考[TypeScript官方文档](https://www.typescriptlang.org/docs/handbook/utility-types.html#parameterstype)。

```ts
function foo(arg1: string, arg2: number): void {}

type FunctionParamsType = MyParameters<typeof foo> // [arg1: string, arg2: number]
```

## 解题思路

通过 条件类型推断，获取函数的参数类型

## 答案

```ts
type MyParameters<T> = T extends (...args: infer R) => any ? R : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type MyParameters<T> = T extends (...args: infer R) => any ? R : never

// ---cut---
function foo(arg1: string, arg2: number): void {}
function bar(arg1: boolean, arg2: { a: 'A' }): void {}
function baz(): void {}

type cases = [
  Expect<Equal<MyParameters<typeof foo>, [string, number]>>,
  Expect<Equal<MyParameters<typeof bar>, [boolean, { a: 'A' }]>>,
  Expect<Equal<MyParameters<typeof baz>, []>>,
]
```

## 参考

> * [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
> * [条件类型内推断 Inferring Within Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /type-challenges/easy/pick/index.md
---
# 实现 Pick
## 题目

[Type-Challenges - **Pick**](https://github.com/type-challenges/type-challenges/blob/main/questions/00004-easy-pick/){.read-more}

实现 TS 内置的 `Pick<T, K>`，但不可以使用它。

**从类型 T 中选择出属性 K，构造成一个新的类型。**

```ts
interface Todo {
  title: string
  description: string
  completed: boolean
}

type TodoPreview = MyPick<Todo, 'title' | 'completed'>

const todo: TodoPreview = {
  title: 'Clean room',
  completed: false,
}
```

## 解题思路

本题需要使用到 **查找类型** 和 **映射类型** 。

* **查找类型** 允许通过名称从另一个类型中提取一个新的类型。
* **映射类型** 允许将一个类型中的每个属性转换为一个新的类型。

在这个挑战中，需要从 `联合(union) K` 中取得所有内容，遍历并返回一个仅包含这些键的新的类型。
同时 `联合(union) K` 仅能包含 `T` 的键值。

## 答案

```ts
type MyPick<T, K extends keyof T> = {
  [P in K]: T[P]
}
```

最终结果为，从 `K` 中获取所有内容，命名为 `P` 并将其作为新对象的一个新键，其值的类型取自输入类型。

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type MyPick<T, K extends keyof T> = {
  [P in K]: T[P]
}
// ---cut---
interface Todo {
  title: string
  description: string
  completed: boolean
}

type Todo2 = MyPick<Todo, 'title' | 'completed'>

type Test = Expect<Equal<Todo2, { title: string, completed: boolean }>>
```

## 参考

> * [查找类型 Lookup Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)
> * [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
> * [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /type-challenges/easy/push/index.md
---
# Push
## 题目

Github: [Push](https://github.com/type-challenges/type-challenges/blob/main/questions/03057-easy-push/)

在类型系统里实现通用的 `Array.push` 。

```ts
type Result = Push<[1, 2], '3'> // [1, 2, '3']
```

## 解题思路

通过 泛型约束`T` 为数组类型，对 `T` 进行展开到新数组中，并将 `U` 合并到新数组的末尾。

## 答案

```ts
type Push<T extends any[], U> = [...T, U]
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type Push<T extends any[], U> = [...T, U]

// ---cut---
type cases = [
  Expect<Equal<Push<[], 1>, [1]>>,
  Expect<Equal<Push<[1, 2], '3'>, [1, 2, '3']>>,
  Expect<Equal<Push<['1', 2, '3'], boolean>, ['1', 2, '3', boolean]>>,
]
```

## 参考

> * [可变元组 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
> * [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
> * [泛型约束 Generics Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)

---

---
url: /type-challenges/easy/readonly/index.md
---
# 对象属性只读
## 题目

Github: [ReadOnly](https://github.com/type-challenges/type-challenges/blob/main/questions/00007-easy-readonly/)

不要使用内置的 `Readonly<T>` ，自己实现一个。

泛型 `Readonly<T>` 会接收一个 *泛型参数* ，并返回一个完全一样的类型，只是所有属性都会是只读 (readonly) 的。

也就是不可以再对该对象的属性赋值。

```ts
interface Todo {
  title: string
  description: string
}

const todo: MyReadonly<Todo> = {
  title: 'Hey',
  description: 'foobar'
}

todo.title = 'Hello' // Error: cannot reassign a readonly property
todo.description = 'barFoo' // Error: cannot reassign a readonly property
```

## 解题思路

使一个对象的所有属性都是只读属性，需要遍历对象的每一个键，并使用 `readonly` 修饰符。

在这里，直接使用 **映射类型** ，对该类型的每个属性，获取它的键并为其添加 `readonly` 修饰符

## 答案

```ts
type MyReadonly<T> = {
  readonly [P in keyof T]: T[P]
}
```

## 验证

```ts twoslash
// @errors: 2540
import type { Equal, Expect } from '~/tc-utils'
type MyReadonly<T> = {
  readonly [P in keyof T]: T[P]
}
// ---cut---
interface Todo {
  title: string
  description: string
}

interface TodoReadonly {
  readonly title: string
  readonly description: string
}

type test = Expect<Equal<MyReadonly<Todo>, TodoReadonly>>

const todo: MyReadonly<Todo> = {
  title: 'Hey',
  description: 'foobar'
}

todo.title = 'Hello'
todo.description = 'barFoo'
```

## 参考

> * [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)

---

---
url: /type-challenges/easy/tuple-to-object/index.md
---
# 元组转换为对象
## 题目

Github: [Tuple to Object](https://github.com/type-challenges/type-challenges/blob/main/questions/)

将一个元组类型转换为对象类型，这个对象类型的键/值和元组中的元素对应。

```ts
const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const

type result = TupleToObject<typeof tuple>
// expected { 'tesla': 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}
```

## 解题思路

解题的关键在于获取元组中的所有值，并将其作为新对象中的键和值。

可以使用 **索引类型** `T[number]` 从数组中获取所有值，通过 **映射类型**，遍历 `T[number]` 中的值，并返回新的类型，
其中 键 和 值 是 `T[number]` 的类型。

## 答案

```ts
type TupleToObject<T extends readonly PropertyKey[]> = {
  [P in T[number]]: P
}
```

## 验证

```ts twoslash
// @errors: 2540
import type { Equal, Expect } from '~/tc-utils'
type TupleToObject<T extends readonly PropertyKey[]> = {
  [P in T[number]]: P
}
// ---cut---
const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const

type test = Expect<Equal<
  TupleToObject<typeof tuple>,
  { 'tesla': 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y' }
>>
```

## 参考

> * [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
> * [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /type-challenges/easy/unshift/index.md
---
# Unshift
## 题目

Github: [Unshift](https://github.com/type-challenges/type-challenges/blob/main/questions/03060-easy-unshift/)

实现类型版本的 `Array.unshift`。

```ts
type Result = Unshift<[1, 2], 0> // [0, 1, 2,]
```

## 解题思路

通过 泛型约束`T` 为数组类型，对 `T` 进行展开到新数组中，并将 `U` 合并到新数组的首位。

## 答案

```ts
type Unshift<T extends any[], U> = [U, ...T]
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type Unshift<T extends any[], U> = [U, ...T]

// ---cut---
type cases = [
  Expect<Equal<Unshift<[], 1>, [1]>>,
  Expect<Equal<Unshift<[1, 2], 0>, [0, 1, 2]>>,
  Expect<Equal<Unshift<['1', 2, '3'], boolean>, [boolean, '1', 2, '3']>>,
]
```

## 参考

> * [可变元组 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
> * [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
> * [泛型约束 Generics Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)

---

---
url: /type-challenges/medium/absolute/index.md
---
# 正数字符串
## 题目

Github: [Absolute](https://github.com/type-challenges/type-challenges/blob/main/questions/00529-medium-absolute/)

实现一个接收 `string`, `number` 或 `bigInt` 类型参数的 `Absolute` 类型,返回一个 正数字符串。

```ts
type Test = -100
type Result = Absolute<Test> // expected to be "100"
```

## 解题思路

将一个负数转为正数的方法，很容易想到就是直接把负号 `-` 去掉，因此，可以使用模板字面量来实现。

首先将 `T` 转为字符串，然后判断是否该字符串是否以 `-` 字符开始。
如果是，就去掉 `-` 字符，否则返回原字符串。

## 答案

```ts
type Absolute<T extends number | string | bigint>
  = `${T}` extends `-${infer R}` ? R : `${T}`
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type Absolute<T extends number | string | bigint> = `${T}` extends `-${infer R}` ? R : `${T}`

// ---cut---
type cases = [
  Expect<Equal<Absolute<0>, '0'>>,
  Expect<Equal<Absolute<-0>, '0'>>,
  Expect<Equal<Absolute<10>, '10'>>,
  Expect<Equal<Absolute<-5>, '5'>>,
  Expect<Equal<Absolute<'0'>, '0'>>,
  Expect<Equal<Absolute<'-0'>, '0'>>,
  Expect<Equal<Absolute<'10'>, '10'>>,
  Expect<Equal<Absolute<'-5'>, '5'>>,
  Expect<Equal<Absolute<-1_000_000n>, '1000000'>>,
  Expect<Equal<Absolute<9_999n>, '9999'>>,
]
```

## 参考

* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /type-challenges/medium/all-combinations/index.md
---
# AllCombinations
## 题目

Github: [AllCombinations](https://github.com/type-challenges/type-challenges/blob/main/questions/04260-medium-nomiwase/README.md)

实现类型 `AllCombinations<S>` ，该类型返回使用 `S` 中的字符且每个字符最多使用一次的所有字符串组合。

```ts
type AllCombinations_ABC = AllCombinations<'ABC'>
// should be '' | 'A' | 'B' | 'C' | 'AB' | 'AC' | 'BA' | 'BC' | 'CA' | 'CB' | 'ABC' | 'ACB' | 'BAC' | 'BCA' | 'CAB' | 'CBA'
```

## 解题思路

参考 [#16430](https://github.com/type-challenges/type-challenges/issues/16430)

## 答案

```ts
type StringToUnion<S extends string> = S extends `${infer F}${infer O}`
  ? F | StringToUnion<O>
  : never

type AllCombinations<
  S extends string,
  U extends string = StringToUnion<S>
> = [U] extends [never]
  ? ''
  : '' | {
    [P in U]: `${P}${AllCombinations<never, Exclude<U, P>>}`
  }[U]
```

## 验证

```ts twoslash
import type { Equal, Expect, NotEqual } from '~/tc-utils'

type StringToUnion<S extends string> = S extends `${infer F}${infer O}`
  ? F | StringToUnion<O>
  : never

type AllCombinations<
  S extends string,
  U extends string = StringToUnion<S>
> = [U] extends [never]
  ? ''
  : '' | {
    [P in U]: `${P}${AllCombinations<never, Exclude<U, P>>}`
  }[U]

// ---cut---
type cases = [
  Expect<Equal<AllCombinations<''>, ''>>,
  Expect<Equal<AllCombinations<'A'>, '' | 'A'>>,
  Expect<Equal<AllCombinations<'AB'>, '' | 'A' | 'B' | 'AB' | 'BA'>>,
  Expect<Equal<AllCombinations<'ABC'>, '' | 'A' | 'B' | 'C' | 'AB' | 'AC' | 'BA' | 'BC' | 'CA' | 'CB' | 'ABC' | 'ACB' | 'BAC' | 'BCA' | 'CAB' | 'CBA'>>,
  Expect<Equal<AllCombinations<'ABCD'>, '' | 'A' | 'B' | 'C' | 'D' | 'AB' | 'AC' | 'AD' | 'BA' | 'BC' | 'BD' | 'CA' | 'CB' | 'CD' | 'DA' | 'DB' | 'DC' | 'ABC' | 'ABD' | 'ACB' | 'ACD' | 'ADB' | 'ADC' | 'BAC' | 'BAD' | 'BCA' | 'BCD' | 'BDA' | 'BDC' | 'CAB' | 'CAD' | 'CBA' | 'CBD' | 'CDA' | 'CDB' | 'DAB' | 'DAC' | 'DBA' | 'DBC' | 'DCA' | 'DCB' | 'ABCD' | 'ABDC' | 'ACBD' | 'ACDB' | 'ADBC' | 'ADCB' | 'BACD' | 'BADC' | 'BCAD' | 'BCDA' | 'BDAC' | 'BDCA' | 'CABD' | 'CADB' | 'CBAD' | 'CBDA' | 'CDAB' | 'CDBA' | 'DABC' | 'DACB' | 'DBAC' | 'DBCA' | 'DCAB' | 'DCBA'>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
* [联合类型 Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)

---

---
url: /type-challenges/medium/all/index.md
---
# All
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/any-of/index.md
---
# AnyOf
## 题目

Github: [AnyOf](https://github.com/type-challenges/type-challenges/blob/main/questions/00949-medium-anyof/)

在类型系统中实现类似于 `Python` 中 `any` 函数。类型接收一个数组，如果数组中任一个元素为真，
则返回 `true`，否则返回 `false`。如果数组为空，返回 `false`。

```ts
type Sample1 = AnyOf<[1, '', false, [], {}]> // expected to be true.
type Sample2 = AnyOf<[0, '', false, [], {}]> // expected to be false.
```

## 解题思路

我们可以使用 `T[number]` 从 `T` 中获取每个元素的类型，然后使用 `extends` 来判断每个元素是否不为真。

为方便比较，我们可以使用 `Falsely` 类型来表示不为真的元素。

## 答案

```ts
type Falsely = 0 | '' | false | undefined | null | [] | { [k: string]: never }
type AnyOf<T extends readonly any[]> = T[number] extends Falsely ? false : true
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Falsely = 0 | '' | false | undefined | null | [] | { [k: string]: never }
type AnyOf<T extends readonly any[]> = T[number] extends Falsely ? false : true

// ---cut---
type cases = [
  Expect<Equal<AnyOf<[1, 'test', true, [1], { name: 'test' }, { 1: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[1, '', false, [], {}]>, true>>,
  Expect<Equal<AnyOf<[0, 'test', false, [], {}]>, true>>,
  Expect<Equal<AnyOf<[0, '', true, [], {}]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [1], {}]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], { name: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], { 1: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], { name: 'test' }, { 1: 'test' }]>, true>>,
  Expect<Equal<AnyOf<[0, '', false, [], {}, undefined, null]>, false>>,
  Expect<Equal<AnyOf<[]>, false>>,
]
```

## 参考

* [联合类型 Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)

---

---
url: /type-challenges/medium/appear-only-once/index.md
---
# appearOnlyOnce
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/append-argument/index.md
---
# 追加参数
## 题目

Github: [Append Argument](https://github.com/type-challenges/type-challenges/blob/main/questions/00191-medium-append-argument/)

实现一个泛型 `AppendArgument<Fn, A>`，对于给定的函数类型 `Fn`，以及一个任意类型 `A`，返回一个新的函数 `G`。
`G` 拥有 `Fn` 的所有参数并在末尾追加类型为 `A` 的参数。

```ts
type Fn = (a: number, b: string) => number

type Result = AppendArgument<Fn, boolean>
// 期望是 (a: number, b: string, x: boolean) => number
```

## 解题思路

首先我们可以使用 `infer` 关键字来推断出函数的参数类型和返回值类型。通过条件类型的类型推断来实现这一点。

```ts
type AppendArgument<Fn, A> = Fn extends (args: infer P) => infer R
  ? (args: P) => R
  : never
```

但需要注意的是，这里的 `(args:infer P)` 只能获取首个参数的类型，因此我们需要使用 `...` 展开语法来获取所有参数的类型。

```ts
type AppendArgument<Fn, A> = Fn extends (...args: infer P) => infer R
  ? (...args: P) => R
  : never
```

此时获取的类型参数 `P` 为一个可变元组类型，可以使用 `...` 展开语法来获取参数的类型，并添加 `A` 类型的参数。
构造新的函数参数签名。

## 答案

```ts
type AppendArgument<Fn extends (...args: any[]) => any, A>
  = Fn extends (...args: infer P) => infer R ? (...args: [...P, A]) => R : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type AppendArgument<Fn extends (...args: any[]) => any, A>
  = Fn extends (...args: infer P) => infer R ? (...args: [...P, A]) => R : never
// ---cut---
type Case1 = AppendArgument<(a: number, b: string) => number, boolean>
type Result1 = (a: number, b: string, x: boolean) => number

type Case2 = AppendArgument<() => void, undefined>
type Result2 = (x: undefined) => void

type cases = [
  Expect<Equal<Case1, Result1>>,
  Expect<Equal<Case2, Result2>>,
  // @ts-expect-error
  AppendArgument<unknown, undefined>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
* [可变参数和参数 Rest Parameters and Arguments](https://www.typescriptlang.org/docs/handbook/2/functions.html#rest-parameters-and-arguments)

---

---
url: /type-challenges/medium/append-to-object/index.md
---
# 追加字段到对象
## 题目

Github: [AppendToObject](https://github.com/type-challenges/type-challenges/blob/main/questions/00527-medium-appendtoobject/)

实现一个为接口添加一个新字段的类型。该类型接收三个参数，返回带有新字段的接口类型。

```ts
interface Test { id: '1' }
type Result = AppendToObject<Test, 'value', 4> // expected to be { id: '1', value: 4 }
```

## 解题思路

一开始可能会想到使用交叉类型来解决此挑战：

```ts
type AppendToObject<T, U extends PropertyKey, V> = T & { [K in U]: V }
```

然而我们需要留意到此挑战，需要 **返回带有新字段的接口类型**，这需要的是一个新的普通类型，而不是一个交叉类型。

首先我们可以先将 `T` 映射为一个普通类型：

```ts
type AppendToObject<T, U extends PropertyKey, V> = {
  [K in keyof T]: T[K]
}
```

接下来，我们可以就可以在 `keyof T` 的联合类型中，添加 泛型 `U`，

```ts
type AppendToObject<T, U extends PropertyKey, V> = {
  [K in keyof T | U]: T[K]
}
```

但是 `K` 如果为类型 `U` 时，很明显 `T[K]` 不满足要求，它的值类型应为 `V`：

```ts
type AppendToObject<T, U extends PropertyKey, V> = {
  [K in keyof T | U]: K extends keyof T ? T[K] : V
}
```

## 答案

```ts
type AppendToObject<T, U extends PropertyKey, V> = {
  [K in keyof T | U]: K extends keyof T ? T[K] : V
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type AppendToObject<T, U extends PropertyKey, V> = {
  [K in keyof T | U]: K extends keyof T ? T[K] : V
}
// ---cut---
interface test1 {
  key: 'cat'
  value: 'green'
}

interface testExpect1 {
  key: 'cat'
  value: 'green'
  home: boolean
}

interface test2 {
  key: 'dog' | undefined
  value: 'white'
  sun: true
}

interface testExpect2 {
  key: 'dog' | undefined
  value: 'white'
  sun: true
  home: 1
}

interface test3 {
  key: 'cow'
  value: 'yellow'
  sun: false
}

interface testExpect3 {
  key: 'cow'
  value: 'yellow'
  sun: false
  moon: false | undefined
}

type cases = [
  Expect<Equal<AppendToObject<test1, 'home', boolean>, testExpect1>>,
  Expect<Equal<AppendToObject<test2, 'home', 1>, testExpect2>>,
  Expect<Equal<AppendToObject<test3, 'moon', false | undefined>, testExpect3>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [联合类型 Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)

---

---
url: /type-challenges/medium/bem-style-string/index.md
---
# BemStyleString
## 题目

Github: [BemStyleString](https://github.com/type-challenges/type-challenges/blob/main/questions/03326-medium-bem-style-string/)

块、元素、修饰符方法（BEM）是CSS中一种流行的类命名规范。

例如，块组件可以表示为`btn`，依赖于该块的元素可以表示为`btn__price`，改变块样式的修饰符可以表示为`btn--big`或`btn__price--warning`。

实现`BEM<B, E, M>`，从这三个参数生成字符串联合类型。其中`B`是字符串字面量，`E`和`M`是字符串数组（可以为空）。

## 解题思路

略。

## 答案

```ts
type BEM<B extends string, E extends string[], M extends string[]>
  = `${B}${E extends [] ? '' : `__${E[number]}`}${M extends [] ? '' : `--${M[number]}`}`
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type BEM<B extends string, E extends string[], M extends string[]>
  = `${B}${E extends [] ? '' : `__${E[number]}`}${M extends [] ? '' : `--${M[number]}`}`

// ---cut---
type cases = [
  Expect<Equal<BEM<'btn', ['price'], []>, 'btn__price'>>,
  Expect<Equal<BEM<'btn', ['price'], ['warning', 'success']>, 'btn__price--warning' | 'btn__price--success'>>,
  Expect<Equal<BEM<'btn', [], ['small', 'medium', 'large']>, 'btn--small' | 'btn--medium' | 'btn--large'>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

---

---
url: /type-challenges/medium/capitalize/index.md
---
# 首字母大写
## 题目

Github: [Capitalize](https://github.com/type-challenges/type-challenges/blob/main/questions/00110-medium-capitalize/)

实现 `Capitalize<T>` 它将字符串的第一个字母转换为大写，其余字母保持原样。

```ts
type capitalized = Capitalize<'hello world'> // expected to be 'Hello world'
```

## 解题思路

此挑战可以拆分为两个问题：

1. 提取字符串的第一个字母；
2. 将这个字母转换为大写。

我们可以使用 **模板字面量类型** 提取字符串的第一个字母，然后使用 内置 `Uppercase` 将其转换为大写字母。

## 答案

```ts
type MyCapitalize<S extends string>
  = S extends `${infer F}${infer R}` ? `${Uppercase<F>}${R}` : S
```

::: details `${infer F}${infer R}` 是如何工作的？

在 模板字面量类型中，如果字符串仅使用 `infer` 进行推导，而不掺杂其他信息，
那么前面的 `infer` 每一次只会推导一个字符。最后的 `infer` 会推导剩下的所有字符。

比如 `abcd`， 推导出 `F = a`， `R = bcd`。

而如果在其中加入某些推导条件，如 `${infer F}-${infer R}`，那么则会按照推导条件进行分割：

比如 `ab-cc-dd` ， 推导出 `F = ab`， `R = cc-dd`

:::

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type MyCapitalize<S extends string> = S extends `${infer F}${infer R}` ? `${Uppercase<F>}${R}` : S

// ---cut---
type cases = [
  Expect<Equal<MyCapitalize<'foobar'>, 'Foobar'>>,
  Expect<Equal<MyCapitalize<'FOOBAR'>, 'FOOBAR'>>,
  Expect<Equal<MyCapitalize<'foo bar'>, 'Foo bar'>>,
  Expect<Equal<MyCapitalize<''>, ''>>,
  Expect<Equal<MyCapitalize<'a'>, 'A'>>,
  Expect<Equal<MyCapitalize<'b'>, 'B'>>,
  Expect<Equal<MyCapitalize<'c'>, 'C'>>,
  Expect<Equal<MyCapitalize<'d'>, 'D'>>,
  Expect<Equal<MyCapitalize<'e'>, 'E'>>,
  Expect<Equal<MyCapitalize<'f'>, 'F'>>,
  Expect<Equal<MyCapitalize<'g'>, 'G'>>,
  Expect<Equal<MyCapitalize<'h'>, 'H'>>,
  Expect<Equal<MyCapitalize<'i'>, 'I'>>,
  Expect<Equal<MyCapitalize<'j'>, 'J'>>,
  Expect<Equal<MyCapitalize<'k'>, 'K'>>,
  Expect<Equal<MyCapitalize<'l'>, 'L'>>,
  Expect<Equal<MyCapitalize<'m'>, 'M'>>,
  Expect<Equal<MyCapitalize<'n'>, 'N'>>,
  Expect<Equal<MyCapitalize<'o'>, 'O'>>,
  Expect<Equal<MyCapitalize<'p'>, 'P'>>,
  Expect<Equal<MyCapitalize<'q'>, 'Q'>>,
  Expect<Equal<MyCapitalize<'r'>, 'R'>>,
  Expect<Equal<MyCapitalize<'s'>, 'S'>>,
  Expect<Equal<MyCapitalize<'t'>, 'T'>>,
  Expect<Equal<MyCapitalize<'u'>, 'U'>>,
  Expect<Equal<MyCapitalize<'v'>, 'V'>>,
  Expect<Equal<MyCapitalize<'w'>, 'W'>>,
  Expect<Equal<MyCapitalize<'x'>, 'X'>>,
  Expect<Equal<MyCapitalize<'y'>, 'Y'>>,
  Expect<Equal<MyCapitalize<'z'>, 'Z'>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [模板字面量类型中的大写字符串类型](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types)

---

---
url: /type-challenges/medium/cartesian-product/index.md
---
# cartesianProduct
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/chainable-options/index.md
---
# 可串联构造器
## 题目

Github: [Chainable options](https://github.com/type-challenges/type-challenges/blob/main/questions/00012-medium-chainable-options/)

在 `JavaScript` 中我们经常会使用可串联（Chainable/Pipeline）的函数构造一个对象，
但在 `TypeScript` 中，你能合理的给它赋上类型吗？

在这个挑战中，你可以使用任意你喜欢的方式实现这个类型 - `Interface`, `Type` 或 `Class` 都行。
你需要提供两个函数 `option(key, value)` 和 `get()`。
在 `option` 中你需要使用提供的 `key` 和 `value` 扩展当前的对象类型，通过 `get` 获取最终结果。

```ts
declare const config: Chainable

const result = config
  .option('foo', 123)
  .option('name', 'type-challenges')
  .option('bar', { value: 'Hello World' })
  .get()

// 期望 result 的类型是：
interface Result {
  foo: number
  name: string
  bar: {
    value: string
  }
}
```

你只需要在类型层面实现这个功能 - 不需要实现任何 `TS/JS` 的实际逻辑。

你可以假设 `key` 只接受字符串而 `value` 接受任何类型，你只需要暴露它传递的类型而不需要进行任何处理。
同样的 `key` 只会被使用一次。

## 解题思路

这是一个实用性非常高的挑战。我们很容易会想到可以在 [`webpack-chain`](https://github.com/neutrinojs/webpack-chain)
\~~(此库以归档不再维护)~~ 中使用它。

在这个挑战中，我们需要实现 `options(key, value)` 和 `get()` 两个方法。
在每次调用 `options(key, value)` 方法时，需要累加 `key` 和 `value` 的类型信息，
累加操作需要持续进行，直到 `get()` 被调用，返回最终的类型信息。

我们从最基础的类型开始，定义一个 `Chainable` 接口，它包含了 `option` 方法和 `get` 方法。

```ts
interface Chainable {
  option: (key: any, value: any) => any
  get: () => any
}
```

首先我们需要得到 `options(key, value)` 的类型信息，这里我们可以使用 类型参数替换 `any`，
以便 TypeScript 可以推断出它们的类 型并将其分配给类型参数。

`option(key, value)` 需要被连续调用，因此，`option(key, value)` 需要返回 `Chainable` 类型本身。

```ts
interface Chainable {
  option: <K, V>(key: K, value: V) => Chainable
  get: () => any
}
```

TypeScript 会将 `key` 推断 为字符串字面量类型，而将 `value` 推断为常见的类型。
例如，调用 `option('foo', 123)` 将得出的类型为：`key = 'foo'` 和 `value = number`。

接下来，我们需要保存 `key` 和 `value` 的类型信息，它必须在能够在连续调用 `option` 方法后能够保存
其状态，因此我们可以把这些信息保存在 `Chainable` 的类型参数中。

```ts
interface Chainable<T = {}> {
  option: <K, V>(key: K, value: V) => Chainable<T & { [P in K]: V }>
  get: () => any
}
```

这里我们使用 交叉类型，将 `T` 的类型信息和 `key` 和 `value` 的类型信息进行了合并，
最终得到的类型是：`T & { [P in K]: V }`。

但在这里我们还需要对 `K` 进行类型检查，因为 `K` 的类型可能不是字符串字面量类型。

```ts
interface Chainable<T = {}> {
  option: <K extends string, V>(key: K, value: V) => Chainable<T & { [P in K]: V }>
  get: () => any
}
```

接下来，我们需要在 `get` 方法 返回 `T` 的类型信息。

```ts
interface Chainable<T = {}> {
  option: <K extends string, V>(key: K, value: V) => Chainable<T & { [P in K]: V }>
  get: () => T
}
```

到这一步，已经基本可以满足挑战的要求了。

但我们还可以进一步思考，当连续调用`option(key, value)` 时传入的 相同的 `key` ，又或者 给相同的 `key` 传入
不同类型的 `value` 时，会发生什么情况？

```ts twoslash
interface Chainable<T = {}> {
  option: <K extends string, V>(key: K, value: V) => Chainable<T & { [P in K]: V }>
  get: () => T
}
// ---cut---
declare const config: Chainable

const result = config
  .option('name', 'foo') // step 1
  .option('name', 'bar') // step 2
  .option('name', 123) // step 3
  .get()
```

很明显可以看到，属性 `name` 的值类型被合并为 `string | number`。

我们不妨增加一些挑战难度，
**不允许合并 `key` 值的类型，重复调用的 `key` 的值类型应该与上一次调用的值类型保持一致，允许值被覆盖。**

这里需要对 `K` 进行类型检查，当 `K` 满足 `keyof T` 约束，即在 `T` 类型上已存在 `K` 这个属性时,
我们需要对 `V` 也进行类型检查，`V` 的类型是否可以分配给 `T[K]`，如果可以的话，那么 `K` 就可以作为 `key`，
否则应该返回 `never`，抛出错误。（由于 `never` 不能给其他类型使用，此时传入其他类型都会报错）

`K extends keyof T ? (V extends T[K] ? K : never) : K`

还需要对 `option()` 的返回类型进行检查，如果 `K` 满足 `keyof T` 约束时，需要先 `T` 上移除 `K` 这个属性，
然后再和 `V` 进行交叉类型，最终得到的类型是：`Omit<T, K> & { [P in K]: V }`。
而不满足 `keyof T` 约束时，直接和 `V` 进行交叉类型，最终得到的类型是：`T & { [P in K]: V }`。

## 答案

```ts
interface Chainable<T extends Record<string, unknown> = object> {
  option: <K extends string, V>(
    key: K extends keyof T ? (V extends T[K] ? K : never) : K,
    value: V,
  ) => K extends keyof T
    ? Chainable<Omit<T, K> & { [P in K]: V }>
    : Chainable<T & { [P in K]: V }>
  get: () => T
}
```

## 验证

```ts twoslash
import type { Alike, Expect } from '~/tc-utils'

interface Chainable<T extends Record<string, unknown> = {}> {
  option: <K extends string, V>(
    key: K extends keyof T ? (V extends T[K] ? K : never) : K,
    value: V
  ) => K extends keyof T
    ? Chainable<Omit<T, K> & { [P in K]: V }>
    : Chainable<T & { [P in K]: V }>
  get: () => T
}

// ---cut---
declare const a: Chainable

const result1 = a
  .option('foo', 123)
  .option('bar', { value: 'Hello World' })
  .option('name', 'type-challenges')
  .get()

const result2 = a
  .option('name', 'another name')
  .option('name', 'last name')
  .get()

const result3 = a
  .option('name', 'another name')
  // @ts-expect-error ignore
  .option('name', 123)
  .get()

type cases = [
  Expect<Alike<typeof result1, Expected1>>,
  Expect<Alike<typeof result2, Expected2>>,
  Expect<Alike<typeof result3, Expected3>>,
]

interface Expected1 {
  foo: number
  bar: {
    value: string
  }
  name: string
}

interface Expected2 {
  name: string
}

interface Expected3 {
  name: number
}
```

## 参考

* [交叉类型 Intersection Types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types)
* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)

---

---
url: /type-challenges/medium/check-repeated-chars/index.md
---
# checkRepeatedChars
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/check-repeated-tuple/index.md
---
# checkRepeatedTuple
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/chunk/index.md
---
# Chunk
## 题目

Github: [Chunk](https://github.com/type-challenges/type-challenges/blob/main/questions/04499-medium-chunk/README.md)

你知道 `lodash` 吗？其中的 `Chunk` 是一个非常实用的函数，现在让我们来实现它。
`Chunk<T, N>` 接受两个必需的类型参数，`T` 必须是一个元组，而 `N` 必须是一个大于等于 `1` 的整数。

```ts
type exp1 = Chunk<[1, 2, 3], 2> // expected to be [[1, 2], [3]]
type exp2 = Chunk<[1, 2, 3], 4> // expected to be [[1, 2, 3]]
type exp3 = Chunk<[1, 2, 3], 1> // expected to be [[1], [2], [3]]
```

## 解题思路

首先我们从类型声明开始，类型 `Chunk` 接受三个参数 `T`，`N`，`R`，`T` 是一个元组，`N` 是一个大于等于 `1` 的整数，
`R` 是一个可选的参数，用于保存单个分块的结果。

```ts
type Chunk<
  T extends unknown[],
  N extends number,
  R extends unknown[] = []
> = any
```

对于单个分块 `R`，当其长度为 `N` 时，即满足 `R['length'] extends N`，则表示分块已经填满，需要继续填充下一个分块：

```ts
type Chunk<T extends unknown[], N extends number, R extends unknown[] = []>
  = R['length'] extends N ? [...R, Chunk<T, N>] : any
```

当分块未填满且数组 `T` 中还有元素时 `T extends [infer F, ...infer U]`，需要继续分块：

```ts
type Chunk<T extends unknown[], N extends number, R extends unknown[] = []>
  = R['length'] extends N
    ? [...R, Chunk<T, N>]
    : T extends [infer F, ...infer U]
      ? Chunk<U, N, [...R, F]>
      : any
```

也要考虑，当数组 `T` 已清空时，如果 `R` 中还有元素，需要将 `[R]` 返回，否则返回 `[]` 。

## 答案

```ts
type Chunk<
  T extends unknown[],
  N extends number,
  R extends unknown[] = []
> = R['length'] extends N
  ? [R, ...Chunk<T, N>]
  : T extends [infer F, ...infer U]
    ? Chunk<U, N, [...R, F]>
    : R extends [] ? [] : [R]
```

## 验证

```ts twoslash
import type { Equal, Expect, NotEqual } from '~/tc-utils'

type Chunk<T extends unknown[], N extends number, R extends unknown[] = []> = R['length'] extends N
  ? [R, ...Chunk<T, N>]
  : T extends [infer F, ...infer U]
    ? Chunk<U, N, [...R, F]>
    : R extends [] ? [] : [R]

// ---cut---
type cases = [
  Expect<Equal<Chunk<[], 1>, []>>,
  Expect<Equal<Chunk<[1, 2, 3], 1>, [[1], [2], [3]]>>,
  Expect<Equal<Chunk<[1, 2, 3], 2>, [[1, 2], [3]]>>,
  Expect<Equal<Chunk<[1, 2, 3, 4], 2>, [[1, 2], [3, 4]]>>,
  Expect<Equal<Chunk<[1, 2, 3, 4], 5>, [[1, 2, 3, 4]]>>,
  Expect<Equal<Chunk<[1, true, 2, false], 2>, [[1, true], [2, false]]>>,
]
```

## 参考

* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [泛型约束 Generics constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /type-challenges/medium/combination-key-type/index.md
---
# combinationKeyType
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/combination/index.md
---
# Combination
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/compare-array-length/index.md
---
# compareArrayLength
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/construct-tuple/index.md
---
# ConstructTuple
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/count-element-number-to-object/index.md
---
# count Element Number To Object
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/deep-mutable/index.md
---
# DeepMutable
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/deep-omit/index.md
---
# deepOmit
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/deep-readonly/index.md
---
# 对象属性只读（递归）
## 题目

Github: [Deep Readonly](https://github.com/type-challenges/type-challenges/blob/main/questions/00009-medium-deep-readonly/)

实现一个通用的`DeepReadonly<T>`，它将对象的每个参数及其子对象递归地设为只读。

您可以假设在此挑战中我们仅处理对象。数组，函数，类等都无需考虑。但是，您仍然可以通过覆盖尽可能多的不同案例来挑战自己。

```ts
interface X {
  x: {
    a: 1
    b: 'hi'
  }
  y: 'hey'
}

interface Expected {
  readonly x: {
    readonly a: 1
    readonly b: 'hi'
  }
  readonly y: 'hey'
}

type Todo = DeepReadonly<X> // should be same as `Expected`
```

## 解题思路

通过 `readonly` 修饰属性为 只读属性。

通过 `T extends Record<any, any>` 判断是否为对象，如果是，使用 `readonly` 修饰属性为 只读属性，
并对 `T[P]` 递归调用 `DeepReadonly` 。

由于 `Function` 继承自 `Object`，所以需要单独处理 `Function` 类型。

## 答案

```ts
type DeepReadonly<T> = T extends Function
  ? T
  : T extends Record<any, any>
    ? { readonly [P in keyof T]: DeepReadonly<T[P]> }
    : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type DeepReadonly<T> = T extends Function
  ? T
  : T extends Record<any, any>
    ? { readonly [P in keyof T]: DeepReadonly<T[P]> }
    : T

// ---cut---
type cases = [
  Expect<Equal<DeepReadonly<X1>, Expected1>>,
  Expect<Equal<DeepReadonly<X2>, Expected2>>,
]

interface X1 {
  a: () => 22
  b: string
  c: {
    d: boolean
    e: {
      g: {
        h: {
          i: true
          j: 'string'
        }
        k: 'hello'
      }
      l: [
        'hi',
        {
          m: ['hey']
        },
      ]
    }
  }
}

type X2 = { a: string } | { b: number }

interface Expected1 {
  readonly a: () => 22
  readonly b: string
  readonly c: {
    readonly d: boolean
    readonly e: {
      readonly g: {
        readonly h: {
          readonly i: true
          readonly j: 'string'
        }
        readonly k: 'hello'
      }
      readonly l: readonly [
        'hi',
        {
          readonly m: readonly ['hey']
        },
      ]
    }
  }
}

type Expected2 = { readonly a: string } | { readonly b: number }
```

## 参考

* [索引类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)

---

---
url: /type-challenges/medium/defined-partial-record/index.md
---
# definedPartialRecord
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/diff/index.md
---
# Diff
## 题目

Github: [Diff](https://github.com/type-challenges/type-challenges/blob/main/questions/00645-medium-diff/)

获取两个接口类型中的差值属性。

```ts
interface Foo {
  a: string
  b: number
}
interface Bar {
  a: string
  c: boolean
}

type Result1 = Diff<Foo, Bar> // { b: number, c: boolean }
type Result2 = Diff<Bar, Foo> // { b: number, c: boolean }
```

## 解题思路

::: tip 此解题思路来自 [type-challenges#3014](https://github.com/type-challenges/type-challenges/issues/3014)
:::

在对象中使用 `|` 与 `&` ，与在非对象中使用存在语义上的差异。

在集合对象中使用联合类型 `|` ，
官网 [working-with-union-types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#working-with-union-types) 有如下说明:

> Notice that given two sets with corresponding facts about each set, only the intersection of those facts applies to the union of the sets themselves.

```ts
interface Foo {
  name: string
  age: string
}
interface Bar {
  name: string
  age: string
  gender: number
}

type result = keyof (Foo | Bar) // "name" | "age"
```

在集合对象中使用交集类型 `&` ，可以见 [intersection-types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types) 给出的 demo:

```ts
interface Colorful {
  color: string
}
interface Circle {
  radius: number
}

type ColorfulCircle = keyof (Colorful & Circle) // "color" | "radius"
```

结合 `&` 与 `|` 的使用，我们能立马写出比如类型 `diff`

## 答案

```ts
type Diff<O, O1> = Omit<O & O1, keyof (O | O1)>
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Diff<O, O1> = Omit<O & O1, keyof (O | O1)>

// ---cut---
interface Foo {
  name: string
  age: string
}
interface Bar {
  name: string
  age: string
  gender: number
}
interface Coo {
  name: string
  gender: number
}

type cases = [
  Expect<Equal<Diff<Foo, Bar>, { gender: number }>>,
  Expect<Equal<Diff<Bar, Foo>, { gender: number }>>,
  Expect<Equal<Diff<Foo, Coo>, { age: string, gender: number }>>,
  Expect<Equal<Diff<Coo, Foo>, { age: string, gender: number }>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [映射类型中的键重映射 Key Remapping In Mapped Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types)
* [联合类型 Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
* [交叉类型 Intersection Types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [keyof 和查找类型 Keyof And Lookup Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)

---

---
url: /type-challenges/medium/drop-char/index.md
---
# Drop Char
## 题目

Github: [DropChar](https://github.com/type-challenges/type-challenges/blob/main/questions/02070-medium-drop-char/)

从字符串中剔除指定字符。

```ts
type Butterfly = DropChar<' b u t t e r f l y ! ', ' '> // 'butterfly!'
```

## 解题思路

这个挑战相对来说很简单，可以通过 模板字面量类型 和 条件类型 快速解决。

需要注意的是， 当`C` 是 `''` 时，可能会导致递归太深的问题，因此当 `C` 为 `''` 时，需要直接返回 `S` 。

## 答案

```ts
type DropChar<S extends string, C extends string> = C extends ''
  ? S
  : S extends `${infer L}${C}${infer R}`
    ? DropChar<`${L}${R}`, C>
    : S
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type DropChar<S extends string, C extends string> = C extends ''
  ? S
  : S extends `${infer L}${C}${infer R}`
    ? DropChar<`${L}${R}`, C>
    : S

// ---cut---
type cases = [
  // @ts-expect-error
  Expect<Equal<DropChar<'butter fly!', ''>, 'butterfly!'>>,
  Expect<Equal<DropChar<'butter fly!', ' '>, 'butterfly!'>>,
  Expect<Equal<DropChar<'butter fly!', '!'>, 'butter fly'>>,
  Expect<Equal<DropChar<'    butter fly!        ', ' '>, 'butterfly!'>>,
  Expect<Equal<DropChar<' b u t t e r f l y ! ', ' '>, 'butterfly!'>>,
  Expect<Equal<DropChar<' b u t t e r f l y ! ', 'b'>, '  u t t e r f l y ! '>>,
  Expect<Equal<DropChar<' b u t t e r f l y ! ', 't'>, ' b u   e r f l y ! '>>,
]
```

## 参考

* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)

---

---
url: /type-challenges/medium/ends-with/index.md
---
# EndsWith
## 题目

实现 `EndsWith<T, U>` ,接收两个 `string` 类型参数,然后判断 `T` 是否以 `U` 结尾,根据结果返回 `true` 或 `false`

```ts
type a = EndsWith<'abc', 'bc'> // expected to be true
type b = EndsWith<'abc', 'abc'> // expected to be true
type c = EndsWith<'abc', 'd'> // expected to be false
```

## 解题思路

略。

## 答案

```ts
type EndsWith<T extends string, U extends string> = T extends `${string}${U}` ? true : false
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type EndsWith<T extends string, U extends string> = T extends `${string}${U}` ? true : false

// ---cut---
type cases = [
  Expect<Equal<EndsWith<'abc', 'bc'>, true>>,
  Expect<Equal<EndsWith<'abc', 'abc'>, true>>,
  Expect<Equal<EndsWith<'abc', 'd'>, false>>,
  Expect<Equal<EndsWith<'abc', 'ac'>, false>>,
  Expect<Equal<EndsWith<'abc', ''>, true>>,
  Expect<Equal<EndsWith<'abc', ' '>, false>>,
]
```

## 参考

* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [泛型约束 Generics constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

---

---
url: /type-challenges/medium/extract-to-object/index.md
---
# extractToObject
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/fibonacci-sequence/index.md
---
# FibonacciSequence
## 题目

Github: [FibonacciSequence](https://github.com/type-challenges/type-challenges/blob/main/questions/04182-medium-fibonacci-sequence/README.zh-CN.md)

实现一个通用的斐波那契函数 `Fibonacci<T>`，它接受一个数字 `T` 并返回其对应的 [斐波那契数](https://en.wikipedia.org/wiki/Fibonacci_number)。

序列开始为：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...

```ts
type Result1 = Fibonacci<3> // 2
type Result2 = Fibonacci<8> // 21
```

## 解题思路

斐波那契数列通常从0和1开始，后续的每一项都是前两项的和。数列的前几项如下：

$$
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \dots
$$

用数学公式表示为：

$$
F(0) = 0, \quad F(1) = 1
$$
$$
F(n) = F(n-1) + F(n-2) \quad (n \geq 2)
$$

在 Typescript 中不支持直接的加减乘除运算，但是对于 加法，我们可以通过 两个元组的合并，
取新合并的元组的长度来间接实现 加法 （对数字有范围限制，这通常由 Typescript 递归深度限制）。

已知 类型 `T` 表示 `n`，求 $F(n)$ 。因此我们需要知道 $F(n-1)$ 和 $F(n-2)$ ，
对 $F(n-1)$ 需要知道 $F(n-2)$ 和 $F(n-3)$ ， 以此类推，最终回到 $F(1)$ 和 $F(0)$ ，这也是我们已知的值。
换句话来说，我们需要知道 `n` 之前的所有 斐波那契数。

因此，不妨从 `n = 2` 开始，即求 $F(0)$ 和 $F(1)$ 的和，通过递归知道 `n = T` 时得到结果：

* 使用元组类型 `CurrentIndex` 的长度表示 `n` ，其默认长度为 `1` ，即 $n=1$ 。
* 使用元组类型 `Prev` 的长度表示 `n - 2` 的值，当 `n = 2` 时，即为 $F(0) = 0$ 。
* 使用元组类型 `Current` 的长度表示 `n - 1` 的值，当 `n = 2` 时，即为 $F(1) = 1$ 。

由于 `CurrentIndex` 默认长度为 `1`，此时 `Current` 即为 `n = 1` 时的 斐波那契数。

通过条件类型 `CurrentIndex['length'] extends T` 当为真时， `Current` 的长度即为 `n = T` 时的斐波那契数。

```ts
type Fibonacci<
  T extends number,
  CurrentIndex extends any[] = [1],
  Prev extends any[] = [],
  Current extends any[] = [1]
> = CurrentIndex['length'] extends T
  ? Current['length']
  : any
```

当为假时，我们继续迭代, 将 `Current` 传给 `Prev`, 并使用 `Current` 和 `Prev` 合并的新元组
作为 `Current` 的新值。同时别忘了需要对 `CurrentIndex` 新增一个成员：

```ts
type Fibonacci<
  T extends number,
  CurrentIndex extends any[] = [1],
  Prev extends any[] = [],
  Current extends any[] = [1]
> = CurrentIndex['length'] extends T
  ? Current['length']
  : Fibonacci<T, [...CurrentIndex, 1], Current, [...Prev, ...Current]> // [!code ++]
```

## 答案

```ts
type Fibonacci<
  T extends number,
  CurrentIndex extends any[] = [1],
  Prev extends any[] = [],
  Current extends any[] = [1]
> = CurrentIndex['length'] extends T
  ? Current['length']
  : Fibonacci<T, [...CurrentIndex, 1], Current, [...Prev, ...Current]>
```

## 验证

```ts twoslash
import type { Equal, Expect, NotEqual } from '~/tc-utils'

type Fibonacci<
  T extends number,
  CurrentIndex extends any[] = [1],
  Prev extends any[] = [],
  Current extends any[] = [1]
> = CurrentIndex['length'] extends T
  ? Current['length']
  : Fibonacci<T, [...CurrentIndex, 1], Current, [...Prev, ...Current]>

// ---cut---
type cases = [
  Expect<Equal<Fibonacci<1>, 1>>,
  Expect<Equal<Fibonacci<2>, 1>>,
  Expect<Equal<Fibonacci<3>, 2>>,
  Expect<Equal<Fibonacci<8>, 21>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)

---

---
url: /type-challenges/medium/fill/index.md
---
# Fill
## 题目

Github: [Fill](https://github.com/type-challenges/type-challenges/blob/main/questions/04518-medium-fill/README.md)

Fill，一个常见的JavaScript函数，现在让我们用类型来实现它。
`Fill<T, N, Start?, End?>`，如你所见，`Fill` 接受四种类型的参数，其中 `T` 和 `N` 是必需参数，
而 `Start` 和 `End` 是可选参数。
这些参数的要求是：`T` 必须是元组，`N` 可以是任何类型的值，`Start` 和 `End` 必须是大于或等于 `0` 的整数。

```ts
type exp = Fill<[1, 2, 3], 0> // expected to be [0, 0, 0]
```

## 解题思路

首先，我们从类型声明开始，类型 `Fill` 接受五个参数 `T`，`N`，`Start`，`End`，`Count`，`Flag`，
`T` 是一个元组，`N` 可以是任何类型的值, `Start` 和 `End` 必须是大于或等于 `0` 的整数。

**通过 `Count` 数组隐式追踪索引：**

* 在 `Count` 等于 `End` 的时候需要结束替换，也就是结束条件
* 当 `Count` 等于 `Start` 的时候是开始替换的条件，递归处理数组替换即可，注意需要把 `T` 换成新的

**使用 `Flag` 标记当前是否需要替换：**

* 通过 `Flag` 的默认值 `Count['length'] extends Start ? true : false` 智能触发状态切换。
* 仅在未显式传递 `Flag` 时 重新计算状态，实现状态锁存：
  * 当第一次进入填充区间时，`Flag` 被设置为 `true`
  * 后续递归中显式传递 `Flag` 参数，保持状态不变

**`Count['length'] extends End` 作为终止条件**

剩余元素直接保留原样，确保处理效率

## 答案

```ts
type Fill<
  T extends unknown[],
  N,
  Start extends number = 0,
  End extends number = T['length'],
  Count extends any[] = [],
  Flag extends boolean = Count['length'] extends Start ? true : false
>
  = Count['length'] extends End
    ? T
    : T extends [infer R, ...infer U]
      ? Flag extends false
        ? [R, ...Fill<U, N, Start, End, [...Count, 0]>]
        : [N, ...Fill<U, N, Start, End, [...Count, 0], Flag>]
      : T
```

## 验证

```ts twoslash
import type { Equal, Expect, NotEqual } from '~/tc-utils'

type Fill<
  T extends unknown[],
  N,
  Start extends number = 0,
  End extends number = T['length'],
  Count extends any[] = [],
  Flag extends boolean = Count['length'] extends Start ? true : false
>
  = Count['length'] extends End
    ? T
    : T extends [infer R, ...infer U]
      ? Flag extends false
        ? [R, ...Fill<U, N, Start, End, [...Count, 0]>]
        : [N, ...Fill<U, N, Start, End, [...Count, 0], Flag>]
      : T

// ---cut---
type cases = [
  Expect<Equal<Fill<[], 0>, []>>,
  Expect<Equal<Fill<[], 0, 0, 3>, []>>,
  Expect<Equal<Fill<[1, 2, 3], 0, 0, 0>, [1, 2, 3]>>,
  Expect<Equal<Fill<[1, 2, 3], 0, 2, 2>, [1, 2, 3]>>,
  Expect<Equal<Fill<[1, 2, 3], 0>, [0, 0, 0]>>,
  Expect<Equal<Fill<[1, 2, 3], true>, [true, true, true]>>,
  Expect<Equal<Fill<[1, 2, 3], true, 0, 1>, [true, 2, 3]>>,
  Expect<Equal<Fill<[1, 2, 3], true, 1, 3>, [1, true, true]>>,
  Expect<Equal<Fill<[1, 2, 3], true, 10, 0>, [1, 2, 3]>>,
  Expect<Equal<Fill<[1, 2, 3], true, 10, 20>, [1, 2, 3]>>,
  Expect<Equal<Fill<[1, 2, 3], true, 0, 10>, [true, true, true]>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /type-challenges/medium/filter/index.md
---
# Filter
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/find-all/index.md
---
# findAll
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/first-unique-char-index/index.md
---
# FirstUniqueCharIndex
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/flatten-depth/index.md
---
# FlattenDepth
## 题目

递归地将数组扁平化，最多进行 `depth` 次。

```ts
type a = FlattenDepth<[1, 2, [3, 4], [[[5]]]], 2> // [1, 2, 3, 4, [5]]. 展开 2 次
type b = FlattenDepth<[1, 2, [3, 4], [[[5]]]]> // [1, 2, 3, 4, [[5]]]. 深度默认为 1
```

如果提供了深度，则保证其为正整数。

## 解题思路

我们已经在 [Flatten](./459.flatten.md) 这个挑战中知道应该如何将一个数组完全扁平化。

```ts
type Flatten<T extends unknown[]> = T extends [infer F, ...infer R]
  ? F extends unknown[]
    ? [...Flatten<F>, ...Flatten<R>]
    : [F, ...Flatten<R>]
  : T
```

同样的思路可以应用到这个挑战多，只是多了一个限制条件，即最多进行 `depth` 次。

在 类型参数中添加一个 `Depth` 类型参数，表示最大次数。由于在 Typescript 中并不支持运算操作，
但我们可以通过给 元组添加成员，再获取元组的长度 来实现累加，添加一个 `R` 类型参数保存元组：

```ts
type FlattenDepth<
  T extends unknown[],
  Depth extends number = 1,
  R extends unknown[] = []
> = T extends [infer F, ...infer O]
  ? F extends unknown[]
    ? [...FlattenDepth<F, Depth, R>, ...FlattenDepth<O, Depth, R>]
  //     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  //     实际只在这里进行一次展开
    : [F, ...FlattenDepth<O, Depth, R>]
  : T
```

我们只需要在实际展开的位置，在类型参数 `R` 中添加成员，通过 `R['length']` 获取最新长度，
判断是否达到 `Depth` 的最大限制。

## 答案

```ts
type FlattenDepth<
  T extends unknown[],
  Depth extends number = 1,
  R extends unknown[] = []
> = R['length'] extends Depth
  ? T
  : T extends [infer F, ...infer O]
    ? F extends unknown[]
      ? [...FlattenDepth<F, Depth, [unknown, ...R]>, ...FlattenDepth<O, Depth, R>]
      : [F, ...FlattenDepth<O, Depth, R>]
    : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type FlattenDepth<
  T extends unknown[],
  Depth extends number = 1,
  R extends unknown[] = []
> = R['length'] extends Depth
  ? T
  : T extends [infer F, ...infer O]
    ? F extends unknown[]
      ? [...FlattenDepth<F, Depth, [unknown, ...R]>, ...FlattenDepth<O, Depth, R>]
      : [F, ...FlattenDepth<O, Depth, R>]
    : T

// ---cut---
type cases = [
  Expect<Equal<FlattenDepth<[]>, []>>,
  Expect<Equal<FlattenDepth<[1, 2, 3, 4]>, [1, 2, 3, 4]>>,
  Expect<Equal<FlattenDepth<[1, [2]]>, [1, 2]>>,
  Expect<Equal<FlattenDepth<[1, 2, [3, 4], [[[5]]]], 2>, [1, 2, 3, 4, [5]]>>,
  Expect<Equal<FlattenDepth<[1, 2, [3, 4], [[[5]]]]>, [1, 2, 3, 4, [[5]]]>>,
  Expect<Equal<FlattenDepth<[1, [2, [3, [4, [5]]]]], 3>, [1, 2, 3, 4, [5]]>>,
  Expect<Equal<FlattenDepth<[1, [2, [3, [4, [5]]]]], 19260817>, [1, 2, 3, 4, 5]>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)

---

---
url: /type-challenges/medium/flatten/index.md
---
# 数组扁平化
## 题目

Github: [Flatten](https://github.com/type-challenges/type-challenges/blob/main/questions/00459-medium-flatten/)

在这个挑战中，你需要写一个接受数组的类型，并且返回扁平化的数组类型。

```ts
type flatten = Flatten<[1, 2, [3, 4], [[[5]]]]> // [1, 2, 3, 4, 5]
```

## 解题思路

首先挑战限制了只能接受数组，因此我们需要使用条件类型限制泛型参数 `T`

```ts
type Flatten<T extends unknown[]> = any
```

由于我们不知道数组的每个成员是数组类型还是其他类型，所以我们需要依次对数组的每个成员进行判断。
这需要使用条件类型类型推断，获取数组的成员。

```ts
type Flatten<T extends unknown[]> = T extends [infer L, ...infer R] ? L : T
```

在获取到第一个成员 `L` 后，我们需要判断它是否是数组类型，以检查它是否需要继续扁平化。
并对剩余成员进行递归处理，直到没有成员需要继续扁平化。

## 答案

```ts
type Flatten<T extends unknown[]> = T extends [infer L, ...infer R]
  ? L extends unknown[]
    ? [...Flatten<L>, ...Flatten<R>]
    : [L, ...Flatten<R>]
  : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type Flatten<T extends unknown[]> = T extends [infer L, ...infer R]
  ? L extends unknown[] ? [...Flatten<L>, ...Flatten<R>] : [L, ...Flatten<R>]
  : T
// ---cut---
type cases = [
  Expect<Equal<Flatten<[]>, []>>,
  Expect<Equal<Flatten<[1, 2, 3, 4]>, [1, 2, 3, 4]>>,
  Expect<Equal<Flatten<[1, [2]]>, [1, 2]>>,
  Expect<Equal<Flatten<[1, 2, [3, 4], [[[5]]]]>, [1, 2, 3, 4, 5]>>,
  Expect<Equal<Flatten<[{ foo: 'bar', 2: 10 }, 'foobar']>, [{ foo: 'bar', 2: 10 }, 'foobar']>>,
]

// @ts-expect-error ignore
type error = Flatten<'1'>
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)

---

---
url: /type-challenges/medium/flip-arguments/index.md
---
# FlipArguments
## 题目

Github: [FlipArguments](https://github.com/type-challenges/type-challenges/blob/main/questions/03196-medium-flip-arguments/)

实现 `lodash` 的 `_.flip` 的类型版本。

类型 `FlipArguments<T>` 要求函数类型 `T`，并返回一个新的函数类型，该类型具有与 `T` 相同的返回类型，但参数顺序相反。

```ts
type Flipped = FlipArguments<(arg0: string, arg1: number, arg2: boolean) => void>
// (arg0: boolean, arg1: number, arg2: string) => void
```

## 解题思路

由于我们已经在 [Reverse](./3192.reverse.md) 中实现了数组翻转。此挑战剩余的问题已十分简单，
利用条件类型推断获取 参数数组，对齐翻转 即可完成挑战。

## 答案

```ts
type Reverse<T extends unknown[]> = T extends [infer L, ...infer O]
  ? [...Reverse<O>, L]
  : T

type FlipArguments<
  T extends (...args: any[]) => any
> = T extends (...args: infer P) => infer R
  ? (...args: Reverse<P>) => R
  : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Reverse<T extends unknown[]> = T extends [infer L, ...infer O]
  ? [...Reverse<O>, L]
  : T

type FlipArguments<
  T extends (...args: any[]) => any
> = T extends (...args: infer P) => infer R
  ? (...args: Reverse<P>) => R
  : never

// ---cut---
type cases = [
  Expect<Equal<FlipArguments<() => boolean>, () => boolean>>,
  Expect<Equal<FlipArguments<(foo: string) => number>, (foo: string) => number>>,
  Expect<Equal<FlipArguments<(arg0: string, arg1: number, arg2: boolean) => void>, (arg0: boolean, arg1: number, arg2: string) => void>>,
]

type errors = [
  // @ts-expect-error
  FlipArguments<'string'>,
  // @ts-expect-error
  FlipArguments<{ key: 'value' }>,
  // @ts-expect-error
  FlipArguments<['apple', 'banana', 100, { a: 1 }]>,
  // @ts-expect-error
  FlipArguments<null | undefined>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [递归条件类型 Recursive conditional types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)

---

---
url: /type-challenges/medium/flip/index.md
---
# Flip
## 题目

Github: [Flip](https://github.com/type-challenges/type-challenges/blob/main/questions/04179-medium-flip/)

实现仅翻转对象的类型。

```ts
Flip<{ a: 'x', b: 'y', c: 'z' }> // {x: 'a', y: 'b', z: 'c'}
Flip<{ a: 1, b: 2, c: 3 }> // {1: 'a', 2: 'b', 3: 'c'}
Flip<{ a: false, b: true }> // {false: 'a', true: 'b'}
```

无需支持嵌套对象以及无法作为对象键的值（如数组）。

## 解题思路

这道题目相对简单，只需使用 映射类型，然后对 对象的 `key` 重映射为预期的类型即可。

## 答案

```ts
type AllowedTypes = string | number | boolean

type Flip<T> = {
  [P in keyof T as T[P] extends AllowedTypes ? `${T[P]}` : never]: P
}
```

## 验证

```ts twoslash
import type { Equal, Expect, NotEqual } from '~/tc-utils'

type AllowedTypes = string | number | boolean

type Flip<T> = {
  [P in keyof T as T[P] extends AllowedTypes ? `${T[P]}` : never]: P
}

// ---cut---
type cases = [
  Expect<Equal<{ a: 'pi' }, Flip<{ pi: 'a' }>>>,
  Expect<NotEqual<{ b: 'pi' }, Flip<{ pi: 'a' }>>>,
  Expect<Equal<{ 3.14: 'pi', true: 'bool' }, Flip<{ pi: 3.14, bool: true }>>>,
  Expect<Equal<{ val2: 'prop2', val: 'prop' }, Flip<{ prop: 'val', prop2: 'val2' }>>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [通过 `as` 进行按键重映射 Key remapping via `as`](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as)

---

---
url: /type-challenges/medium/get-middle-element/index.md
---
# GetMiddleElement
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/get-return-type/index.md
---
# 获取函数返回类型
## 题目

Github: [Get return type](https://github.com/type-challenges/type-challenges/blob/main/questions/00002-medium-return-type/)

不使用 `ReturnType` 实现 `TypeScript` 的 `ReturnType<T>` 泛型。

```ts
function fn(v: boolean) {
  if (v)
    return 1
  else return 2
}

type a = MyReturnType<typeof fn> // 应推导出 "1 | 2"
```

## 解题思路

使用条件类型中的类型推断，泛型参数 `T` 是否可以分配给 `() => void`。

通过类型参数从条件类型推断为真时，获取函数返回类型 `() => infer R` 。

我们并不关心函数是否带参数，需要带上参数 `...args: any[]` 表示可以接受任何参数。

## 答案

```ts
type MyReturnType<T> = T extends (...args: any[]) => infer R ? R : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type MyReturnType<T> = T extends (...args: any[]) => infer R ? R : never

// ---cut---
type cases = [
  Expect<Equal<string, MyReturnType<() => string>>>,
  Expect<Equal<123, MyReturnType<() => 123>>>,
  Expect<Equal<ComplexObject, MyReturnType<() => ComplexObject>>>,
  Expect<Equal<Promise<boolean>, MyReturnType<() => Promise<boolean>>>>,
  Expect<Equal<() => 'foo', MyReturnType<() => () => 'foo'>>>,
  Expect<Equal<1 | 2, MyReturnType<typeof fn>>>,
  Expect<Equal<1 | 2, MyReturnType<typeof fn1>>>,
]

interface ComplexObject {
  a: [12, 'foo']
  bar: 'hello'
  prev: () => number
}

const fn = (v: boolean) => v ? 1 : 2
const fn1 = (v: boolean, w: any) => v ? 1 : 2
```

## 参考

> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
> * [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /type-challenges/medium/greater-than/index.md
---
# GreaterThan
## 题目

Github: [GreaterThan](https://github.com/type-challenges/type-challenges/blob/main/questions/04425-medium-greater-than/)

在此挑战中，您需要实现一个类型 `GreaterThan<T, U>`，类似于 `T > U`。

无需考虑负数。

```ts
GreaterThan<2, 1> // should be true
GreaterThan<1, 1> // should be false
GreaterThan<10, 100> // should be false
GreaterThan<111, 11> // should be true
```

## 解题思路

比较大小在 JavaScript 中是非常容易的事情，但是放到 typescript 的类型系统中，就不那么容易了。
typescript 的类型系统并不支持这些数学运算。

对于这个挑战，一开始很容易想到利用 数组 的特性来解决，通过构建两个长度为 `T` 和 `U` 的数组，判断
`ArrU` 是否是 `ArrT` 的子集，如果是的话，那么 `T` 就比 `U` 大，反之则不是。对于构建特定长度的数组，
可以使用递归的方式来实现。

```ts
type LenToArr<T extends number, R extends any[] = []> = R['length'] extends T
  ? R
  : LenToArr<T, [...R, 0]>

type GreaterThan<T extends number, U extends number>
  = LenToArr<U> extends [...LenToArr<T>, ...infer _] ? false : true
```

我们使用这个实现来进行验证：

```ts twoslash
// @errors: 2589
import type { Equal, Expect, NotEqual } from '~/tc-utils'

type LenToArr<T extends number, R extends any[] = []> = R['length'] extends T
  ? R
  : LenToArr<T, [...R, 0]>

type GreaterThan<T extends number, U extends number>
  = LenToArr<U> extends [...LenToArr<T>, ...infer _] ? false : true

// ---cut---
type cases = [
  Expect<Equal<GreaterThan<1, 0>, true>>,
  Expect<Equal<GreaterThan<5, 4>, true>>,
  Expect<Equal<GreaterThan<4, 5>, false>>,
  Expect<Equal<GreaterThan<0, 0>, false>>,
  Expect<Equal<GreaterThan<10, 9>, true>>,
  Expect<Equal<GreaterThan<20, 20>, false>>,
  Expect<Equal<GreaterThan<10, 100>, false>>,
  Expect<Equal<GreaterThan<111, 11>, true>>,
  Expect<Equal<GreaterThan<13, 12>, true>>,
  Expect<Equal<GreaterThan<1234567891011, 1234567891010>, true>>,
]
```

可以看到，在数字比较小时，通过 递归实现的类型是可以通过的，但是在大数字时，会出现错误，
这是因为 typescript 的类型系统对递归有深度限制。

因此，通过递归实现并不是最优解。

我们不妨将数字转为字符串，通过比对字符串来实现，这可以避免递归深度的问题。

我们可以延续 [minus one](./2257.minusOne.md) 挑战中的思路，将数字转为字符串，然后分别对相对应
的位数进行比较，最终得到结果。

**对于两个不同的十以内的数，通过检查这两个数分别位于 `0123456789` 的位置判断大小：**

```ts
type GreaterThan<T extends number, U extends number>
  = '0123456789' extends `${string}${T}${string}${U}${string}`
    ? false
    : true
```

当 `T` 位于 `U` 的左侧时，则说明 `T` 小于 `U`, 反之则 `T` 大于 `U`。

**检查两个数字字符串的长度，根据长度判断大小：**

```ts
type DigitCountArr<T extends string> = T extends `${string}${infer R}`
  ? [0, ...DigitCountArr<R>]
  : []

type DigitCountCompare<
  T extends number,
  U extends number
> = '0123456789' extends `${string}${T}${string}${U}${string}`
  ? '<'
  : '0123456789' extends `${string}${U}${string}${T}${string}`
    ? '>'
    : '='
```

**当两个数字字符串的长度相同时，分别对每位位数进行比较：**

```ts
type GreaterThanSameDigitCount<
  T extends number | string,
  U extends number | string
> = `${T}` extends `${infer TF}${infer TR}`
  ? `${U}` extends `${infer UF}${infer UR}`
    ? TF extends UF
      ? GreaterThanSameDigitCount<TR, UR>
      : '0123456789' extends `${string}${TF}${string}${UF}${string}`
        ? false
        : true
    : true
  : false
```

## 答案

```ts
type DigitCountArr<T extends string> = T extends `${string}${infer R}`
  ? [0, ...DigitCountArr<R>]
  : []

type DigitCountCompare<
  T extends number,
  U extends number
> = '0123456789' extends `${string}${T}${string}${U}${string}`
  ? '<'
  : '0123456789' extends `${string}${U}${string}${T}${string}`
    ? '>'
    : '='

type GreaterThanSameDigitCount<
  T extends number | string,
  U extends number | string
> = `${T}` extends `${infer TF}${infer TR}`
  ? `${U}` extends `${infer UF}${infer UR}`
    ? TF extends UF
      ? GreaterThanSameDigitCount<TR, UR>
      : '0123456789' extends `${string}${TF}${string}${UF}${string}`
        ? false
        : true
    : true
  : false

type GreaterThan<
  T extends number | string,
  U extends number | string,
  C = DigitCountCompare<DigitCountArr<`${T}`>['length'], DigitCountArr<`${U}`>['length']>
> = C extends '='
  ? GreaterThanSameDigitCount<T, U>
  : C extends '>'
    ? true
    : false
```

## 验证

```ts twoslash
import type { Equal, Expect, NotEqual } from '~/tc-utils'

type DigitCountArr<T extends string> = T extends `${string}${infer R}` ? [0, ...DigitCountArr<R>] : []
type DigitCountCompare<T extends number, U extends number> = '0123456789' extends `${string}${T}${string}${U}${string}`
  ? '<'
  : '0123456789' extends `${string}${U}${string}${T}${string}`
    ? '>'
    : '='
type GreaterThanSameDigitCount<T extends number | string, U extends number | string>
  = `${T}` extends `${infer TF}${infer TR}`
    ? `${U}` extends `${infer UF}${infer UR}`
      ? TF extends UF
        ? GreaterThanSameDigitCount<TR, UR>
        : '0123456789' extends `${string}${TF}${string}${UF}${string}`
          ? false
          : true
      : true
    : false

type GreaterThan<
  T extends number | string,
  U extends number | string,
  C = DigitCountCompare<DigitCountArr<`${T}`>['length'], DigitCountArr<`${U}`>['length']>
> = C extends '='
  ? GreaterThanSameDigitCount<T, U>
  : C extends '>'
    ? true
    : false

// ---cut---
type cases = [
  Expect<Equal<GreaterThan<1, 0>, true>>,
  Expect<Equal<GreaterThan<5, 4>, true>>,
  Expect<Equal<GreaterThan<4, 5>, false>>,
  Expect<Equal<GreaterThan<0, 0>, false>>,
  Expect<Equal<GreaterThan<10, 9>, true>>,
  Expect<Equal<GreaterThan<20, 20>, false>>,
  Expect<Equal<GreaterThan<10, 100>, false>>,
  Expect<Equal<GreaterThan<111, 11>, true>>,
  Expect<Equal<GreaterThan<13, 12>, true>>,
  Expect<Equal<GreaterThan<1234567891011, 1234567891010>, true>>,
]
```

## 参考

* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [泛型约束 Generics constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /type-challenges/medium/in-order-traversal/index.md
---
# InorderTraversal
## 题目

Github: [InorderTraversal](https://github.com/type-challenges/type-challenges/blob/main/questions/03376-medium-inordertraversal/README.md)

实现二叉树中序遍历的类型版本。

```ts
const tree1 = {
  val: 1,
  left: null,
  right: {
    val: 2,
    left: {
      val: 3,
      left: null,
      right: null,
    },
    right: null,
  },
} as const

type A = InorderTraversal<typeof tree1> // [1, 3, 2]
```

## 解题思路

在二叉树的有序遍历中，我们遍历一个节点的子树，然后“访问”这个节点，然后遍历它的另 一个子树。通常，我们会先遍历左子树，然后再遍历节点的右子树。

```txt
      A
    /   \
   B     C
 /   \
D     E

In-order Traversal: D, B, E, A, C
```

## 答案

```ts
interface TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
}

type InorderTraversal<
  T extends TreeNode | null,
  R extends TreeNode = NonNullable<T>
>
  = T extends null
    ? []
    : [...InorderTraversal<R['left']>, R['val'], ...InorderTraversal<R['right']>]
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

interface TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
}

type InorderTraversal<
  T extends TreeNode | null,
  R extends TreeNode = NonNullable<T>
>
  = T extends null
    ? []
    : [...InorderTraversal<R['left']>, R['val'], ...InorderTraversal<R['right']>]

// ---cut---
const tree1 = {
  val: 1,
  left: null,
  right: {
    val: 2,
    left: {
      val: 3,
      left: null,
      right: null,
    },
    right: null,
  },
} as const

const tree2 = {
  val: 1,
  left: null,
  right: null,
} as const

const tree3 = {
  val: 1,
  left: {
    val: 2,
    left: null,
    right: null,
  },
  right: null,
} as const

const tree4 = {
  val: 1,
  left: null,
  right: {
    val: 2,
    left: null,
    right: null,
  },
} as const

type cases = [
  Expect<Equal<InorderTraversal<null>, []>>,
  Expect<Equal<InorderTraversal<typeof tree1>, [1, 3, 2]>>,
  Expect<Equal<InorderTraversal<typeof tree2>, [1]>>,
  Expect<Equal<InorderTraversal<typeof tree3>, [2, 1]>>,
  Expect<Equal<InorderTraversal<typeof tree4>, [1, 2]>>,
]
```

## 参考

* [Tree Traversal Techniques](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)

---

---
url: /type-challenges/medium/index-of/index.md
---
# IndexOf
## 题目

Github: [IndexOf](https://github.com/type-challenges/type-challenges/blob/main/questions/05153-medium-indexof/)

实现数组的索引查找类型版本，`indexOf<T, U>` 接收一个数组 `T` 和任意类型 `U`，
并返回数组 `T` 中第一个 `U` 类型的元素的索引。

```ts
type Res = IndexOf<[1, 2, 3], 2> // expected to be 1
type Res1 = IndexOf<[2, 6, 3, 8, 4, 1, 7, 3, 9], 3> // expected to be 2
type Res2 = IndexOf<[0, 0, 0], 2> // expected to be -1
```

## 解题思路

本挑战的难点在于 如何判断一个类型是否严格等于另一个类型。

对于此难点，请参考 [类型系统的真假美猴王：破解 IsEqual\<X, Y> 之谜](../../../1.前端/12.TypeScript/isEqual.md)

通过 条件类型 `infer`，从数组 `T` 中，通过递归的方式取出一个个元素，判断是否严格等于类型 `U`，
如果是，则直接返回 `R['length']` 的长度，否则继续递归取下一个元素，并为 `R` 添加一个元素。

由于开始递归时，类型`R` 为空数组，因此此时的 `R['length']` 恰好 为 `0`。

## 答案

```ts
type Equal<X, Y>
  = (<T>() => T extends X ? 1 : 2) extends
  (<T>() => T extends Y ? 1 : 2) ? true : false

type IndexOf<T extends unknown[], U, R extends unknown[] = []>
  = T extends [infer F, ...infer O]
    ? Equal<U, F> extends true
      ? R['length']
      : IndexOf<O, U, [unknown, ...R]>
    : -1
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type IndexOf<T extends unknown[], U, R extends unknown[] = []>
  = T extends [infer F, ...infer O]
    ? Equal<U, F> extends true
      ? R['length']
      : IndexOf<O, U, [unknown, ...R]>
    : -1

// ---cut---
type cases = [
  Expect<Equal<IndexOf<[1, 2, 3], 2>, 1>>,
  Expect<Equal<IndexOf<[2, 6, 3, 8, 4, 1, 7, 3, 9], 3>, 2>>,
  Expect<Equal<IndexOf<[0, 0, 0], 2>, -1>>,
  Expect<Equal<IndexOf<[string, 1, number, 'a'], number>, 2>>,
  Expect<Equal<IndexOf<[string, 1, number, 'a', any], any>, 4>>,
  Expect<Equal<IndexOf<[string, 'a'], 'a'>, 1>>,
  Expect<Equal<IndexOf<[any, 1], 1>, 1>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /type-challenges/medium/integer/index.md
---
# Integer
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/is-alphabet/index.md
---
# isAlphabet
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/is-never/index.md
---
# IsNever
## 题目

Github: [IsNever](https://github.com/type-challenges/type-challenges/blob/main/questions/01042-medium-isnever/)

实现一个类型 `IsNever`，它接受输入类型 `T`。如果 `T` 解析为 `never`，则返回 `true`，否则返回 `false`。

```ts
type A = IsNever<never> // expected to be true
type B = IsNever<undefined> // expected to be false
type C = IsNever<null> // expected to be false
type D = IsNever<[]> // expected to be false
type E = IsNever<number> // expected to be false
```

## 解题思路

在 typescript 中，我们不能通过 `T extends never ？ true : false` 判断一个类型是否为 `never`，
因为 在 `T extends never` 中 `never` 本质上是一个没有成员的联合类型，
这导致了 `never extends never ? true : false` 整体被跳过了，得到的结果为 `never` , 而不是 `true/false`。

要避免这种情况，可以在`extends` 两边的类型用方括号包裹，这可以避免 触发条件类型分支。

## 答案

```ts
type IsNever<T> = [T] extends [never] ? true : false
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type IsNever<T> = [T] extends [never] ? true : false

// ---cut---
type cases = [
  Expect<Equal<IsNever<never>, true>>,
  Expect<Equal<IsNever<never | string>, false>>,
  Expect<Equal<IsNever<''>, false>>,
  Expect<Equal<IsNever<undefined>, false>>,
  Expect<Equal<IsNever<null>, false>>,
  Expect<Equal<IsNever<[]>, false>>,
  Expect<Equal<IsNever<{}>, false>>,
]
```

## 参考

* [Never Types](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-never-type)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)

---

---
url: /type-challenges/medium/is-odd/index.md
---
# isOdd
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/is-tuple/index.md
---
# IsTuple
## 题目

Github: [IsTuple](https://github.com/type-challenges/type-challenges/blob/main/questions/04484-medium-istuple/README.md)

实现一个类型 `IsTuple`，它接受一个输入类型 `T` 并返回 `T` 是否为元组类型。

```ts
type case1 = IsTuple<[number]> // true
type case2 = IsTuple<readonly [number]> // true
type case3 = IsTuple<number[]> // false
```

## 解题思路

在 typescript 类型系统中，普通数组类型和元组类型的核心区别在于其 `length` 属性的类型。
数组的 `length` 是泛用的 `number` 类型，而 元组类型的 `length` 是具体的数组字面量类型（如 `2`）。
根据这个差异，我们可以通过条件类型来判断一个类型是否为元组类型。

**检查是否为数组类型：**

首先确定 `T` 是否继承自 `readonly any[]`（兼容普通数组和元组，包括只读元组）。

**判断 length 类型：**

若 `T` 是数组类型，进一步检查其 `length` 属性的类型是否为 `number`。若 `number extends T['length']` 成立，
说明 `T` 是普通数组（`length` 是 `number`），否则是元组（length 是具体数字）。

**别忘了处理传入的类型参数为 `never` 类型时的情况**

## 答案

```ts
type IsTuple<T> = [T] extends [never]
  ? false
  : T extends readonly any[]
    ? number extends T['length']
      ? false
      : true
    : false
```

## 验证

```ts twoslash
import type { Equal, Expect, NotEqual } from '~/tc-utils'

type IsTuple<T> = [T] extends [never]
  ? false
  : T extends readonly any[]
    ? number extends T['length']
      ? false
      : true
    : false

// ---cut---
type cases = [
  Expect<Equal<IsTuple<[]>, true>>,
  Expect<Equal<IsTuple<[number]>, true>>,
  Expect<Equal<IsTuple<readonly [1]>, true>>,
  Expect<Equal<IsTuple<{ length: 1 }>, false>>,
  Expect<Equal<IsTuple<number[]>, false>>,
  Expect<Equal<IsTuple<never>, false>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /type-challenges/medium/is-union/index.md
---
# IsUnion
## 题目

Github: [IsUnion](https://github.com/type-challenges/type-challenges/blob/main/questions/01097-medium-isunion/)

实现一个类型 `IsUnion`，它接受一个输入类型 `T` 并返回 `T` 是否解析为联合类型。

```ts
type case1 = IsUnion<string> // false
type case2 = IsUnion<string | number> // true
type case3 = IsUnion<[string | number]> // false
```

## 解题思路

> 起初看到这道题目时，我有些无从下手，在看了 [#1140](https://github.com/type-challenges/type-challenges/issues/1140#issue-838282400) 的回答后才恍然大悟。

首先，我们需要思考 联合类型 及其含义。

当我们指定一个普通类型时，比如 `string`，它将永远是字符串。当我们指定一个联合类型时，比如 `string | number` ,
它可以是 字符串，也可以是 数值 。

普通类型并不能表示一组值，但是 联合类型 可以。因此，在 普通类型 上进行分布式迭代是没有意义的，但对于 联合类型
来说是有意义的。

这就是我们如何检测是否是 联合类型 的关键点。但对 类型 `T` （普通类型）进行分布式迭代时，它不会产生变化，
但如果 类型 `T` 是 联合类型，它会产生比较大的变化。

当我们构造一个 `T extends T ? ConditionTrue<T> : never` 时，比如 `T` 为 联合类型 `string | number`:

```mermaid
---
title: "T extends T ? ConditionTrue<T> : never"
---
flowchart TD
A["T extends string | number"]
B["string extends string | number"]
C["number extends string | number"]
D["ConditionTrue&lt;string&gt;"]
E["ConditionTrue&lt;number&gt;"]
A --> B -- true --> D
A --> C -- true --> E
```

我们继续构造 `ConditionTrue<T> = string | number extends T ? true : false`：

```mermaid
---
title: "string | number extends T ? true : false"
---
flowchart TD
A["string | number extends string"]
B["string | number extends number"]
C["string extends string"]
D["number extends string"]
E["string extends number"]
F["number extends number"]
A --> C --> G[true] --> K[false] --> M[false]
A --> D --> H[false] --> K
B --> E --> I[false] --> L[false] --> M
B --> F --> J[true] --> L

```

看到了吧！如果 `T` 是联合类型，那么它的每个元素 `subT` 必然不能满足 `T extends subT` 。

基于以上，我们可以开始实现 `IsUnion` 类型。

首先保存一个类型 `T` 的副本，以方便后续的使用：

```ts
type IsUnion<T, C extends T = T> = never
```

通过应用条件类型，我们得到了分布式语义。在条件类型的 true 分支中，我们将获取联合 类型中的每一项。

```ts
type IsUnion<T, C extends T = T> = T extends T ? true : never
```

接下来，将每一项与原来的输入类型T进行比较：

```ts
type IsUnion<T, C extends T = T> = T extends T
  ? C extends T
    ? false : true
  : never
```

当然，我们还需要完善一些边界情况。

## 答案

```ts
type IsUnion<T, C extends T = T> = (T extends T
  ? C extends T
    ? true
    : unknown
  : never) extends true
  ? false
  : true
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type IsUnion<T, C extends T = T> = (T extends T ? C extends T ? true : unknown : never) extends true ? false : true

// ---cut---
type cases = [
  Expect<Equal<IsUnion<string>, false>>,
  Expect<Equal<IsUnion<string | number>, true>>,
  Expect<Equal<IsUnion<'a' | 'b' | 'c' | 'd'>, true>>,
  Expect<Equal<IsUnion<undefined | null | void | ''>, true>>,
  Expect<Equal<IsUnion<{ a: string } | { a: number }>, true>>,
  Expect<Equal<IsUnion<{ a: string | number }>, false>>,
  Expect<Equal<IsUnion<[string | number]>, false>>,
  // Cases where T resolves to a non-union type.
  Expect<Equal<IsUnion<string | never>, false>>,
  Expect<Equal<IsUnion<string | unknown>, false>>,
  Expect<Equal<IsUnion<string | any>, false>>,
  Expect<Equal<IsUnion<string | 'a'>, false>>,
  Expect<Equal<IsUnion<never>, false>>,
]
```

## 参考

* [联合类型 Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型分支 Distributive Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)
* [元组类型 Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-3.html#tuple-types)

---

---
url: /type-challenges/medium/join/index.md
---
# Join
## 题目

Github: [Join](https://github.com/type-challenges/type-challenges/blob/main/questions/05310-medium-join/)

实现数组类型的 `Array.join` 版本，`Join<T, U>` 接受一个数组 `T`，字符串或数字 `U`，并返回用 `U` 拼接后的数组 `T`。

```ts
type Res = Join<['a', 'p', 'p', 'l', 'e'], '-'> // expected to be 'a-p-p-l-e'
type Res1 = Join<['Hello', 'World'], ' '> // expected to be 'Hello World'
type Res2 = Join<['2', '2', '2'], 1> // expected to be '21212'
type Res3 = Join<['o'], 'u'> // expected to be 'o'
```

## 解题思路

略。

## 答案

```ts
type Join<T extends any[], U extends string | number = ','>
  = T extends [infer F, ...infer O]
    ? O['length'] extends 0
      ? `${F & string}`
      : `${F & string}${U}${Join<O, U>}`
    : ''
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Join<T extends any[], U extends string | number = ','>
  = T extends [infer F, ...infer O]
    ? O['length'] extends 0
      ? `${F & string}`
      : `${F & string}${U}${Join<O, U>}`
    : ''

// ---cut---
type cases = [
  Expect<Equal<Join<['a', 'p', 'p', 'l', 'e'], '-'>, 'a-p-p-l-e'>>,
  Expect<Equal<Join<['Hello', 'World'], ' '>, 'Hello World'>>,
  Expect<Equal<Join<['2', '2', '2'], 1>, '21212'>>,
  Expect<Equal<Join<['o'], 'u'>, 'o'>>,
  Expect<Equal<Join<[], 'u'>, ''>>,
  Expect<Equal<Join<['1', '1', '1']>, '1,1,1'>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

---

---
url: /type-challenges/medium/json-schema-to-typescript/index.md
---
# jsonSchemaToTypeScript
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/kebab-case/index.md
---
# kebabCase
## 题目

Github: [KebabCase](https://github.com/type-challenges/type-challenges/blob/main/questions/00612-medium-kebabcase/)

将 `camelCase` 或 `PascalCase` 字符串替换为 `kebab-case` 。

`FooBarBaz` -> `foo-bar-baz`

```ts
type FooBarBaz = KebabCase<'FooBarBaz'>
const foobarbaz: FooBarBaz = 'foo-bar-baz'

type DoNothing = KebabCase<'do-nothing'>
const doNothing: DoNothing = 'do-nothing'
```

## 解题思路

使用模板字面量类型，以及条件类型推断，获取字符串中的首个字符和剩下的字符串：

```ts
type KebabCase<S extends string, > = S extends `${infer L}${infer O}` ? never : never
```

对于首个字符，因为它总是小写的，所以直接使用 `Uncapitalize` 将首个字符转为小写。

```ts
type KebabCase<S extends string, > = S extends `${infer L}${infer O}`
  ? `${Uncapitalize<L>}${O}`
  : never
```

但是对于剩下的字符串，我们需要考虑其首个字母是否是大写，如果是大写，则需要拼接 `-` 并转为小写，
如果是小写，则不需要进行处理。

同样的，借助内置类型 `Uncapitalize`，先将 `O` 转为小写，然后再使用 `T extends Uncapitalize<O>` 来判断首字母是否小写

```ts
type KebabCase<S extends string, > = S extends `${infer L}${infer O}`
  ? T extends Uncapitalize<T>
    ? `${Uncapitalize<L>}${O}`
    : `${Uncapitalize<L>}-${O}`
  : never
```

很显然，我们还需要对 类型 `O` 进行递归处理，直到没有剩余的字符串为止。

```ts
type KebabCase<S extends string, > = S extends `${infer L}${infer O}`
  ? O extends Uncapitalize<O>
    ? `${Uncapitalize<L>}${KebabCase<O>}`
    : `${Uncapitalize<L>}-${KebabCase<O>}`
  : never
```

别忘了，在不满足 `S extends ${infer L}${infer O}` 的情况下，需要返回原字符串 `S` 。

## 答案

```ts
type KebabCase<S extends string, > = S extends `${infer L}${infer O}`
  ? O extends Uncapitalize<O>
    ? `${Uncapitalize<L>}${KebabCase<O>}`
    : `${Uncapitalize<L>}-${KebabCase<O>}`
  : S
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type KebabCase<S extends string, > = S extends `${infer L}${infer O}`
  ? O extends Uncapitalize<O>
    ? `${Uncapitalize<L>}${KebabCase<O>}`
    : `${Uncapitalize<L>}-${KebabCase<O>}`
  : S

// ---cut---
type cases = [
  Expect<Equal<KebabCase<'FooBarBaz'>, 'foo-bar-baz'>>,
  Expect<Equal<KebabCase<'fooBarBaz'>, 'foo-bar-baz'>>,
  Expect<Equal<KebabCase<'foo-bar'>, 'foo-bar'>>,
  Expect<Equal<KebabCase<'foo_bar'>, 'foo_bar'>>,
  Expect<Equal<KebabCase<'Foo-Bar'>, 'foo--bar'>>,
  Expect<Equal<KebabCase<'ABC'>, 'a-b-c'>>,
  Expect<Equal<KebabCase<'-'>, '-'>>,
  Expect<Equal<KebabCase<''>, ''>>,
  Expect<Equal<KebabCase<'😎'>, '😎'>>,
]
```

## 参考

* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)

---

---
url: /type-challenges/medium/last-index-of/index.md
---
# LastIndexOf
## 题目

实现类型版本的 `Array.lastIndexOf`, `LastIndexOf<T, U>` 接受数组 `T`, `any` 类型 `U`, 如果 `U` 存在于 `T` 中,
返回 `U` 在数组 `T` 中最后一个位置的索引, 不存在则返回 `-1`

```ts
type Res1 = LastIndexOf<[1, 2, 3, 2, 1], 2> // 3
type Res2 = LastIndexOf<[0, 0, 0], 2> // -1
```

## 解题思路

本挑战的难点在于 如何判断一个类型是否严格等于另一个类型。

对于此难点，请参考 [类型系统的真假美猴王：破解 IsEqual\<X, Y> 之谜](../../../1.前端/12.TypeScript/isEqual.md)

通过 条件类型 `infer`，从数组 `T` 中，通过递归的方式取出一个个元素，判断是否严格等于类型 `U`，
如果是，则直接返回 `R['length']` 的长度，否则继续递归取下一个元素，并为 `R` 添加一个元素。

递归时，类型`R` 的剩余数组长度，恰好为 `T` 的最后一个元素的索引。

## 答案

```ts
type Equal<X, Y>
  = (<T>() => T extends X ? 1 : 2) extends
  (<T>() => T extends Y ? 1 : 2) ? true : false

type LastIndexOf<T extends unknown[], U> = T extends [...infer R, infer F]
  ? Equal<F, U> extends true
    ? R['length']
    : LastIndexOf<R, U>
  : -1
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type LastIndexOf<T extends unknown[], U> = T extends [...infer R, infer F]
  ? Equal<F, U> extends true
    ? R['length']
    : LastIndexOf<R, U>
  : -1

// ---cut---
type cases = [
  Expect<Equal<LastIndexOf<[1, 2, 3, 2, 1], 2>, 3>>,
  Expect<Equal<LastIndexOf<[2, 6, 3, 8, 4, 1, 7, 3, 9], 3>, 7>>,
  Expect<Equal<LastIndexOf<[0, 0, 0], 2>, -1>>,
  Expect<Equal<LastIndexOf<[string, 2, number, 'a', number, 1], number>, 4>>,
  Expect<Equal<LastIndexOf<[string, any, 1, number, 'a', any, 1], any>, 5>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /type-challenges/medium/last-of-array/index.md
---
# 最后一个元素
## 题目

Github: [Last of array](https://github.com/type-challenges/type-challenges/blob/main/questions/00015-medium-last/)

实现一个通用`Last<T>`，它接受一个数组T并返回其最后一个元素的类型。

```ts
type arr1 = ['a', 'b', 'c']
type arr2 = [3, 2, 1]

type tail1 = Last<arr1> // expected to be 'c'
type tail2 = Last<arr2> // expected to be 1
```

## 解题思路

我们可以直接使用 **条件类型** 将数组的最后一个元素推导出来。

## 答案

```ts
type Last<T extends any[]> = T extends [...any[], infer R] ? R : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Last<T extends any[]> = T extends [...any[], infer R] ? R : never

// ---cut---
type cases = [
  Expect<Equal<Last<[]>, never>>,
  Expect<Equal<Last<[2]>, 2>>,
  Expect<Equal<Last<[3, 2, 1]>, 1>>,
  Expect<Equal<Last<[() => 123, { a: string }]>, { a: string }>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型内推断 Inferring Within Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [可变参数元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)

---

---
url: /type-challenges/medium/length-of-string/index.md
---
# 字符串长度
## 题目

[Github](https://github.com/type-challenges/type-challenges/blob/main/questions/00298-medium-length-of-string/)

计算字符串的长度，类似于 `String#length` 。

```ts
type length = LengthOfString<'Hello World'> // 11
```

## 解题思路

Typescript 类型系统不支持 `String['length']` 获取字符串的长度，同时，类型系统也没有提供可供累加计算的支持。

但幸运的是，我们可以很容易想到元组类型支持 `Tuple['length']` 获取元组的长度，因此我们可以把字符串转换为元组，
每个字符对应元组中的每个成员，通过元组的长度间接获取字符串的长度。

通过模板字面量类型，以及条件类型来实现字符串转换为元组。

## 答案

```ts
type LengthOfString<S extends string, U extends string[] = []>
  = S extends `${infer F}${infer T}`
    ? LengthOfString<T, [F, ...U]>
    : U['length']
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type LengthOfString<S extends string, U extends string[] = []>
  = S extends `${infer F}${infer T}`
    ? LengthOfString<T, [F, ...U]>
    : U['length']

// ---cut---
type cases = [
  Expect<Equal<LengthOfString<''>, 0>>,
  Expect<Equal<LengthOfString<'kumiko'>, 6>>,
  Expect<Equal<LengthOfString<'reina'>, 5>>,
  Expect<Equal<LengthOfString<'Sound! Euphonium'>, 16>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /type-challenges/medium/longest-common-prefix/index.md
---
# longestCommonPrefix
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/map-types/index.md
---
# MapTypes
## 题目

实现 `MapTypes<T, R>`，它将对象 `T` 中的类型转换为由类型 `R` 定义的不同类型，`R` 的结构如下：

```ts
interface StringToNumber {
  mapFrom: string // 值为字符串的键的值
  mapTo: number // 将被转换为数字
}
```

示例：

```ts
interface StringToNumber { mapFrom: string, mapTo: number }
MapTypes<{ iWillBeANumberOneDay: string }, StringToNumber>
// gives { iWillBeANumberOneDay: number; }
```

请注意，用户可以提供一个联合类型：

```ts
interface StringToNumber { mapFrom: string, mapTo: number }
interface StringToDate { mapFrom: string, mapTo: Date }

MapTypes<{ iWillBeNumberOrDate: string }, StringToDate | StringToNumber>
// gives { iWillBeNumberOrDate: number | Date; }
```

如果我们在映射中不存在这种类型，就让它保持原样：

```ts
interface StringToNumber { mapFrom: string, mapTo: number }
MapTypes<{ iWillBeANumberOneDay: string, iWillStayTheSame: Function }, StringToNumber>
// // gives { iWillBeANumberOneDay: number, iWillStayTheSame: Function }
```

## 解题思路

## 答案

```ts
type MapTypes<T, R extends { mapFrom: unknown, mapTo: unknown }> = {
  [P in keyof T]: T[P] extends R['mapFrom']
    ? R extends { mapFrom: T[P] }
      ? R['mapTo']
      : never
    : T[P]
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type MapTypes<T, R extends { mapFrom: unknown, mapTo: unknown }> = {
  [P in keyof T]: T[P] extends R['mapFrom']
    ? R extends { mapFrom: T[P] }
      ? R['mapTo']
      : never
    : T[P]
}
// ---cut---
type cases = [
  Expect<Equal<MapTypes<{ stringToArray: string }, { mapFrom: string, mapTo: [] }>, { stringToArray: [] }>>,
  Expect<Equal<MapTypes<{ stringToNumber: string }, { mapFrom: string, mapTo: number }>, { stringToNumber: number }>>,
  Expect<Equal<MapTypes<{ stringToNumber: string, skipParsingMe: boolean }, { mapFrom: string, mapTo: number }>, { stringToNumber: number, skipParsingMe: boolean }>>,
  Expect<Equal<MapTypes<{ date: string }, { mapFrom: string, mapTo: Date } | { mapFrom: string, mapTo: null }>, { date: null | Date }>>,
  Expect<Equal<MapTypes<{ date: string }, { mapFrom: string, mapTo: Date | null }>, { date: null | Date }>>,
  Expect<Equal<MapTypes<{ fields: Record<string, boolean> }, { mapFrom: Record<string, boolean>, mapTo: string[] }>, { fields: string[] }>>,
  Expect<Equal<MapTypes<{ name: string }, { mapFrom: boolean, mapTo: never }>, { name: string }>>,
  Expect<Equal<MapTypes<{ name: string, date: Date }, { mapFrom: string, mapTo: boolean } | { mapFrom: Date, mapTo: string }>, { name: boolean, date: string }>>,
]
```

## 参考

* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)

---

---
url: /type-challenges/medium/merge-all/index.md
---
# mergeAll
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/merge/index.md
---
# 合并两个类型
## 题目

Github: [Merge](https://github.com/type-challenges/type-challenges/blob/main/questions/00599-medium-merge/)

将两个类型合并成一个类型，第二个类型的键会覆盖第一个类型的键。

```ts
interface foo {
  name: string
  age: string
}

interface coo {
  age: number
  sex: string
}

type Result = Merge<foo, coo> // expected to be {name: string, age: number, sex: string}
```

## 解题思路

首先使用 `keyof` 和联合类型获取两个类型的所有 `key`

```ts
type Merge<F, S> = {
  [K in keyof F | keyof S]: any
}
```

接下来，判断 `K` 是否在 `S` 中，如果在，返回 `S[K]`：

```ts
type Merge<F, S> = {
  [K in keyof F | keyof S]: K extends keyof S ? S[K] : any
}
```

最后，判断 `K` 是否在 `F` 中，如果在，返回 `F[K]`

```ts
type Merge<F, S> = {
  [K in keyof F | keyof S]: K extends keyof S ? S[K] : K extends keyof F ? F[K] : never
}
```

## 答案

```ts
type Merge<F, S> = {
  [K in keyof F | keyof S]: K extends keyof S
    ? S[K]
    : K extends keyof F
      ? F[K]
      : never
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Merge<F, S> = {
  [K in keyof F | keyof S]: K extends keyof S
    ? S[K]
    : K extends keyof F
      ? F[K]
      : never
}

// ---cut---
interface Foo {
  a: number
  b: string
}
interface Bar {
  b: number
  c: boolean
}

type cases = [
  Expect<Equal<Merge<Foo, Bar>, {
    a: number
    b: number
    c: boolean
  }>>,
]
```

## 参考

* [联合类型 Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
* [查找类型 Lookup Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)
* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)

---

---
url: /type-challenges/medium/minus-one/index.md
---
# Minus One
## 题目

Github: [MinusOne](https://github.com/type-challenges/type-challenges/blob/main/questions/02257-medium-minusone/)

给定一个正整数作为类型的参数，要求返回的类型是该数字减 1。

```ts
type Zero = MinusOne<1> // 0
type FiftyFour = MinusOne<55> // 54
```

## 解题思路

这个挑战咋一看似乎很简单，但是别忘了，Typescript 类型系统是不支持 算术运算 的，即无法直接进行
加减乘除运算，这让我们即便是实现 **减去一** 都变得不那么简单了。

一开始，我想到的是利用 可变元祖类型 的长度，通过 将特定长度的元组删去一个成员，然后通过 `T['length']` 获取
新的长度 实现 减一。

```ts
type MinusOne<T extends number, R extends unknown[] = []> = R['length'] extends T
  ? R extends [infer _, ...infer O] ? O['length'] : never
  : MinusOne<T, [unknown, ...R]>
```

这个实现看起来完成了这个挑战，但是却存在潜在的问题。

**发现了吗，`T` 的值越大，递归的深度越深！**

我们找一个比较大一点的数试试：

```ts twoslash
// @errors: 2589
type MinusOne<T extends number, R extends unknown[] = []> = R['length'] extends T
  ? R extends [infer _, ...infer O] ? O['length'] : never
  : MinusOne<T, [unknown, ...R]>
// ---cut---
type n = MinusOne<1100>
```

很显然，这已经超过 Typescript 的递归深度限制了，而且由于 递归深度太深，需要消耗的时间也非常夸张，
这显然是不可接受的。

> 以下解答来自于 [#13507](https://github.com/type-challenges/type-challenges/issues/13507) 。

我们回归到 减法运算本身，对数字减去 `1`，以个位数的运算如下：

* `9 - 1 = 8`
* `8 - 1 = 7`
* `7 - 1 = 6`
* ...
* `1 - 1 = 0`

当个位数为 `0` ，减去 `1`时 ，则 个位数 变为 `9`，同时 十位数 也需要减去 `1`。

在十位数上为 `0` 减去 `1` 时，十位数变更为 `9`，同时 百位数也需要减去 `1`。

千位数、万位数、 ... 以此类推。

这告诉我们，可以单独处理每位数的运算，在当前位数为 `0`时，则继续对下一位数进行处理。

太棒了，我们不再需要创建一个冗长的元组，再用元组的长度去求值！现在，迭代深度只跟数字的位数相关！

为了便于处理，我们需要先将 数字转为 字符串，然后通过 模板字面量类型中的类型推理，取出数字中的每一位数。

由于 `T extends ${infer F}${infer R}` 是从左往右依次提取单个字符 `F`, 我们可以先将 数字字符串进行翻转，
在完成处理后再翻转回来。

```ts
type ReverseString<S extends string> = S extends `${infer First}${infer Rest}`
  ? `${ReverseString<Rest>}${First}`
  : ''

type MinusOne<T extends number> = ReverseString<`${T}`>
```

接下来，我们对单个位数进行 减 `1` 处理。由于现在我们只需要考虑 10 个 数字的 减 `1` 操作，因为我们
可以取巧，直接用元组保存运算结果，以 元组索引作为原始值，以索引对应的值作为 减 `1` 后的结果：

```ts
type Result<Index extends number> = [9, 0, 1, 2, 3, 4, 5, 6, 7, 8][Index]
```

比如索引为 `7` 时，取得的值为 `6`。

现在，我们从 数字字符串中取出每一位数，进行处理：

```ts
type InternalMinusOne<
  S extends string
> = S extends `${infer Digit extends number}${infer Rest}`
  ? never
  : never
```

你可能注意到，`infer Digit extends number`，这是为了约束在 模板字面量类型中的类型推理时， `Digit` 约束为
`number` 类型，因为 **元组的索引类型应该为 `number`** ，否则无法访问元组中的成员。

对于取出的 `Digit` ，当其值为 `0` 时，我们需要继续处理剩余位数，而非 `0` 时，则可以直接从 `Result<T>`
中取出结果，与剩余的 `Rest` 拼接得到结果：

```ts
type InternalMinusOne<
  S extends string
> = S extends `${infer Digit extends number}${infer Rest}`
  ? Digit extends 0
    ? `9${InternalMinusOne<Rest>}`
    : `${[9, 0, 1, 2, 3, 4, 5, 6, 7, 8][Digit]}${Rest}`
  : never

type MinusOne<T extends number> = InternalMinusOne<ReverseString<`${T}`>>
```

处理完成后，得到的结果别忘了需要重新翻转回来：

```ts
type MinusOne<T extends number> = ReverseString<InternalMinusOne<ReverseString<`${T}`>>>
```

同时还需要注意，在数字的高位数，可能是以 `0` 开头，还需要删除起始的 `0`：

```ts
type RemoveLeadingZeros<S extends string> = S extends '0'
  ? S
  : S extends `${'0'}${infer R}`
    ? RemoveLeadingZeros<R>
    : S

type MinusOne<T extends number> = RemoveLeadingZeros<
  ReverseString<InternalMinusOne<ReverseString<`${T}`>>>
>
```

此时，我们已经得到了 减 `1` 结果的 数字字符串，还需要将其转为 `number` 类型：

```ts
type ParseInt<T extends string> = T extends `${infer Digit extends number}`
  ? Digit
  : never

type MinusOne<T extends number> = ParseInt<RemoveLeadingZeros<
  ReverseString<InternalMinusOne<ReverseString<`${T}`>>>
>>
```

理论上此方法可以处理非常大的数，但由于 `number` 类型的限制，它允许的边界最大值为 2^53^ 。
即 `9007199254740991` 。

## 答案

```ts
type ParseInt<T extends string> = T extends `${infer Digit extends number}`
  ? Digit
  : never

type ReverseString<S extends string> = S extends `${infer First}${infer Rest}`
  ? `${ReverseString<Rest>}${First}`
  : ''

type RemoveLeadingZeros<S extends string> = S extends '0'
  ? S
  : S extends `${'0'}${infer R}`
    ? RemoveLeadingZeros<R>
    : S

type InternalMinusOne<
  S extends string
> = S extends `${infer Digit extends number}${infer Rest}`
  ? Digit extends 0
    ? `9${InternalMinusOne<Rest>}`
    : `${[9, 0, 1, 2, 3, 4, 5, 6, 7, 8][Digit]}${Rest}`
  : never

type MinusOne<T extends number> = ParseInt<RemoveLeadingZeros<
  ReverseString<InternalMinusOne<ReverseString<`${T}`>>>
>>
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type ParseInt<T extends string> = T extends `${infer Digit extends number}`
  ? Digit
  : never

type ReverseString<S extends string> = S extends `${infer First}${infer Rest}`
  ? `${ReverseString<Rest>}${First}`
  : ''

type RemoveLeadingZeros<S extends string> = S extends '0'
  ? S
  : S extends `${'0'}${infer R}`
    ? RemoveLeadingZeros<R>
    : S

type InternalMinusOne<
  S extends string
> = S extends `${infer Digit extends number}${infer Rest}`
  ? Digit extends 0
    ? `9${InternalMinusOne<Rest>}`
    : `${[9, 0, 1, 2, 3, 4, 5, 6, 7, 8][Digit]}${Rest}`
  : never

type MinusOne<T extends number> = ParseInt<RemoveLeadingZeros<
  ReverseString<InternalMinusOne<ReverseString<`${T}`>>>
>>

// ---cut---
type cases = [
  Expect<Equal<MinusOne<1>, 0>>,
  Expect<Equal<MinusOne<55>, 54>>,
  Expect<Equal<MinusOne<3>, 2>>,
  Expect<Equal<MinusOne<100>, 99>>,
  Expect<Equal<MinusOne<1101>, 1100>>,
  Expect<Equal<MinusOne<9_007_199_254_740_992>, 9_007_199_254_740_991>>,
]
```

## 参考

* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [改进模板字符串类型中推断类型的推理能力 improved inference for infer types in template string types](https://devblogs.microsoft.com/typescript/announcing-typescript-4-8-beta/#improved-inference-for-infer-types-in-template-string-types)

---

---
url: /type-challenges/medium/mutable/index.md
---
# Mutable
## 题目

Github: [Mutable](https://github.com/type-challenges/type-challenges/blob/main/questions/02793-medium-mutable/)

实现一个通用的类型 `Mutable<T>` ，使类型 `T` 的全部属性可变（非只读）。

```ts
interface Todo {
  readonly title: string
  readonly description: string
  readonly completed: boolean
}

type MutableTodo = Mutable<Todo>
// { title: string; description: string; completed: boolean; }
```

## 解题思路

略。

## 答案

```ts
type Mutable<T extends object> = {
  -readonly [P in keyof T]: T[P]
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Mutable<T extends object> = {
  -readonly [P in keyof T]: T[P]
}

// ---cut---
interface Todo1 {
  title: string
  description: string
  completed: boolean
  meta: {
    author: string
  }
}

type List = [1, 2, 3]

type cases = [
  Expect<Equal<Mutable<Readonly<Todo1>>, Todo1>>,
  Expect<Equal<Mutable<Readonly<List>>, List>>,
]

type errors = [
  // @ts-expect-error
  Mutable<'string'>,
  // @ts-expect-error
  Mutable<0>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [映射修饰符 Mapping modifiers](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers)

---

---
url: /type-challenges/medium/number-range/index.md
---
# NumberRange
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/object-entries/index.md
---
# ObjectEntries
## 题目

Github: [ObjectEntries](https://github.com/type-challenges/type-challenges/blob/main/questions/02946-medium-objectentries/)

实现 `Object.entries` 的类型版本

```ts
interface Model {
  name: string
  age: number
  locations: string[] | null
}
type modelEntries = ObjectEntries<Model>
// ['name', string] | ['age', number] | ['locations', string[] | null];
```

## 解题思路

在 Typescript 中，条件类型推断是分布式的，因此我们可以通过条件类型推断，从 对象类型 中，利用 `key` 推断
形成新的元组：

```ts
type ObjectEntries<T extends object, K extends keyof T = keyof T>
  = K extends K ? [K, T[K]] : never
```

也许会觉得到这里这个挑战就完成了，但是实际情况稍微有些麻烦。

我们知道，在 对象类型中，存在 必要属性 和 可选属性：

```ts twoslash
interface Mode {
  name: string // 必要属性
  arg?: number // 可选属性
// ^?
}
```

那么 `Mode` 应用 `ObjectEntries`, 得到的结果为：

```ts twoslash
type ObjectEntries<T extends object, K extends keyof T = keyof T>
  = K extends K ? [K, T[K]] : never

interface Mode {
  name: string // 必要属性
  arg?: number // 可选属性
}
// ---cut---
type a = ObjectEntries<Mode>
//   ^?
//
```

可以看到，在结果中， `arg` 的 `value` 类型被转为了包含 `undefined` 的 联合类型，它应该只是 `number` 类型 。

这里我们可以通过 `Required<T>` 将 对象类型的所有属性全部转为 必要属性，以消除 可选属性中的 `undefined`：

```ts
type ObjectEntries<T extends object, K extends keyof T = keyof T>
  = K extends K ? [K, Required<T>[K]] : never
```

```ts twoslash
type ObjectEntries<T extends object, K extends keyof T = keyof T>
  = K extends K ? [K, Required<T>[K]] : never

interface Mode {
  name: string // 必要属性
  arg?: number // 可选属性
}
// ---cut---
type a = ObjectEntries<Mode>
//   ^?
//
```

但是，如果可选属性的值类型就是 `undefined` 呢？

```ts twoslash
type ObjectEntries<T extends object, K extends keyof T = keyof T>
  = K extends K ? [K, Required<T>[K]] : never
// ---cut---
interface Mode {
  name: string // 必要属性
  arg?: undefined // 可选属性
}

type a = ObjectEntries<Mode>
//   ^?
//
```

可以看到，其结果为 `['arg', never]`，很明显不符合预期，它应该是 `undefined` 类型。
针对此情况，还需要通过条件类型推断对 值类型为 `undefined` 进行处理。

## 答案

```ts
type ObjectEntries<T extends object, K extends keyof T = keyof T>
  = K extends K ? [K, T[K] extends undefined ? undefined : Required<T>[K]] : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type ObjectEntries<T extends object, K extends keyof T = keyof T>
  = K extends K ? [K, T[K] extends undefined ? undefined : Required<T>[K]] : never

// ---cut---
interface Model {
  name: string
  age: number
  locations: string[] | null
}

type ModelEntries = ['name', string] | ['age', number] | ['locations', string[] | null]

type cases = [
  Expect<Equal<ObjectEntries<Model>, ModelEntries>>,
  Expect<Equal<ObjectEntries<Partial<Model>>, ModelEntries>>,
  Expect<Equal<ObjectEntries<{ key?: undefined }>, ['key', undefined]>>,
  Expect<Equal<ObjectEntries<{ key: undefined }>, ['key', undefined]>>,
  Expect<Equal<ObjectEntries<{ key: string | undefined }>, ['key', string | undefined]>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
* [`keyof` 和查找类型 `keyof` and lookup types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)

---

---
url: /type-challenges/medium/omit-by-type/index.md
---
# OmitByType
## 题目

Github: [OmitByType](https://github.com/type-challenges/type-challenges/blob/main/questions/02852-medium-omitbytype/README.md)

从 `T` 中选取一组属性，这些属性的类型不可分配给 `U` 。

```ts
type OmitBoolean = OmitByType<{
  name: string
  count: number
  isReadonly: boolean
  isEnable: boolean
}, boolean> // { name: string; count: number }
```

## 解题思路

略。

## 答案

```ts
type OmitByType<T, U> = {
  [P in keyof T as T[P] extends U ? never : P]: T[P]
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type OmitByType<T, U> = {
  [P in keyof T as T[P] extends U ? never : P]: T[P]
}

// ---cut---
interface Model {
  name: string
  count: number
  isReadonly: boolean
  isEnable: boolean
}

type cases = [
  Expect<Equal<OmitByType<Model, boolean>, { name: string, count: number }>>,
  Expect<Equal<OmitByType<Model, string>, { count: number, isReadonly: boolean, isEnable: boolean }>>,
  Expect<Equal<OmitByType<Model, number>, { name: string, isReadonly: boolean, isEnable: boolean }>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [通过 `as` 进行按键重映射 Key remapping via `as`](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [`keyof` 和查找类型 `keyof` and lookup types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)

---

---
url: /type-challenges/medium/omit/index.md
---
# 实现 Omit
## 题目

Github: [Omit](https://github.com/type-challenges/type-challenges/blob/main/questions/00003-medium-omit/)

不使用 `Omit` 实现 `TypeScript` 的 `Omit<T, K>` 泛型。

`Omit` 会创建一个省略 `K` 中字段的 `T` 对象。

```ts
interface Todo {
  title: string
  description: string
  completed: boolean
}

type TodoPreview = MyOmit<Todo, 'description' | 'title'>

const todo: TodoPreview = {
  completed: false,
}
```

## 解题思路

首先这里需要创建一个新的对象类型，但不指定健，因此这里需要使用 **映射类型**。

```ts
type MyOmit<T, K> = {
  [P in keyof T]: T[P]
}
```

这里通过 `keyof` 遍历 `T` 中的所有键，然后将其映射到类型 `P`，使其成为新对象类型的键，其值为 `T[P]` 。

在此基础上，还需要对 `keyof T` 进行过滤，排除 `K` 中的所有健。

这里可以使用 `as` 语法重新映射键类型，最后新对象的值为 原类型的相对应键的值类型。

## 答案

```ts
type MyOmit<T, K extends keyof T> = {
  [Key in keyof T as Key extends K ? never : Key]: T[Key]
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type MyOmit<T, K extends keyof T> = {
  [Key in keyof T as Key extends K ? never : Key]: T[Key]
}
// ---cut---
type cases = [
  Expect<Equal<Expected1, MyOmit<Todo, 'description'>>>,
  Expect<Equal<Expected2, MyOmit<Todo, 'description' | 'completed'>>>,
  Expect<Equal<Expected3, MyOmit<Todo1, 'description' | 'completed'>>>,
]

// @ts-expect-error ignore
type error = MyOmit<Todo, 'description' | 'invalid'>

interface Todo {
  title: string
  description: string
  completed: boolean
}

interface Todo1 {
  readonly title: string
  description: string
  completed: boolean
}

interface Expected1 {
  title: string
  completed: boolean
}

interface Expected2 {
  title: string
}

interface Expected3 {
  readonly title: string
}
```

## 参考

> * [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
> * [索引类型 indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
> * [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
> * [映射类型中的键重映射 Key Remapping in Mapped Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types)

---

---
url: /type-challenges/medium/parse-url-params/index.md
---
# parseURLParams
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/partial-by-keys/index.md
---
# PartialByKeys
## 题目

Github: [PartialByKeys](https://github.com/type-challenges/type-challenges/blob/main/questions/02757-medium-partialbykeys/)

实现一个通用的 `PartialByKeys<T, K>` ，它接收两个类型参数 `T` 和 `K` 。

`K` 指定应设置为可选的T的属性集。当没有提供 `K` 时，它就和普通的 `Partial<T>` 一样使所有属性都是可选的。

```ts
interface User {
  name: string
  age: number
  address: string
}

type UserPartialName = PartialByKeys<User, 'name'>
// { name?:string; age:number; address:string }
```

## 解题思路

略。

## 答案

```ts
type PartialByKeys<T, K extends keyof T = keyof T> = Omit<{
  [P in keyof T as P extends K ? P : never]?: T[P]
} & {
  [P in keyof T as P extends K ? never : P]: T[P]
}, never>
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type PartialByKeys<T, K extends keyof T = keyof T> = Omit<{
  [P in keyof T as P extends K ? P : never]?: T[P]
} & {
  [P in keyof T as P extends K ? never : P]: T[P]
}, never>

// ---cut---
interface User {
  name: string
  age: number
  address: string
}

interface UserPartialName {
  name?: string
  age: number
  address: string
}

interface UserPartialNameAndAge {
  name?: string
  age?: number
  address: string
}

type cases = [
  Expect<Equal<PartialByKeys<User, 'name'>, UserPartialName>>,
  Expect<Equal<PartialByKeys<User, 'name' | 'age'>, UserPartialNameAndAge>>,
  Expect<Equal<PartialByKeys<User>, Partial<User>>>,
  // @ts-expect-error
  Expect<Equal<PartialByKeys<User, 'name' | 'unknown'>, UserPartialName>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [通过 `as` 进行按键重映射 Key remapping via `as`](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [`keyof` 和查找类型 `keyof` and lookup types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)
* [交叉类型 Intersection Types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types)

---

---
url: /type-challenges/medium/pascals-triangle/index.md
---
# pascalsTriangle
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/percentage-parser/index.md
---
# Percentage Parser
## 题目

Github: [Percentage Parser](https://github.com/type-challenges/type-challenges/blob/main/questions/01978-medium-percentage-parser/)

实现类型 `PercentageParser`。根据规则 `/^(\+|\-)?(\d*)?(\%)?$/` 匹配类型 `T` 。

匹配的结果由三部分组成，分别是：\[正负号, 数字, 单位]，如果没有匹配，则默认是空字符串。

```ts
type R1 = PercentageParser<''> // expected ['', '', '']
type R2 = PercentageParser<'+85%'> // expected ["+", "85", "%"]
type R3 = PercentageParser<'-85%'> // expected ["-", "85", "%"]
type R4 = PercentageParser<'85%'> // expected ["", "85", "%"]
type R5 = PercentageParser<'85'> // expected ["", "85", ""]
```

## 解题思路

一开始，我想到的最粗暴的解题方式如下：

```ts
type PercentageParser<
  A extends string,
  R extends readonly [string, string, string] = ['', '', '']
> = A extends ''
  ? R
  : A extends `${infer F}${infer O}`
    ? F extends '-' | '+'
      ? PercentageParser<O, [F, '', '']>
      : F extends `${number}`
        ? PercentageParser<O, [R[0], `${R[1]}${F}`, '']>
        : F extends '%'
          ? PercentageParser<O, [R[0], R[1], F]>
          : PercentageParser<O, [R[0], R[1], '']>
    : R
```

但这样做需要迭代每一个字符，处理起来并不简洁高效。

我们回归的挑战本身，对于 百分比字符串，它的首位字符 可能是 `+`、 `-`，以及不带符号为 `''` 的情况；
它的末尾则可能是 `%` ；剩下的字符则没有特殊的情况。

这告诉我们，可以将挑战分开为两个问题来解决：

1. 首个字符是否是 `+`, `-`;
2. 剩下字符是否以 `%` 结尾。

问题已经变得非常简单，我们可以使用 模板字面量类型 和 条件类型 解决：

字符是否是 `+`, `-`：

```ts
type CheckPrefix<T> = T extends '+' | '-' ? T : never
```

字符是否以 `%` 结尾：

```ts
type CheckSuffix<T> = T extends `${infer P}%` ? [P, '%'] : [T, '']
```

接下来，从原字符串中提取首个字符和剩下的字符，分别交给对应的类型处理即可，这里同样使用
模板字面量类型 和 条件类型 解决：

```ts
type PercentageParser<A extends string> = A extends `${CheckPrefix<infer L>}${infer R}`
  ? [L, ...CheckSuffix<R>] // 首字符是 + -
  : ['', ...CheckSuffix<A>]
```

## 答案

```ts
type CheckPrefix<T> = T extends '+' | '-' ? T : never
type CheckSuffix<T> = T extends `${infer P}%` ? [P, '%'] : [T, '']
type PercentageParser<A extends string> = A extends `${CheckPrefix<infer L>}${infer R}`
  ? [L, ...CheckSuffix<R>]
  : ['', ...CheckSuffix<A>]
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type CheckPrefix<T> = T extends '+' | '-' ? T : never
type CheckSuffix<T> = T extends `${infer P}%` ? [P, '%'] : [T, '']
type PercentageParser<A extends string> = A extends `${CheckPrefix<infer L>}${infer R}` ? [L, ...CheckSuffix<R>] : ['', ...CheckSuffix<A>]

// ---cut---
type cases = [
  Expect<Equal<PercentageParser<''>, ['', '', '']>>,
  Expect<Equal<PercentageParser<'+'>, ['+', '', '']>>,
  Expect<Equal<PercentageParser<'+1'>, ['+', '1', '']>>,
  Expect<Equal<PercentageParser<'+100'>, ['+', '100', '']>>,
  Expect<Equal<PercentageParser<'+100%'>, ['+', '100', '%']>>,
  Expect<Equal<PercentageParser<'100%'>, ['', '100', '%']>>,
  Expect<Equal<PercentageParser<'-100%'>, ['-', '100', '%']>>,
  Expect<Equal<PercentageParser<'-100'>, ['-', '100', '']>>,
  Expect<Equal<PercentageParser<'-1'>, ['-', '1', '']>>,
  Expect<Equal<PercentageParser<'%'>, ['', '', '%']>>,
  Expect<Equal<PercentageParser<'1'>, ['', '1', '']>>,
  Expect<Equal<PercentageParser<'100'>, ['', '100', '']>>,
]
```

## 参考

* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)

---

---
url: /type-challenges/medium/permutation/index.md
---
# 联合类型全排列
## 题目

实现联合类型的全排列，将联合类型转换成所有可能的全排列数组的联合类型。

```ts
type perm = Permutation<'A' | 'B' | 'C'>
// ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']
```

## 解题思路

这个挑战需要我们深入理解
[条件类型分支 Distributive Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)。
在我们对联合类型进行条件类型推断时：

```ts
type Permutation<T> = T extends T ? [T] : never
```

假设 `T` 为 `'A' | 'B' | 'C'`:

```ts twoslash
type Permutation<T> = T extends T ? [T] : never
// ---cut---
type Result = Permutation<'A' | 'B' | 'C'>
//    ^?
//
```

`T extends T` 从语法上看起来很怪，但它实际上是从泛型 `T` 中取出每一个成员，判断该成员是否在联合类型 `T` 中。

```mermaid
---
title: 条件类型分支
---
flowchart TD
  A["T extends T ? [T] : never"]
  B["T extends 'A' | 'B' | 'C'"]
  C["'A' extends 'A' | 'B' | 'C'"]
  D["'B' extends 'A' | 'B' | 'C'"]
  E["'C' extends 'A' | 'B' | 'C'"]
  CC["['A']"]
  DD["['B']"]
  EE["['C']"]
  R["['A'] | ['B'] | ['C']"]
  A --> B
  B --> C --> CC --> R
  B --> D --> DD --> R
  B --> E --> EE --> R
```

在理解了 条件类型分支后，再来看 联合类型的全排列，当 `T` 为 `'A' | 'B' | 'C'` 时，存在以下的所有排列：

| 首位成员 | 全部成员 | 去除首位成员 |
| -------- | -------- | ------------ |
| A        | A, B, C  | B, C         |
|          | A, C, B  | C, B         |
| B        | B, A, C  | A, C         |
|          | B, C, A  | C, A         |
| C        | C, A, B  | A, B         |
|          | C, B, A  | B, A         |

观察可以发现，在首位成员确定时，全排列就是 首位成员 加上 剩余成员的全排列 的集合。

| 首位成员 | 剩余成员 | 全排列  |
| -------- | -------- | ------- |
| A        | B, C     | A, B, C |
|          | C, B     | A, C, B |

因此可以通过递归的方式，在 `type Permutation<T> = T extends T ? [T] : never` 中添加剩余成员全排列集合：

```ts
type Permutation<T, U = T> = U extends U
  ? [U, ...Permutation<Exclude<T, U>>]
  : never
```

这里我们使用一个泛型参数 `U` 保存条件类型分支中的成员。

同时，还需要考虑递归应该在何时停止，当 联合类型 `T` 中没有成员时，即 `never` 时，应该终止递归。

在 typescript 中，我们不能通过 `T extends never ？ true : false` 判断一个类型是否为 `never`，
因为 在 `T extends never` 中 `never` 本质上是一个没有成员的联合类型，
这导致了 `never extends never ? true : false` 整体被跳过了，得到的结果为 `never` , 而不是 `true/false`。

要避免这种情况，可以在`extends` 两边的类型用方括号包裹，这可以避免 触发条件类型分支：

```ts
type Permutation<T, U = T> = [T] extends [never]
  ? []
  : T
```

## 答案

```ts
type Permutation<T, U = T> = [T] extends [never]
  ? []
  : U extends U
    ? [U, ...Permutation<Exclude<T, U>>]
    : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Permutation<T, U = T> = [T] extends [never]
  ? []
  : U extends U
    ? [U, ...Permutation<Exclude<T, U>>]
    : never

// ---cut---
type cases = [
  Expect<Equal<Permutation<'A'>, ['A']>>,
  Expect<Equal<Permutation<'A' | 'B' | 'C'>, ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']>>,
  Expect<Equal<Permutation<'B' | 'A' | 'C'>, ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A']>>,
  Expect<Equal<Permutation<boolean>, [false, true] | [true, false]>>,
  Expect<Equal<Permutation<never>, []>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型分支 Distributive Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)

---

---
url: /type-challenges/medium/permutations-of-tuple/index.md
---
# permutationsOfTuple
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/pick-by-type/index.md
---
# PickByType
## 题目

Github: [PickByType](https://github.com/type-challenges/type-challenges/blob/main/questions/02595-medium-pickbytype/)

从 `T` 中选取一组类型可分配给 `U` 的属性。

```ts
type OnlyBoolean = PickByType<{
  name: string
  count: number
  isReadonly: boolean
  isEnable: boolean
}, boolean> // { isReadonly: boolean; isEnable: boolean; }
```

## 解题思路

这个挑战比较简单。让我们从 映射类型 开始，从 `T` 中获取所有的 键，以及对应的 值：

```ts
type PickByType<T, U> = {
  [P in keyof T]: T[P]
}
```

接下来，我们通过 `as` 对 键进行重映射，过滤不满足 `U` 的情况：

```ts
type PickByType<T, U> = {
  [P in keyof T as T[P] extends U ? P : never]: T[P]
}
```

## 答案

```ts
type PickByType<T, U> = {
  [P in keyof T as T[P] extends U ? P : never]: T[P]
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type PickByType<T, U> = {
  [P in keyof T as T[P] extends U ? P : never]: T[P]
}

// ---cut---
interface Model {
  name: string
  count: number
  isReadonly: boolean
  isEnable: boolean
}

type cases = [
  Expect<Equal<PickByType<Model, boolean>, { isReadonly: boolean, isEnable: boolean }>>,
  Expect<Equal<PickByType<Model, string>, { name: string }>>,
  Expect<Equal<PickByType<Model, number>, { count: number }>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [通过 `as` 进行按键重映射 Key remapping via `as`](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [`keyof` 和查找类型 `keyof` and lookup types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)

---

---
url: /type-challenges/medium/pop/index.md
---
# 排除最后一项
## 题目

Github: [Pop](https://github.com/type-challenges/type-challenges/blob/main/questions/00016-medium-pop/)

实现一个通用`Pop<T>`，它接受一个数组 `T`，并返回一个由数组T的前 `N-1` 项以相同的顺序组成的数组。

```ts
type arr1 = ['a', 'b', 'c', 'd']
type arr2 = [3, 2, 1]

type re1 = Pop<arr1> // expected to be ['a', 'b', 'c']
type re2 = Pop<arr2> // expected to be [3, 2]
```

## 解题思路

我们需要将数组分成两部份：从头部到最后一个元素之前的所有内容和最后一个元素本身。
然后去掉最后一个元素并返回头部部分。

## 答案

```ts
type Pop<T extends any[]> = T extends [...infer R, unknown] ? R : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Pop<T extends any[]> = T extends [...infer R, unknown] ? R : T

// ---cut---
type cases = [
  Expect<Equal<Pop<[3, 2, 1]>, [3, 2]>>,
  Expect<Equal<Pop<['a', 'b', 'c', 'd']>, ['a', 'b', 'c']>>,
  Expect<Equal<Pop<[]>, []>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型内推断 Inferring Within Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [可变元组类型 Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)

---

---
url: /type-challenges/medium/promise-all/index.md
---
# Promise.all
## 题目

Github: [Promise.all](https://github.com/type-challenges/type-challenges/blob/main/questions/00020-medium-promise-all/)

传入函数`PromiseAll`，它接受PromiseLike对象数组，返回值应为`Promise<T>`，其中`T`是解析的结果数组。

```ts
const promise1 = Promise.resolve(3)
const promise2 = 42
const promise3 = new Promise<string>((resolve, reject) => {
  setTimeout(resolve, 100, 'foo')
})

// 应推导出 `Promise<[number, 42, string]>`
const p = PromiseAll([promise1, promise2, promise3] as const)
```

## 解题思路

这个挑战要求我们从 `Promise.all` 方法的入参中，提取出 参数类型。
`Promise.all` 接收一个数组参数，数组的每个成员可以是不同的类型，这也包括 `Promise<T>` 类型,
对于 `Promise<T>` 类型，需要递归展开获取 `T` 类型。

这个挑战实际上可以转换为 对 数组的每个成员进行递归展开，即对每个成员进行 `Awaited` 的展开操作。
我们已经在 [简单 > Awaited](../简单/189.awaited.md) 中完成了该挑战：

```ts
type Awaited<T> = T extends Promise<infer R> ? Awaited<R> : T
```

因此，我们只需要完成 参数的类型约束，再对返回类型进行做 映射类型 的操作即可。

## 答案

```ts
type Awaited<T> = T extends Promise<infer R> ? Awaited<R> : T

declare function PromiseAll<T extends any[]>(
  values: readonly [...T],
): Promise<{
  [K in keyof T]: Awaited<T[K]>
}>
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Awaited<T> = T extends Promise<infer R> ? Awaited<R> : T

declare function PromiseAll<T extends any[]>(
  values: readonly [...T],
): Promise<{
  [K in keyof T]: Awaited<T[K]>
}>

// ---cut---
const promiseAllTest1 = PromiseAll([1, 2, 3] as const)
const promiseAllTest2 = PromiseAll([1, 2, Promise.resolve(3)] as const)
const promiseAllTest3 = PromiseAll([1, 2, Promise.resolve(3)])
const promiseAllTest4 = PromiseAll<Array<number | Promise<number>>>([1, 2, 3])

type cases = [
  Expect<Equal<typeof promiseAllTest1, Promise<[1, 2, 3]>>>,
  Expect<Equal<typeof promiseAllTest2, Promise<[1, 2, number]>>>,
  Expect<Equal<typeof promiseAllTest3, Promise<[number, number, number]>>>,
  Expect<Equal<typeof promiseAllTest4, Promise<number[]>>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型内推断 Inferring Within Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /type-challenges/medium/public-type/index.md
---
# publicType
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/readonly-2/index.md
---
# 对象部分属性只读
## 题目

Github: [Readonly 2](https://github.com/type-challenges/type-challenges/blob/main/questions/00008-medium-readonly-2/)

实现一个泛型 `MyReadonly2<T, K>`，它带有两种类型的参数`T`和`K`。

K指定应设置为`Readonly`的`T`的属性集。如果未提供`K`，则应使所有属性都变为只读，就像普通的`Readonly<T>`一样。

```ts
interface Todo {
  title: string
  description: string
  completed: boolean
}

const todo: MyReadonly2<Todo, 'title' | 'description'> = {
  title: 'Hey',
  description: 'foobar',
  completed: false,
}

todo.title = 'Hello' // Error: cannot reassign a readonly property
todo.description = 'barFoo' // Error: cannot reassign a readonly property
todo.completed = true // OK
```

## 解题思路

泛型参数`K` 需要约束为 `T` 的属性集，同时默认值为 `T`的属性集；

创建一个只含有 只读属性的对象类型，通过 `in` 操作符，遍历`T` 的所有成员，映射给泛型属性 `P`；

创建一个只含有可读属性的对象类型， 通过 `as` 语法，重新映射给泛型属性 `P`；

合并两个对象类型即可实现 `MyReadonly<T, K>`

## 答案

```ts
type MyReadonly2<T, K extends keyof T = keyof T> = {
  readonly [P in K]: T[P]
} & {
  [P in keyof T as P extends K ? never : P]: T[P]
}
```

## 验证

```ts twoslash
import type { Alike, Expect } from '~/tc-utils'
type MyReadonly2<T, K extends keyof T = keyof T> = {
  readonly [P in K]: T[P]
} & {
  [P in keyof T as P extends K ? never : P]: T[P]
}

// ---cut---
type cases = [
  Expect<Alike<MyReadonly2<Todo1>, Readonly<Todo1>>>,
  Expect<Alike<MyReadonly2<Todo1, 'title' | 'description'>, Expected>>,
  Expect<Alike<MyReadonly2<Todo2, 'title' | 'description'>, Expected>>,
  Expect<Alike<MyReadonly2<Todo2, 'description'>, Expected>>,
]

// @ts-expect-error ignore
type error = MyReadonly2<Todo1, 'title' | 'invalid'>

interface Todo1 {
  title: string
  description?: string
  completed: boolean
}

interface Todo2 {
  readonly title: string
  description?: string
  completed: boolean
}

interface Expected {
  readonly title: string
  readonly description?: string
  completed: boolean
}
```

## 参考

* [交叉类型 Intersection Types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types)
* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [索引访问类型 Indexed Access Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
* [在泛型约束中使用类型参数 Generic Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#using-type-parameters-in-generic-constraints)
* [映射类型中的键重映射 Key Remapping in Mapped Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#key-remapping-in-mapped-types)

---

---
url: /type-challenges/medium/remove-index-signature/index.md
---
# Remove Index Signature
## 题目

Github: [RemoveIndexSignature](https://github.com/type-challenges/type-challenges/blob/main/questions/01367-medium-remove-index-signature/README.md)

实现 `RemoveIndexSignature<T>`，从对象类型中排除索引签名。

```ts
interface Foo {
  [key: string]: any
  foo: () => void
}

type A = RemoveIndexSignature<Foo> // expected { foo(): void }
```

## 解题思路

这个挑战需要我们从 对象类型 中排除以 `{ [key: string]: any }` 形式声明的签名，同时需要保留如
`{ name: any }` 形式声明的签名。

这很明显需要使用 映射类型 和 条件类型 来解决。

首先我们知道， `'name' extends string` 的结果为 真，但是反过来，`string extends 'name'` 结果为 假 。
因为 `'name'` 本身就是 `string`，但 `string` 不止 `'name'` 。 我们可以利用这一特性，完成这个挑战。

我们可以使用 Typescript 的内置类型 `PropertyKey` ，它表示 `string | number | symbol` ，即 键类型，
先完成最基础的类型声明：

```ts
type RemoveIndexSignature<T, K extends PropertyKey = PropertyKey> = {
  [P in keyof T]: T[P]
}
```

接下来，我们对 `P` 进行约束，当 `K extends P` 为真时，这表示 `P` 可能是 `string` 、`number` 或 `symbol`。
我们需要排除这些情况：

```ts
type RemoveIndexSignature<T, K extends PropertyKey = PropertyKey> = {
  [P in keyof T as K extends P ? never : P]: T[P]
}
```

这发生了什么？`K` 表示的是 `string | number | symbol`，`K extends P` 相当于：

```ts
type a = string extends P ? never : P
type b = number extends P ? never : P
type c = symbol extends P ? never : P
```

这直接从 键类型中过滤了 `string`, `number`, `symbol` 的 索引签名。

当然这还不够，还需要限制 `P` 应该是一个合法的 键，因此我们还需要使用 `P extends K` 约束 键类型：

```ts
type RemoveIndexSignature<T, K extends PropertyKey = PropertyKey> = {
  [P in keyof T as K extends P ? never : P extends K ? P : never]: T[P]
}
```

这相当于，如果 `P` 为对象中的 `name` 属性，则发生了以下检查：

```ts
type P = 'name' extends string | number | symbol ? 'name' : never
```

此时 `name` 满足 `K` 的约束。

## 答案

```ts
type RemoveIndexSignature<T, K extends PropertyKey = PropertyKey> = {
  [P in keyof T as K extends P
    ? never
    : P extends K
      ? P
      : never
  ]: T[P]
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type RemoveIndexSignature<T, K extends PropertyKey = PropertyKey> = {
  [P in keyof T as K extends P ? never : P extends K ? P : never]: T[P]
}

// ---cut---
interface Foo {
  [key: string]: any
  foo: () => void
}

interface Bar {
  [key: number]: any
  bar: () => void
  0: string
}

const foobar = Symbol('foobar')
interface FooBar {
  [key: symbol]: any
  [foobar]: () => void
}

interface Baz {
  bar: () => void
  baz: string
}

type cases = [
  Expect<Equal<RemoveIndexSignature<Foo>, { foo: () => void }>>,
  Expect<Equal<RemoveIndexSignature<Bar>, { bar: () => void, 0: string }>>,
  Expect<Equal<RemoveIndexSignature<FooBar>, { [foobar]: () => void }>>,
  Expect<Equal<RemoveIndexSignature<Baz>, { bar: () => void, baz: string }>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /type-challenges/medium/replace-all/index.md
---
# ReplaceAll
## 题目

Github: [ReplaceAll](https://github.com/type-challenges/type-challenges/blob/main/questions/00119-medium-replaceall/)

实现 `ReplaceAll<S, From, To>` 将一个字符串 `S` 中的所有子字符串 `From` 替换为 `To` 。

```ts
type replaced = ReplaceAll<'t y p e s', ' ', ''> // 期望是 'types'
```

## 解题思路

与 [`Replace`](./116.replace.md) 类似，在 **Replace** 挑战中，我们将字符串 `S` 拆分为 `F` 、 `From` 、 `R` 三个部分，
然后对 `From` 进行替换， 在完成替换后，我们需要继续对 `R` 进行替换，直到 `R` 为不包含 `From` 的字符串。

## 答案

```ts
type ReplaceAll<S extends string, From extends string, To extends string>
  = From extends ''
    ? S
    : S extends `${infer F}${From}${infer R}`
      ? `${F}${To}${ReplaceAll<R, From, To>}`
      : S
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type ReplaceAll<S extends string, From extends string, To extends string>
  = From extends ''
    ? S
    : S extends `${infer F}${From}${infer R}`
      ? `${F}${To}${ReplaceAll<R, From, To>}`
      : S
// ---cut---
type cases = [
  Expect<Equal<ReplaceAll<'foobar', 'bar', 'foo'>, 'foofoo'>>,
  Expect<Equal<ReplaceAll<'foobar', 'bag', 'foo'>, 'foobar'>>,
  Expect<Equal<ReplaceAll<'foobarbar', 'bar', 'foo'>, 'foofoofoo'>>,
  Expect<Equal<ReplaceAll<'t y p e s', ' ', ''>, 'types'>>,
  Expect<Equal<ReplaceAll<'foobarbar', '', 'foo'>, 'foobarbar'>>,
  Expect<Equal<ReplaceAll<'barfoo', 'bar', 'foo'>, 'foofoo'>>,
  Expect<Equal<ReplaceAll<'foobarfoobar', 'ob', 'b'>, 'fobarfobar'>>,
  Expect<Equal<ReplaceAll<'foboorfoboar', 'bo', 'b'>, 'foborfobar'>>,
  Expect<Equal<ReplaceAll<'', '', ''>, ''>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

---

---
url: /type-challenges/medium/replace-first/index.md
---
# replaceFirst
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/replace-keys/index.md
---
# ReplaceKeys
## 题目

Github: [ReplaceKeys](https://github.com/type-challenges/type-challenges/blob/main/questions/01130-medium-replacekeys/README.md)

实现一个类型 `ReplaceKeys`，用于替换联合类型中的键，如果某个类型没有该键，则跳过替换。该类型接受三个参数。

```ts
interface NodeA {
  type: 'A'
  name: string
  flag: number
}

interface NodeB {
  type: 'B'
  id: number
  flag: number
}

interface NodeC {
  type: 'C'
  name: string
  flag: number
}

type Nodes = NodeA | NodeB | NodeC

// 将 name 从 string 替换为 number，将 flag 从 number 替换为 string。
type ReplacedNodes = ReplaceKeys<
  Nodes,
  'name' | 'flag',
  { name: number, flag: string }
>
// {type: 'A', name: number, flag: string} | {type: 'B', id: number, flag: string} | {type: 'C', name: number, flag: string}

// 将 name 替换为 never
type ReplacedNotExistKeys = ReplaceKeys<Nodes, 'name', { aa: number }>
// {type: 'A', name: never, flag: number} | NodeB | {type: 'C', name: never, flag: number}
```

## 解题思路

对于这个挑战，很明显需要使用 映射类型和 条件类型 来解决。

首先需要说明的是，在 Typescript 中，映射类型 也是 **分布式** 的。
这表示我们可以直接编写映 射类型来遍历接口的键，同时对联合类型具有分布性。

我们从最简单的开始。
从联合类型U中取出所有元素 (分布性)，对每个元素遍历其键 并返回一个副本。

```ts
type ReplaceKeys<U, T, Y> = {
  [K in keyof U]: U[K]
}
```

首先，我们需要检查 `K` 是否在需要更新的键列表 `T` 中，
与此同时，我们也不能确定 `Y` 中是否存在相同的键，因此也需要进行检查：

```ts
type ReplaceKeys<U, T, Y> = {
  [K in keyof U]:
  K extends T // 是否在键列表中
    ? K extends keyof Y // 是否在 `Y` 中存在相同的键
      ? Y[K] // 返回新的类型
      : never
    : U[K] // 无需修改
}
```

## 答案

```ts
type ReplaceKeys<U, T, Y> = {
  [K in keyof U]: K extends T ? K extends keyof Y ? Y[K] : never : U[K]
}
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type ReplaceKeys<U, T, Y> = {
  [K in keyof U]: K extends T ? K extends keyof Y ? Y[K] : never : U[K]
}
// ---cut---
interface NodeA {
  type: 'A'
  name: string
  flag: number
}

interface NodeB {
  type: 'B'
  id: number
  flag: number
}

interface NodeC {
  type: 'C'
  name: string
  flag: number
}

interface ReplacedNodeA {
  type: 'A'
  name: number
  flag: string
}

interface ReplacedNodeB {
  type: 'B'
  id: number
  flag: string
}

interface ReplacedNodeC {
  type: 'C'
  name: number
  flag: string
}

interface NoNameNodeA {
  type: 'A'
  flag: number
  name: never
}

interface NoNameNodeC {
  type: 'C'
  flag: number
  name: never
}

type Nodes = NodeA | NodeB | NodeC
type ReplacedNodes = ReplacedNodeA | ReplacedNodeB | ReplacedNodeC
type NodesNoName = NoNameNodeA | NoNameNodeC | NodeB

type cases = [
  Expect<Equal<ReplaceKeys<Nodes, 'name' | 'flag', { name: number, flag: string }>, ReplacedNodes>>,
  Expect<Equal<ReplaceKeys<Nodes, 'name', { aa: number }>, NodesNoName>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /type-challenges/medium/replace/index.md
---
# Replace
## 题目

Github: [Replace](https://github.com/type-challenges/type-challenges/blob/main/questions/00116-medium-replace/)

实现 `Replace<S, From, To>` 将字符串 `S` 中的第一个子字符串 `From` 替换为 `To` 。

```ts
type replaced = Replace<'types are fun!', 'fun', 'awesome'> // 期望是 'types are awesome!'
```

## 解题思路

我们可以使用 **模板字面量类型** 来实现这个挑战。对于字符串 `S` ，我们将其拆分为三个部分，并对每个部分
进行推断。

推断从字符串的左侧开始，直到找到 `Form` 位置，此时 `S` 为拆分为 `F` 、 `From` 、 `R` 三个部分。

```ts
type Replace<S extends string, From extends string, To extends string>
  = S extends `${infer F}${From}${infer R}` ? S : S
```

在找到 `From` 位置后，我们对 `From` 位置的字符串进行替换，将其替换为 `To`，拼接为新的字符串。

```ts
type Replace<S extends string, From extends string, To extends string>
  = S extends `${infer F}${From}${infer R}` ? `${F}${To}${R}` : S
```

我们也需要考虑 `From` 为空字符串的情况，此时我们直接返回 `S`。

## 答案

```ts
type Replace<S extends string, From extends string, To extends string>
  = From extends ''
    ? S
    : S extends `${infer F}${From}${infer R}`
      ? `${F}${To}${R}`
      : S
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type Replace<S extends string, From extends string, To extends string>
  = From extends ''
    ? S
    : S extends `${infer F}${From}${infer R}`
      ? `${F}${To}${R}`
      : S

// ---cut---
type cases = [
  Expect<Equal<Replace<'foobar', 'bar', 'foo'>, 'foofoo'>>,
  Expect<Equal<Replace<'foobarbar', 'bar', 'foo'>, 'foofoobar'>>,
  Expect<Equal<Replace<'foobarbar', '', 'foo'>, 'foobarbar'>>,
  Expect<Equal<Replace<'foobarbar', 'bar', ''>, 'foobar'>>,
  Expect<Equal<Replace<'foobarbar', 'bra', 'foo'>, 'foobarbar'>>,
  Expect<Equal<Replace<'', '', ''>, ''>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

---

---
url: /type-challenges/medium/required-by-keys/index.md
---
# requiredByKeys
## 题目

Github: [requiredByKeys](https://github.com/type-challenges/type-challenges/blob/main/questions/02759-medium-requiredbykeys/)

实现一个通用的`RequiredByKeys<T, K>`，它接收两个类型参数`T`和`K`。

`K`指定应设为必选的`T`的属性集。当没有提供`K`时，它就和普通的`Required<T>`一样使所有的属性成为必选的。

```ts
interface User {
  name?: string
  age?: number
  address?: string
}

type UserRequiredName = RequiredByKeys<User, 'name'>
// { name: string; age?: number; address?: string }
```

## 解题思路

略。

## 答案

```ts
type RequiredByKeys<T, K extends keyof T = keyof T> = Omit<{
  [P in keyof T as P extends K ? P : never]-?: T[P]
} & {
  [P in keyof T as P extends K ? never : P]: T[P]
}, never>
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type RequiredByKeys<T, K extends keyof T = keyof T> = Omit<{
  [P in keyof T as P extends K ? P : never]-?: T[P]
} & {
  [P in keyof T as P extends K ? never : P]: T[P]
}, never>

// ---cut---
interface User {
  name?: string
  age?: number
  address?: string
}

interface UserRequiredName {
  name: string
  age?: number
  address?: string
}

interface UserRequiredNameAndAge {
  name: string
  age: number
  address?: string
}

type cases = [
  Expect<Equal<RequiredByKeys<User, 'name'>, UserRequiredName>>,
  Expect<Equal<RequiredByKeys<User, 'name' | 'age'>, UserRequiredNameAndAge>>,
  Expect<Equal<RequiredByKeys<User>, Required<User>>>,
  // @ts-expect-error
  Expect<Equal<RequiredByKeys<User, 'name' | 'unknown'>, UserRequiredName>>,
]
```

## 参考

* [映射类型 Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [映射修饰符 Mapping modifiers](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers)
* [通过 `as` 进行按键重映射 Key remapping via `as`](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [`keyof` 和查找类型 `keyof` and lookup types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)
* [交叉类型 Intersection Types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types)

---

---
url: /type-challenges/medium/reverse/index.md
---
# Reverse
## 题目

Github: [Reverse](https://github.com/type-challenges/type-challenges/blob/main/questions/03192-medium-reverse/README.zh-CN.md)

实现类型版本的数组反转 `Array.reverse`

```ts
type a = Reverse<['a', 'b']> // ['b', 'a']
type b = Reverse<['a', 'b', 'c']> // ['c', 'b', 'a']
```

## 解题思路

略。

## 答案

```ts
type Reverse<T extends unknown[]> = T extends [infer L, ...infer O]
  ? [...Reverse<O>, L]
  : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Reverse<T extends unknown[]> = T extends [infer L, ...infer O]
  ? [...Reverse<O>, L]
  : T

// ---cut---
type cases = [
  Expect<Equal<Reverse<[]>, []>>,
  Expect<Equal<Reverse<['a', 'b']>, ['b', 'a']>>,
  Expect<Equal<Reverse<['a', 'b', 'c']>, ['c', 'b', 'a']>>,
]

type errors = [
  // @ts-expect-error
  Reverse<'string'>,
  // @ts-expect-error
  Reverse<{ key: 'value' }>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [在条件类型中进行推断 Inferring within conditional types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive conditional types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)

---

---
url: /type-challenges/medium/shift/index.md
---
# Shift
## 题目

Github: [Shift](https://github.com/type-challenges/type-challenges/blob/main/questions/03062-medium-shift/README.md)

实现 `Array.shift` 的类型版本

```ts
type Result = Shift<[3, 2, 1]> // [2, 1]
```

## 解题思路

略。

## 答案

```ts
type Shift<T extends unknown[]> = T extends [infer _, ...infer O] ? O : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Shift<T extends unknown[]> = T extends [infer _, ...infer O] ? O : T

// ---cut---
type cases = [
  // @ts-expect-error
  Shift<unknown>,
  Expect<Equal<Shift<[]>, []>>,
  Expect<Equal<Shift<[1]>, []>>,
  Expect<Equal<Shift<[3, 2, 1]>, [2, 1]>>,
  Expect<Equal<Shift<['a', 'b', 'c', 'd']>, ['b', 'c', 'd']>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型分支 Distributive Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)
* [元组类型 Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-3.html#tuple-types)

---

---
url: /type-challenges/medium/shitariteraru/index.md
---
# shitariteraru
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/square/index.md
---
# square
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/stars-with/index.md
---
# StartsWith
## 题目

Github: [StartsWith](https://github.com/type-challenges/type-challenges/blob/main/questions/02688-medium-startswith/)

实现 `StartsWith<T, U>` ,接收两个 `string` 类型参数,然后判断 `T` 是否以 `U` 开头,根据结果返回 `true` 或 `false`

```ts
type a = StartsWith<'abc', 'ac'> // expected to be false
type b = StartsWith<'abc', 'ab'> // expected to be true
type c = StartsWith<'abc', 'abcd'> // expected to be false
```

## 解题思路

略。

## 答案

```ts
type StartsWith<T extends string, U extends string> = T extends `${U}${string}` ? true : false
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type StartsWith<T extends string, U extends string> = T extends `${U}${string}` ? true : false

// ---cut---
type cases = [
  Expect<Equal<StartsWith<'abc', 'ac'>, false>>,
  Expect<Equal<StartsWith<'abc', 'ab'>, true>>,
  Expect<Equal<StartsWith<'abc', 'abc'>, true>>,
  Expect<Equal<StartsWith<'abc', 'abcd'>, false>>,
  Expect<Equal<StartsWith<'abc', ''>, true>>,
  Expect<Equal<StartsWith<'abc', ' '>, false>>,
  Expect<Equal<StartsWith<'', ''>, true>>,
]
```

## 参考

* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [泛型约束 Generics constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

---

---
url: /type-challenges/medium/string-to-union/index.md
---
# 字符串转联合类型
## 题目

Github: [StringToUnion](https://github.com/type-challenges/type-challenges/blob/main/questions/00531-medium-string-to-union/)

实现一个将接收到的 `String` 参数转换为一个字母 `Union` 的类型。

```ts
type Test = '123'
type Result = StringToUnion<Test> // expected to be "1" | "2" | "3"
```

## 解题思路

通过模板字面量类型 和 条件类型推断，从字符串中取出一个个字符，并使用 尾递归的方式，将字符串转为联合类型。

## 答案

```ts
type StringToUnion<S extends string>
  = S extends `${infer L}${infer R}` ? `${L | StringToUnion<R>}` : never
```

## 验证

```ts twoslash
import { Equal, Expect } from '~/tc-utils'
type StringToUnion<S extends string>
  = S extends `${infer L}${infer R}` ? `${L | StringToUnion<R>}` : never

// ---cut---
type cases = [
  Expect<Equal<StringToUnion<''>, never>>,
  Expect<Equal<StringToUnion<'t'>, 't'>>,
  Expect<Equal<StringToUnion<'hello'>, 'h' | 'e' | 'l' | 'l' | 'o'>>,
  Expect<Equal<StringToUnion<'coronavirus'>, 'c' | 'o' | 'r' | 'o' | 'n' | 'a' | 'v' | 'i' | 'r' | 'u' | 's'>>,
]
```

## 参考

* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [联合类型 Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)

---

---
url: /type-challenges/medium/subsequence/index.md
---
# Subsequence
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/to-primitive/index.md
---
# ToPrimitive
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/tower-of-hanoi/index.md
---
# towerOfHanoi
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/trace/index.md
---
# trace
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/transpose/index.md
---
# transpose
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/triangular-number/index.md
---
# triangularNumber
## 题目

## 解题思路

## 答案

## 验证

## 参考

---

---
url: /type-challenges/medium/trim-left/index.md
---
# 去除左侧空白
## 题目

Github: [TrimLeft](https://github.com/type-challenges/type-challenges/blob/main/questions/00106-medium-trimleft/)

实现 `TrimLeft<T>` ，它接收确定的字符串类型并返回一个新的字符串，
其中新返回的字符串删除了原字符串开头的空白字符串。

```ts
type trimed = TrimLeft<'  Hello World  '> // 应推导出 'Hello World  '
```

## 解题思路

这里我们需要使用 [模板字面量类型](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types) ，对 字符串进行建模。

我们需要处理两种情况，左边有空格的字符串和没有空格的字符串。
如果我们有空格，我们需要推断字符串的另一部分并再次检查它是否有空格，否则，我们返回推断的部分而不做任何更改。

```ts
type TrimLeft<S extends string> = S extends `${' '}${infer R}` ? TrimLeft<R> : S
```

除了需要检查 空格，还需要检查换行符和制表符。

## 答案

```ts
type TrimLeft<S extends string>
  = S extends `${' ' | '\n' | '\t'}${infer R}` ? TrimLeft<R> : S
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type TrimLeft<S extends string>
  = S extends `${' ' | '\n' | '\t'}${infer R}` ? TrimLeft<R> : S

// ---cut---
type cases = [
  Expect<Equal<TrimLeft<'str'>, 'str'>>,
  Expect<Equal<TrimLeft<' str'>, 'str'>>,
  Expect<Equal<TrimLeft<'     str'>, 'str'>>,
  Expect<Equal<TrimLeft<'     str     '>, 'str     '>>,
  Expect<Equal<TrimLeft<'   \n\t foo bar '>, 'foo bar '>>,
  Expect<Equal<TrimLeft<''>, ''>>,
  Expect<Equal<TrimLeft<' \n\t'>, ''>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types)

---

---
url: /type-challenges/medium/trim-right/index.md
---
# TrimRight
## 题目

Github: [TrimRight](https://github.com/type-challenges/type-challenges/blob/main/questions/04803-medium-trim-right/)

实现 `TrimRight<T>` ，它接收确定的字符串类型并返回一个新的字符串，
其中新返回的字符串删除了原字符串结尾的空白字符串。

```ts
type Trimed = TrimRight<'  Hello World  '> // 应推导出 '  Hello World'
```

## 解题思路

这里我们需要使用 [模板字面量类型](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types) ，对 字符串进行建模。

我们需要处理两种情况，右边有空格的字符串和没有空格的字符串。
如果我们有空格，我们需要推断字符串的另一部分并再次检查它是否有空格，否则，我们返回推断的部分而不做任何更改。

```ts
type TrimRight<S extends string> = S extends `${infer R}${' '}` ? TrimRight<R> : S
```

除了需要检查 空格，还需要检查换行符和制表符。

## 答案

```ts
type TrimRight<S extends string>
  = S extends `${infer R}${' ' | '\n' | '\t'}` ? TrimRight<R> : S
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type TrimRight<S extends string>
  = S extends `${infer R}${' ' | '\n' | '\t'}` ? TrimRight<R> : S

// ---cut---
type cases = [
  Expect<Equal<TrimRight<'str'>, 'str'>>,
  Expect<Equal<TrimRight<'str '>, 'str'>>,
  Expect<Equal<TrimRight<'str     '>, 'str'>>,
  Expect<Equal<TrimRight<'     str     '>, '     str'>>,
  Expect<Equal<TrimRight<'   foo bar  \n\t '>, '   foo bar'>>,
  Expect<Equal<TrimRight<''>, ''>>,
  Expect<Equal<TrimRight<'\n\t '>, ''>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types)

---

---
url: /type-challenges/medium/trim/index.md
---
# 去除两端空白字符
## 题目

Github: [Trim](https://github.com/type-challenges/type-challenges/blob/main/questions/00108-medium-trim/)

实现 `Trim<T>`，它接受一个明确的字符串类型，并返回一个新字符串，其中两端的空白符都已被删除。

```ts
type trimed = Trim<'  Hello World  '> // 应推导出 'Hello World'
```

## 解题思路

此挑战的解题思路与 [中等 > 去除左侧空白](./trimRight.md) 类似，只是需要处理两端的空白字符。
因此我们可以将问题拆解为，先删除左边的空白字符，然后再删除右边的空白字符。

## 答案

```ts
type Whitespace = ' ' | '\n' | '\t'
type Trim<S extends string> = S extends `${Whitespace}${infer R}`
  ? Trim<R>
  : S extends `${infer L}${Whitespace}`
    ? Trim<L>
    : S
```

## 验证

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Whitespace = ' ' | '\n' | '\t'
type Trim<S extends string> = S extends `${Whitespace}${infer R}`
  ? Trim<R>
  : S extends `${infer L}${Whitespace}`
    ? Trim<L>
    : S

// ---cut---
type cases = [
  Expect<Equal<Trim<'str'>, 'str'>>,
  Expect<Equal<Trim<' str'>, 'str'>>,
  Expect<Equal<Trim<'     str'>, 'str'>>,
  Expect<Equal<Trim<'str   '>, 'str'>>,
  Expect<Equal<Trim<'     str     '>, 'str'>>,
  Expect<Equal<Trim<'   \n\t foo bar \t'>, 'foo bar'>>,
  Expect<Equal<Trim<''>, ''>>,
  Expect<Equal<Trim<' \n\t '>, ''>>,
]
```

## 参考

* [联合类型 Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#template-literal-types)

---

---
url: /type-challenges/medium/trunc/index.md
---
# Trunc
## 题目

Github: [Trunc](https://github.com/type-challenges/type-challenges/blob/main/questions/05140-medium-trunc/)

实现 `Math.trunc` 的类型版本，该版本接受字符串或数字，并通过移除任何小数部分返回数字的整数部分。

```ts
type A = Trunc<12.34> // 12
```

## 解题思路

这个挑战很容易想到用 模板字面量类型 和 条件类型 `infer` 判断字符串是否包含小数部分，然后进行处理。

需要注意的是，数字字符串中可能包含 `-`，也可能省略整数部分的 `0` 。

## 答案

```ts
type Trunc<T extends number | string> = `${T}` extends `${infer D}.${string}`
  ? D extends '' | '-' ? `${D}0` : D
  : `${T}`
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Trunc<T extends number | string> = `${T}` extends `${infer D}.${string}`
  ? D extends '' | '-' ? `${D}0` : D
  : `${T}`

// ---cut---
type cases = [
  Expect<Equal<Trunc<0.1>, '0'>>,
  Expect<Equal<Trunc<0.2>, '0'>>,
  Expect<Equal<Trunc<1.234>, '1'>>,
  Expect<Equal<Trunc<12.345>, '12'>>,
  Expect<Equal<Trunc<-5.1>, '-5'>>,
  Expect<Equal<Trunc<'.3'>, '0'>>,
  Expect<Equal<Trunc<'1.234'>, '1'>>,
  Expect<Equal<Trunc<'-.3'>, '-0'>>,
  Expect<Equal<Trunc<'-10.234'>, '-10'>>,
  Expect<Equal<Trunc<10>, '10'>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

---

---
url: /type-challenges/medium/tuple-to-nested-object/index.md
---
# TupleToNestedObject
## 题目

Github: [TupleToNestedObject](https://github.com/type-challenges/type-challenges/blob/main/questions/03188-medium-tuple-to-nested-object/README.md)

给定一个仅包含字符串类型的元组类型 `T` ，以及一个类型 `U` ，递归地构建一个对象。

```ts
type a = TupleToNestedObject<['a'], string> // {a: string}
type b = TupleToNestedObject<['a', 'b'], number> // {a: {b: number}}
type c = TupleToNestedObject<[], boolean> // boolean. if the tuple is empty, just return the U type
```

## 解题思路

略。

## 答案

```ts
type TupleToNestedObject<T, U> = T extends [infer L extends PropertyKey, ...infer O]
  ? { [P in L]: TupleToNestedObject<O, U> }
  : U
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type TupleToNestedObject<T, U> = T extends [infer L extends PropertyKey, ...infer O]
  ? { [P in L]: TupleToNestedObject<O, U> }
  : U

// ---cut---
type cases = [
  Expect<Equal<TupleToNestedObject<['a'], string>, { a: string }>>,
  Expect<Equal<TupleToNestedObject<['a', 'b'], number>, { a: { b: number } }>>,
  Expect<Equal<TupleToNestedObject<['a', 'b', 'c'], boolean>, { a: { b: { c: boolean } } }>>,
  Expect<Equal<TupleToNestedObject<[], boolean>, boolean>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [在条件类型中进行推断 Inferring within conditional types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive conditional types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)

---

---
url: /type-challenges/medium/tuple-to-union/index.md
---
# 元组转合集
## 题目

Github: [Tuple to union](https://github.com/type-challenges/type-challenges/blob/main/questions/00010-medium-tuple-to-union/)

实现泛型`TupleToUnion<T>`，它返回元组所有值的合集。

```ts
type Arr = ['1', '2', '3']

type Test = TupleToUnion<Arr> // expected to be '1' | '2' | '3'
```

## 解题思路

在访问元组的成员时，可以通过 `[number]` 索引，访问一个 由元组所有成员构成的联合类型。

同时，需要对 `T` 添加约束，以告知编译器 `T` 是一个可以被索引的数组。

## 答案

```ts
type TupleToUnion<T extends unknown[]> = T[number]
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'
type TupleToUnion<T extends unknown[]> = T[number]

// ---cut---
type cases = [
  Expect<Equal<TupleToUnion<[123, '456', true]>, 123 | '456' | true>>,
  Expect<Equal<TupleToUnion<[123]>, 123>>,
]
```

## 参考

* [查找类型 Lookup Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#keyof-and-lookup-types)

---

---
url: /type-challenges/medium/type-lookup/index.md
---
# 查找类型
## 题目

Github: [Type lookup](https://github.com/type-challenges/type-challenges/blob/main/questions/00062-medium-type-lookup/)

有时，您可能希望根据某个属性在联合类型中查找类型。

在此挑战中，我们想通过在联合类型 `Cat | Dog` 中搜索公共type字段来获取相应的类型。
换句话说，在以下示例中，我们期望 `LookUp<Dog | Cat, 'dog'>` 获得 `Dog` ，`LookUp<Dog | Cat, 'cat'>` 获得 `Cat`。

```ts
interface Cat {
  type: 'cat'
  breeds: 'Abyssinian' | 'Shorthair' | 'Curl' | 'Bengal'
}

interface Dog {
  type: 'dog'
  breeds: 'Hound' | 'Brittany' | 'Bulldog' | 'Boxer'
  color: 'brown' | 'white' | 'black'
}

type MyDog = LookUp<Cat | Dog, 'dog'> // expected to be `Dog`
```

## 解题思路

利用 TypeScript 中 的 **条件类型** 来 检查类型是否可分配给某些特定布局。
检查 `U` 是否可以赋值给 `{ type: T }` 。

值得注意的是，条件类型在 TypeScript 中是分布式的，因此联合类型中的每个成员都将按照条件进行检查。

## 答案

```ts
type LookUp<U, T> = U extends { type: T } ? U : never
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type LookUp<U, T> = U extends { type: T } ? U : never

// ---cut---
interface Cat {
  type: 'cat'
  breeds: 'Abyssinian' | 'Shorthair' | 'Curl' | 'Bengal'
}

interface Dog {
  type: 'dog'
  breeds: 'Hound' | 'Brittany' | 'Bulldog' | 'Boxer'
  color: 'brown' | 'white' | 'black'
}

type Animal = Cat | Dog

type cases = [
  Expect<Equal<LookUp<Animal, 'dog'>, Dog>>,
  Expect<Equal<LookUp<Animal, 'cat'>, Cat>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型分支 Distributive Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)

---

---
url: /type-challenges/medium/unique/index.md
---
# Unique
## 题目

Github: [Unique](https://github.com/type-challenges/type-challenges/blob/main/questions/05360-medium-unique/)

实现类型版本的 Lodash.uniq 方法, Unique 接收数组类型 T, 返回去重后的数组类型.

```ts
type Res = Unique<[1, 1, 2, 2, 3, 3]> // expected to be [1, 2, 3]
type Res1 = Unique<[1, 2, 3, 4, 4, 5, 6, 7]> // expected to be [1, 2, 3, 4, 5, 6, 7]
type Res2 = Unique<[1, 'a', 2, 'b', 2, 'a']> // expected to be [1, "a", 2, "b"]
type Res3 = Unique<[string, number, 1, 'a', 1, string, 2, 'b', 2, number]> // expected to be [string, number, 1, "a", 2, "b"]
type Res4 = Unique<[unknown, unknown, any, any, never, never]> // expected to be [unknown, any, never]
```

## 解题思路

本挑战有两个难点：判断数组中是否包含某个元素；判断两个类型是否严格相等。

**判断两个类型是否严格相等**，请参考 [类型系统的真假美猴王：破解 IsEqual\<X, Y> 之谜](../../../1.前端/12.TypeScript/isEqual.md)

```ts
type Equal<X, Y>
  = (<T>() => T extends X ? 1 : 2) extends
  (<T>() => T extends Y ? 1 : 2) ? true : false
```

有了 `Equal<X, Y>` 类型工具，就可以实现 `Include<T, U>` 类型工具，判断数组 `T` 中是否包含元素 `U`。

```ts
type Include<T extends unknown[], U> = T extends [infer F, ...infer O]
  ? Equal<F, U> extends true
    ? true
    : Include<O, U>
  : false
```

接下来，就可以实现 `Unique<T>` 类型工具，通过 条件类型 `infer`，从数组 `T` 中，
通过递归的方式从末尾取出一个个元素，判断是否严格等于类型 `U`。

## 答案

```ts
type Equal<X, Y>
  = (<T>() => T extends X ? 1 : 2) extends
  (<T>() => T extends Y ? 1 : 2) ? true : false

type Include<T extends unknown[], U> = T extends [infer F, ...infer O]
  ? Equal<F, U> extends true
    ? true
    : Include<O, U>
  : false

type Unique<T extends unknown[],> = T extends [...infer O, infer F]
  ? Include<O, F> extends true
    ? Unique<O>
    : [...Unique<O>, F]
  : []
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type Include<T extends unknown[], U> = T extends [infer F, ...infer O]
  ? Equal<F, U> extends true
    ? true
    : Include<O, U>
  : false

type Unique<T extends unknown[],> = T extends [...infer O, infer F]
  ? Include<O, F> extends true
    ? Unique<O>
    : [...Unique<O>, F]
  : []

// ---cut---
type cases = [
  Expect<Equal<Unique<[1, 1, 2, 2, 3, 3]>, [1, 2, 3]>>,
  Expect<Equal<Unique<[1, 2, 3, 4, 4, 5, 6, 7]>, [1, 2, 3, 4, 5, 6, 7]>>,
  Expect<Equal<Unique<[1, 'a', 2, 'b', 2, 'a']>, [1, 'a', 2, 'b']>>,
  Expect<Equal<Unique<[string, number, 1, 'a', 1, string, 2, 'b', 2, number]>, [string, number, 1, 'a', 2, 'b']>>,
  Expect<Equal<Unique<[unknown, unknown, any, any, never, never]>, [unknown, any, never]>>,
]
```

## 参考

* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)

---

---
url: /type-challenges/medium/without/index.md
---
# Without
## 题目

Github: [Without](https://github.com/type-challenges/type-challenges/blob/main/questions/05117-medium-without/)

实现一个像 `Lodash.without` 函数一样的泛型 `Without<T, U>`，它接收数组类型的 `T` 和数字或数组类型的 `U` 为参数，
会返回一个去除 `U` 中元素的数组 `T`。

```ts
type Res = Without<[1, 2], 1> // expected to be [2]
type Res1 = Without<[1, 2, 4, 1, 5], [1, 2]> // expected to be [4, 5]
type Res2 = Without<[2, 3, 2, 3, 2, 3, 2, 3], [2, 3]> // expected to be []
```

## 解题思路

此挑战很容易想到使用 `infer` 和递归 来实现，从 数组 `T` 中取出一个个元素，判断是否为 `U` 的元素。

但还需要注意一点，即 `U` 可能传入的是 数组，也可能是 非数组。因此，需要将 `U` 转换为 联合类型。

## 答案

```ts
type ToUnion<U> = U extends readonly any[] ? U[number] : U
type Without<T extends any[], U> = T extends [infer F, ...infer O]
  ? F extends ToUnion<U>
    ? Without<O, U>
    : [F, ...Without<O, U>]
  : T
```

## 验证

```ts twoslash
import type { Equal, Expect } from '~/tc-utils'

type ToUnion<U> = U extends readonly any[] ? U[number] : U
type Without<T extends any[], U> = T extends [infer F, ...infer O]
  ? F extends ToUnion<U>
    ? Without<O, U>
    : [F, ...Without<O, U>]
  : T

// ---cut---
type cases = [
  Expect<Equal<Without<[1, 2], 1>, [2]>>,
  Expect<Equal<Without<[1, 2, 4, 1, 5], [1, 2]>, [4, 5]>>,
  Expect<Equal<Without<[2, 3, 2, 3, 2, 3, 2, 3], [2, 3]>, []>>,
]
```

## 参考

* [联合类型 Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [条件类型中的类型推断 Type Inference in Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)

---

---
url: /type-challenges/medium/zip/index.md
---
# Zip
## 题目

Github: [Zip](https://github.com/type-challenges/type-challenges/blob/main/questions/04471-medium-zip/)

在此挑战中，您需要实现一个类型 `Zip<T, U>`，其中 `T` 和 `U` 必须是元组。

```ts
type exp = Zip<[1, 2], [true, false]> // expected to be [[1, true], [2, false]]
```

## 解题思路

这个挑战要求我们创建一个分组元素的数组，数组的第一个元素包含数组 `T` 和 `U` 的第一个元素，
数组的第二个元素包含数组 `T` 和 `U`的第二个元素，以此类推。

首先添加类型参数 `L` 用于保存分组元素的数组，初始值为空数组。

当 `L` 为空数组时，此时 数组长度 `L['length']` 为 `0`，我们恰好可以从数组 `T` 和 `U` 中通过索引下标获取第一个元素，
并将其添加到 `L` 中，此时 `L` 的类型结果为 `[T[0], U[0]]`，然后继续递归调用 `Zip` 。

当 `L` 的长度为 数组 `T` 或 `U` 的最小长度时，则表示递归结束。

## 答案

```ts
type Zip<T extends any[], U extends any[], L extends any[] = []>
  = L['length'] extends T['length'] | U['length']
    ? L
    : Zip<T, U, [...L, [T[L['length']], U[L['length']]]]>
```

## 验证

```ts twoslash
import type { Equal, Expect, NotEqual } from '~/tc-utils'

type Zip<T extends any[], U extends any[], L extends any[] = []>
  = L['length'] extends T['length'] | U['length']
    ? L
    : Zip<T, U, [...L, [T[L['length']], U[L['length']]]]>

// ---cut---
type cases = [
  Expect<Equal<Zip<[], []>, []>>,
  Expect<Equal<Zip<[1, 2], [true, false]>, [[1, true], [2, false]]>>,
  Expect<Equal<Zip<[1, 2, 3], ['1', '2']>, [[1, '1'], [2, '2']]>>,
  Expect<Equal<Zip<[], [1, 2, 3]>, []>>,
  Expect<Equal<Zip<[[1, 2]], [3]>, [[[1, 2], 3]]>>,
]
```

## 参考

* [泛型 Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [泛型约束 Generics constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
* [条件类型 Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [递归条件类型 Recursive Conditional Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html#recursive-conditional-types)
* [模板字面量类型 Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [索引访问类型 Indexed Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)

---

---
url: /type-challenges/warm-up/hello-world/index.md
---
# Hello World
## 题目

Github: [Hello World](https://github.com/type-challenges/type-challenges/tree/main/questions/00013-warm-hello-world)

这个简单的提问希望让你可以快速上手 Type Challenges。在这里，我们使用了一些神奇的技巧让 TypeScript 通过自身的类型系统来实现自动判题。

在这个挑战中，你需要修改下方的代码使得测试通过（使其没有类型错误）。

```ts
// 期望是一个 string 类型
type HelloWorld = any
```

你需要使得如下这行不会抛出异常

```ts
type test = Expect<Equal<HelloWorld, string>>
```

## 解题思路

这道题目仅作为热身，用于熟悉 `type-challenges`， 了解如何接受挑战。
在这里，只需要将 `any` 改为 `string` 即可。

## 答案

```ts
type HelloWorld = string
```

## 验证

```ts twoslash
import { Equal, Expect } from '~/tc-utils'
type HelloWorld = string
// ---cut---
type test = Expect<Equal<HelloWorld, string>>
```
