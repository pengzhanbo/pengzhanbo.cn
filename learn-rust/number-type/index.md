---
url: /learn-rust/number-type/index.md
---
在Rust 中， 数字类型主要分为 **整数类型** 和 **浮点类型。**

* 类型定义的形式： **有无符号** + **类型大小(位数)**
* **无符号数** 只能取正数， **有符号数** 既可以取正数也可以取负数

## 整数类型

整数是指没有小数部分的数字。在Rust中，内置了如下的整数类型：

| 长度       | 有符号类型 | 无符号类型 |
| ---------- | ---------- | ---------- |
| 8位        | i8         | u8         |
| 16位       | i16        | u16        |
| 32位       | i32        | u32        |
| 64位       | i64        | u64        |
| 128位      | i128       | u128       |
| 视架构而定 | isize      | usize      |

* 每个有符号类型规定的数字，取值范围为 : $-(2^{n-1})$ ~ $2^{n-1} -1$ ，其中 `n` 为位长度。
  如 `i8` 可存储数字范围为 **-128 ~ 127**
* 每个无符号类型规定的数字，取值范围为 0 ~ $2^n-1$ ，其中 `n` 为位长度。
  如 `u8` 可存储数字范围为 **0 ~ 255**
* `isize` 和 `usize` 取决于程序运行的计算机CPU类型：若CPU是 32位 的，则这两个类型的位数是 32位，同理，如CPU是64位，这两个类型位数为 64位
* 在Rust中，整型默认使用的类型是 `i32`

**整型字面量书写形式:**

| 数字字面量    | 示例        |
| ------------- | ----------- |
| 十进制        | 95\_232      |
| 十六进制      | 0xff        |
| 八进制        | 0o76        |
| 二进制        | 0b1111\_0000 |
| 字节(仅限 u8) | b’A'        |

### 整型溢出

如果一个 `u8` 类型的变量，被修改为超过了 **0 ~ 255** 范围的值，比如 256， 那么就会发生 **整型溢出**。

* debug模式下，Rust在编译时， 会检查整型溢出，若存在这个问题，则会导致程序在编译时崩溃（panic)
* release模式下，Rust在编译时，不检测溢出。当检查出溢出时，Rust 会按照补码循环溢出的规则处理：大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 `u8`的情况下，256 变成 0，257 变成 1，依此类推。
  程序不会被 panic ，但是该变量的值可能不是期望的值。

## 浮点类型

**浮点类型数字** 即 带小数点的数字。

在 Rust 中，浮点类型有两种基本类型： `f32` 和 `f64` 。

浮点数根据 `IEEE-754` 标准实现。`f32` 类型是单精度浮点型，`f64` 为双精度。

### NaN

对于数学上未定义的结果，例如对负数取平方根 `-42.1.sqrt()`  ，会产生一个特殊的结果：Rust 的浮点数类型使用 `NaN`  (not a number)来处理这些情况。

**所有跟 `NaN` 交互的操作，都会返回一个 `NaN` 。**

## 序列

Rust提供了一种简洁的方式，用于生成连续的数值：

`1..5` 表示 生成 `1, 2, 3, 4` 的数字

`1..=5` 表示 生成 `1, 2, 3, 4, 5` 的 数字。

序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，
字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。
