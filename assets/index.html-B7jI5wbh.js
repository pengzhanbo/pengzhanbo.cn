import{_ as i,c as a,e,o as n}from"./app-D7KDYWdB.js";const t={};function h(l,s){return n(),a("div",null,[...s[0]||(s[0]=[e(`<p><a href="https://github.com/axios/axios" target="_blank" rel="noopener noreferrer">axios</a></p><div class="hint-container tip"><p class="hint-container-title">提问</p><ol><li>简单介绍一下 axios</li><li>axios拦截器是如何实现的？</li></ol></div><h2 id="axios" tabindex="-1"><a class="header-anchor" href="#axios"><span>axios</span></a></h2><p>axios 是一个基于 promise 的 HTTP库，可以在浏览器和nodejs中使用。</p><h3 id="特性" tabindex="-1"><a class="header-anchor" href="#特性"><span>特性</span></a></h3><ul><li>从浏览器中创建 XMLHttpRequests</li><li>从 nodejs 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防御 XSRF</li></ul><h2 id="拦截器实现" tabindex="-1"><a class="header-anchor" href="#拦截器实现"><span>拦截器实现</span></a></h2><p>axios的拦截器分为 请求体拦截器 和 响应体拦截器，</p><ul><li><p>请求体拦截器： 在请求发送前，进行拦截，在拦截的回调中可以对请求体数据进行 同步或异步处理， 并返回一个处理后的 请求体数据 或者 由 promise 包装的 请求体数据。</p></li><li><p>响应体拦截器： 在请求成功收到响应后，进入响应回调前，进行拦截，在拦截的回调中可以响应体数据进行同步或异步处理， 并返回一个处理后的响应体数据或者 由 promise 包装的响应期数据</p></li></ul><p>两个拦截器的实现思路是相同的。本质上是定义了一个拦截器队列 <code>handlers</code>，当使用 <code>use()</code> 方法时，</p><p><code>use()</code> 方法接受两个参数： <code>fulfilled</code> 和 <code>rejected</code> 函数， 参数以 <code>{ fulfilled, rejected }</code> 的形式推送到 <code>handlers</code> 的尾部。</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Interceptor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  constructor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">    this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">handlers</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> []</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  use</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">fulfilled</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> rejected</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">    this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">handlers</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">push</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">({</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> fulfilled</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> rejected</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> })</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">handlers</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">length</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> -</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在发起请求前，初始化一个 promise, 并直接返回 请求体数据<code>requestConfig</code>, 同时以 请求对象实例，初始化一个 promise 队列 <code>[dispatchRequest, undefined]</code></p><div class="language-js" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">let</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> promise</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;"> Promise</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">resolve</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">requestConfig</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// dispatchRequest，即一个 实例化后封装的 XMLHttpRequests，返回一个 promise.resolve(response)</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> chain</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">dispatchRequest</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> undefined</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span></span></code></pre></div><p>然后将 请求拦截器 的 <code>handlers</code> 按顺序，以 <code>fulfilled, rejected</code> 添加到 <code>chain</code> 的头部， 将 响应拦截器 的 <code>handlers</code> 按顺序，以 <code>fulfilled, rejected</code> 添加到 <code>chain</code> 的尾部。</p><p>最后将得到 chain 数组，作为参数，循环传入 promise.then 的链式调用中,</p><div class="language-js" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">while</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">chain</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">length</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">  promise</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> promise</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">then</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">chain</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">shift</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(),</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> chain</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">shift</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">())</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><p>即， 拦截器的本质上是在 请求实例的 promise 上，在其前后添加 promise实例，然后依次，将上一个promise的结果 作为参数，传入到下一个promise中。 这也是 拦截器 为什么支持 同步函数和异步函数的原因。</p>`,18)])])}const k=i(t,[["render",h]]),d=JSON.parse('{"path":"/interview-question/7fmfc0hi/","title":"axios","lang":"zh-CN","frontmatter":{"title":"axios","createTime":"2022/04/17 11:38:09","permalink":"/interview-question/7fmfc0hi/","description":"axios 提问 简单介绍一下 axios axios拦截器是如何实现的？ axios axios 是一个基于 promise 的 HTTP库，可以在浏览器和nodejs中使用。 特性 从浏览器中创建 XMLHttpRequests 从 nodejs 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"axios\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-07T17:39:39.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://pengzhanbo.cn/interview-question/7fmfc0hi/"}],["meta",{"property":"og:site_name","content":"鹏展博"}],["meta",{"property":"og:title","content":"axios"}],["meta",{"property":"og:description","content":"axios 提问 简单介绍一下 axios axios拦截器是如何实现的？ axios axios 是一个基于 promise 的 HTTP库，可以在浏览器和nodejs中使用。 特性 从浏览器中创建 XMLHttpRequests 从 nodejs 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-07T17:39:39.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-07T17:39:39.000Z"}]]},"readingTime":{"minutes":1.93,"words":578},"git":{"createdTime":1650212829000,"updatedTime":1759858779000,"contributors":[{"name":"pengzhanbo","username":"pengzhanbo","email":"volodymyr@foxmail.com","commits":13,"avatar":"https://avatars.githubusercontent.com/pengzhanbo?v=4","url":"https://github.com/pengzhanbo"}]},"autoDesc":true,"filePathRelative":"面试题/常用库/axios.md","headers":[]}');export{k as comp,d as data};
