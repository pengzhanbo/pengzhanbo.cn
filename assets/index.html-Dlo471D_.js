import{_ as t,c as o,a as i,o as r}from"./app-CswOyyIB.js";const a={};function l(n,e){return r(),o("div",null,[...e[0]||(e[0]=[i('<p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/badge/vue-%402-brightgreen" alt="vue@2"></a></p><p><a href="https://v3.router.vuejs.org/zh/" target="_blank" rel="noopener noreferrer"><img src="https://img.shields.io/badge/vue--router-%403-brightgreen" alt="vue-router@3"></a></p><div class="hint-container tip"><p class="hint-container-title">提示</p><ol><li>路由的历史模式有哪些？有什么不同？</li><li>路由的导航守卫</li><li>导航守卫的解析流程（执行顺序）</li></ol></div><h2 id="历史模式" tabindex="-1"><a class="header-anchor" href="#历史模式"><span>历史模式</span></a></h2><ol><li><p>Hash 模式</p><p>使用 URL 的 <code>hash</code> 来模拟一个完整的 URL， 当 <code>hash</code> 改变时，页面不会重新加载</p></li><li><p>History 模式</p><p>使用 <code>history.pushState</code> API 来完成 URL 而无需页面重新加载。</p><p>History 模式需要后端服务器进行配置以提供支持。通过特定的规则，将路径重定向到 一个特定的页面路径。</p></li></ol><h2 id="导航守卫" tabindex="-1"><a class="header-anchor" href="#导航守卫"><span>导航守卫</span></a></h2><p>路由的导航守卫 主要是用来 通过跳转和取消的方式守卫导航。</p><p>导航守卫 包括：</p><ul><li><p><code>beforeEach</code></p><p>全局前置守卫。 在导航被确认之前调用。</p></li><li><p><code>beforeResolve</code></p><p>全局解析守卫。 在导航被确认之前，同时所有组件内守卫和异步路由组件被解析之后 调用。</p></li><li><p><code>afterEach</code></p><p>全局后置钩子. 在导航被确认之后调用。</p></li><li><p>路由独享守卫</p><p>在路由配置上定义 <code>beforeEnter</code>。 在进入当前路由之前被调用。</p></li><li><p>组件内守卫</p><ul><li><code>beforeRouteEnter</code> 渲染该组件的对应路由被 confirm 前调用</li><li><code>beforeRouteUpdate</code> 当前路由改变，但是该组件被复用时调用</li><li><code>beforeRouteLeave</code> 导航离开该组件的对应路由时调用</li></ul></li></ul><h2 id="导航守卫的解析流程" tabindex="-1"><a class="header-anchor" href="#导航守卫的解析流程"><span>导航守卫的解析流程</span></a></h2><ol><li>导航被触发。</li><li>在失活的组件里调用 beforeRouteLeave 守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol>',11)])])}const s=t(a,[["render",l]]),h=JSON.parse('{"path":"/interview-question/9zwkibho/","title":"路由 | 面试题","lang":"zh-CN","frontmatter":{"title":"路由","createTime":"2022/04/23 06:30:49","permalink":"/interview-question/9zwkibho/","description":"vue@2 vue-router@3 提示 路由的历史模式有哪些？有什么不同？ 路由的导航守卫 导航守卫的解析流程（执行顺序） 历史模式 Hash 模式 使用 URL 的 hash 来模拟一个完整的 URL， 当 hash 改变时，页面不会重新加载 History 模式 使用 history.pushState API 来完成 URL 而无需页面重新加...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"路由\\",\\"image\\":[\\"https://img.shields.io/badge/vue-%402-brightgreen\\",\\"https://img.shields.io/badge/vue--router-%403-brightgreen\\"],\\"dateModified\\":\\"2025-10-07T17:39:39.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://pengzhanbo.cn/interview-question/9zwkibho/"}],["meta",{"property":"og:site_name","content":"鹏展博"}],["meta",{"property":"og:title","content":"路由"}],["meta",{"property":"og:description","content":"vue@2 vue-router@3 提示 路由的历史模式有哪些？有什么不同？ 路由的导航守卫 导航守卫的解析流程（执行顺序） 历史模式 Hash 模式 使用 URL 的 hash 来模拟一个完整的 URL， 当 hash 改变时，页面不会重新加载 History 模式 使用 history.pushState API 来完成 URL 而无需页面重新加..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://img.shields.io/badge/vue-%402-brightgreen"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-07T17:39:39.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-07T17:39:39.000Z"}]]},"readingTime":{"minutes":1.67,"words":501},"git":{"createdTime":1650719495000,"updatedTime":1759858779000,"contributors":[{"name":"pengzhanbo","username":"pengzhanbo","email":"volodymyr@foxmail.com","commits":10,"avatar":"https://avatars.githubusercontent.com/pengzhanbo?v=4","url":"https://github.com/pengzhanbo"}]},"autoDesc":true,"filePathRelative":"面试题/Vue/v2/路由.md","headers":[]}');export{s as comp,h as data};
