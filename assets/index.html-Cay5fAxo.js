import{_ as i,c as n,a as o,e as c,d as t,b as r,w as l,r as s,o as d}from"./app-D7KDYWdB.js";const p={};function m(u,e){const a=s("VPLink");return d(),n("div",null,[e[2]||(e[2]=o("div",{class:"hint-container tip"},[o("p",{class:"hint-container-title"},"提问"),o("ol",null,[o("li",null,"什么是事件循环？"),o("li",null,"什么是宏任务和微任务？"),o("li",null,"事件循环的执行步骤？")])],-1)),o("p",null,[e[1]||(e[1]=t("参阅 ",-1)),r(a,{href:"/article/browser-event-loop"},{default:l(()=>[...e[0]||(e[0]=[t("Event Loop 浏览器端的事件循环",-1)])]),_:1})]),e[3]||(e[3]=c('<h2 id="什么是-event-loop" tabindex="-1"><a class="header-anchor" href="#什么是-event-loop"><span>什么是 Event-Loop ？</span></a></h2><p>Event-Loop 是一个执行模型，在 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank" rel="noopener noreferrer">html5规范</a> 中进行了浏览器端的 Event-Loop 的明确定义。</p><h2 id="宏任务与微任务" tabindex="-1"><a class="header-anchor" href="#宏任务与微任务"><span>宏任务与微任务</span></a></h2><p>javascript 有两种异步任务，分别是<code>宏任务</code>和<code>微任务</code></p><h3 id="宏任务" tabindex="-1"><a class="header-anchor" href="#宏任务"><span>宏任务</span></a></h3><p>宏任务，<code>macro task</code>，也叫 <code>tasks</code>，一些异步任务的回调会依次进入 <code>macro task queue</code>，等待后续被调用。</p><p>这些异步任务包括：</p><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate (Node独有)</li><li>requestAnimationFrame (浏览器独有)</li><li>I/O</li><li>UI rendering</li></ul><h3 id="微任务" tabindex="-1"><a class="header-anchor" href="#微任务"><span>微任务</span></a></h3><p>微任务， <code>micro task</code>, 也叫 <code>jobs</code>，另一些异步任务的回调会依次进入<code>micro task queue</code>，等待后续被调用。</p><p>这些异步任务包括：</p><ul><li>process.nextTick(Node独有)</li><li>Promise</li><li>Object.observe</li><li>MutationObserver</li></ul><h2 id="事件循环-event-loop" tabindex="-1"><a class="header-anchor" href="#事件循环-event-loop"><span>事件循环 Event Loop</span></a></h2><ol><li>执行全局 <code>script</code> 代码，这些代码有一些是同步语句，有一些是异步语句（如： setTimeout）；</li><li>全局<code>script</code>同步代码执行完毕后，调用栈Stack会清空；</li><li>从微任务<code>micro task queue</code> 中取出位于队首的任务，放入调用栈Stack中执行，执行完后<code>micro task queue</code>长度减一；</li><li>继续取出微任务<code>micro task queue</code>位于队首的任务，放入调用栈Stack中执行， 以此类推，直到把<code>micro task queue</code>中的所有任务都执行完毕。<strong>注意，如果在执行micro task的过程中，产生了<code>micro task</code>那么会加入到队列的末尾，也会在这个周期被调用执行</strong>；</li><li><code>micro task</code>中的所有无人都执行完毕，此时 <code>micro task queue</code> 为空队列，调用栈Stack也为空；</li><li>取出宏队列 <code>macro task queue</code> 中位于队首的任务，放入Stack中执行；</li><li>执行完毕后，调用栈Stack为空；</li><li>重复第3-7个步骤；</li><li>以此继续循环重复；</li></ol><div class="hint-container important"><p class="hint-container-title">重点</p><ol><li>宏任务<code>marco task</code> 一次只从队列中取出一个任务执行，执行后就去执行微任务队列中的任务；</li><li>微任务队列中所有的任务都会依次取出来执行，直到<code>micro task queue</code>为空， 且当前微任务执行过程中产生新的<code>micro task</code>，也会加入到当前<code>micro task queue</code>;</li><li><code>UI Rendering</code>由浏览器自定判断决定执行节点。但是只要执行<code>UI Rendering</code>，它的节点是在执行完所有 <code>micro task</code>之后，下一个<code>macro task</code>之前，紧跟着执行<code>UI Rendering</code></li></ol></div>',15))])}const k=i(p,[["render",m]]),v=JSON.parse('{"path":"/interview-question/7y6d3oqt/","title":"事件循环","lang":"zh-CN","frontmatter":{"title":"事件循环","createTime":"2022/04/17 06:18:33","permalink":"/interview-question/7y6d3oqt/","description":"提问 什么是事件循环？ 什么是宏任务和微任务？ 事件循环的执行步骤？ 参阅 什么是 Event-Loop ？ Event-Loop 是一个执行模型，在 html5规范 中进行了浏览器端的 Event-Loop 的明确定义。 宏任务与微任务 javascript 有两种异步任务，分别是宏任务和微任务 宏任务 宏任务，macro task，也叫 tasks...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"事件循环\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-07T17:39:39.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://pengzhanbo.cn/interview-question/7y6d3oqt/"}],["meta",{"property":"og:site_name","content":"鹏展博"}],["meta",{"property":"og:title","content":"事件循环"}],["meta",{"property":"og:description","content":"提问 什么是事件循环？ 什么是宏任务和微任务？ 事件循环的执行步骤？ 参阅 什么是 Event-Loop ？ Event-Loop 是一个执行模型，在 html5规范 中进行了浏览器端的 Event-Loop 的明确定义。 宏任务与微任务 javascript 有两种异步任务，分别是宏任务和微任务 宏任务 宏任务，macro task，也叫 tasks..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-07T17:39:39.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-07T17:39:39.000Z"}]]},"readingTime":{"minutes":2.16,"words":648},"git":{"createdTime":1650212829000,"updatedTime":1759858779000,"contributors":[{"name":"pengzhanbo","username":"pengzhanbo","email":"volodymyr@foxmail.com","commits":14,"avatar":"https://avatars.githubusercontent.com/pengzhanbo?v=4","url":"https://github.com/pengzhanbo"}]},"autoDesc":true,"filePathRelative":"面试题/浏览器/事件循环.md","headers":[]}');export{k as comp,v as data};
