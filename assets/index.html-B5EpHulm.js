import{_ as l,c as e,e as h,a as i,d as a,b as t,r as p,o as k}from"./app-D7KDYWdB.js";const r="/images/algorithm/recursion-1.png",d={};function g(o,s){const n=p("Badge");return k(),e("div",null,[s[40]||(s[40]=h('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p><mark>递归</mark> ，在数学和计算机科学中是指在函数的定义中使用函数自身的方法， 在计算机科学中还额外指一种 <strong>通过重复将问题分解为同类的子问题而解决问题的方法</strong>。</p><p>递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。 求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。</p><h2 id="如何理解递归" tabindex="-1"><a class="header-anchor" href="#如何理解递归"><span>如何理解递归？</span></a></h2><p>请看下面的例子：</p><ul><li><p>点击：<a href="javascript:location.reload();">递归</a></p></li><li><p>在 google 中 搜索 <strong>递归</strong> 时，会得到如下结果：</p><p><img src="'+r+`" alt="递归"></p></li><li><p>给一堆数字排序？分成两半，先排左半边再排右半边，最后进行合并。而怎么排左边和右边，重新阅读这句话。</p></li></ul><h2 id="递归的要素" tabindex="-1"><a class="header-anchor" href="#递归的要素"><span>递归的要素</span></a></h2><ul><li><p><strong>基线条件（Base Case）</strong></p><p>递归终止的条件，防止无限递归（栈溢出）。</p></li><li><p><strong>递归条件（Recursive Case）</strong></p><p>将问题分解为更小的子问题，并调用自身。</p></li><li><p><strong>递归方向（Progress）</strong></p><p>每次递归必须向基线条件靠近。</p></li></ul><h2 id="递归示例" tabindex="-1"><a class="header-anchor" href="#递归示例"><span>递归示例</span></a></h2><h3 id="阶乘计算" tabindex="-1"><a class="header-anchor" href="#阶乘计算"><span>阶乘计算</span></a></h3><div class="language-ts" data-highlighter="shiki" data-ext="ts" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-ts"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">function</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> factorial</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">: </span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">):</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 基线条件：0! = 1, 1! = 1</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> &lt;=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> return</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 递归条件：n! = n * (n-1)!</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  return</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> n</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> factorial</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">n</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> -</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">console</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">log</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">factorial</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 120</span></span></code></pre></div><h3 id="斐波那契数列" tabindex="-1"><a class="header-anchor" href="#斐波那契数列"><span>斐波那契数列</span></a></h3><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-ts"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">function</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> fibonacci</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">: </span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">):</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 基线条件</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">n</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ===</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> return</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">n</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ===</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> return</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 递归条件：F(n) = F(n-1) + F(n-2)</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  return</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> fibonacci</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">n</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> -</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> +</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> fibonacci</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">n</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> -</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">console</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">log</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">fibonacci</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">6</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 8</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="递归的优化策略" tabindex="-1"><a class="header-anchor" href="#递归的优化策略"><span>递归的优化策略</span></a></h2><h3 id="记忆化-memoization" tabindex="-1"><a class="header-anchor" href="#记忆化-memoization"><span>记忆化（Memoization）</span></a></h3><p>缓存计算结果，避免重复递归（适合有重叠子问题的情况）。</p><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-ts"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">memo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> new </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Map</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">function</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> fibonacciMemo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">: </span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">):</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> &lt;=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> return</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 检查缓存</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">memo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">has</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> return</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> memo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">get</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">!</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 计算并缓存结果</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  const </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">result</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> fibonacciMemo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">n</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> - </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> + </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">fibonacciMemo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">n</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> - </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">  memo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">set</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> result</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  return</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> result</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="尾递归优化-tail-recursion" tabindex="-1"><a class="header-anchor" href="#尾递归优化-tail-recursion"><span>尾递归优化（Tail Recursion）</span></a></h3><p>将递归操作置于函数末尾，编译器可优化为迭代（TypeScript 需手动转换）。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-ts"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 阶乘的尾递归实现</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">function</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> factorialTail</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">: </span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> acc</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">: </span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">):</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  return</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> &lt;=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ?</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> acc</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> :</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> factorialTail</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">n</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> -</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> n</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> acc</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre></div><h2 id="递归的典型应用场景" tabindex="-1"><a class="header-anchor" href="#递归的典型应用场景"><span>递归的典型应用场景</span></a></h2><ul><li><p><strong>分治算法</strong></p><p>如归并排序、快速排序。</p></li><li><p><strong>树/图遍历</strong></p><p>如深度优先搜索（DFS）。</p></li><li><p><strong>回溯算法</strong></p><p>如八皇后问题、迷宫求解。</p></li><li><p><strong>动态规划</strong></p><p>通常基于递归定义状态转移方程。</p></li></ul><h2 id="递归的优缺点" tabindex="-1"><a class="header-anchor" href="#递归的优缺点"><span>递归的优缺点</span></a></h2><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>代码简洁直观，贴近数学定义</td><td>栈溢出风险（深度过大）</td></tr><tr><td>简化复杂问题的实现</td><td>重复计算（需记忆化优化）</td></tr><tr><td>天然适合处理嵌套结构</td><td>函数调用开销比循环大</td></tr></tbody></table><h2 id="写递归的要点" tabindex="-1"><a class="header-anchor" href="#写递归的要点"><span>写递归的要点</span></a></h2><ul><li><strong>明确基线条件</strong>：确保递归最终会终止。</li><li><strong>信任递归</strong>：假设子问题已解决，聚焦当前逻辑。</li><li><strong>缩小问题规模</strong>：每次递归必须更接近基线条件。</li><li><strong>避免重复计算</strong>：对重叠子问题使用记忆化。</li></ul><div class="hint-container important"><p class="hint-container-title">明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节，否则就会陷入无穷的细节无法自拔。</p></div><h2 id="递归与分治的区别" tabindex="-1"><a class="header-anchor" href="#递归与分治的区别"><span>递归与分治的区别</span></a></h2><p>递归是一种编程技巧，一种解决问题的思维方式；分治算法很大程度上是基于递归的，解决更具体问题的算法思想。</p><h2 id="相关问题" tabindex="-1"><a class="header-anchor" href="#相关问题"><span>相关问题</span></a></h2><p><a href="https://leetcode.cn/tag/recursion/" class="read-more" target="_blank" rel="noopener noreferrer"><strong>LeetCode - 递归</strong></a></p><h3 id="基础递归问题" tabindex="-1"><a class="header-anchor" href="#基础递归问题"><span>基础递归问题</span></a></h3>`,32)),i("ul",null,[i("li",null,[s[0]||(s[0]=i("strong",null,"509. 斐波那契数",-1)),s[1]||(s[1]=a("（",-1)),s[2]||(s[2]=i("a",{href:"https://leetcode.cn/problems/fibonacci-number/",target:"_blank",rel:"noopener noreferrer"},"LeetCode",-1)),s[3]||(s[3]=a("）",-1)),t(n,{text:"简单",type:"tip"})]),i("li",null,[s[4]||(s[4]=i("strong",null,"70. 爬楼梯",-1)),s[5]||(s[5]=a("（",-1)),s[6]||(s[6]=i("a",{href:"https://leetcode.cn/problems/climbing-stairs/",target:"_blank",rel:"noopener noreferrer"},"LeetCode",-1)),s[7]||(s[7]=a("）",-1)),t(n,{text:"简单",type:"tip"})]),i("li",null,[s[8]||(s[8]=i("strong",null,"50. Pow(x, n)",-1)),s[9]||(s[9]=a("（",-1)),s[10]||(s[10]=i("a",{href:"https://leetcode.cn/problems/powx-n/",target:"_blank",rel:"noopener noreferrer"},"LeetCode",-1)),s[11]||(s[11]=a("）",-1)),t(n,{text:"中等",type:"tip"})])]),s[41]||(s[41]=i("h3",{id:"链表与树结构递归",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#链表与树结构递归"},[i("span",null,"链表与树结构递归")])],-1)),i("ul",null,[i("li",null,[s[12]||(s[12]=i("strong",null,"206. 反转链表",-1)),s[13]||(s[13]=a("（",-1)),s[14]||(s[14]=i("a",{href:"https://leetcode.cn/problems/reverse-linked-list/",target:"_blank",rel:"noopener noreferrer"},"LeetCode",-1)),s[15]||(s[15]=a("）",-1)),t(n,{text:"简单",type:"tip"})]),i("li",null,[s[16]||(s[16]=i("strong",null,"112. 路径总和",-1)),s[17]||(s[17]=a("（",-1)),s[18]||(s[18]=i("a",{href:"https://leetcode.cn/problems/path-sum/",target:"_blank",rel:"noopener noreferrer"},"LeetCode",-1)),s[19]||(s[19]=a("）",-1)),t(n,{text:"简单",type:"tip"})]),i("li",null,[s[20]||(s[20]=i("strong",null,"236. 二叉树的最近公共祖先",-1)),s[21]||(s[21]=a("（",-1)),s[22]||(s[22]=i("a",{href:"https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/",target:"_blank",rel:"noopener noreferrer"},"LeetCode",-1)),s[23]||(s[23]=a("）",-1)),t(n,{text:"中等",type:"warning"})]),i("li",null,[s[24]||(s[24]=i("strong",null,"230. 二叉搜索树中第K小的元素",-1)),s[25]||(s[25]=a("（",-1)),s[26]||(s[26]=i("a",{href:"https://leetcode.cn/problems/kth-smallest-element-in-a-bst/",target:"_blank",rel:"noopener noreferrer"},"LeetCode",-1)),s[27]||(s[27]=a("）",-1)),t(n,{text:"中等",type:"warning"})])]),s[42]||(s[42]=i("h3",{id:"分治与回溯问题",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#分治与回溯问题"},[i("span",null,"分治与回溯问题")])],-1)),i("ul",null,[i("li",null,[s[28]||(s[28]=i("strong",null,"169. 多数元素",-1)),s[29]||(s[29]=a("（",-1)),s[30]||(s[30]=i("a",{href:"https://leetcode.cn/problems/majority-element/",target:"_blank",rel:"noopener noreferrer"},"LeetCode",-1)),s[31]||(s[31]=a("）",-1)),t(n,{text:"中等",type:"warning"})]),i("li",null,[s[32]||(s[32]=i("strong",null,"22. 括号生成",-1)),s[33]||(s[33]=a("（",-1)),s[34]||(s[34]=i("a",{href:"https://leetcode.cn/problems/generate-parentheses/",target:"_blank",rel:"noopener noreferrer"},"LeetCode",-1)),s[35]||(s[35]=a("）",-1)),t(n,{text:"中等",type:"warning"})]),i("li",null,[s[36]||(s[36]=i("strong",null,"46. 全排列",-1)),s[37]||(s[37]=a("（",-1)),s[38]||(s[38]=i("a",{href:"https://leetcode.cn/problems/permutations/",target:"_blank",rel:"noopener noreferrer"},"LeetCode",-1)),s[39]||(s[39]=a("）",-1)),t(n,{text:"中等",type:"warning"})])])])}const A=l(d,[["render",g]]),m=JSON.parse('{"path":"/algorithm/recursion/","title":"递归","lang":"zh-CN","frontmatter":{"title":"递归","createTime":"2019/06/09 08:49:10","permalink":"/algorithm/recursion/","description":"概述 递归 ，在数学和计算机科学中是指在函数的定义中使用函数自身的方法， 在计算机科学中还额外指一种 通过重复将问题分解为同类的子问题而解决问题的方法。 递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。 求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"递归\\",\\"image\\":[\\"https://pengzhanbo.cn/images/algorithm/recursion-1.png\\"],\\"dateModified\\":\\"2025-10-07T17:39:39.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://pengzhanbo.cn/algorithm/recursion/"}],["meta",{"property":"og:site_name","content":"鹏展博"}],["meta",{"property":"og:title","content":"递归"}],["meta",{"property":"og:description","content":"概述 递归 ，在数学和计算机科学中是指在函数的定义中使用函数自身的方法， 在计算机科学中还额外指一种 通过重复将问题分解为同类的子问题而解决问题的方法。 递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。 求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://pengzhanbo.cn/images/algorithm/recursion-1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-07T17:39:39.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-07T17:39:39.000Z"}]]},"readingTime":{"minutes":3.69,"words":1106},"git":{"createdTime":1749647714000,"updatedTime":1759858779000,"contributors":[{"name":"pengzhanbo","username":"pengzhanbo","email":"volodymyr@foxmail.com","commits":2,"avatar":"https://avatars.githubusercontent.com/pengzhanbo?v=4","url":"https://github.com/pengzhanbo"}]},"autoDesc":true,"filePathRelative":"算法/算法/1.递归.md","headers":[]}');export{A as comp,m as data};
