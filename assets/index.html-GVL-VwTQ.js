import{_ as o,c as t,a as d,o as c}from"./app-CswOyyIB.js";const i={};function n(a,e){return c(),t("div",null,[...e[0]||(e[0]=[d('<div class="hint-container tip"><p class="hint-container-title">提问</p><ol><li>MVC</li><li>MVP</li><li>MVVM</li><li>区别</li></ol></div><div class="hint-container info"><p class="hint-container-title">说明</p><p>以上架构设计模式，仅限于在前端领域内进行说明</p></div><h2 id="model-view" tabindex="-1"><a class="header-anchor" href="#model-view"><span>Model&amp;View</span></a></h2><ul><li><p><code>Model</code> 是用于封装应用程序的业务逻辑的相关数据以及对数据的处理方法。</p></li><li><p><code>View</code> 作为视图层，主要负责数据的展示。</p></li></ul><h2 id="mvc" tabindex="-1"><a class="header-anchor" href="#mvc"><span>MVC</span></a></h2><p><code>C</code> 是指 <code>Controller</code>。负责监听 <code>View</code> 的用户事件，得到数据后后 <code>Controller</code> 做一些处理，然后渲染 <code>View</code>。</p><p><code>MVC</code> 通过分离 <code>Model</code>、<code>View</code> 和 <code>Controller</code> 的方式来组织代码结构。 <code>View</code> 和 <code>Model</code> 应用了观察者模式，当 <code>Model</code> 层发生改变的时候它会通知有关 View 层更新页面。 <code>Controller</code> 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候， <code>Controller</code> 中的事件触发器就开始工作了，通过调用 <code>Model</code> 层，来完成对 <code>Model</code> 的修改，然后 <code>Model</code> 层再去通知 View 层更新。</p><h2 id="mvp" tabindex="-1"><a class="header-anchor" href="#mvp"><span>MVP</span></a></h2><p><code>P</code> 是指 <code>Presenter</code>。<code>Presenter</code>会调用View层提供的接口去渲染Model。</p><p><code>MVP</code> 模式中，View 层的接口暴露给了 <code>Presenter</code>， 因此可以在 <code>Presenter</code> 中将 <code>Model</code> 的变化和 <code>View</code> 的变化绑定在一起，以此来实现 <code>View</code> 和 Model 的同步更新。 这样就实现了对 <code>View</code> 和 <code>Model</code> 的解耦，<code>Presenter</code> 还包含了其他的响应逻辑。</p><h2 id="mvvm" tabindex="-1"><a class="header-anchor" href="#mvvm"><span>MVVM</span></a></h2><p><code>VM</code> 是指 <code>ViewModel</code>。</p><p><code>MVVM</code> 在<code>VM</code>中构建一组状态数据（state data），作为<code>View</code>状态的抽象。 然后通过 <strong>双向数据绑定（data binding）</strong> 使<code>VM</code>中的 <strong>状态数据（state data）</strong> 与<code>View</code>中的 <strong>显示状态（screen state）</strong> 保持一致。 这样，<code>VM</code>中的展示逻辑只需要修改对应的状态数据，就可以控制<code>View</code>的状态，从而避免在<code>View</code>上开发大量的接口。</p>',13)])])}const l=o(i,[["render",n]]),p=JSON.parse('{"path":"/interview-question/ud3m8zxg/","title":"MVC/MVP/MVVM | 面试题","lang":"zh-CN","frontmatter":{"title":"MVC/MVP/MVVM","createTime":"2022/04/20 02:32:11","permalink":"/interview-question/ud3m8zxg/","description":"提问 MVC MVP MVVM 区别 说明 以上架构设计模式，仅限于在前端领域内进行说明 Model&View Model 是用于封装应用程序的业务逻辑的相关数据以及对数据的处理方法。 View 作为视图层，主要负责数据的展示。 MVC C 是指 Controller。负责监听 View 的用户事件，得到数据后后 Controller 做一些处理，然后...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MVC/MVP/MVVM\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-07T17:39:39.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://pengzhanbo.cn/interview-question/ud3m8zxg/"}],["meta",{"property":"og:site_name","content":"鹏展博"}],["meta",{"property":"og:title","content":"MVC/MVP/MVVM"}],["meta",{"property":"og:description","content":"提问 MVC MVP MVVM 区别 说明 以上架构设计模式，仅限于在前端领域内进行说明 Model&View Model 是用于封装应用程序的业务逻辑的相关数据以及对数据的处理方法。 View 作为视图层，主要负责数据的展示。 MVC C 是指 Controller。负责监听 View 的用户事件，得到数据后后 Controller 做一些处理，然后..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-07T17:39:39.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-07T17:39:39.000Z"}]]},"readingTime":{"minutes":1.52,"words":457},"git":{"createdTime":1650444591000,"updatedTime":1759858779000,"contributors":[{"name":"pengzhanbo","username":"pengzhanbo","email":"q942450674@outlook.com","commits":7,"avatar":"https://avatars.githubusercontent.com/pengzhanbo?v=4","url":"https://github.com/pengzhanbo"}]},"autoDesc":true,"filePathRelative":"面试题/JavaScript/MV-设计模式.md","headers":[]}');export{l as comp,p as data};
