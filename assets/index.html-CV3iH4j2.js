import{_ as n,c as s,e,b as r,r as i,o as a}from"./app-D7KDYWdB.js";const o={};function g(d,t){const l=i("Mermaid");return a(),s("div",null,[t[0]||(t[0]=e('<p>想象一下建设一座城市（你的Web应用）。</p><p>你是选择在工厂（服务器）里预先建造好整栋房子运过去（SSG）？</p><p>还是派个施工队（浏览器）到现场根据图纸（JS）慢慢盖（CSR）？</p><p>或者是让工厂按订单要求快速生产好毛坯房再运过去让施工队装修（SSR）？</p><p>甚至是在预制好的房子里预留模块，按需更新（ISG）？</p><p>🤔 今天，我们就来拆解这四种主流渲染策略：<strong>客户端渲染 (CSR)</strong>、<strong>服务器端渲染 (SSR)</strong>、<strong>静态站点生成 (SSG)</strong> 和 <strong>增量静态再生 (ISG)</strong>，帮你找到最适合项目的“城市建设方案”。</p><h2 id="客户端渲染-csr-client-side-rendering" tabindex="-1"><a class="header-anchor" href="#客户端渲染-csr-client-side-rendering"><span>客户端渲染 (CSR - Client-Side Rendering)</span></a></h2><h3 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理"><span>工作原理</span></a></h3><ul><li>用户请求一个URL。</li><li>服务器返回一个<strong>近乎空白的HTML文件</strong>（通常只有一个根元素<code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code>和指向大量JavaScript文件的链接）。</li><li>浏览器下载HTML、CSS和<strong>所有必需的JavaScript</strong>（包括框架如React/Vue/Angular，以及应用代码）。</li><li>JavaScript <strong>在用户的浏览器中执行</strong>，负责： <ul><li>获取数据（通常通过API调用）。</li><li>构建DOM（页面结构）。</li><li>将构建好的DOM插入到根元素中。</li><li>处理后续的交互和路由切换（所有后续页面跳转也由JS处理，无需整页刷新）。</li></ul></li></ul><h3 id="典型代表" tabindex="-1"><a class="header-anchor" href="#典型代表"><span>典型代表</span></a></h3><p>传统的单页应用 (SPA) 框架如 <strong>Create React App, Vue CLI 默认输出</strong>。</p><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h3><ul><li><strong>交互体验流畅：</strong> 首次加载后，后续导航和交互感觉极其快速，接近原生应用，因为只更新变化的部分。</li><li><strong>服务器压力小：</strong> 服务器主要提供静态文件和API，计算负担转移到客户端。</li><li><strong>开发体验好：</strong> 前后端分离清晰，前端开发者拥有完全控制权，利用现代框架开发高效。</li><li><strong>丰富的交互能力：</strong> 非常适合构建高度交互式、类应用（Application-like）的体验。</li></ul><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h3><ul><li><strong>首屏加载慢 (FCP/TTI 差)：</strong> 用户需要等待所有JS下载、解析、执行、数据获取、渲染完成才能看到有意义的内容。尤其对低端设备和慢网络用户不友好。</li><li><strong>SEO 不友好：</strong> 搜索引擎爬虫早期（现在部分高级爬虫如Googlebot能执行JS，但仍有延迟和不确定性）可能只能看到空HTML或加载状态，难以正确索引内容。</li><li><strong>内容可见性延迟：</strong> 用户盯着空白屏或加载动画的时间较长。</li></ul><h3 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景"><span>适用场景</span></a></h3><ul><li>后台管理系统、Dashboards（对SEO无要求）。</li><li>高度交互的Web应用（如在线编辑器、复杂表单、实时协作工具）。</li><li>登录后才能访问的内容（此时SEO不重要）。</li><li>网络条件较好（或对首屏性能要求不高）的场景。</li></ul><h2 id="服务器端渲染-ssr-server-side-rendering" tabindex="-1"><a class="header-anchor" href="#服务器端渲染-ssr-server-side-rendering"><span>服务器端渲染 (SSR - Server-Side Rendering)</span></a></h2><h3 id="工作原理-1" tabindex="-1"><a class="header-anchor" href="#工作原理-1"><span>工作原理</span></a></h3><ul><li>用户请求一个URL。</li><li>服务器<strong>实时</strong>接收到请求。</li><li>服务器运行JavaScript应用（如Node.js + React/Vue）。</li><li>服务器根据请求的URL，<strong>获取所需数据</strong>（查询数据库、调用API等）。</li><li>服务器执行应用代码，<strong>将组件渲染成完整的HTML字符串</strong>（包含实际内容）。</li><li>服务器将这个<strong>完整的、包含数据的HTML文档</strong>发送给浏览器。</li><li>浏览器接收到HTML后能<strong>立即显示有意义的内容</strong>（FCP快）。</li><li>同时，浏览器会下载JS包（hydration）。JS下载执行后，会“接管”页面，附加事件监听器，使页面变得可交互（TTI可能稍晚于FCP）。后续交互和导航通常又转为CSR模式。</li></ul><h3 id="典型代表-1" tabindex="-1"><a class="header-anchor" href="#典型代表-1"><span>典型代表</span></a></h3><ul><li><strong>Next.js</strong> (<code>getServerSideProps</code>),</li><li><strong>Nuxt.js</strong> (<code>server-side rendering mode</code>)</li><li><strong>SvelteKit</strong> (适配器如<code>@sveltejs/adapter-node</code>)</li></ul><h3 id="优点-1" tabindex="-1"><a class="header-anchor" href="#优点-1"><span>优点</span></a></h3><ul><li><strong>优秀的首屏性能 (FCP)：</strong> 用户能快速看到完整内容，提升感知速度。</li><li><strong>卓越的SEO：</strong> 搜索引擎爬虫直接获取到包含完整内容的HTML，索引无忧。</li><li><strong>更好的社交分享：</strong> 分享链接时，社交媒体的爬虫也能获取到包含完整元信息（如Open Graph tags）和内容的HTML，生成正确的预览卡片。</li><li><strong>对低端设备/慢网络更友好：</strong> 用户能尽早看到内容。</li></ul><h3 id="缺点-1" tabindex="-1"><a class="header-anchor" href="#缺点-1"><span>缺点</span></a></h3><ul><li><strong>服务器压力大：</strong> 每个请求都需要服务器实时渲染，消耗CPU资源。高并发时可能成为瓶颈，需要良好的服务器架构和缓存策略（如CDN缓存、反向代理缓存）。</li><li><strong>TTI可能延迟：</strong> 虽然内容显示快，但页面可交互（TTI）需要等待JS下载和执行完成（hydration）。如果JS包很大，用户看到内容但无法立即点击，体验会打折扣（需优化hydration性能）。</li><li><strong>开发复杂度稍高：</strong> 需要考虑服务器环境、数据获取方式（<code>getServerSideProps</code>等）、hydration过程，调试可能更复杂。</li></ul><h3 id="适用场景-1" tabindex="-1"><a class="header-anchor" href="#适用场景-1"><span>适用场景</span></a></h3><ul><li>内容密集型且对SEO要求极高的网站（新闻、博客、电商列表/详情页）。</li><li>需要良好社交分享预览的页面。</li><li>用户网络条件差异较大的公共网站。</li><li>需要用户立即看到核心内容的页面。</li></ul><h2 id="静态站点生成-ssg-static-site-generation" tabindex="-1"><a class="header-anchor" href="#静态站点生成-ssg-static-site-generation"><span>静态站点生成 (SSG - Static Site Generation)</span></a></h2><h3 id="工作原理-2" tabindex="-1"><a class="header-anchor" href="#工作原理-2"><span>工作原理</span></a></h3><ul><li><strong>在构建时（Build Time）</strong>，而不是在用户请求时。</li><li>应用代码运行在<strong>构建服务器</strong>上。</li><li>为网站中的<strong>每一个可能的页面路径</strong>（基于文件路由或配置），执行以下操作： <ul><li><strong>获取该页面所需的所有数据</strong>（从CMS、API、数据库、本地文件等）。</li><li><strong>将React/Vue/Svelte组件渲染成纯HTML字符串</strong>。</li></ul></li><li>将生成的每个HTML文件，连同其CSS、JS、图片等资源，<strong>输出为静态文件</strong>。</li><li>将这些静态文件部署到CDN或静态文件托管服务。</li><li>用户请求一个URL时，CDN直接返回<strong>预先渲染好的、包含完整内容的静态HTML文件</strong>，浏览器快速展示（FCP极快）。JS随后下载执行进行hydration，添加交互性（TTI通常也很快，因为资源在CDN边缘）。</li></ul><h3 id="典型代表-2" tabindex="-1"><a class="header-anchor" href="#典型代表-2"><span>典型代表</span></a></h3><ul><li><strong>Next.js</strong> (<code>getStaticProps</code>/<code>getStaticPaths</code>)</li><li><strong>Gatsby</strong></li><li><strong>Nuxt.js</strong> (<code>target: static</code>)</li><li><strong>VitePress</strong></li><li><strong>Hugo</strong></li><li><strong>Jekyll</strong></li><li><strong>Eleventy (11ty)</strong></li></ul><h3 id="优点-2" tabindex="-1"><a class="header-anchor" href="#优点-2"><span>优点</span></a></h3><ul><li><strong>极致性能：</strong> 页面直接从全球CDN边缘节点提供，加载速度极快（FCP, TTI, LCP 都优秀）。</li><li><strong>超强安全性：</strong> 没有实时服务器或数据库暴露给公共网络，攻击面极小。</li><li><strong>成本低廉：</strong> 静态文件托管（如Vercel, Netlify, GitHub Pages, AWS S3 + CloudFront）通常非常便宜甚至免费，且能轻松应对高流量。</li><li><strong>优秀的SEO：</strong> 和SSR一样，爬虫直接获取完整HTML内容。</li><li><strong>简单可靠：</strong> 部署就是上传文件，没有服务器运行时的复杂性和潜在故障点。</li></ul><h3 id="缺点-2" tabindex="-1"><a class="header-anchor" href="#缺点-2"><span>缺点</span></a></h3><ul><li><strong>构建时数据：</strong> 页面内容在构建时就固定了。如果数据源更新，必须<strong>重新构建并部署整个站点（或受影响页面）</strong> 才能更新页面内容。不适合<strong>数据频繁变化</strong>的页面（如实时股票行情、高频更新的评论区）。</li><li><strong>大规模站点构建时间长：</strong> 如果页面数量成千上万，每次构建可能需要几分钟甚至几十分钟。</li></ul><h3 id="适用场景-2" tabindex="-1"><a class="header-anchor" href="#适用场景-2"><span>适用场景</span></a></h3><ul><li>博客、文档网站、营销/宣传页（内容相对稳定）。</li><li>产品展示页、公司官网。</li><li>基于CMS但内容发布不频繁的网站（可以在CMS更新后触发构建）。</li><li>任何内容变化频率低于构建/部署频率的场景。追求极致性能、安全和成本效益的场景。</li></ul><h2 id="增量静态再生-isg-incremental-static-regeneration" tabindex="-1"><a class="header-anchor" href="#增量静态再生-isg-incremental-static-regeneration"><span>增量静态再生 (ISG - Incremental Static Regeneration)</span></a></h2><h3 id="工作原理-3" tabindex="-1"><a class="header-anchor" href="#工作原理-3"><span>工作原理</span></a></h3><div class="hint-container tip"><p class="hint-container-title">Next.js 提出的概念，核心思想</p></div><ul><li>在SSG的基础上，增加了<strong>按需或在后台更新静态内容的能力</strong>，<strong>无需重新部署整个应用</strong>。</li><li>在构建时 (<code>getStaticProps</code>) 可以指定一个 <code>revalidate</code> 时间（单位：秒）。</li><li>用户请求一个页面： <ol><li><strong>首先</strong>，CDN/服务器会立即返回<strong>上次构建或再生的静态HTML</strong>（极快）。</li><li><strong>同时</strong>，在后台检查该页面自上次生成后是否已超过 <code>revalidate</code> 时间。</li><li><strong>如果超过</strong>，则在后台触发一次该页面的“再生”： <ul><li>重新运行 <code>getStaticProps</code> 获取<strong>最新数据</strong>。</li><li>用新数据<strong>重新生成该页面的HTML</strong>。</li><li>将新HTML<strong>保存/缓存</strong>起来，替换旧版本。</li></ul></li><li><strong>下次请求</strong>该页面时，用户将直接获得新生成的HTML。</li></ol></li><li>第一个触发再生的用户可能看到的还是旧页面，但他“默默”帮助后续用户更新了缓存。</li><li>也可以使用 <code>On-Demand Revalidation</code> (按需再生)：通过API路由手动触发特定页面（或带标签的一组页面）的立即再生（如CMS更新后调用Webhook）。</li></ul><h3 id="典型代表-3" tabindex="-1"><a class="header-anchor" href="#典型代表-3"><span>典型代表</span></a></h3><p><strong>Next.js</strong> (<code>getStaticProps</code> with <code>revalidate</code> 或 <code>unstable_revalidate</code> API / On-Demand ISR)。</p><h3 id="优点-3" tabindex="-1"><a class="header-anchor" href="#优点-3"><span>优点</span></a></h3><ul><li><strong>保留SSG的所有优点：</strong> 极致的性能、安全性、成本效益、SEO。</li><li><strong>解决SSG的最大痛点：</strong> 内容可以<strong>在部署后更新</strong>！数据不再是完全静态的。可以设置一个合理的更新频率（如每10秒、1分钟、1小时）。</li><li><strong>增量更新：</strong> 只更新过期的页面，而不是全站重建，大大减少构建压力。</li><li><strong>优雅降级：</strong> 即使后台再生失败或超时，用户看到的仍是有效的（可能稍旧的）缓存内容。</li></ul><h3 id="缺点-3" tabindex="-1"><a class="header-anchor" href="#缺点-3"><span>缺点</span></a></h3><ul><li><strong>内容更新非即时：</strong> 用户可能在 <code>revalidate</code> 时间窗口内看到稍旧的数据（但通常可接受）。需要按需再生API才能实现接近实时（但仍有CDN传播延迟）。</li><li><strong>概念稍复杂：</strong> 需要理解缓存、再生、过期时间等机制。</li><li><strong>平台依赖：</strong> 主要深度集成在Vercel平台，其他平台实现可能不同或有局限（如Netlify也支持类似功能）。</li></ul><h3 id="适用场景-3" tabindex="-1"><a class="header-anchor" href="#适用场景-3"><span>适用场景</span></a></h3><p><strong>SSG的理想场景，但数据更新频率高于全站部署频率时</strong>：</p><ul><li>电商网站（商品列表/详情页 - 价格/库存可设置短时刷新，商品增删触发按需再生）。</li><li>新闻/博客网站（新文章发布触发按需再生，热门文章设置短刷新）。</li><li>社交媒体Feed（用户主页Feed设置分钟级刷新）。</li><li>任何需要良好性能+SEO+动态内容组合的页面。</li></ul><h2 id="对比" tabindex="-1"><a class="header-anchor" href="#对比"><span>对比</span></a></h2><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">CSR (Client-Side)</th><th style="text-align:left;">SSR (Server-Side)</th><th style="text-align:left;">SSG (Static Site Gen)</th><th style="text-align:left;">ISG (Incremental Static Regen)</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>渲染发生地</strong></td><td style="text-align:left;">浏览器</td><td style="text-align:left;">服务器 (每次请求)</td><td style="text-align:left;">构建服务器 (一次)</td><td style="text-align:left;">构建服务器 + 运行服务器 (按需)</td></tr><tr><td style="text-align:left;"><strong>首次内容加载 (FCP)</strong></td><td style="text-align:left;">慢 (需下载执行JS)</td><td style="text-align:left;"><strong>快</strong> (收到完整HTML)</td><td style="text-align:left;"><strong>极快</strong> (CDN静态文件)</td><td style="text-align:left;"><strong>极快</strong> (CDN静态文件)</td></tr><tr><td style="text-align:left;"><strong>可交互时间 (TTI)</strong></td><td style="text-align:left;">慢 (依赖JS下载执行完)</td><td style="text-align:left;">中 (需Hydration)</td><td style="text-align:left;"><strong>快</strong> (Hydration快)</td><td style="text-align:left;"><strong>快</strong> (Hydration快)</td></tr><tr><td style="text-align:left;"><strong>SEO</strong></td><td style="text-align:left;">差/需额外处理</td><td style="text-align:left;"><strong>优</strong></td><td style="text-align:left;"><strong>优</strong></td><td style="text-align:left;"><strong>优</strong></td></tr><tr><td style="text-align:left;"><strong>服务器压力</strong></td><td style="text-align:left;">低 (主要API)</td><td style="text-align:left;"><strong>高</strong> (每次渲染)</td><td style="text-align:left;"><strong>极低</strong> (仅静态文件)</td><td style="text-align:left;"><strong>低</strong> (按需再生)</td></tr><tr><td style="text-align:left;"><strong>数据实时性</strong></td><td style="text-align:left;">实时 (API调用)</td><td style="text-align:left;">实时 (请求时获取)</td><td style="text-align:left;">构建时 (固定)</td><td style="text-align:left;"><strong>可配置</strong> (<code>revalidate</code>时间/按需)</td></tr><tr><td style="text-align:left;"><strong>内容更新方式</strong></td><td style="text-align:left;">JS动态更新</td><td style="text-align:left;">重新请求</td><td style="text-align:left;"><strong>重新构建部署</strong></td><td style="text-align:left;"><strong>后台再生/按需触发</strong></td></tr><tr><td style="text-align:left;"><strong>成本</strong></td><td style="text-align:left;">中 (需要API服务器)</td><td style="text-align:left;">高 (需要计算型服务器)</td><td style="text-align:left;"><strong>极低</strong> (静态托管)</td><td style="text-align:left;"><strong>低</strong> (静态托管+少量计算)</td></tr><tr><td style="text-align:left;"><strong>安全性</strong></td><td style="text-align:left;">中 (暴露API)</td><td style="text-align:left;">中 (暴露服务器)</td><td style="text-align:left;"><strong>高</strong> (纯静态)</td><td style="text-align:left;"><strong>高</strong> (主要静态)</td></tr><tr><td style="text-align:left;"><strong>开发复杂度</strong></td><td style="text-align:left;">低</td><td style="text-align:left;">中高</td><td style="text-align:left;">低</td><td style="text-align:left;">中</td></tr><tr><td style="text-align:left;"><strong>典型用例</strong></td><td style="text-align:left;">后台SPA, 复杂交互应用</td><td style="text-align:left;">电商详情, 新闻, 高SEO页</td><td style="text-align:left;">博客, 文档, 营销页</td><td style="text-align:left;">电商, 新闻Feed, 需更新的SSG页</td></tr><tr><td style="text-align:left;"><strong>代表框架</strong></td><td style="text-align:left;">CRA, Vite, Vue CLI</td><td style="text-align:left;">Next.js, Nuxt, SvelteKit</td><td style="text-align:left;">Next.js, Gatsby, Nuxt, 11ty</td><td style="text-align:left;"><strong>Next.js (最佳支持)</strong></td></tr></tbody></table><h2 id="如何选择-决策流程图" tabindex="-1"><a class="header-anchor" href="#如何选择-决策流程图"><span>如何选择？决策流程图</span></a></h2>',55)),r(l,{code:"eJxdzk1qwlAUBeC5q3gbcAuFGn9HBV9nIYOO2mHpNCkklv6nporGKEpAMAoaoxMxGnEz3pu8kVswPBWD03Pv+TiPLw/PT+Q+m7oVIVBh+CuRdPqGZGTWVSNHg58Rqho2Z/g33S0bYFigm6xfC31tH9ivqQz/VtDyFCLI4PnMMWFuoDqM3jZQ12nuLlZwXmFjixeERCErUlom+GWSEi1I5xP8OwrJiQItS2eeR3kZPt5h6oO9wu6E9drxME7mE2QhJmPqFPFeUT7Ov2yvfu6Wbuh+7wMdDA+rAzBaoe1ipwLrRbS1uVpMqCWRDzxFXL3afgBcg6PG"}),t[1]||(t[1]=e('<p><strong>决策要点：</strong></p><ol><li><strong>数据变化频率：</strong> 数据多久变一次？秒级？分钟级？小时级？天级？这是选择SSG vs SSR/ISG的关键。</li><li><strong>SEO需求：</strong> 页面是否需要被搜索引擎良好索引？是则优先考虑SSR、SSG、ISG。</li><li><strong>性能要求：</strong> 首屏速度 (FCP) 和可交互速度 (TTI) 有多重要？追求极致选SSG/ISG。</li><li><strong>用户交互复杂度：</strong> 页面是否高度交互？是则CSR或SSR/SSG/ISG + 强大的客户端JS。</li><li><strong>基础设施与成本：</strong> 是否有预算/能力维护服务器（SSR）？还是倾向于零服务器管理/低成本（SSG/ISG）？</li><li><strong>内容规模：</strong> 页面数量巨大？SSG全量构建可能慢，ISR或SSR（配合缓存）可能是更好的选择。</li></ol><h2 id="结论-没有银弹-只有权衡" tabindex="-1"><a class="header-anchor" href="#结论-没有银弹-只有权衡"><span>结论：没有银弹，只有权衡</span></a></h2><p>CSR、SSR、SSG、ISG 代表了Web渲染策略的演进，每一种都有其独特的优势和适用场景。现代框架（尤其是Next.js）的强大之处在于它们<strong>支持混合渲染模式</strong>：你可以为一个应用中的不同页面选择最合适的策略！</p><ul><li>将营销首页、博客文章页用 <strong>SSG/ISG</strong> 实现极致性能和SEO。</li><li>将用户个人中心、设置页用 <strong>CSR</strong> 实现流畅交互（SEO不重要）。</li><li>将需要实时数据的特定页面（如最新交易）用 <strong>SSR</strong> 或 <strong>ISR (短<code>revalidate</code>)</strong>。</li></ul><p><strong>理解这些模式的核心原理、优缺点和适用场景，是作为前端工程师做出明智架构决策的基础。</strong> 选择哪种方案，最终取决于你的具体项目需求在性能、SEO、开发体验、成本和数据实时性之间的优先级排序。</p>',6))])}const h=n(o,[["render",g]]),c=JSON.parse('{"path":"/article/dixuz4sh/","title":"前端渲染策略 —— CSR、SSR、SSG、ISG","lang":"zh-CN","frontmatter":{"title":"前端渲染策略 —— CSR、SSR、SSG、ISG","createTime":"2024/10/06 18:28:33","permalink":"/article/dixuz4sh/","description":"想象一下建设一座城市（你的Web应用）。 你是选择在工厂（服务器）里预先建造好整栋房子运过去（SSG）？ 还是派个施工队（浏览器）到现场根据图纸（JS）慢慢盖（CSR）？ 或者是让工厂按订单要求快速生产好毛坯房再运过去让施工队装修（SSR）？ 甚至是在预制好的房子里预留模块，按需更新（ISG）？ 🤔 今天，我们就来拆解这四种主流渲染策略：客户端渲染 ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"前端渲染策略 —— CSR、SSR、SSG、ISG\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-07T17:39:39.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://pengzhanbo.cn/article/dixuz4sh/"}],["meta",{"property":"og:site_name","content":"鹏展博"}],["meta",{"property":"og:title","content":"前端渲染策略 —— CSR、SSR、SSG、ISG"}],["meta",{"property":"og:description","content":"想象一下建设一座城市（你的Web应用）。 你是选择在工厂（服务器）里预先建造好整栋房子运过去（SSG）？ 还是派个施工队（浏览器）到现场根据图纸（JS）慢慢盖（CSR）？ 或者是让工厂按订单要求快速生产好毛坯房再运过去让施工队装修（SSR）？ 甚至是在预制好的房子里预留模块，按需更新（ISG）？ 🤔 今天，我们就来拆解这四种主流渲染策略：客户端渲染 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-07T17:39:39.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-07T17:39:39.000Z"}]]},"readingTime":{"minutes":11.39,"words":3417},"git":{"createdTime":1750071408000,"updatedTime":1759858779000,"contributors":[{"name":"pengzhanbo","username":"pengzhanbo","email":"volodymyr@foxmail.com","commits":2,"avatar":"https://avatars.githubusercontent.com/pengzhanbo?v=4","url":"https://github.com/pengzhanbo"}]},"autoDesc":true,"filePathRelative":"blog/1.前端/9.框架/CSR-SSR-SSG-ISG.md","headers":[],"categoryList":[{"id":"72e6d5","sort":1,"name":"前端"},{"id":"c6689c","sort":9,"name":"框架"}]}');export{h as comp,c as data};
