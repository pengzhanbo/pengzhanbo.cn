import{_ as i,c as a,e as n,o as e}from"./app-D7KDYWdB.js";const t={};function l(h,s){return e(),a("div",null,[...s[0]||(s[0]=[n(`<div class="hint-container warning"><p class="hint-container-title">建议优先使用 ES6 模块（静态加载、显式依赖）和 class（面向对象）实现类似功能。</p><p>模块模式的价值更多体现在遗留项目维护或需要精细控制闭包的场景中。</p></div><h2 id="什么是模块模式" tabindex="-1"><a class="header-anchor" href="#什么是模块模式"><span>什么是模块模式？</span></a></h2><p><mark>Module (模块)模式</mark> 是用于封装代码、实现私有作用域的一种设计模式。</p><p>它通过闭包和立即执行函数表达式（IIFE），将变量和方法划分为“私有”和“公有”两部分，从而减少全局污染、提高代码可维护性。</p><h2 id="实现模块模式" tabindex="-1"><a class="header-anchor" href="#实现模块模式"><span>实现模块模式</span></a></h2><h3 id="基本模块模式" tabindex="-1"><a class="header-anchor" href="#基本模块模式"><span>基本模块模式</span></a></h3><p>通过 IIFE 创建闭包，返回一个包含公有方法的对象：</p><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-ts"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">myModule</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">function </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 私有变量和方法</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  let </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">privateVar</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">私有数据</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  function </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">privateMethod</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    console</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">log</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">privateVar</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 公有接口</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    publicMethod</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">() {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">      privateMethod</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    },</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">})()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">myModule</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">publicMethod</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 输出 &quot;私有数据&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="揭示模块-revealing-module-模式" tabindex="-1"><a class="header-anchor" href="#揭示模块-revealing-module-模式"><span>揭示模块（Revealing Module）模式</span></a></h3><p>明确声明公有方法，直接暴露内部函数引用，增强可读性：</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-ts"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">myModule</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">function </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  function </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">privateMethod</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> /* ... */</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  function </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">publicMethod</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    privateMethod</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> { </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">publicMethod</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 直接暴露公有方法</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">})()</span></span></code></pre></div><h3 id="其它" tabindex="-1"><a class="header-anchor" href="#其它"><span>其它</span></a></h3><ul><li>AMD 模块</li><li>CommonJS 模块</li><li>ES6 模块</li></ul><h2 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h2><ul><li><p><strong>封装性</strong></p><p>私有变量和方法仅在模块内部可见，避免外部误操作。</p></li><li><p><strong>减少全局污染</strong></p><p>所有逻辑封装在模块内，避免全局命名冲突。</p></li><li><p><strong>代码组织清晰</strong></p><p>通过公有接口管理外部可访问的方法，提高可维护性。</p></li><li><p><strong>支持依赖注入</strong></p><p>可通过参数注入依赖（如 jQuery）：</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-ts"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">myModule</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">function </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">$</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 使用 $ 作为局部变量</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">})(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">jQuery</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span></code></pre></div></li></ul><h2 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h2><ul><li><p><strong>内存占用</strong></p><p>闭包导致私有变量无法被垃圾回收，长期存在可能增加内存消耗。</p></li><li><p><strong>扩展性差</strong></p><p>模块是单例的，难以直接继承或扩展（需通过组合或混入模式实现）。</p></li><li><p><strong>测试困难</strong></p><p>私有方法无法直接测试，需通过公有接口间接验证。</p></li><li><p><strong>ES6 替代方案</strong></p><p>ES6 模块（import/export）和 class 语法更现代，模块模式在部分场景下已过时。</p></li></ul>`,17)])])}const k=i(t,[["render",l]]),r=JSON.parse('{"path":"/design-pattern/module/","title":"模块模式","lang":"zh-CN","frontmatter":{"title":"模块模式","createTime":"2018/04/26 10:00:36","permalink":"/design-pattern/module/","tags":["设计模式"],"description":"建议优先使用 ES6 模块（静态加载、显式依赖）和 class（面向对象）实现类似功能。 模块模式的价值更多体现在遗留项目维护或需要精细控制闭包的场景中。 什么是模块模式？ Module (模块)模式 是用于封装代码、实现私有作用域的一种设计模式。 它通过闭包和立即执行函数表达式（IIFE），将变量和方法划分为“私有”和“公有”两部分，从而减少全局污染...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"模块模式\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-07T17:39:39.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://pengzhanbo.cn/design-pattern/module/"}],["meta",{"property":"og:site_name","content":"鹏展博"}],["meta",{"property":"og:title","content":"模块模式"}],["meta",{"property":"og:description","content":"建议优先使用 ES6 模块（静态加载、显式依赖）和 class（面向对象）实现类似功能。 模块模式的价值更多体现在遗留项目维护或需要精细控制闭包的场景中。 什么是模块模式？ Module (模块)模式 是用于封装代码、实现私有作用域的一种设计模式。 它通过闭包和立即执行函数表达式（IIFE），将变量和方法划分为“私有”和“公有”两部分，从而减少全局污染..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-07T17:39:39.000Z"}],["meta",{"property":"article:tag","content":"设计模式"}],["meta",{"property":"article:modified_time","content":"2025-10-07T17:39:39.000Z"}]]},"readingTime":{"minutes":1.75,"words":524},"git":{"createdTime":1748511651000,"updatedTime":1759858779000,"contributors":[{"name":"pengzhanbo","username":"pengzhanbo","email":"volodymyr@foxmail.com","commits":2,"avatar":"https://avatars.githubusercontent.com/pengzhanbo?v=4","url":"https://github.com/pengzhanbo"}]},"autoDesc":true,"filePathRelative":"设计模式/12.模块模式.md","headers":[]}');export{k as comp,r as data};
