import{_ as l,c as e,e as i,b as a,r as t,o as h}from"./app-D7KDYWdB.js";const p={};function r(k,s){const n=t("Mermaid");return h(),e("div",null,[s[0]||(s[0]=i('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>在探讨 React 内部机制时，经常提及一个关键转折点：<strong>React 16 引入了Fiber架构</strong>。这引发了一系列核心问题：何为 Fiber 架构？它所取代的原有架构是什么？React 团队引入 Fiber 架构的根本动因何在？</p><p>本文旨在系统解析Fiber架构的核心概念与设计思想，揭示其如何解决历史架构的瓶颈。深入的技术细节（如具体调度算法、优先级机制）将在后续专题文章中探讨。</p><p><strong>前置知识：</strong> 深入理解 <strong>Virtual DOM (虚拟DOM)</strong> 是掌握React协调（Reconciliation）机制的基础。</p><h2 id="栈式协调器-stack-reconciler" tabindex="-1"><a class="header-anchor" href="#栈式协调器-stack-reconciler"><span>栈式协调器（Stack Reconciler）</span></a></h2><p>在Fiber架构诞生前，React的核心更新机制依赖于 <strong>栈式协调器（Stack Reconciler）</strong> 。</p><p>其核心在于通过 <strong>递归深度优先遍历</strong> 的方式对比新旧虚拟DOM树（Virtual DOM Tree），并计算最小更新操作（diff算法）。</p>',7)),a(n,{code:"eJxLL0osyFDwCeJSAALH6GeztzybtuHpnoany7tjFXR17RScol82THq6d9LLxt6nfW1hLv6+sWC1TmBZ5+hn2zc+3bXsyZ4ZT1s7IGog8s5geZfopxN6nq1d+qxz+YuFPSmZaWkQWRewrGv0yxm7ny6c92TH7ue79j9f0Q2RdAVLukW/XLj15dxFT3sXvly4HyLjBpZxhzrz+e7Jz+bOj+UCAIlUWKM="}),s[1]||(s[1]=i(`<p>以下是一个简化的虚拟DOM树结构示例，栈式协调器正是递归遍历此类结构：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> tree</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">  type</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">div</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">  props</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">    id</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">list</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">    children</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">      {</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">        type</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">ul</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">        props</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">          children</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">            {</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">              type</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">li</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">              props</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">                children</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">apple</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">              }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">            },</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">            // ... 其他子节点</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">          ]</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">      }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    ]</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="主要特性与局限性" tabindex="-1"><a class="header-anchor" href="#主要特性与局限性"><span>主要特性与局限性</span></a></h3><ol><li><p><strong>同步不可中断（Synchronous &amp; Uninterruptible）</strong>：</p><ul><li>更新流程一旦启动（即开始递归遍历与 diff 计算），必须 <strong>连续执行直至完成</strong> 。</li><li>无法将庞大的更新任务拆分为小单元，也无法在执行过程中响应更高优先级的任务。</li></ul></li><li><p><strong>性能瓶颈（Performance Bottlenecks）</strong>：</p><ul><li>虽然 Virtual DOM 操作在 JavaScript 层面执行，相比直接操作真实 DOM 已是显著优化，但在处理<strong>大型应用、深层嵌套组件树或复杂数据结构</strong>时，递归遍历和 diff 计算仍可能消耗大量主线程（Main Thread）时间。</li><li>长时间占用主线程会导致 <strong>页面渲染卡顿（Jank）</strong>、<strong>交互响应延迟（Input Lag）</strong>，严重损害用户体验（User Experience, UX）。</li></ul></li><li><p><strong>缺乏任务优先级（Absence of Task Prioritization）</strong>：</p><ul><li>所有更新任务均按生成顺序 <strong>同步、无差别执行</strong> 。</li><li>当低优先级任务（如后台数据拉取后的UI更新）正在进行时，高优先级任务（如用户输入、动画）必须等待，导致 <strong>高优先级交互无法得到即时响应</strong> （例如，用户输入框输入时，毫秒级的延迟即可被感知为卡顿，而数据加载指示器更新延迟几秒可能尚可接受）。</li></ul></li></ol><h3 id="核心瓶颈" tabindex="-1"><a class="header-anchor" href="#核心瓶颈"><span>核心瓶颈</span></a></h3><p>栈式协调器主要面临两类影响UX的核心瓶颈：</p><ol><li><p><strong>CPU瓶颈</strong>：</p><ul><li><strong>本质</strong>：应用的计算复杂度（Virtual DOM diff、组件渲染逻辑）超出了单次事件循环（Event Loop）中主线程的处理能力上限。</li><li><strong>表现</strong>：长时间、同步的JavaScript执行阻塞主线程，导致UI渲染与用户交互停滞。这是栈式架构最直接的性能痛点。</li></ul></li><li><p><strong>I/O瓶颈</strong>：</p><ul><li><strong>本质</strong>：网络请求延迟等I/O操作耗时是客观存在的物理限制。</li><li><strong>前端优化目标</strong>：在I/O等待期间，主线程应保持响应能力，优先处理用户可感知的交互；同时，需根据任务来源（用户交互 vs. 后台数据）<strong>区分更新优先级</strong>，确保高优先级任务不被低优先级任务阻塞。栈式架构对此无能为力。</li></ul></li></ol><h2 id="fiber架构" tabindex="-1"><a class="header-anchor" href="#fiber架构"><span>Fiber架构</span></a></h2><p>Fiber 架构是 React 为解决栈式协调器瓶颈而设计的全新协调引擎。</p><p>其核心思想是将 <strong>同步不可中断的更新过程</strong> 重构为 <strong>异步可中断、可恢复且具备优先级调度能力</strong> 的机制。</p><p>以下阐述其关键概念：</p><h3 id="fiber节点-fiber-node" tabindex="-1"><a class="header-anchor" href="#fiber节点-fiber-node"><span>Fiber节点（Fiber Node）</span></a></h3>`,12)),a(n,{code:"eJxLL0osyFDwCeJSAALHaLfMpNSiF11Nz5t2xiro6topOEUnZ2TmpMRC5MFCztHFmUk5mXnpyIIu0UWpJaVFeRAxJ7CYa/TTtROghoGFncHCbtFPW1ue7pmPLOMClnGPft6xDSYMFi8uqcxJBVqRlpmTY6WcZpmmU1xSlJ+daqVsbGyMpMIJqiIpCZcKZ5iKtCQcKlxgtiShqgAAh61eEg=="}),s[2]||(s[2]=i(`<ul><li><p><strong>本质</strong>：Fiber节点是Fiber架构下 <strong>工作单元（Work Unit）</strong> 的抽象，也是虚拟DOM节点在Fiber架构中的具体实现形式。</p></li><li><p><strong>核心创新：链表数据结构</strong>：与栈式协调器基于递归树不同，Fiber 节点通过 <strong>显式链表指针</strong> （<code>child</code>, <code>sibling</code>, <code>return</code>）组织成一颗<strong>Fiber树</strong>。这种结构赋予了遍历过程 <strong>可暂停、可恢复、可回溯</strong> 的能力。</p></li><li><p><strong>结构示意</strong>：</p><ul><li><code>child</code>: 指向当前节点的 <strong>第一个子Fiber节点</strong>。</li><li><code>sibling</code>: 指向当前节点的 <strong>下一个兄弟Fiber节点</strong>。</li><li><code>return</code>: 指向当前节点的 <strong>父Fiber节点</strong> （完成当前节点工作后需返回的节点）。</li></ul></li><li><p><strong>Fiber节点对象（源码简化版，附关键注释）</strong>：</p><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-ts"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">function</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> FiberNode</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">  tag</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">: </span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">WorkTag</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 节点类型标识：FunctionComponent, ClassComponent, HostRoot(根), HostComponent(DOM元素)等</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">  pendingProps</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">: </span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">mixed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 从新更新中接收到的、待处理的props</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">  key</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">: </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">null</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> | </span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">string</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // React元素的key，用于列表diff优化</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">  mode</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">: </span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">TypeOfMode</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 渲染模式标志位（如ConcurrentMode, StrictMode）</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 实例标识与关联</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">tag</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> tag</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">key</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> key</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">elementType</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> null</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 创建该元素的函数/类或DOM标签名 (e.g., &#39;div&#39;, MyComponent)</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">type</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> null</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 与elementType类似，但对于懒加载组件可能不同</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">stateNode</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> null</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 关联的类组件实例、Host组件(DOM节点) 或 FiberRoot</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // Fiber树链表指针 (核心数据结构)</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> null</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 指向父Fiber节点</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">child</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> null</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 指向第一个子Fiber节点</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">sibling</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> null</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 指向下一个兄弟Fiber节点</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">index</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 在父节点children中的索引</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">ref</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> null</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // ref引用</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // Props 与 State 管理</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">pendingProps</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> pendingProps</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 新传入的props</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">memoizedProps</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> null</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 上次渲染使用的props</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">updateQueue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> null</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 状态更新、回调函数的队列</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">memoizedState</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> null</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 上次渲染产生的state (hooks链表等)</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">dependencies</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> null</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // contexts, events订阅等依赖</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">mode</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> mode</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 渲染模式</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 副作用 (Effects) 标记</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">flags</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> NoFlags</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 标记该Fiber节点需要进行的操作(Placement, Update, Deletion等)</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">subtreeFlags</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> NoFlags</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 子树中存在的副作用标记 (优化遍历)</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">deletions</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> null</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 记录待删除的子节点 (用于安全卸载)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 优先级与调度相关 (Lane 模型)</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">lanes</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> NoLanes</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 该Fiber上待处理的更新优先级 (lanes)</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">childLanes</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> NoLanes</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 子树中存在的最高优先级 (优化子树的跳过)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 双缓冲技术关键指针</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">  this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">alternate</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> null</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 指向current树或workInProgress树中的对应节点</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 性能分析(Profiler)相关属性 (开发/分析构建下启用)</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">enableProfilerTimer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> /* ... */</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 开发模式调试属性</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">__DEV__</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> /* ... */</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="调度器-scheduler-、协调器-reconciler-、渲染器-renderer" tabindex="-1"><a class="header-anchor" href="#调度器-scheduler-、协调器-reconciler-、渲染器-renderer"><span>调度器（Scheduler）、协调器（Reconciler）、渲染器（Renderer）</span></a></h3>`,2)),a(n,{code:"eJxV0M9KAkEcB/C7TzEvIL1BhxDpUAarnQYPuk65IBqb1mUuIuVauGWJCglpRC6ErQezZbdlX2Z+M+5btP8K+h5nPsN8f7+TWuNSrpbUJirspVCQPM7LVVJp1YhaROn0LqLbVQfsN+Y4cDOnSMISkRt1WQlB9EKKmRg+c+0eeiZzp2JogDbezg2KMoGvV4j6qzOx5k9rPlrBh8csR+gmvHQo2seZo8OdXKmpXJBiKtLnrfKpWjqrIj6zwOvwz7YwbqObMBVFJXJTadTRgfR3mNSBO5NZSz5a+u0+6NcUZXFWKROVzwZxkTDZpMx444/XoHVFr0tRAYedbC/4iesL0DaxD6aIOx3jYDyufTH7ldkPyZL89wn7nsCVJuwFRfkI5rBwB8KZwmMf7GECmav/gz/kx6yJ"}),s[3]||(s[3]=i('<p>React Fiber 架构将渲染流程清晰地划分为三个协同工作的层级：</p><ul><li><p><strong>调度器（Scheduler）</strong>：</p><ul><li><strong>职责</strong>：作为 React 16+ 新增的核心模块，负责 <strong>任务调度</strong>。 它管理一个任务队列，根据任务的 <strong>优先级</strong> （如：<code>Immediate</code> - 用户输入、<code>UserBlocking</code> - 交互反馈、<code>Normal</code> - UI更新、<code>Low</code> - 数据分析、<code>Idle</code> - 非必要任务）决定任务的执行顺序。</li><li><strong>解决关键问题</strong>：直接应对 <strong>I/O瓶颈优化需求</strong> 和 <strong>高优先级任务抢占需求</strong> 。确保用户交互（高优先级）能及时打断并插队正在进行的低优先级渲染任务（如大数据列表更新），极大提升应用响应度（Responsiveness）。</li><li><strong>机制</strong>：通常利用浏览器的<code>requestIdleCallback</code>(或polyfill/shim)在浏览器空闲期执行低优先级任务，并实现任务的中断与恢复。</li></ul></li><li><p><strong>协调器（Reconciler） - 运行于Fiber架构之上</strong>：</p><ul><li><strong>职责</strong>：执行核心的 <strong>diff算法</strong> 。它接收更新请求，在内存中操作 <strong>工作树（workInProgress tree）</strong> ，对比新旧Fiber树（或根据状态变化生成新树），计算出 <strong>副作用列表（Effect List）</strong> - 即描述哪些节点需要被插入、更新或删除。</li><li><strong>关键特性</strong>：得益于Fiber节点的链表结构，协调过程是 <strong>可中断的异步过程</strong> 。协调器与调度器紧密配合，根据调度器分配的优先级和时间片进行工作。</li></ul></li><li><p><strong>渲染器（Renderer）</strong> (如 ReactDOM, React Native)：</p><ul><li><strong>职责</strong>：<strong>平台特异性渲染</strong>。接收协调器产生的副作用列表，将其 <strong>安全、高效地应用到真实的宿主环境（如浏览器DOM或原生移动视图）</strong> 上，完成最终的UI更新。</li><li><strong>关注点分离</strong>：Renderer不关心如何计算更新，只负责执行更新命令。这使得React核心协调逻辑可以跨平台复用。</li></ul></li></ul><h3 id="时间切片-time-slicing" tabindex="-1"><a class="header-anchor" href="#时间切片-time-slicing"><span>时间切片（Time Slicing）</span></a></h3>',3)),a(n,{code:"eJyNjz9Lw0Achvd+ilsEhVBMEzO4+QcHcdLF9UyjBGwCySGuorWJWhSrREWQgpKIoFBMLG300/QuyZSv4OUaDpEiZvzled733h1oIFQB9EM62tXAugZVRLwo896x00rcFrkfYCcirp92z0h4kASneezg9vXos53Hd+TtJfEv89hlEXWItBXTakAEwCa7wH3dLi9Ta+xiayrSTQPgvi+CaVGpKg17hv1Z3RgNh/ikS8Nx83ABzAPV0pEAoCiAWQHIE6BFCsEaRbaRZjFwTJHwPPUdfBuQfo88dLKbiLyGBUu79zQBbFGydKg9x5zkeZB5PTp9jNZNowB5eKFIVaXye0TtrxFLfITKG4vIsvEqIM5H+tXBzSf8eJRcHP94osqbC1WaEL5chEucovz/xqsyd6gt003fBYTU8w=="}),s[4]||(s[4]=i('<ul><li><strong>核心思想</strong>：将原本可能长时间阻塞主线程的大型更新任务，<strong>分解成多个小的、有限时的工作单元</strong>。</li><li><strong>实现方式</strong>：调度器与协调器协同工作。协调器在遍历处理Fiber节点时，会检查当前帧剩余时间（通过调度器提供的能力）。如果一个工作单元执行时间过长或超过了分配的帧时间（如5ms），协调器会暂停当前工作，将控制权交还给浏览器，让其处理更紧急的任务（如绘制、用户输入）。</li><li><strong>价值</strong>：有效避免JavaScript长时间独占主线程，保证浏览器有 <strong>足够的时间进行渲染（Rendering）和响应用户输入（Input Handling）</strong>，从而维持界面的 <strong>流畅性（Fluency）</strong> 和 <strong>响应性（Responsiveness）</strong>。这是解决<strong>CPU瓶颈</strong>的核心手段之一。</li></ul><h3 id="双重缓冲-double-buffering" tabindex="-1"><a class="header-anchor" href="#双重缓冲-double-buffering"><span>双重缓冲（Double Buffering）</span></a></h3>',2)),a(n,{code:"eJxLL0osyFDwCeJSAALnaOfSoqLUvBKFkKLU1FgFXV07hZqnG/uf7pz6dO/kp529z2bse75kV42CS/TzOfOfrpvn4u8bC9YZHh2eX5TtmRdQlJ9elFpcjGJAW+vTtTOe7Fj7bF7L091A3WHRz6ZteDFz1rPu+WADIHaDFNc8be1+OautRiEcYipY7Fn/hCe7ljxd1/OsY0KNgjNMtR5QKjGnJLUoL7Ek9VlP+8tJHSB9YOniksqcVKCitMycHCvlVLM087Q0JIlwqESaWVpaagqShAuQLsrPTgVKpZlbmJsiSYXBpUyNkk0ME7kAtEJ3xw=="}),s[5]||(s[5]=i('<ul><li><p><strong>技术类比</strong>：借鉴图形学中的双重缓冲技术，避免画面撕裂。</p></li><li><p><strong>在Fiber中的实现</strong>：React在内存中同时维护两棵Fiber树：</p><ul><li><strong>当前树（Current Tree）</strong>：对应屏幕上当前显示的UI状态。Fiber节点的<code>stateNode</code>指向真实的DOM节点。</li><li><strong>工作树（Work-In-Progress Tree, WIP Tree）</strong>：正在后台构建的、反映下一次更新后UI状态的树。构建过程不会直接影响当前显示的UI。</li></ul></li><li><p><strong>工作流程</strong>：</p><ol><li>更新开始时，协调器基于当前树克隆（或创建）出工作树。</li><li>所有diff计算和状态更新都在工作树上进行。</li><li>当工作树完整构建完成（或达到可提交状态），且当前无更高优先级任务时，Renderer将 <strong>原子性地（Atomically）</strong> 将工作树的更新应用到真实DOM上。此过程称为 <strong>提交（Commit）</strong>。</li><li>提交完成后，工作树即成为新的当前树。旧的当前树节点可能被回收或作为下次更新的备用（Alternate）。</li></ol></li><li><p><strong>优势</strong>：</p><ul><li><strong>非破坏性更新</strong>：更新计算过程不影响当前显示，确保UI稳定性。</li><li><strong>快速回滚</strong>：若更新过程中有更高优先级任务介入，可直接丢弃未完成的工作树，避免显示中间的不一致状态。</li><li><strong>并发模式基础</strong>：是实现异步渲染（Concurrent Rendering）的关键机制。</li></ul></li></ul><h2 id="结语" tabindex="-1"><a class="header-anchor" href="#结语"><span>结语</span></a></h2><p>Fiber架构通过引入 <strong>Fiber节点（链表结构）</strong>、<strong>任务调度器（Scheduler）</strong>、<strong>时间切片（Time Slicing）</strong> 和 <strong>双重缓冲（Double Buffering）</strong> 等核心机制，成功将React的协调过程从 <strong>同步不可中断</strong> 转变为 <strong>异步可中断且具备优先级调度能力</strong>。</p><p>这一变革从根本上解决了栈式协调器面临的 <strong>CPU瓶颈</strong>（长时间任务阻塞主线程）与 <strong>I/O瓶颈优化需求</strong>（优先级调度），为React应用的 <strong>流畅性、响应性</strong> 奠定了坚实基础。理解这些基础概念是深入探索React Concurrent Features（并发特性）如<code>useTransition</code>、<code>useDeferredValue</code>以及Suspense流式渲染等高级能力的前提。</p>',4))])}const g=l(p,[["render",r]]),o=JSON.parse('{"path":"/article/uocv0xza/","title":"React 架构演进探析 —— 从栈式协调到Fiber架构","lang":"zh-CN","frontmatter":{"title":"React 架构演进探析 —— 从栈式协调到Fiber架构","createTime":"2025/03/05 11:25:45","permalink":"/article/uocv0xza/","tags":["react"],"description":"前言 在探讨 React 内部机制时，经常提及一个关键转折点：React 16 引入了Fiber架构。这引发了一系列核心问题：何为 Fiber 架构？它所取代的原有架构是什么？React 团队引入 Fiber 架构的根本动因何在？ 本文旨在系统解析Fiber架构的核心概念与设计思想，揭示其如何解决历史架构的瓶颈。深入的技术细节（如具体调度算法、优先级机...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"React 架构演进探析 —— 从栈式协调到Fiber架构\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-07T17:39:39.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://pengzhanbo.cn/article/uocv0xza/"}],["meta",{"property":"og:site_name","content":"鹏展博"}],["meta",{"property":"og:title","content":"React 架构演进探析 —— 从栈式协调到Fiber架构"}],["meta",{"property":"og:description","content":"前言 在探讨 React 内部机制时，经常提及一个关键转折点：React 16 引入了Fiber架构。这引发了一系列核心问题：何为 Fiber 架构？它所取代的原有架构是什么？React 团队引入 Fiber 架构的根本动因何在？ 本文旨在系统解析Fiber架构的核心概念与设计思想，揭示其如何解决历史架构的瓶颈。深入的技术细节（如具体调度算法、优先级机..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-07T17:39:39.000Z"}],["meta",{"property":"article:tag","content":"react"}],["meta",{"property":"article:modified_time","content":"2025-10-07T17:39:39.000Z"}]]},"readingTime":{"minutes":10.62,"words":3185},"git":{"createdTime":1749986499000,"updatedTime":1759858779000,"contributors":[{"name":"pengzhanbo","username":"pengzhanbo","email":"volodymyr@foxmail.com","commits":2,"avatar":"https://avatars.githubusercontent.com/pengzhanbo?v=4","url":"https://github.com/pengzhanbo"}]},"autoDesc":true,"filePathRelative":"blog/1.前端/4.React/React架构演进探析——从栈式协调到Fiber架构.md","headers":[],"categoryList":[{"id":"72e6d5","sort":1,"name":"前端"},{"id":"0d0c6d","sort":4,"name":"React"}]}');export{g as comp,o as data};
